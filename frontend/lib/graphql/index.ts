/* DO NOT EDIT! This file is auto-generated by graphql-code-generator - see `codegen.yml` */
/* eslint-disable */
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** A floating point number that requires more precision than IEEE 754 binary 64 */
  BigFloat: any;
  /**
   * A signed eight-byte integer. The upper big integer values are greater than the
   * max value for a JavaScript number. Therefore all big integers will be output as
   * strings and not numbers.
   */
  BigInt: string;
  /** A location in a connection that can be used for resuming pagination. */
  Cursor: any;
  /** The day, does not include a time. */
  Date: string;
  /**
   * A point in time as described by the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
   */
  Datetime: string;
  /** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
  JSON: { [key: string]: any };
  /** A builtin object identifier type for a relation name */
  RegClass: any;
  /** A builtin object identifier type for a function name */
  RegProc: any;
  /** The exact time of day, does not include the date. May or may not have a timezone offset. */
  Time: string;
};

/** A `ActiveProspectsRecord` edge in the connection. */
export type ActiveProspectEdge = {
  __typename?: 'ActiveProspectEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `ActiveProspectsRecord` at the end of the edge. */
  node: ActiveProspectsRecord;
};

/** A connection to a list of `ActiveProspectsRecord` values. */
export type ActiveProspectsConnection = {
  __typename?: 'ActiveProspectsConnection';
  /** A list of edges which contains the `ActiveProspectsRecord` and cursor to aid in pagination. */
  edges: Array<ActiveProspectEdge>;
  /** A list of `ActiveProspectsRecord` objects. */
  nodes: Array<ActiveProspectsRecord>;
  /** The count of *all* `ActiveProspectsRecord` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** The return type of our `activeProspects` query. */
export type ActiveProspectsRecord = {
  __typename?: 'ActiveProspectsRecord';
  cohort: Maybe<CrmCohort>;
  data: Maybe<ProspectDatum>;
  id: Maybe<Scalars['BigInt']>;
  updatedAt: Maybe<Scalars['Datetime']>;
};

export type Akce = {
  __typename?: 'Akce';
  aDo: Maybe<Scalars['Date']>;
  aDokumenty: Maybe<Scalars['String']>;
  aId: Maybe<Scalars['BigInt']>;
  aInfo: Maybe<Scalars['String']>;
  aJmeno: Maybe<Scalars['String']>;
  aKapacita: Maybe<Scalars['BigInt']>;
  aKde: Maybe<Scalars['String']>;
  aLock: Maybe<Scalars['Boolean']>;
  aOd: Maybe<Scalars['Date']>;
  aTimestamp: Maybe<Scalars['Datetime']>;
  aVisible: Maybe<Scalars['Boolean']>;
  /** Reads and enables pagination through a set of `AkceItem`. */
  akceItemsByAiIdRodic: AkceItemsConnection;
  enableNotes: Maybe<Scalars['Boolean']>;
  isPublic: Maybe<Scalars['Boolean']>;
  summary: Maybe<Scalars['String']>;
};


export type AkceAkceItemsByAiIdRodicArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AkceItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AkceItemsOrderBy>>;
};

/** A condition to be used against `Akce` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type AkceCondition = {
  /** Checks for equality with the object’s `aDo` field. */
  aDo?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `aDokumenty` field. */
  aDokumenty?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `aId` field. */
  aId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `aInfo` field. */
  aInfo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `aJmeno` field. */
  aJmeno?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `aKapacita` field. */
  aKapacita?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `aKde` field. */
  aKde?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `aLock` field. */
  aLock?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `aOd` field. */
  aOd?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `aTimestamp` field. */
  aTimestamp?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `aVisible` field. */
  aVisible?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `enableNotes` field. */
  enableNotes?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `isPublic` field. */
  isPublic?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `summary` field. */
  summary?: InputMaybe<Scalars['String']>;
};

/** An input for mutations affecting `Akce` */
export type AkceInput = {
  aDo?: InputMaybe<Scalars['Date']>;
  aDokumenty?: InputMaybe<Scalars['String']>;
  aId?: InputMaybe<Scalars['BigInt']>;
  aInfo?: InputMaybe<Scalars['String']>;
  aJmeno?: InputMaybe<Scalars['String']>;
  aKapacita?: InputMaybe<Scalars['BigInt']>;
  aKde?: InputMaybe<Scalars['String']>;
  aLock?: InputMaybe<Scalars['Boolean']>;
  aOd?: InputMaybe<Scalars['Date']>;
  aTimestamp?: InputMaybe<Scalars['Datetime']>;
  aVisible?: InputMaybe<Scalars['Boolean']>;
  enableNotes?: InputMaybe<Scalars['Boolean']>;
  isPublic?: InputMaybe<Scalars['Boolean']>;
  summary?: InputMaybe<Scalars['String']>;
};

export type AkceItem = {
  __typename?: 'AkceItem';
  aiId: Maybe<Scalars['BigInt']>;
  aiIdRodic: Maybe<Scalars['BigInt']>;
  aiRokNarozeni: Maybe<Scalars['Int']>;
  aiUser: Maybe<Scalars['BigInt']>;
  /** Reads a single `Akce` that is related to this `AkceItem`. */
  akceByAiIdRodic: Maybe<Akce>;
  notes: Maybe<Scalars['String']>;
  /** Reads a single `User` that is related to this `AkceItem`. */
  userByAiUser: Maybe<User>;
};

/**
 * A condition to be used against `AkceItem` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type AkceItemCondition = {
  /** Checks for equality with the object’s `aiId` field. */
  aiId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `aiIdRodic` field. */
  aiIdRodic?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `aiRokNarozeni` field. */
  aiRokNarozeni?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `aiUser` field. */
  aiUser?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: InputMaybe<Scalars['String']>;
};

/** An input for mutations affecting `AkceItem` */
export type AkceItemInput = {
  aiId?: InputMaybe<Scalars['BigInt']>;
  aiIdRodic?: InputMaybe<Scalars['BigInt']>;
  aiRokNarozeni?: InputMaybe<Scalars['Int']>;
  aiUser?: InputMaybe<Scalars['BigInt']>;
  notes?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `AkceItem` values. */
export type AkceItemsConnection = {
  __typename?: 'AkceItemsConnection';
  /** A list of edges which contains the `AkceItem` and cursor to aid in pagination. */
  edges: Array<AkceItemsEdge>;
  /** A list of `AkceItem` objects. */
  nodes: Array<AkceItem>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AkceItem` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `AkceItem` edge in the connection. */
export type AkceItemsEdge = {
  __typename?: 'AkceItemsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `AkceItem` at the end of the edge. */
  node: AkceItem;
};

/** Methods to use when ordering `AkceItem`. */
export type AkceItemsOrderBy =
  | 'AI_ID_ASC'
  | 'AI_ID_DESC'
  | 'AI_ID_RODIC_ASC'
  | 'AI_ID_RODIC_DESC'
  | 'AI_ROK_NAROZENI_ASC'
  | 'AI_ROK_NAROZENI_DESC'
  | 'AI_USER_ASC'
  | 'AI_USER_DESC'
  | 'AKCE_BY_AI_ID_RODIC__A_DOKUMENTY_ASC'
  | 'AKCE_BY_AI_ID_RODIC__A_DOKUMENTY_DESC'
  | 'AKCE_BY_AI_ID_RODIC__A_DO_ASC'
  | 'AKCE_BY_AI_ID_RODIC__A_DO_DESC'
  | 'AKCE_BY_AI_ID_RODIC__A_ID_ASC'
  | 'AKCE_BY_AI_ID_RODIC__A_ID_DESC'
  | 'AKCE_BY_AI_ID_RODIC__A_INFO_ASC'
  | 'AKCE_BY_AI_ID_RODIC__A_INFO_DESC'
  | 'AKCE_BY_AI_ID_RODIC__A_JMENO_ASC'
  | 'AKCE_BY_AI_ID_RODIC__A_JMENO_DESC'
  | 'AKCE_BY_AI_ID_RODIC__A_KAPACITA_ASC'
  | 'AKCE_BY_AI_ID_RODIC__A_KAPACITA_DESC'
  | 'AKCE_BY_AI_ID_RODIC__A_KDE_ASC'
  | 'AKCE_BY_AI_ID_RODIC__A_KDE_DESC'
  | 'AKCE_BY_AI_ID_RODIC__A_LOCK_ASC'
  | 'AKCE_BY_AI_ID_RODIC__A_LOCK_DESC'
  | 'AKCE_BY_AI_ID_RODIC__A_OD_ASC'
  | 'AKCE_BY_AI_ID_RODIC__A_OD_DESC'
  | 'AKCE_BY_AI_ID_RODIC__A_TIMESTAMP_ASC'
  | 'AKCE_BY_AI_ID_RODIC__A_TIMESTAMP_DESC'
  | 'AKCE_BY_AI_ID_RODIC__A_VISIBLE_ASC'
  | 'AKCE_BY_AI_ID_RODIC__A_VISIBLE_DESC'
  | 'AKCE_BY_AI_ID_RODIC__ENABLE_NOTES_ASC'
  | 'AKCE_BY_AI_ID_RODIC__ENABLE_NOTES_DESC'
  | 'AKCE_BY_AI_ID_RODIC__IS_PUBLIC_ASC'
  | 'AKCE_BY_AI_ID_RODIC__IS_PUBLIC_DESC'
  | 'AKCE_BY_AI_ID_RODIC__SUMMARY_ASC'
  | 'AKCE_BY_AI_ID_RODIC__SUMMARY_DESC'
  | 'NATURAL'
  | 'NOTES_ASC'
  | 'NOTES_DESC'
  | 'USER_BY_AI_USER__U_BAN_ASC'
  | 'USER_BY_AI_USER__U_BAN_DESC'
  | 'USER_BY_AI_USER__U_CITY_ASC'
  | 'USER_BY_AI_USER__U_CITY_DESC'
  | 'USER_BY_AI_USER__U_CONFIRMED_ASC'
  | 'USER_BY_AI_USER__U_CONFIRMED_DESC'
  | 'USER_BY_AI_USER__U_CONSCRIPTION_NUMBER_ASC'
  | 'USER_BY_AI_USER__U_CONSCRIPTION_NUMBER_DESC'
  | 'USER_BY_AI_USER__U_CREATED_AT_ASC'
  | 'USER_BY_AI_USER__U_CREATED_AT_DESC'
  | 'USER_BY_AI_USER__U_DANCER_ASC'
  | 'USER_BY_AI_USER__U_DANCER_DESC'
  | 'USER_BY_AI_USER__U_DISTRICT_ASC'
  | 'USER_BY_AI_USER__U_DISTRICT_DESC'
  | 'USER_BY_AI_USER__U_EMAIL_ASC'
  | 'USER_BY_AI_USER__U_EMAIL_DESC'
  | 'USER_BY_AI_USER__U_GDPR_SIGNED_AT_ASC'
  | 'USER_BY_AI_USER__U_GDPR_SIGNED_AT_DESC'
  | 'USER_BY_AI_USER__U_GROUP_ASC'
  | 'USER_BY_AI_USER__U_GROUP_DESC'
  | 'USER_BY_AI_USER__U_ID_ASC'
  | 'USER_BY_AI_USER__U_ID_DESC'
  | 'USER_BY_AI_USER__U_JMENO_ASC'
  | 'USER_BY_AI_USER__U_JMENO_DESC'
  | 'USER_BY_AI_USER__U_LEVEL_ASC'
  | 'USER_BY_AI_USER__U_LEVEL_DESC'
  | 'USER_BY_AI_USER__U_LOCK_ASC'
  | 'USER_BY_AI_USER__U_LOCK_DESC'
  | 'USER_BY_AI_USER__U_LOGIN_ASC'
  | 'USER_BY_AI_USER__U_LOGIN_DESC'
  | 'USER_BY_AI_USER__U_MEMBER_SINCE_ASC'
  | 'USER_BY_AI_USER__U_MEMBER_SINCE_DESC'
  | 'USER_BY_AI_USER__U_MEMBER_UNTIL_ASC'
  | 'USER_BY_AI_USER__U_MEMBER_UNTIL_DESC'
  | 'USER_BY_AI_USER__U_NAROZENI_ASC'
  | 'USER_BY_AI_USER__U_NAROZENI_DESC'
  | 'USER_BY_AI_USER__U_NATIONALITY_ASC'
  | 'USER_BY_AI_USER__U_NATIONALITY_DESC'
  | 'USER_BY_AI_USER__U_ORIENTATION_NUMBER_ASC'
  | 'USER_BY_AI_USER__U_ORIENTATION_NUMBER_DESC'
  | 'USER_BY_AI_USER__U_PASS_ASC'
  | 'USER_BY_AI_USER__U_PASS_DESC'
  | 'USER_BY_AI_USER__U_POHLAVI_ASC'
  | 'USER_BY_AI_USER__U_POHLAVI_DESC'
  | 'USER_BY_AI_USER__U_POSTAL_CODE_ASC'
  | 'USER_BY_AI_USER__U_POSTAL_CODE_DESC'
  | 'USER_BY_AI_USER__U_POZNAMKY_ASC'
  | 'USER_BY_AI_USER__U_POZNAMKY_DESC'
  | 'USER_BY_AI_USER__U_PRIJMENI_ASC'
  | 'USER_BY_AI_USER__U_PRIJMENI_DESC'
  | 'USER_BY_AI_USER__U_RODNE_CISLO_ASC'
  | 'USER_BY_AI_USER__U_RODNE_CISLO_DESC'
  | 'USER_BY_AI_USER__U_SKUPINA_ASC'
  | 'USER_BY_AI_USER__U_SKUPINA_DESC'
  | 'USER_BY_AI_USER__U_STREET_ASC'
  | 'USER_BY_AI_USER__U_STREET_DESC'
  | 'USER_BY_AI_USER__U_SYSTEM_ASC'
  | 'USER_BY_AI_USER__U_SYSTEM_DESC'
  | 'USER_BY_AI_USER__U_TEACHER_ASC'
  | 'USER_BY_AI_USER__U_TEACHER_DESC'
  | 'USER_BY_AI_USER__U_TELEFON_ASC'
  | 'USER_BY_AI_USER__U_TELEFON_DESC'
  | 'USER_BY_AI_USER__U_TIMESTAMP_ASC'
  | 'USER_BY_AI_USER__U_TIMESTAMP_DESC';

/** A connection to a list of `Akce` values. */
export type AkcesConnection = {
  __typename?: 'AkcesConnection';
  /** A list of edges which contains the `Akce` and cursor to aid in pagination. */
  edges: Array<AkcesEdge>;
  /** A list of `Akce` objects. */
  nodes: Array<Akce>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Akce` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Akce` edge in the connection. */
export type AkcesEdge = {
  __typename?: 'AkcesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Akce` at the end of the edge. */
  node: Akce;
};

/** Methods to use when ordering `Akce`. */
export type AkcesOrderBy =
  | 'AKCE_ITEMS_BY_AI_ID_RODIC__COUNT_ASC'
  | 'AKCE_ITEMS_BY_AI_ID_RODIC__COUNT_DESC'
  | 'A_DOKUMENTY_ASC'
  | 'A_DOKUMENTY_DESC'
  | 'A_DO_ASC'
  | 'A_DO_DESC'
  | 'A_ID_ASC'
  | 'A_ID_DESC'
  | 'A_INFO_ASC'
  | 'A_INFO_DESC'
  | 'A_JMENO_ASC'
  | 'A_JMENO_DESC'
  | 'A_KAPACITA_ASC'
  | 'A_KAPACITA_DESC'
  | 'A_KDE_ASC'
  | 'A_KDE_DESC'
  | 'A_LOCK_ASC'
  | 'A_LOCK_DESC'
  | 'A_OD_ASC'
  | 'A_OD_DESC'
  | 'A_TIMESTAMP_ASC'
  | 'A_TIMESTAMP_DESC'
  | 'A_VISIBLE_ASC'
  | 'A_VISIBLE_DESC'
  | 'ENABLE_NOTES_ASC'
  | 'ENABLE_NOTES_DESC'
  | 'IS_PUBLIC_ASC'
  | 'IS_PUBLIC_DESC'
  | 'NATURAL'
  | 'SUMMARY_ASC'
  | 'SUMMARY_DESC';

/** A connection to a list of `Aktuality` values. */
export type AktualitiesConnection = {
  __typename?: 'AktualitiesConnection';
  /** A list of edges which contains the `Aktuality` and cursor to aid in pagination. */
  edges: Array<AktualitiesEdge>;
  /** A list of `Aktuality` objects. */
  nodes: Array<Aktuality>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Aktuality` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Aktuality` edge in the connection. */
export type AktualitiesEdge = {
  __typename?: 'AktualitiesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Aktuality` at the end of the edge. */
  node: Aktuality;
};

/** Methods to use when ordering `Aktuality`. */
export type AktualitiesOrderBy =
  | 'AT_FOTO_ASC'
  | 'AT_FOTO_DESC'
  | 'AT_FOTO_MAIN_ASC'
  | 'AT_FOTO_MAIN_DESC'
  | 'AT_ID_ASC'
  | 'AT_ID_DESC'
  | 'AT_JMENO_ASC'
  | 'AT_JMENO_DESC'
  | 'AT_KAT_ASC'
  | 'AT_KAT_DESC'
  | 'AT_KDO_ASC'
  | 'AT_KDO_DESC'
  | 'AT_PREVIEW_ASC'
  | 'AT_PREVIEW_DESC'
  | 'AT_TEXT_ASC'
  | 'AT_TEXT_DESC'
  | 'AT_TIMESTAMP_ADD_ASC'
  | 'AT_TIMESTAMP_ADD_DESC'
  | 'AT_TIMESTAMP_ASC'
  | 'AT_TIMESTAMP_DESC'
  | 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_ID_ASC'
  | 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_ID_DESC'
  | 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_ID_RODIC_ASC'
  | 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_ID_RODIC_DESC'
  | 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_KDO_ASC'
  | 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_KDO_DESC'
  | 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_NAME_ASC'
  | 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_NAME_DESC'
  | 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_PATH_ASC'
  | 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_PATH_DESC'
  | 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_TIMESTAMP_ASC'
  | 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_TIMESTAMP_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'USER_BY_AT_KDO__U_BAN_ASC'
  | 'USER_BY_AT_KDO__U_BAN_DESC'
  | 'USER_BY_AT_KDO__U_CITY_ASC'
  | 'USER_BY_AT_KDO__U_CITY_DESC'
  | 'USER_BY_AT_KDO__U_CONFIRMED_ASC'
  | 'USER_BY_AT_KDO__U_CONFIRMED_DESC'
  | 'USER_BY_AT_KDO__U_CONSCRIPTION_NUMBER_ASC'
  | 'USER_BY_AT_KDO__U_CONSCRIPTION_NUMBER_DESC'
  | 'USER_BY_AT_KDO__U_CREATED_AT_ASC'
  | 'USER_BY_AT_KDO__U_CREATED_AT_DESC'
  | 'USER_BY_AT_KDO__U_DANCER_ASC'
  | 'USER_BY_AT_KDO__U_DANCER_DESC'
  | 'USER_BY_AT_KDO__U_DISTRICT_ASC'
  | 'USER_BY_AT_KDO__U_DISTRICT_DESC'
  | 'USER_BY_AT_KDO__U_EMAIL_ASC'
  | 'USER_BY_AT_KDO__U_EMAIL_DESC'
  | 'USER_BY_AT_KDO__U_GDPR_SIGNED_AT_ASC'
  | 'USER_BY_AT_KDO__U_GDPR_SIGNED_AT_DESC'
  | 'USER_BY_AT_KDO__U_GROUP_ASC'
  | 'USER_BY_AT_KDO__U_GROUP_DESC'
  | 'USER_BY_AT_KDO__U_ID_ASC'
  | 'USER_BY_AT_KDO__U_ID_DESC'
  | 'USER_BY_AT_KDO__U_JMENO_ASC'
  | 'USER_BY_AT_KDO__U_JMENO_DESC'
  | 'USER_BY_AT_KDO__U_LEVEL_ASC'
  | 'USER_BY_AT_KDO__U_LEVEL_DESC'
  | 'USER_BY_AT_KDO__U_LOCK_ASC'
  | 'USER_BY_AT_KDO__U_LOCK_DESC'
  | 'USER_BY_AT_KDO__U_LOGIN_ASC'
  | 'USER_BY_AT_KDO__U_LOGIN_DESC'
  | 'USER_BY_AT_KDO__U_MEMBER_SINCE_ASC'
  | 'USER_BY_AT_KDO__U_MEMBER_SINCE_DESC'
  | 'USER_BY_AT_KDO__U_MEMBER_UNTIL_ASC'
  | 'USER_BY_AT_KDO__U_MEMBER_UNTIL_DESC'
  | 'USER_BY_AT_KDO__U_NAROZENI_ASC'
  | 'USER_BY_AT_KDO__U_NAROZENI_DESC'
  | 'USER_BY_AT_KDO__U_NATIONALITY_ASC'
  | 'USER_BY_AT_KDO__U_NATIONALITY_DESC'
  | 'USER_BY_AT_KDO__U_ORIENTATION_NUMBER_ASC'
  | 'USER_BY_AT_KDO__U_ORIENTATION_NUMBER_DESC'
  | 'USER_BY_AT_KDO__U_PASS_ASC'
  | 'USER_BY_AT_KDO__U_PASS_DESC'
  | 'USER_BY_AT_KDO__U_POHLAVI_ASC'
  | 'USER_BY_AT_KDO__U_POHLAVI_DESC'
  | 'USER_BY_AT_KDO__U_POSTAL_CODE_ASC'
  | 'USER_BY_AT_KDO__U_POSTAL_CODE_DESC'
  | 'USER_BY_AT_KDO__U_POZNAMKY_ASC'
  | 'USER_BY_AT_KDO__U_POZNAMKY_DESC'
  | 'USER_BY_AT_KDO__U_PRIJMENI_ASC'
  | 'USER_BY_AT_KDO__U_PRIJMENI_DESC'
  | 'USER_BY_AT_KDO__U_RODNE_CISLO_ASC'
  | 'USER_BY_AT_KDO__U_RODNE_CISLO_DESC'
  | 'USER_BY_AT_KDO__U_SKUPINA_ASC'
  | 'USER_BY_AT_KDO__U_SKUPINA_DESC'
  | 'USER_BY_AT_KDO__U_STREET_ASC'
  | 'USER_BY_AT_KDO__U_STREET_DESC'
  | 'USER_BY_AT_KDO__U_SYSTEM_ASC'
  | 'USER_BY_AT_KDO__U_SYSTEM_DESC'
  | 'USER_BY_AT_KDO__U_TEACHER_ASC'
  | 'USER_BY_AT_KDO__U_TEACHER_DESC'
  | 'USER_BY_AT_KDO__U_TELEFON_ASC'
  | 'USER_BY_AT_KDO__U_TELEFON_DESC'
  | 'USER_BY_AT_KDO__U_TIMESTAMP_ASC'
  | 'USER_BY_AT_KDO__U_TIMESTAMP_DESC';

export type Aktuality = Node & {
  __typename?: 'Aktuality';
  atFoto: Maybe<Scalars['BigInt']>;
  atFotoMain: Maybe<Scalars['BigInt']>;
  atId: Scalars['BigInt'];
  atJmeno: Scalars['String'];
  atKat: Scalars['String'];
  atKdo: Maybe<Scalars['BigInt']>;
  atPreview: Scalars['String'];
  atText: Scalars['String'];
  atTimestamp: Maybe<Scalars['Datetime']>;
  atTimestampAdd: Maybe<Scalars['Datetime']>;
  /** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
  galerieFotoByAtFotoMain: Maybe<GalerieFoto>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `User` that is related to this `Aktuality`. */
  userByAtKdo: Maybe<User>;
};

/**
 * A condition to be used against `Aktuality` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type AktualityCondition = {
  /** Checks for equality with the object’s `atFoto` field. */
  atFoto?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `atFotoMain` field. */
  atFotoMain?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `atId` field. */
  atId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `atJmeno` field. */
  atJmeno?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `atKat` field. */
  atKat?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `atKdo` field. */
  atKdo?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `atPreview` field. */
  atPreview?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `atText` field. */
  atText?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `atTimestamp` field. */
  atTimestamp?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `atTimestampAdd` field. */
  atTimestampAdd?: InputMaybe<Scalars['Datetime']>;
};

/** An input for mutations affecting `Aktuality` */
export type AktualityInput = {
  atFoto?: InputMaybe<Scalars['BigInt']>;
  atFotoMain?: InputMaybe<Scalars['BigInt']>;
  atId?: InputMaybe<Scalars['BigInt']>;
  atJmeno: Scalars['String'];
  atKat?: InputMaybe<Scalars['String']>;
  atKdo?: InputMaybe<Scalars['BigInt']>;
  atPreview: Scalars['String'];
  atText: Scalars['String'];
  atTimestamp?: InputMaybe<Scalars['Datetime']>;
  atTimestampAdd?: InputMaybe<Scalars['Datetime']>;
};

/** Represents an update to a `Aktuality`. Fields that are set will be updated. */
export type AktualityPatch = {
  atFoto?: InputMaybe<Scalars['BigInt']>;
  atFotoMain?: InputMaybe<Scalars['BigInt']>;
  atId?: InputMaybe<Scalars['BigInt']>;
  atJmeno?: InputMaybe<Scalars['String']>;
  atKat?: InputMaybe<Scalars['String']>;
  atKdo?: InputMaybe<Scalars['BigInt']>;
  atPreview?: InputMaybe<Scalars['String']>;
  atText?: InputMaybe<Scalars['String']>;
  atTimestamp?: InputMaybe<Scalars['Datetime']>;
  atTimestampAdd?: InputMaybe<Scalars['Datetime']>;
};

export type Attachment = Node & {
  __typename?: 'Attachment';
  /** Reads and enables pagination through a set of `LocationAttachment`. */
  locationAttachmentsByObjectName: LocationAttachmentsConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  objectName: Scalars['String'];
  previewObjectName: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `RoomAttachment`. */
  roomAttachmentsByObjectName: RoomAttachmentsConnection;
  /** Reads and enables pagination through a set of `TenantAttachment`. */
  tenantAttachmentsByObjectName: TenantAttachmentsConnection;
  uploadedAt: Scalars['Datetime'];
  uploadedBy: Maybe<Scalars['BigInt']>;
  /** Reads a single `User` that is related to this `Attachment`. */
  userByUploadedBy: Maybe<User>;
};


export type AttachmentLocationAttachmentsByObjectNameArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<LocationAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LocationAttachmentsOrderBy>>;
};


export type AttachmentRoomAttachmentsByObjectNameArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<RoomAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RoomAttachmentsOrderBy>>;
};


export type AttachmentTenantAttachmentsByObjectNameArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<TenantAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TenantAttachmentsOrderBy>>;
};

/**
 * A condition to be used against `Attachment` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type AttachmentCondition = {
  /** Checks for equality with the object’s `objectName` field. */
  objectName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `previewObjectName` field. */
  previewObjectName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uploadedAt` field. */
  uploadedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `uploadedBy` field. */
  uploadedBy?: InputMaybe<Scalars['BigInt']>;
};

/** An input for mutations affecting `Attachment` */
export type AttachmentInput = {
  objectName: Scalars['String'];
  previewObjectName?: InputMaybe<Scalars['String']>;
  uploadedAt?: InputMaybe<Scalars['Datetime']>;
  uploadedBy?: InputMaybe<Scalars['BigInt']>;
};

/** Represents an update to a `Attachment`. Fields that are set will be updated. */
export type AttachmentPatch = {
  objectName?: InputMaybe<Scalars['String']>;
  previewObjectName?: InputMaybe<Scalars['String']>;
  uploadedAt?: InputMaybe<Scalars['Datetime']>;
  uploadedBy?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `Attachment` values. */
export type AttachmentsConnection = {
  __typename?: 'AttachmentsConnection';
  /** A list of edges which contains the `Attachment` and cursor to aid in pagination. */
  edges: Array<AttachmentsEdge>;
  /** A list of `Attachment` objects. */
  nodes: Array<Attachment>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Attachment` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Attachment` edge in the connection. */
export type AttachmentsEdge = {
  __typename?: 'AttachmentsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Attachment` at the end of the edge. */
  node: Attachment;
};

/** Methods to use when ordering `Attachment`. */
export type AttachmentsOrderBy =
  | 'LOCATION_ATTACHMENTS_BY_OBJECT_NAME__COUNT_ASC'
  | 'LOCATION_ATTACHMENTS_BY_OBJECT_NAME__COUNT_DESC'
  | 'NATURAL'
  | 'OBJECT_NAME_ASC'
  | 'OBJECT_NAME_DESC'
  | 'PREVIEW_OBJECT_NAME_ASC'
  | 'PREVIEW_OBJECT_NAME_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'ROOM_ATTACHMENTS_BY_OBJECT_NAME__COUNT_ASC'
  | 'ROOM_ATTACHMENTS_BY_OBJECT_NAME__COUNT_DESC'
  | 'TENANT_ATTACHMENTS_BY_OBJECT_NAME__COUNT_ASC'
  | 'TENANT_ATTACHMENTS_BY_OBJECT_NAME__COUNT_DESC'
  | 'UPLOADED_AT_ASC'
  | 'UPLOADED_AT_DESC'
  | 'UPLOADED_BY_ASC'
  | 'UPLOADED_BY_DESC'
  | 'USER_BY_UPLOADED_BY__U_BAN_ASC'
  | 'USER_BY_UPLOADED_BY__U_BAN_DESC'
  | 'USER_BY_UPLOADED_BY__U_CITY_ASC'
  | 'USER_BY_UPLOADED_BY__U_CITY_DESC'
  | 'USER_BY_UPLOADED_BY__U_CONFIRMED_ASC'
  | 'USER_BY_UPLOADED_BY__U_CONFIRMED_DESC'
  | 'USER_BY_UPLOADED_BY__U_CONSCRIPTION_NUMBER_ASC'
  | 'USER_BY_UPLOADED_BY__U_CONSCRIPTION_NUMBER_DESC'
  | 'USER_BY_UPLOADED_BY__U_CREATED_AT_ASC'
  | 'USER_BY_UPLOADED_BY__U_CREATED_AT_DESC'
  | 'USER_BY_UPLOADED_BY__U_DANCER_ASC'
  | 'USER_BY_UPLOADED_BY__U_DANCER_DESC'
  | 'USER_BY_UPLOADED_BY__U_DISTRICT_ASC'
  | 'USER_BY_UPLOADED_BY__U_DISTRICT_DESC'
  | 'USER_BY_UPLOADED_BY__U_EMAIL_ASC'
  | 'USER_BY_UPLOADED_BY__U_EMAIL_DESC'
  | 'USER_BY_UPLOADED_BY__U_GDPR_SIGNED_AT_ASC'
  | 'USER_BY_UPLOADED_BY__U_GDPR_SIGNED_AT_DESC'
  | 'USER_BY_UPLOADED_BY__U_GROUP_ASC'
  | 'USER_BY_UPLOADED_BY__U_GROUP_DESC'
  | 'USER_BY_UPLOADED_BY__U_ID_ASC'
  | 'USER_BY_UPLOADED_BY__U_ID_DESC'
  | 'USER_BY_UPLOADED_BY__U_JMENO_ASC'
  | 'USER_BY_UPLOADED_BY__U_JMENO_DESC'
  | 'USER_BY_UPLOADED_BY__U_LEVEL_ASC'
  | 'USER_BY_UPLOADED_BY__U_LEVEL_DESC'
  | 'USER_BY_UPLOADED_BY__U_LOCK_ASC'
  | 'USER_BY_UPLOADED_BY__U_LOCK_DESC'
  | 'USER_BY_UPLOADED_BY__U_LOGIN_ASC'
  | 'USER_BY_UPLOADED_BY__U_LOGIN_DESC'
  | 'USER_BY_UPLOADED_BY__U_MEMBER_SINCE_ASC'
  | 'USER_BY_UPLOADED_BY__U_MEMBER_SINCE_DESC'
  | 'USER_BY_UPLOADED_BY__U_MEMBER_UNTIL_ASC'
  | 'USER_BY_UPLOADED_BY__U_MEMBER_UNTIL_DESC'
  | 'USER_BY_UPLOADED_BY__U_NAROZENI_ASC'
  | 'USER_BY_UPLOADED_BY__U_NAROZENI_DESC'
  | 'USER_BY_UPLOADED_BY__U_NATIONALITY_ASC'
  | 'USER_BY_UPLOADED_BY__U_NATIONALITY_DESC'
  | 'USER_BY_UPLOADED_BY__U_ORIENTATION_NUMBER_ASC'
  | 'USER_BY_UPLOADED_BY__U_ORIENTATION_NUMBER_DESC'
  | 'USER_BY_UPLOADED_BY__U_PASS_ASC'
  | 'USER_BY_UPLOADED_BY__U_PASS_DESC'
  | 'USER_BY_UPLOADED_BY__U_POHLAVI_ASC'
  | 'USER_BY_UPLOADED_BY__U_POHLAVI_DESC'
  | 'USER_BY_UPLOADED_BY__U_POSTAL_CODE_ASC'
  | 'USER_BY_UPLOADED_BY__U_POSTAL_CODE_DESC'
  | 'USER_BY_UPLOADED_BY__U_POZNAMKY_ASC'
  | 'USER_BY_UPLOADED_BY__U_POZNAMKY_DESC'
  | 'USER_BY_UPLOADED_BY__U_PRIJMENI_ASC'
  | 'USER_BY_UPLOADED_BY__U_PRIJMENI_DESC'
  | 'USER_BY_UPLOADED_BY__U_RODNE_CISLO_ASC'
  | 'USER_BY_UPLOADED_BY__U_RODNE_CISLO_DESC'
  | 'USER_BY_UPLOADED_BY__U_SKUPINA_ASC'
  | 'USER_BY_UPLOADED_BY__U_SKUPINA_DESC'
  | 'USER_BY_UPLOADED_BY__U_STREET_ASC'
  | 'USER_BY_UPLOADED_BY__U_STREET_DESC'
  | 'USER_BY_UPLOADED_BY__U_SYSTEM_ASC'
  | 'USER_BY_UPLOADED_BY__U_SYSTEM_DESC'
  | 'USER_BY_UPLOADED_BY__U_TEACHER_ASC'
  | 'USER_BY_UPLOADED_BY__U_TEACHER_DESC'
  | 'USER_BY_UPLOADED_BY__U_TELEFON_ASC'
  | 'USER_BY_UPLOADED_BY__U_TELEFON_DESC'
  | 'USER_BY_UPLOADED_BY__U_TIMESTAMP_ASC'
  | 'USER_BY_UPLOADED_BY__U_TIMESTAMP_DESC';

export type AttendeeExternal = Node & {
  __typename?: 'AttendeeExternal';
  birthNumber: Maybe<Scalars['String']>;
  confirmedAt: Maybe<Scalars['Datetime']>;
  confirmedBy: Maybe<Scalars['BigInt']>;
  createdAt: Scalars['Datetime'];
  email: Scalars['String'];
  /** Reads a single `Event` that is related to this `AttendeeExternal`. */
  event: Maybe<Event>;
  eventId: Scalars['BigInt'];
  firstName: Scalars['String'];
  guardianName: Scalars['String'];
  id: Scalars['BigInt'];
  lastName: Scalars['String'];
  managedBy: Maybe<Scalars['BigInt']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  notes: Scalars['String'];
  phone: Scalars['String'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `User` that is related to this `AttendeeExternal`. */
  userByConfirmedBy: Maybe<User>;
  /** Reads a single `User` that is related to this `AttendeeExternal`. */
  userByManagedBy: Maybe<User>;
};

/**
 * A condition to be used against `AttendeeExternal` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type AttendeeExternalCondition = {
  /** Checks for equality with the object’s `birthNumber` field. */
  birthNumber?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `confirmedAt` field. */
  confirmedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `confirmedBy` field. */
  confirmedBy?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `eventId` field. */
  eventId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `guardianName` field. */
  guardianName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `managedBy` field. */
  managedBy?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `phone` field. */
  phone?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']>;
};

/** An input for mutations affecting `AttendeeExternal` */
export type AttendeeExternalInput = {
  birthNumber?: InputMaybe<Scalars['String']>;
  confirmedAt?: InputMaybe<Scalars['Datetime']>;
  confirmedBy?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  email: Scalars['String'];
  eventId: Scalars['BigInt'];
  firstName: Scalars['String'];
  guardianName?: InputMaybe<Scalars['String']>;
  lastName: Scalars['String'];
  managedBy?: InputMaybe<Scalars['BigInt']>;
  notes?: InputMaybe<Scalars['String']>;
  phone: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['Datetime']>;
};

/** Represents an update to a `AttendeeExternal`. Fields that are set will be updated. */
export type AttendeeExternalPatch = {
  birthNumber?: InputMaybe<Scalars['String']>;
  confirmedAt?: InputMaybe<Scalars['Datetime']>;
  confirmedBy?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  email?: InputMaybe<Scalars['String']>;
  eventId?: InputMaybe<Scalars['BigInt']>;
  firstName?: InputMaybe<Scalars['String']>;
  guardianName?: InputMaybe<Scalars['String']>;
  lastName?: InputMaybe<Scalars['String']>;
  managedBy?: InputMaybe<Scalars['BigInt']>;
  notes?: InputMaybe<Scalars['String']>;
  phone?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['Datetime']>;
};

/** A connection to a list of `AttendeeExternal` values. */
export type AttendeeExternalsConnection = {
  __typename?: 'AttendeeExternalsConnection';
  /** A list of edges which contains the `AttendeeExternal` and cursor to aid in pagination. */
  edges: Array<AttendeeExternalsEdge>;
  /** A list of `AttendeeExternal` objects. */
  nodes: Array<AttendeeExternal>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AttendeeExternal` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `AttendeeExternal` edge in the connection. */
export type AttendeeExternalsEdge = {
  __typename?: 'AttendeeExternalsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `AttendeeExternal` at the end of the edge. */
  node: AttendeeExternal;
};

/** Methods to use when ordering `AttendeeExternal`. */
export type AttendeeExternalsOrderBy =
  | 'BIRTH_NUMBER_ASC'
  | 'BIRTH_NUMBER_DESC'
  | 'CONFIRMED_AT_ASC'
  | 'CONFIRMED_AT_DESC'
  | 'CONFIRMED_BY_ASC'
  | 'CONFIRMED_BY_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'EMAIL_ASC'
  | 'EMAIL_DESC'
  | 'EVENT_BY_EVENT_ID__CAPACITY_ASC'
  | 'EVENT_BY_EVENT_ID__CAPACITY_DESC'
  | 'EVENT_BY_EVENT_ID__DESCRIPTION_ASC'
  | 'EVENT_BY_EVENT_ID__DESCRIPTION_DESC'
  | 'EVENT_BY_EVENT_ID__ENABLE_NOTES_ASC'
  | 'EVENT_BY_EVENT_ID__ENABLE_NOTES_DESC'
  | 'EVENT_BY_EVENT_ID__FILES_LEGACY_ASC'
  | 'EVENT_BY_EVENT_ID__FILES_LEGACY_DESC'
  | 'EVENT_BY_EVENT_ID__ID_ASC'
  | 'EVENT_BY_EVENT_ID__ID_DESC'
  | 'EVENT_BY_EVENT_ID__IS_LOCKED_ASC'
  | 'EVENT_BY_EVENT_ID__IS_LOCKED_DESC'
  | 'EVENT_BY_EVENT_ID__IS_PUBLIC_ASC'
  | 'EVENT_BY_EVENT_ID__IS_PUBLIC_DESC'
  | 'EVENT_BY_EVENT_ID__IS_VISIBLE_ASC'
  | 'EVENT_BY_EVENT_ID__IS_VISIBLE_DESC'
  | 'EVENT_BY_EVENT_ID__LOCATION_TEXT_ASC'
  | 'EVENT_BY_EVENT_ID__LOCATION_TEXT_DESC'
  | 'EVENT_BY_EVENT_ID__NAME_ASC'
  | 'EVENT_BY_EVENT_ID__NAME_DESC'
  | 'EVENT_BY_EVENT_ID__SINCE_ASC'
  | 'EVENT_BY_EVENT_ID__SINCE_DESC'
  | 'EVENT_BY_EVENT_ID__SUMMARY_ASC'
  | 'EVENT_BY_EVENT_ID__SUMMARY_DESC'
  | 'EVENT_BY_EVENT_ID__UNTIL_ASC'
  | 'EVENT_BY_EVENT_ID__UNTIL_DESC'
  | 'EVENT_BY_EVENT_ID__UPDATED_AT_ASC'
  | 'EVENT_BY_EVENT_ID__UPDATED_AT_DESC'
  | 'EVENT_ID_ASC'
  | 'EVENT_ID_DESC'
  | 'FIRST_NAME_ASC'
  | 'FIRST_NAME_DESC'
  | 'GUARDIAN_NAME_ASC'
  | 'GUARDIAN_NAME_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'LAST_NAME_ASC'
  | 'LAST_NAME_DESC'
  | 'MANAGED_BY_ASC'
  | 'MANAGED_BY_DESC'
  | 'NATURAL'
  | 'NOTES_ASC'
  | 'NOTES_DESC'
  | 'PHONE_ASC'
  | 'PHONE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC'
  | 'USER_BY_CONFIRMED_BY__U_BAN_ASC'
  | 'USER_BY_CONFIRMED_BY__U_BAN_DESC'
  | 'USER_BY_CONFIRMED_BY__U_CITY_ASC'
  | 'USER_BY_CONFIRMED_BY__U_CITY_DESC'
  | 'USER_BY_CONFIRMED_BY__U_CONFIRMED_ASC'
  | 'USER_BY_CONFIRMED_BY__U_CONFIRMED_DESC'
  | 'USER_BY_CONFIRMED_BY__U_CONSCRIPTION_NUMBER_ASC'
  | 'USER_BY_CONFIRMED_BY__U_CONSCRIPTION_NUMBER_DESC'
  | 'USER_BY_CONFIRMED_BY__U_CREATED_AT_ASC'
  | 'USER_BY_CONFIRMED_BY__U_CREATED_AT_DESC'
  | 'USER_BY_CONFIRMED_BY__U_DANCER_ASC'
  | 'USER_BY_CONFIRMED_BY__U_DANCER_DESC'
  | 'USER_BY_CONFIRMED_BY__U_DISTRICT_ASC'
  | 'USER_BY_CONFIRMED_BY__U_DISTRICT_DESC'
  | 'USER_BY_CONFIRMED_BY__U_EMAIL_ASC'
  | 'USER_BY_CONFIRMED_BY__U_EMAIL_DESC'
  | 'USER_BY_CONFIRMED_BY__U_GDPR_SIGNED_AT_ASC'
  | 'USER_BY_CONFIRMED_BY__U_GDPR_SIGNED_AT_DESC'
  | 'USER_BY_CONFIRMED_BY__U_GROUP_ASC'
  | 'USER_BY_CONFIRMED_BY__U_GROUP_DESC'
  | 'USER_BY_CONFIRMED_BY__U_ID_ASC'
  | 'USER_BY_CONFIRMED_BY__U_ID_DESC'
  | 'USER_BY_CONFIRMED_BY__U_JMENO_ASC'
  | 'USER_BY_CONFIRMED_BY__U_JMENO_DESC'
  | 'USER_BY_CONFIRMED_BY__U_LEVEL_ASC'
  | 'USER_BY_CONFIRMED_BY__U_LEVEL_DESC'
  | 'USER_BY_CONFIRMED_BY__U_LOCK_ASC'
  | 'USER_BY_CONFIRMED_BY__U_LOCK_DESC'
  | 'USER_BY_CONFIRMED_BY__U_LOGIN_ASC'
  | 'USER_BY_CONFIRMED_BY__U_LOGIN_DESC'
  | 'USER_BY_CONFIRMED_BY__U_MEMBER_SINCE_ASC'
  | 'USER_BY_CONFIRMED_BY__U_MEMBER_SINCE_DESC'
  | 'USER_BY_CONFIRMED_BY__U_MEMBER_UNTIL_ASC'
  | 'USER_BY_CONFIRMED_BY__U_MEMBER_UNTIL_DESC'
  | 'USER_BY_CONFIRMED_BY__U_NAROZENI_ASC'
  | 'USER_BY_CONFIRMED_BY__U_NAROZENI_DESC'
  | 'USER_BY_CONFIRMED_BY__U_NATIONALITY_ASC'
  | 'USER_BY_CONFIRMED_BY__U_NATIONALITY_DESC'
  | 'USER_BY_CONFIRMED_BY__U_ORIENTATION_NUMBER_ASC'
  | 'USER_BY_CONFIRMED_BY__U_ORIENTATION_NUMBER_DESC'
  | 'USER_BY_CONFIRMED_BY__U_PASS_ASC'
  | 'USER_BY_CONFIRMED_BY__U_PASS_DESC'
  | 'USER_BY_CONFIRMED_BY__U_POHLAVI_ASC'
  | 'USER_BY_CONFIRMED_BY__U_POHLAVI_DESC'
  | 'USER_BY_CONFIRMED_BY__U_POSTAL_CODE_ASC'
  | 'USER_BY_CONFIRMED_BY__U_POSTAL_CODE_DESC'
  | 'USER_BY_CONFIRMED_BY__U_POZNAMKY_ASC'
  | 'USER_BY_CONFIRMED_BY__U_POZNAMKY_DESC'
  | 'USER_BY_CONFIRMED_BY__U_PRIJMENI_ASC'
  | 'USER_BY_CONFIRMED_BY__U_PRIJMENI_DESC'
  | 'USER_BY_CONFIRMED_BY__U_RODNE_CISLO_ASC'
  | 'USER_BY_CONFIRMED_BY__U_RODNE_CISLO_DESC'
  | 'USER_BY_CONFIRMED_BY__U_SKUPINA_ASC'
  | 'USER_BY_CONFIRMED_BY__U_SKUPINA_DESC'
  | 'USER_BY_CONFIRMED_BY__U_STREET_ASC'
  | 'USER_BY_CONFIRMED_BY__U_STREET_DESC'
  | 'USER_BY_CONFIRMED_BY__U_SYSTEM_ASC'
  | 'USER_BY_CONFIRMED_BY__U_SYSTEM_DESC'
  | 'USER_BY_CONFIRMED_BY__U_TEACHER_ASC'
  | 'USER_BY_CONFIRMED_BY__U_TEACHER_DESC'
  | 'USER_BY_CONFIRMED_BY__U_TELEFON_ASC'
  | 'USER_BY_CONFIRMED_BY__U_TELEFON_DESC'
  | 'USER_BY_CONFIRMED_BY__U_TIMESTAMP_ASC'
  | 'USER_BY_CONFIRMED_BY__U_TIMESTAMP_DESC'
  | 'USER_BY_MANAGED_BY__U_BAN_ASC'
  | 'USER_BY_MANAGED_BY__U_BAN_DESC'
  | 'USER_BY_MANAGED_BY__U_CITY_ASC'
  | 'USER_BY_MANAGED_BY__U_CITY_DESC'
  | 'USER_BY_MANAGED_BY__U_CONFIRMED_ASC'
  | 'USER_BY_MANAGED_BY__U_CONFIRMED_DESC'
  | 'USER_BY_MANAGED_BY__U_CONSCRIPTION_NUMBER_ASC'
  | 'USER_BY_MANAGED_BY__U_CONSCRIPTION_NUMBER_DESC'
  | 'USER_BY_MANAGED_BY__U_CREATED_AT_ASC'
  | 'USER_BY_MANAGED_BY__U_CREATED_AT_DESC'
  | 'USER_BY_MANAGED_BY__U_DANCER_ASC'
  | 'USER_BY_MANAGED_BY__U_DANCER_DESC'
  | 'USER_BY_MANAGED_BY__U_DISTRICT_ASC'
  | 'USER_BY_MANAGED_BY__U_DISTRICT_DESC'
  | 'USER_BY_MANAGED_BY__U_EMAIL_ASC'
  | 'USER_BY_MANAGED_BY__U_EMAIL_DESC'
  | 'USER_BY_MANAGED_BY__U_GDPR_SIGNED_AT_ASC'
  | 'USER_BY_MANAGED_BY__U_GDPR_SIGNED_AT_DESC'
  | 'USER_BY_MANAGED_BY__U_GROUP_ASC'
  | 'USER_BY_MANAGED_BY__U_GROUP_DESC'
  | 'USER_BY_MANAGED_BY__U_ID_ASC'
  | 'USER_BY_MANAGED_BY__U_ID_DESC'
  | 'USER_BY_MANAGED_BY__U_JMENO_ASC'
  | 'USER_BY_MANAGED_BY__U_JMENO_DESC'
  | 'USER_BY_MANAGED_BY__U_LEVEL_ASC'
  | 'USER_BY_MANAGED_BY__U_LEVEL_DESC'
  | 'USER_BY_MANAGED_BY__U_LOCK_ASC'
  | 'USER_BY_MANAGED_BY__U_LOCK_DESC'
  | 'USER_BY_MANAGED_BY__U_LOGIN_ASC'
  | 'USER_BY_MANAGED_BY__U_LOGIN_DESC'
  | 'USER_BY_MANAGED_BY__U_MEMBER_SINCE_ASC'
  | 'USER_BY_MANAGED_BY__U_MEMBER_SINCE_DESC'
  | 'USER_BY_MANAGED_BY__U_MEMBER_UNTIL_ASC'
  | 'USER_BY_MANAGED_BY__U_MEMBER_UNTIL_DESC'
  | 'USER_BY_MANAGED_BY__U_NAROZENI_ASC'
  | 'USER_BY_MANAGED_BY__U_NAROZENI_DESC'
  | 'USER_BY_MANAGED_BY__U_NATIONALITY_ASC'
  | 'USER_BY_MANAGED_BY__U_NATIONALITY_DESC'
  | 'USER_BY_MANAGED_BY__U_ORIENTATION_NUMBER_ASC'
  | 'USER_BY_MANAGED_BY__U_ORIENTATION_NUMBER_DESC'
  | 'USER_BY_MANAGED_BY__U_PASS_ASC'
  | 'USER_BY_MANAGED_BY__U_PASS_DESC'
  | 'USER_BY_MANAGED_BY__U_POHLAVI_ASC'
  | 'USER_BY_MANAGED_BY__U_POHLAVI_DESC'
  | 'USER_BY_MANAGED_BY__U_POSTAL_CODE_ASC'
  | 'USER_BY_MANAGED_BY__U_POSTAL_CODE_DESC'
  | 'USER_BY_MANAGED_BY__U_POZNAMKY_ASC'
  | 'USER_BY_MANAGED_BY__U_POZNAMKY_DESC'
  | 'USER_BY_MANAGED_BY__U_PRIJMENI_ASC'
  | 'USER_BY_MANAGED_BY__U_PRIJMENI_DESC'
  | 'USER_BY_MANAGED_BY__U_RODNE_CISLO_ASC'
  | 'USER_BY_MANAGED_BY__U_RODNE_CISLO_DESC'
  | 'USER_BY_MANAGED_BY__U_SKUPINA_ASC'
  | 'USER_BY_MANAGED_BY__U_SKUPINA_DESC'
  | 'USER_BY_MANAGED_BY__U_STREET_ASC'
  | 'USER_BY_MANAGED_BY__U_STREET_DESC'
  | 'USER_BY_MANAGED_BY__U_SYSTEM_ASC'
  | 'USER_BY_MANAGED_BY__U_SYSTEM_DESC'
  | 'USER_BY_MANAGED_BY__U_TEACHER_ASC'
  | 'USER_BY_MANAGED_BY__U_TEACHER_DESC'
  | 'USER_BY_MANAGED_BY__U_TELEFON_ASC'
  | 'USER_BY_MANAGED_BY__U_TELEFON_DESC'
  | 'USER_BY_MANAGED_BY__U_TIMESTAMP_ASC'
  | 'USER_BY_MANAGED_BY__U_TIMESTAMP_DESC';

export type AttendeeUser = Node & {
  __typename?: 'AttendeeUser';
  birthYear: Scalars['Int'];
  /** Reads a single `Event` that is related to this `AttendeeUser`. */
  event: Maybe<Event>;
  eventId: Scalars['BigInt'];
  id: Scalars['BigInt'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  notes: Scalars['String'];
  /** Reads a single `User` that is related to this `AttendeeUser`. */
  user: Maybe<User>;
  userId: Scalars['BigInt'];
};

/**
 * A condition to be used against `AttendeeUser` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type AttendeeUserCondition = {
  /** Checks for equality with the object’s `birthYear` field. */
  birthYear?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `eventId` field. */
  eventId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']>;
};

/** An input for mutations affecting `AttendeeUser` */
export type AttendeeUserInput = {
  birthYear: Scalars['Int'];
  eventId: Scalars['BigInt'];
  id?: InputMaybe<Scalars['BigInt']>;
  notes?: InputMaybe<Scalars['String']>;
  userId: Scalars['BigInt'];
};

/** Represents an update to a `AttendeeUser`. Fields that are set will be updated. */
export type AttendeeUserPatch = {
  birthYear?: InputMaybe<Scalars['Int']>;
  eventId?: InputMaybe<Scalars['BigInt']>;
  id?: InputMaybe<Scalars['BigInt']>;
  notes?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `AttendeeUser` values. */
export type AttendeeUsersConnection = {
  __typename?: 'AttendeeUsersConnection';
  /** A list of edges which contains the `AttendeeUser` and cursor to aid in pagination. */
  edges: Array<AttendeeUsersEdge>;
  /** A list of `AttendeeUser` objects. */
  nodes: Array<AttendeeUser>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AttendeeUser` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `AttendeeUser` edge in the connection. */
export type AttendeeUsersEdge = {
  __typename?: 'AttendeeUsersEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `AttendeeUser` at the end of the edge. */
  node: AttendeeUser;
};

/** Methods to use when ordering `AttendeeUser`. */
export type AttendeeUsersOrderBy =
  | 'BIRTH_YEAR_ASC'
  | 'BIRTH_YEAR_DESC'
  | 'EVENT_BY_EVENT_ID__CAPACITY_ASC'
  | 'EVENT_BY_EVENT_ID__CAPACITY_DESC'
  | 'EVENT_BY_EVENT_ID__DESCRIPTION_ASC'
  | 'EVENT_BY_EVENT_ID__DESCRIPTION_DESC'
  | 'EVENT_BY_EVENT_ID__ENABLE_NOTES_ASC'
  | 'EVENT_BY_EVENT_ID__ENABLE_NOTES_DESC'
  | 'EVENT_BY_EVENT_ID__FILES_LEGACY_ASC'
  | 'EVENT_BY_EVENT_ID__FILES_LEGACY_DESC'
  | 'EVENT_BY_EVENT_ID__ID_ASC'
  | 'EVENT_BY_EVENT_ID__ID_DESC'
  | 'EVENT_BY_EVENT_ID__IS_LOCKED_ASC'
  | 'EVENT_BY_EVENT_ID__IS_LOCKED_DESC'
  | 'EVENT_BY_EVENT_ID__IS_PUBLIC_ASC'
  | 'EVENT_BY_EVENT_ID__IS_PUBLIC_DESC'
  | 'EVENT_BY_EVENT_ID__IS_VISIBLE_ASC'
  | 'EVENT_BY_EVENT_ID__IS_VISIBLE_DESC'
  | 'EVENT_BY_EVENT_ID__LOCATION_TEXT_ASC'
  | 'EVENT_BY_EVENT_ID__LOCATION_TEXT_DESC'
  | 'EVENT_BY_EVENT_ID__NAME_ASC'
  | 'EVENT_BY_EVENT_ID__NAME_DESC'
  | 'EVENT_BY_EVENT_ID__SINCE_ASC'
  | 'EVENT_BY_EVENT_ID__SINCE_DESC'
  | 'EVENT_BY_EVENT_ID__SUMMARY_ASC'
  | 'EVENT_BY_EVENT_ID__SUMMARY_DESC'
  | 'EVENT_BY_EVENT_ID__UNTIL_ASC'
  | 'EVENT_BY_EVENT_ID__UNTIL_DESC'
  | 'EVENT_BY_EVENT_ID__UPDATED_AT_ASC'
  | 'EVENT_BY_EVENT_ID__UPDATED_AT_DESC'
  | 'EVENT_ID_ASC'
  | 'EVENT_ID_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'NOTES_ASC'
  | 'NOTES_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'USER_BY_USER_ID__U_BAN_ASC'
  | 'USER_BY_USER_ID__U_BAN_DESC'
  | 'USER_BY_USER_ID__U_CITY_ASC'
  | 'USER_BY_USER_ID__U_CITY_DESC'
  | 'USER_BY_USER_ID__U_CONFIRMED_ASC'
  | 'USER_BY_USER_ID__U_CONFIRMED_DESC'
  | 'USER_BY_USER_ID__U_CONSCRIPTION_NUMBER_ASC'
  | 'USER_BY_USER_ID__U_CONSCRIPTION_NUMBER_DESC'
  | 'USER_BY_USER_ID__U_CREATED_AT_ASC'
  | 'USER_BY_USER_ID__U_CREATED_AT_DESC'
  | 'USER_BY_USER_ID__U_DANCER_ASC'
  | 'USER_BY_USER_ID__U_DANCER_DESC'
  | 'USER_BY_USER_ID__U_DISTRICT_ASC'
  | 'USER_BY_USER_ID__U_DISTRICT_DESC'
  | 'USER_BY_USER_ID__U_EMAIL_ASC'
  | 'USER_BY_USER_ID__U_EMAIL_DESC'
  | 'USER_BY_USER_ID__U_GDPR_SIGNED_AT_ASC'
  | 'USER_BY_USER_ID__U_GDPR_SIGNED_AT_DESC'
  | 'USER_BY_USER_ID__U_GROUP_ASC'
  | 'USER_BY_USER_ID__U_GROUP_DESC'
  | 'USER_BY_USER_ID__U_ID_ASC'
  | 'USER_BY_USER_ID__U_ID_DESC'
  | 'USER_BY_USER_ID__U_JMENO_ASC'
  | 'USER_BY_USER_ID__U_JMENO_DESC'
  | 'USER_BY_USER_ID__U_LEVEL_ASC'
  | 'USER_BY_USER_ID__U_LEVEL_DESC'
  | 'USER_BY_USER_ID__U_LOCK_ASC'
  | 'USER_BY_USER_ID__U_LOCK_DESC'
  | 'USER_BY_USER_ID__U_LOGIN_ASC'
  | 'USER_BY_USER_ID__U_LOGIN_DESC'
  | 'USER_BY_USER_ID__U_MEMBER_SINCE_ASC'
  | 'USER_BY_USER_ID__U_MEMBER_SINCE_DESC'
  | 'USER_BY_USER_ID__U_MEMBER_UNTIL_ASC'
  | 'USER_BY_USER_ID__U_MEMBER_UNTIL_DESC'
  | 'USER_BY_USER_ID__U_NAROZENI_ASC'
  | 'USER_BY_USER_ID__U_NAROZENI_DESC'
  | 'USER_BY_USER_ID__U_NATIONALITY_ASC'
  | 'USER_BY_USER_ID__U_NATIONALITY_DESC'
  | 'USER_BY_USER_ID__U_ORIENTATION_NUMBER_ASC'
  | 'USER_BY_USER_ID__U_ORIENTATION_NUMBER_DESC'
  | 'USER_BY_USER_ID__U_PASS_ASC'
  | 'USER_BY_USER_ID__U_PASS_DESC'
  | 'USER_BY_USER_ID__U_POHLAVI_ASC'
  | 'USER_BY_USER_ID__U_POHLAVI_DESC'
  | 'USER_BY_USER_ID__U_POSTAL_CODE_ASC'
  | 'USER_BY_USER_ID__U_POSTAL_CODE_DESC'
  | 'USER_BY_USER_ID__U_POZNAMKY_ASC'
  | 'USER_BY_USER_ID__U_POZNAMKY_DESC'
  | 'USER_BY_USER_ID__U_PRIJMENI_ASC'
  | 'USER_BY_USER_ID__U_PRIJMENI_DESC'
  | 'USER_BY_USER_ID__U_RODNE_CISLO_ASC'
  | 'USER_BY_USER_ID__U_RODNE_CISLO_DESC'
  | 'USER_BY_USER_ID__U_SKUPINA_ASC'
  | 'USER_BY_USER_ID__U_SKUPINA_DESC'
  | 'USER_BY_USER_ID__U_STREET_ASC'
  | 'USER_BY_USER_ID__U_STREET_DESC'
  | 'USER_BY_USER_ID__U_SYSTEM_ASC'
  | 'USER_BY_USER_ID__U_SYSTEM_DESC'
  | 'USER_BY_USER_ID__U_TEACHER_ASC'
  | 'USER_BY_USER_ID__U_TEACHER_DESC'
  | 'USER_BY_USER_ID__U_TELEFON_ASC'
  | 'USER_BY_USER_ID__U_TELEFON_DESC'
  | 'USER_BY_USER_ID__U_TIMESTAMP_ASC'
  | 'USER_BY_USER_ID__U_TIMESTAMP_DESC'
  | 'USER_ID_ASC'
  | 'USER_ID_DESC';

/** All input for the `bookLesson` mutation. */
export type BookLessonInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  lessonId: Scalars['BigInt'];
};

/** The output of our `bookLesson` mutation. */
export type BookLessonPayload = {
  __typename?: 'BookLessonPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  rozpisItems: Maybe<Array<RozpisItem>>;
};

/** All input for the `cancelLesson` mutation. */
export type CancelLessonInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  lessonId: Scalars['BigInt'];
};

/** The output of our `cancelLesson` mutation. */
export type CancelLessonPayload = {
  __typename?: 'CancelLessonPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  rozpisItems: Maybe<Array<RozpisItem>>;
};

/** All input for the `cancelParticipation` mutation. */
export type CancelParticipationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  eventId: Scalars['BigInt'];
};

/** The output of our `cancelParticipation` mutation. */
export type CancelParticipationPayload = {
  __typename?: 'CancelParticipationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `changePassword` mutation. */
export type ChangePasswordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  newPass: Scalars['String'];
  oldPass: Scalars['String'];
};

/** The output of our `changePassword` mutation. */
export type ChangePasswordPayload = {
  __typename?: 'ChangePasswordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type CohortGroup = Node & {
  __typename?: 'CohortGroup';
  description: Scalars['String'];
  id: Scalars['BigInt'];
  isPublic: Scalars['Boolean'];
  name: Scalars['String'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  ordering: Scalars['Int'];
  /** Reads and enables pagination through a set of `Skupiny`. */
  skupiniesByCohortGroup: SkupiniesConnection;
  tenant: Maybe<Scalars['BigInt']>;
  /** Reads a single `Tenant` that is related to this `CohortGroup`. */
  tenantByTenant: Maybe<Tenant>;
};


export type CohortGroupSkupiniesByCohortGroupArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<SkupinyCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SkupiniesOrderBy>>;
};

/**
 * A condition to be used against `CohortGroup` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type CohortGroupCondition = {
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `isPublic` field. */
  isPublic?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `ordering` field. */
  ordering?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `tenant` field. */
  tenant?: InputMaybe<Scalars['BigInt']>;
};

/** An input for mutations affecting `CohortGroup` */
export type CohortGroupInput = {
  description?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['BigInt']>;
  isPublic?: InputMaybe<Scalars['Boolean']>;
  name: Scalars['String'];
  ordering?: InputMaybe<Scalars['Int']>;
  tenant?: InputMaybe<Scalars['BigInt']>;
};

/** Represents an update to a `CohortGroup`. Fields that are set will be updated. */
export type CohortGroupPatch = {
  description?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['BigInt']>;
  isPublic?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  ordering?: InputMaybe<Scalars['Int']>;
  tenant?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `CohortGroup` values. */
export type CohortGroupsConnection = {
  __typename?: 'CohortGroupsConnection';
  /** A list of edges which contains the `CohortGroup` and cursor to aid in pagination. */
  edges: Array<CohortGroupsEdge>;
  /** A list of `CohortGroup` objects. */
  nodes: Array<CohortGroup>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CohortGroup` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CohortGroup` edge in the connection. */
export type CohortGroupsEdge = {
  __typename?: 'CohortGroupsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `CohortGroup` at the end of the edge. */
  node: CohortGroup;
};

/** Methods to use when ordering `CohortGroup`. */
export type CohortGroupsOrderBy =
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'IS_PUBLIC_ASC'
  | 'IS_PUBLIC_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'NATURAL'
  | 'ORDERING_ASC'
  | 'ORDERING_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SKUPINIES_BY_COHORT_GROUP__COUNT_ASC'
  | 'SKUPINIES_BY_COHORT_GROUP__COUNT_DESC'
  | 'TENANT_ASC'
  | 'TENANT_BY_TENANT__ID_ASC'
  | 'TENANT_BY_TENANT__ID_DESC'
  | 'TENANT_BY_TENANT__MEMBER_INFO_ASC'
  | 'TENANT_BY_TENANT__MEMBER_INFO_DESC'
  | 'TENANT_BY_TENANT__NAME_ASC'
  | 'TENANT_BY_TENANT__NAME_DESC'
  | 'TENANT_DESC';

/** All input for the `confirmUser` mutation. */
export type ConfirmUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  cohort: Scalars['BigInt'];
  grp: Scalars['BigInt'];
  id: Scalars['BigInt'];
};

/** The output of our `confirmUser` mutation. */
export type ConfirmUserPayload = {
  __typename?: 'ConfirmUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `Akce` mutation. */
export type CreateAkceInput = {
  /** The `Akce` to be created by this mutation. */
  akce: AkceInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** All input for the create `AkceItem` mutation. */
export type CreateAkceItemInput = {
  /** The `AkceItem` to be created by this mutation. */
  akceItem: AkceItemInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** The output of our create `AkceItem` mutation. */
export type CreateAkceItemPayload = {
  __typename?: 'CreateAkceItemPayload';
  /** Reads a single `Akce` that is related to this `AkceItem`. */
  akceByAiIdRodic: Maybe<Akce>;
  /** The `AkceItem` that was created by this mutation. */
  akceItem: Maybe<AkceItem>;
  /** An edge for our `AkceItem`. May be used by Relay 1. */
  akceItemEdge: Maybe<AkceItemsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `AkceItem`. */
  userByAiUser: Maybe<User>;
};


/** The output of our create `AkceItem` mutation. */
export type CreateAkceItemPayloadAkceItemEdgeArgs = {
  orderBy?: InputMaybe<Array<AkceItemsOrderBy>>;
};

/** The output of our create `Akce` mutation. */
export type CreateAkcePayload = {
  __typename?: 'CreateAkcePayload';
  /** The `Akce` that was created by this mutation. */
  akce: Maybe<Akce>;
  /** An edge for our `Akce`. May be used by Relay 1. */
  akceEdge: Maybe<AkcesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Akce` mutation. */
export type CreateAkcePayloadAkceEdgeArgs = {
  orderBy?: InputMaybe<Array<AkcesOrderBy>>;
};

/** All input for the create `Aktuality` mutation. */
export type CreateAktualityInput = {
  /** The `Aktuality` to be created by this mutation. */
  aktuality: AktualityInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Aktuality` mutation. */
export type CreateAktualityPayload = {
  __typename?: 'CreateAktualityPayload';
  /** The `Aktuality` that was created by this mutation. */
  aktuality: Maybe<Aktuality>;
  /** An edge for our `Aktuality`. May be used by Relay 1. */
  aktualityEdge: Maybe<AktualitiesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
  galerieFotoByAtFotoMain: Maybe<GalerieFoto>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Aktuality`. */
  userByAtKdo: Maybe<User>;
};


/** The output of our create `Aktuality` mutation. */
export type CreateAktualityPayloadAktualityEdgeArgs = {
  orderBy?: InputMaybe<Array<AktualitiesOrderBy>>;
};

/** All input for the create `Attachment` mutation. */
export type CreateAttachmentInput = {
  /** The `Attachment` to be created by this mutation. */
  attachment: AttachmentInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Attachment` mutation. */
export type CreateAttachmentPayload = {
  __typename?: 'CreateAttachmentPayload';
  /** The `Attachment` that was created by this mutation. */
  attachment: Maybe<Attachment>;
  /** An edge for our `Attachment`. May be used by Relay 1. */
  attachmentEdge: Maybe<AttachmentsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Attachment`. */
  userByUploadedBy: Maybe<User>;
};


/** The output of our create `Attachment` mutation. */
export type CreateAttachmentPayloadAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<AttachmentsOrderBy>>;
};

/** All input for the create `AttendeeExternal` mutation. */
export type CreateAttendeeExternalInput = {
  /** The `AttendeeExternal` to be created by this mutation. */
  attendeeExternal: AttendeeExternalInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** The output of our create `AttendeeExternal` mutation. */
export type CreateAttendeeExternalPayload = {
  __typename?: 'CreateAttendeeExternalPayload';
  /** The `AttendeeExternal` that was created by this mutation. */
  attendeeExternal: Maybe<AttendeeExternal>;
  /** An edge for our `AttendeeExternal`. May be used by Relay 1. */
  attendeeExternalEdge: Maybe<AttendeeExternalsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Event` that is related to this `AttendeeExternal`. */
  event: Maybe<Event>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `AttendeeExternal`. */
  userByConfirmedBy: Maybe<User>;
  /** Reads a single `User` that is related to this `AttendeeExternal`. */
  userByManagedBy: Maybe<User>;
};


/** The output of our create `AttendeeExternal` mutation. */
export type CreateAttendeeExternalPayloadAttendeeExternalEdgeArgs = {
  orderBy?: InputMaybe<Array<AttendeeExternalsOrderBy>>;
};

/** All input for the create `AttendeeUser` mutation. */
export type CreateAttendeeUserInput = {
  /** The `AttendeeUser` to be created by this mutation. */
  attendeeUser: AttendeeUserInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** The output of our create `AttendeeUser` mutation. */
export type CreateAttendeeUserPayload = {
  __typename?: 'CreateAttendeeUserPayload';
  /** The `AttendeeUser` that was created by this mutation. */
  attendeeUser: Maybe<AttendeeUser>;
  /** An edge for our `AttendeeUser`. May be used by Relay 1. */
  attendeeUserEdge: Maybe<AttendeeUsersEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Event` that is related to this `AttendeeUser`. */
  event: Maybe<Event>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `AttendeeUser`. */
  user: Maybe<User>;
};


/** The output of our create `AttendeeUser` mutation. */
export type CreateAttendeeUserPayloadAttendeeUserEdgeArgs = {
  orderBy?: InputMaybe<Array<AttendeeUsersOrderBy>>;
};

/** All input for the create `CohortGroup` mutation. */
export type CreateCohortGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `CohortGroup` to be created by this mutation. */
  cohortGroup: CohortGroupInput;
};

/** The output of our create `CohortGroup` mutation. */
export type CreateCohortGroupPayload = {
  __typename?: 'CreateCohortGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `CohortGroup` that was created by this mutation. */
  cohortGroup: Maybe<CohortGroup>;
  /** An edge for our `CohortGroup`. May be used by Relay 1. */
  cohortGroupEdge: Maybe<CohortGroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `CohortGroup`. */
  tenantByTenant: Maybe<Tenant>;
};


/** The output of our create `CohortGroup` mutation. */
export type CreateCohortGroupPayloadCohortGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<CohortGroupsOrderBy>>;
};

/** All input for the `createCouple` mutation. */
export type CreateCoupleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  man: Scalars['BigInt'];
  woman: Scalars['BigInt'];
};

/** The output of our `createCouple` mutation. */
export type CreateCouplePayload = {
  __typename?: 'CreateCouplePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  paries: Maybe<Array<Pary>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `Dokumenty` mutation. */
export type CreateDokumentyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Dokumenty` to be created by this mutation. */
  dokumenty: DokumentyInput;
};

/** The output of our create `Dokumenty` mutation. */
export type CreateDokumentyPayload = {
  __typename?: 'CreateDokumentyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Dokumenty` that was created by this mutation. */
  dokumenty: Maybe<Dokumenty>;
  /** An edge for our `Dokumenty`. May be used by Relay 1. */
  dokumentyEdge: Maybe<DokumentiesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Dokumenty`. */
  userByDKdo: Maybe<User>;
};


/** The output of our create `Dokumenty` mutation. */
export type CreateDokumentyPayloadDokumentyEdgeArgs = {
  orderBy?: InputMaybe<Array<DokumentiesOrderBy>>;
};

/** All input for the create `Event` mutation. */
export type CreateEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Event` to be created by this mutation. */
  event: EventInput;
};

/** The output of our create `Event` mutation. */
export type CreateEventPayload = {
  __typename?: 'CreateEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Event` that was created by this mutation. */
  event: Maybe<Event>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge: Maybe<EventsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Event` mutation. */
export type CreateEventPayloadEventEdgeArgs = {
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};

/** All input for the create `FormResponse` mutation. */
export type CreateFormResponseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `FormResponse` to be created by this mutation. */
  formResponse: FormResponseInput;
};

/** The output of our create `FormResponse` mutation. */
export type CreateFormResponsePayload = {
  __typename?: 'CreateFormResponsePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `FormResponse` that was created by this mutation. */
  formResponse: Maybe<FormResponse>;
  /** An edge for our `FormResponse`. May be used by Relay 1. */
  formResponseEdge: Maybe<FormResponsesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `FormResponse` mutation. */
export type CreateFormResponsePayloadFormResponseEdgeArgs = {
  orderBy?: InputMaybe<Array<FormResponsesOrderBy>>;
};

/** All input for the create `GalerieDir` mutation. */
export type CreateGalerieDirInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `GalerieDir` to be created by this mutation. */
  galerieDir: GalerieDirInput;
};

/** The output of our create `GalerieDir` mutation. */
export type CreateGalerieDirPayload = {
  __typename?: 'CreateGalerieDirPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GalerieDir` that was created by this mutation. */
  galerieDir: Maybe<GalerieDir>;
  /** An edge for our `GalerieDir`. May be used by Relay 1. */
  galerieDirEdge: Maybe<GalerieDirsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `GalerieDir` mutation. */
export type CreateGalerieDirPayloadGalerieDirEdgeArgs = {
  orderBy?: InputMaybe<Array<GalerieDirsOrderBy>>;
};

/** All input for the create `GalerieFoto` mutation. */
export type CreateGalerieFotoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `GalerieFoto` to be created by this mutation. */
  galerieFoto: GalerieFotoInput;
};

/** The output of our create `GalerieFoto` mutation. */
export type CreateGalerieFotoPayload = {
  __typename?: 'CreateGalerieFotoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
  galerieDirByGfIdRodic: Maybe<GalerieDir>;
  /** The `GalerieFoto` that was created by this mutation. */
  galerieFoto: Maybe<GalerieFoto>;
  /** An edge for our `GalerieFoto`. May be used by Relay 1. */
  galerieFotoEdge: Maybe<GalerieFotosEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `GalerieFoto`. */
  userByGfKdo: Maybe<User>;
};


/** The output of our create `GalerieFoto` mutation. */
export type CreateGalerieFotoPayloadGalerieFotoEdgeArgs = {
  orderBy?: InputMaybe<Array<GalerieFotosOrderBy>>;
};

/** All input for the create `LocationAttachment` mutation. */
export type CreateLocationAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `LocationAttachment` to be created by this mutation. */
  locationAttachment: LocationAttachmentInput;
};

/** The output of our create `LocationAttachment` mutation. */
export type CreateLocationAttachmentPayload = {
  __typename?: 'CreateLocationAttachmentPayload';
  /** Reads a single `Attachment` that is related to this `LocationAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Location` that is related to this `LocationAttachment`. */
  location: Maybe<Location>;
  /** The `LocationAttachment` that was created by this mutation. */
  locationAttachment: Maybe<LocationAttachment>;
  /** An edge for our `LocationAttachment`. May be used by Relay 1. */
  locationAttachmentEdge: Maybe<LocationAttachmentsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `LocationAttachment` mutation. */
export type CreateLocationAttachmentPayloadLocationAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<LocationAttachmentsOrderBy>>;
};

/** All input for the create `Location` mutation. */
export type CreateLocationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Location` to be created by this mutation. */
  location: LocationInput;
};

/** The output of our create `Location` mutation. */
export type CreateLocationPayload = {
  __typename?: 'CreateLocationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Location` that was created by this mutation. */
  location: Maybe<Location>;
  /** An edge for our `Location`. May be used by Relay 1. */
  locationEdge: Maybe<LocationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `Location`. */
  tenantByTenant: Maybe<Tenant>;
};


/** The output of our create `Location` mutation. */
export type CreateLocationPayloadLocationEdgeArgs = {
  orderBy?: InputMaybe<Array<LocationsOrderBy>>;
};

/** All input for the create `Nabidka` mutation. */
export type CreateNabidkaInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Nabidka` to be created by this mutation. */
  nabidka: NabidkaInput;
};

/** All input for the create `NabidkaItem` mutation. */
export type CreateNabidkaItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `NabidkaItem` to be created by this mutation. */
  nabidkaItem: NabidkaItemInput;
};

/** The output of our create `NabidkaItem` mutation. */
export type CreateNabidkaItemPayload = {
  __typename?: 'CreateNabidkaItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Nabidka` that is related to this `NabidkaItem`. */
  nabidkaByNiIdRodic: Maybe<Nabidka>;
  /** The `NabidkaItem` that was created by this mutation. */
  nabidkaItem: Maybe<NabidkaItem>;
  /** An edge for our `NabidkaItem`. May be used by Relay 1. */
  nabidkaItemEdge: Maybe<NabidkaItemsEdge>;
  /** Reads a single `Pary` that is related to this `NabidkaItem`. */
  paryByNiPartner: Maybe<Pary>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `NabidkaItem` mutation. */
export type CreateNabidkaItemPayloadNabidkaItemEdgeArgs = {
  orderBy?: InputMaybe<Array<NabidkaItemsOrderBy>>;
};

/** The output of our create `Nabidka` mutation. */
export type CreateNabidkaPayload = {
  __typename?: 'CreateNabidkaPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Nabidka` that was created by this mutation. */
  nabidka: Maybe<Nabidka>;
  /** An edge for our `Nabidka`. May be used by Relay 1. */
  nabidkaEdge: Maybe<NabidkasEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Nabidka`. */
  userByNTrener: Maybe<User>;
};


/** The output of our create `Nabidka` mutation. */
export type CreateNabidkaPayloadNabidkaEdgeArgs = {
  orderBy?: InputMaybe<Array<NabidkasOrderBy>>;
};

/** All input for the create `Page` mutation. */
export type CreatePageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Page` to be created by this mutation. */
  page: PageInput;
};

/** The output of our create `Page` mutation. */
export type CreatePagePayload = {
  __typename?: 'CreatePagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Page` that was created by this mutation. */
  page: Maybe<Page>;
  /** An edge for our `Page`. May be used by Relay 1. */
  pageEdge: Maybe<PagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Page` mutation. */
export type CreatePagePayloadPageEdgeArgs = {
  orderBy?: InputMaybe<Array<PagesOrderBy>>;
};

/** All input for the create `Parameter` mutation. */
export type CreateParameterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Parameter` to be created by this mutation. */
  parameter: ParameterInput;
};

/** The output of our create `Parameter` mutation. */
export type CreateParameterPayload = {
  __typename?: 'CreateParameterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Parameter` that was created by this mutation. */
  parameter: Maybe<Parameter>;
  /** An edge for our `Parameter`. May be used by Relay 1. */
  parameterEdge: Maybe<ParametersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Parameter` mutation. */
export type CreateParameterPayloadParameterEdgeArgs = {
  orderBy?: InputMaybe<Array<ParametersOrderBy>>;
};

/** All input for the `createParticipationExternal` mutation. */
export type CreateParticipationExternalInput = {
  birthNumber: Scalars['String'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  email: Scalars['String'];
  eventId: Scalars['BigInt'];
  firstName: Scalars['String'];
  guardianName: Scalars['String'];
  lastName: Scalars['String'];
  notes: Scalars['String'];
  phone: Scalars['String'];
};

/** The output of our `createParticipationExternal` mutation. */
export type CreateParticipationExternalPayload = {
  __typename?: 'CreateParticipationExternalPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `createParticipation` mutation. */
export type CreateParticipationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  eventId: Scalars['BigInt'];
  myNotes: Scalars['String'];
  yearOfBirth: Scalars['Int'];
};

/** The output of our `createParticipation` mutation. */
export type CreateParticipationPayload = {
  __typename?: 'CreateParticipationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `Pary` mutation. */
export type CreateParyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Pary` to be created by this mutation. */
  pary: ParyInput;
};

/** All input for the create `ParyNavrh` mutation. */
export type CreateParyNavrhInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `ParyNavrh` to be created by this mutation. */
  paryNavrh: ParyNavrhInput;
};

/** The output of our create `ParyNavrh` mutation. */
export type CreateParyNavrhPayload = {
  __typename?: 'CreateParyNavrhPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ParyNavrh` that was created by this mutation. */
  paryNavrh: Maybe<ParyNavrh>;
  /** An edge for our `ParyNavrh`. May be used by Relay 1. */
  paryNavrhEdge: Maybe<ParyNavrhsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnNavrhl: Maybe<User>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnPartnerka: Maybe<User>;
};


/** The output of our create `ParyNavrh` mutation. */
export type CreateParyNavrhPayloadParyNavrhEdgeArgs = {
  orderBy?: InputMaybe<Array<ParyNavrhsOrderBy>>;
};

/** The output of our create `Pary` mutation. */
export type CreateParyPayload = {
  __typename?: 'CreateParyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Pary` that was created by this mutation. */
  pary: Maybe<Pary>;
  /** An edge for our `Pary`. May be used by Relay 1. */
  paryEdge: Maybe<PariesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartnerka: Maybe<User>;
};


/** The output of our create `Pary` mutation. */
export type CreateParyPayloadParyEdgeArgs = {
  orderBy?: InputMaybe<Array<PariesOrderBy>>;
};

/** All input for the create `Permission` mutation. */
export type CreatePermissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Permission` to be created by this mutation. */
  permission: PermissionInput;
};

/** The output of our create `Permission` mutation. */
export type CreatePermissionPayload = {
  __typename?: 'CreatePermissionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Permission` that was created by this mutation. */
  permission: Maybe<Permission>;
  /** An edge for our `Permission`. May be used by Relay 1. */
  permissionEdge: Maybe<PermissionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Permission` mutation. */
export type CreatePermissionPayloadPermissionEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
};

/** All input for the create `Person` mutation. */
export type CreatePersonInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Person` to be created by this mutation. */
  person: PersonInput;
};

/** The output of our create `Person` mutation. */
export type CreatePersonPayload = {
  __typename?: 'CreatePersonPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Person` that was created by this mutation. */
  person: Maybe<Person>;
  /** An edge for our `Person`. May be used by Relay 1. */
  personEdge: Maybe<PeopleEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Person` mutation. */
export type CreatePersonPayloadPersonEdgeArgs = {
  orderBy?: InputMaybe<Array<PeopleOrderBy>>;
};

/** All input for the create `PlatbyCategoryGroup` mutation. */
export type CreatePlatbyCategoryGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `PlatbyCategoryGroup` to be created by this mutation. */
  platbyCategoryGroup: PlatbyCategoryGroupInput;
};

/** The output of our create `PlatbyCategoryGroup` mutation. */
export type CreatePlatbyCategoryGroupPayload = {
  __typename?: 'CreatePlatbyCategoryGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyCategoryGroup`. */
  platbyCategoryByPcgIdCategory: Maybe<PlatbyCategory>;
  /** The `PlatbyCategoryGroup` that was created by this mutation. */
  platbyCategoryGroup: Maybe<PlatbyCategoryGroup>;
  /** An edge for our `PlatbyCategoryGroup`. May be used by Relay 1. */
  platbyCategoryGroupEdge: Maybe<PlatbyCategoryGroupsEdge>;
  /** Reads a single `PlatbyGroup` that is related to this `PlatbyCategoryGroup`. */
  platbyGroupByPcgIdGroup: Maybe<PlatbyGroup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `PlatbyCategoryGroup` mutation. */
export type CreatePlatbyCategoryGroupPayloadPlatbyCategoryGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyCategoryGroupsOrderBy>>;
};

/** All input for the create `PlatbyCategory` mutation. */
export type CreatePlatbyCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `PlatbyCategory` to be created by this mutation. */
  platbyCategory: PlatbyCategoryInput;
};

/** The output of our create `PlatbyCategory` mutation. */
export type CreatePlatbyCategoryPayload = {
  __typename?: 'CreatePlatbyCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlatbyCategory` that was created by this mutation. */
  platbyCategory: Maybe<PlatbyCategory>;
  /** An edge for our `PlatbyCategory`. May be used by Relay 1. */
  platbyCategoryEdge: Maybe<PlatbyCategoriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `PlatbyCategory` mutation. */
export type CreatePlatbyCategoryPayloadPlatbyCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyCategoriesOrderBy>>;
};

/** All input for the create `PlatbyGroup` mutation. */
export type CreatePlatbyGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `PlatbyGroup` to be created by this mutation. */
  platbyGroup: PlatbyGroupInput;
};

/** The output of our create `PlatbyGroup` mutation. */
export type CreatePlatbyGroupPayload = {
  __typename?: 'CreatePlatbyGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlatbyGroup` that was created by this mutation. */
  platbyGroup: Maybe<PlatbyGroup>;
  /** An edge for our `PlatbyGroup`. May be used by Relay 1. */
  platbyGroupEdge: Maybe<PlatbyGroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `PlatbyGroup` mutation. */
export type CreatePlatbyGroupPayloadPlatbyGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyGroupsOrderBy>>;
};

/** All input for the create `PlatbyGroupSkupina` mutation. */
export type CreatePlatbyGroupSkupinaInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `PlatbyGroupSkupina` to be created by this mutation. */
  platbyGroupSkupina: PlatbyGroupSkupinaInput;
};

/** The output of our create `PlatbyGroupSkupina` mutation. */
export type CreatePlatbyGroupSkupinaPayload = {
  __typename?: 'CreatePlatbyGroupSkupinaPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `PlatbyGroup` that is related to this `PlatbyGroupSkupina`. */
  platbyGroupByPgsIdGroup: Maybe<PlatbyGroup>;
  /** The `PlatbyGroupSkupina` that was created by this mutation. */
  platbyGroupSkupina: Maybe<PlatbyGroupSkupina>;
  /** An edge for our `PlatbyGroupSkupina`. May be used by Relay 1. */
  platbyGroupSkupinaEdge: Maybe<PlatbyGroupSkupinasEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `PlatbyGroupSkupina`. */
  skupinyByPgsIdSkupina: Maybe<Skupiny>;
};


/** The output of our create `PlatbyGroupSkupina` mutation. */
export type CreatePlatbyGroupSkupinaPayloadPlatbyGroupSkupinaEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyGroupSkupinasOrderBy>>;
};

/** All input for the create `PlatbyItem` mutation. */
export type CreatePlatbyItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `PlatbyItem` to be created by this mutation. */
  platbyItem: PlatbyItemInput;
};

/** The output of our create `PlatbyItem` mutation. */
export type CreatePlatbyItemPayload = {
  __typename?: 'CreatePlatbyItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
  platbyCategoryByPiIdCategory: Maybe<PlatbyCategory>;
  /** The `PlatbyItem` that was created by this mutation. */
  platbyItem: Maybe<PlatbyItem>;
  /** An edge for our `PlatbyItem`. May be used by Relay 1. */
  platbyItemEdge: Maybe<PlatbyItemsEdge>;
  /** Reads a single `PlatbyRaw` that is related to this `PlatbyItem`. */
  platbyRawByPiIdRaw: Maybe<PlatbyRaw>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `PlatbyItem`. */
  userByPiIdUser: Maybe<User>;
};


/** The output of our create `PlatbyItem` mutation. */
export type CreatePlatbyItemPayloadPlatbyItemEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyItemsOrderBy>>;
};

/** All input for the create `PlatbyRaw` mutation. */
export type CreatePlatbyRawInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `PlatbyRaw` to be created by this mutation. */
  platbyRaw: PlatbyRawInput;
};

/** The output of our create `PlatbyRaw` mutation. */
export type CreatePlatbyRawPayload = {
  __typename?: 'CreatePlatbyRawPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlatbyRaw` that was created by this mutation. */
  platbyRaw: Maybe<PlatbyRaw>;
  /** An edge for our `PlatbyRaw`. May be used by Relay 1. */
  platbyRawEdge: Maybe<PlatbyRawsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `PlatbyRaw` mutation. */
export type CreatePlatbyRawPayloadPlatbyRawEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyRawsOrderBy>>;
};

/** All input for the create `RoomAttachment` mutation. */
export type CreateRoomAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `RoomAttachment` to be created by this mutation. */
  roomAttachment: RoomAttachmentInput;
};

/** The output of our create `RoomAttachment` mutation. */
export type CreateRoomAttachmentPayload = {
  __typename?: 'CreateRoomAttachmentPayload';
  /** Reads a single `Attachment` that is related to this `RoomAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Room` that is related to this `RoomAttachment`. */
  room: Maybe<Room>;
  /** The `RoomAttachment` that was created by this mutation. */
  roomAttachment: Maybe<RoomAttachment>;
  /** An edge for our `RoomAttachment`. May be used by Relay 1. */
  roomAttachmentEdge: Maybe<RoomAttachmentsEdge>;
};


/** The output of our create `RoomAttachment` mutation. */
export type CreateRoomAttachmentPayloadRoomAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<RoomAttachmentsOrderBy>>;
};

/** All input for the create `Room` mutation. */
export type CreateRoomInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Room` to be created by this mutation. */
  room: RoomInput;
};

/** The output of our create `Room` mutation. */
export type CreateRoomPayload = {
  __typename?: 'CreateRoomPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Location` that is related to this `Room`. */
  locationByLocation: Maybe<Location>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Room` that was created by this mutation. */
  room: Maybe<Room>;
  /** An edge for our `Room`. May be used by Relay 1. */
  roomEdge: Maybe<RoomsEdge>;
};


/** The output of our create `Room` mutation. */
export type CreateRoomPayloadRoomEdgeArgs = {
  orderBy?: InputMaybe<Array<RoomsOrderBy>>;
};

/** All input for the create `Rozpi` mutation. */
export type CreateRozpiInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Rozpi` to be created by this mutation. */
  rozpi: RozpiInput;
};

/** The output of our create `Rozpi` mutation. */
export type CreateRozpiPayload = {
  __typename?: 'CreateRozpiPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Rozpi` that was created by this mutation. */
  rozpi: Maybe<Rozpi>;
  /** An edge for our `Rozpi`. May be used by Relay 1. */
  rozpiEdge: Maybe<RozpisEdge>;
  /** Reads a single `User` that is related to this `Rozpi`. */
  userByRTrener: Maybe<User>;
};


/** The output of our create `Rozpi` mutation. */
export type CreateRozpiPayloadRozpiEdgeArgs = {
  orderBy?: InputMaybe<Array<RozpisOrderBy>>;
};

/** All input for the create `RozpisItem` mutation. */
export type CreateRozpisItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `RozpisItem` to be created by this mutation. */
  rozpisItem: RozpisItemInput;
};

/** The output of our create `RozpisItem` mutation. */
export type CreateRozpisItemPayload = {
  __typename?: 'CreateRozpisItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Pary` that is related to this `RozpisItem`. */
  paryByRiPartner: Maybe<Pary>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Rozpi` that is related to this `RozpisItem`. */
  rozpiByRiIdRodic: Maybe<Rozpi>;
  /** The `RozpisItem` that was created by this mutation. */
  rozpisItem: Maybe<RozpisItem>;
  /** An edge for our `RozpisItem`. May be used by Relay 1. */
  rozpisItemEdge: Maybe<RozpisItemsEdge>;
};


/** The output of our create `RozpisItem` mutation. */
export type CreateRozpisItemPayloadRozpisItemEdgeArgs = {
  orderBy?: InputMaybe<Array<RozpisItemsOrderBy>>;
};

/** All input for the create `Session` mutation. */
export type CreateSessionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Session` to be created by this mutation. */
  session: SessionInput;
};

/** The output of our create `Session` mutation. */
export type CreateSessionPayload = {
  __typename?: 'CreateSessionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Session` that was created by this mutation. */
  session: Maybe<Session>;
  /** An edge for our `Session`. May be used by Relay 1. */
  sessionEdge: Maybe<SessionsEdge>;
  /** Reads a single `User` that is related to this `Session`. */
  userBySsUser: Maybe<User>;
};


/** The output of our create `Session` mutation. */
export type CreateSessionPayloadSessionEdgeArgs = {
  orderBy?: InputMaybe<Array<SessionsOrderBy>>;
};

/** All input for the create `Skupiny` mutation. */
export type CreateSkupinyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Skupiny` to be created by this mutation. */
  skupiny: SkupinyInput;
};

/** The output of our create `Skupiny` mutation. */
export type CreateSkupinyPayload = {
  __typename?: 'CreateSkupinyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `CohortGroup` that is related to this `Skupiny`. */
  cohortGroupByCohortGroup: Maybe<CohortGroup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Skupiny` that was created by this mutation. */
  skupiny: Maybe<Skupiny>;
  /** An edge for our `Skupiny`. May be used by Relay 1. */
  skupinyEdge: Maybe<SkupiniesEdge>;
};


/** The output of our create `Skupiny` mutation. */
export type CreateSkupinyPayloadSkupinyEdgeArgs = {
  orderBy?: InputMaybe<Array<SkupiniesOrderBy>>;
};

/** All input for the create `TenantAttachment` mutation. */
export type CreateTenantAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `TenantAttachment` to be created by this mutation. */
  tenantAttachment: TenantAttachmentInput;
};

/** The output of our create `TenantAttachment` mutation. */
export type CreateTenantAttachmentPayload = {
  __typename?: 'CreateTenantAttachmentPayload';
  /** Reads a single `Attachment` that is related to this `TenantAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `TenantAttachment`. */
  tenant: Maybe<Tenant>;
  /** The `TenantAttachment` that was created by this mutation. */
  tenantAttachment: Maybe<TenantAttachment>;
  /** An edge for our `TenantAttachment`. May be used by Relay 1. */
  tenantAttachmentEdge: Maybe<TenantAttachmentsEdge>;
};


/** The output of our create `TenantAttachment` mutation. */
export type CreateTenantAttachmentPayloadTenantAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<TenantAttachmentsOrderBy>>;
};

/** All input for the create `Tenant` mutation. */
export type CreateTenantInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Tenant` to be created by this mutation. */
  tenant: TenantInput;
};

/** The output of our create `Tenant` mutation. */
export type CreateTenantPayload = {
  __typename?: 'CreateTenantPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Tenant` that was created by this mutation. */
  tenant: Maybe<Tenant>;
  /** An edge for our `Tenant`. May be used by Relay 1. */
  tenantEdge: Maybe<TenantsEdge>;
};


/** The output of our create `Tenant` mutation. */
export type CreateTenantPayloadTenantEdgeArgs = {
  orderBy?: InputMaybe<Array<TenantsOrderBy>>;
};

/** All input for the create `TenantPerson` mutation. */
export type CreateTenantPersonInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `TenantPerson` to be created by this mutation. */
  tenantPerson: TenantPersonInput;
};

/** The output of our create `TenantPerson` mutation. */
export type CreateTenantPersonPayload = {
  __typename?: 'CreateTenantPersonPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Person` that is related to this `TenantPerson`. */
  person: Maybe<Person>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `TenantPerson`. */
  tenant: Maybe<Tenant>;
  /** The `TenantPerson` that was created by this mutation. */
  tenantPerson: Maybe<TenantPerson>;
  /** An edge for our `TenantPerson`. May be used by Relay 1. */
  tenantPersonEdge: Maybe<TenantPeopleEdge>;
};


/** The output of our create `TenantPerson` mutation. */
export type CreateTenantPersonPayloadTenantPersonEdgeArgs = {
  orderBy?: InputMaybe<Array<TenantPeopleOrderBy>>;
};

/** All input for the create `Upozorneni` mutation. */
export type CreateUpozorneniInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Upozorneni` to be created by this mutation. */
  upozorneni: UpozorneniInput;
};

/** The output of our create `Upozorneni` mutation. */
export type CreateUpozorneniPayload = {
  __typename?: 'CreateUpozorneniPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Upozorneni` that was created by this mutation. */
  upozorneni: Maybe<Upozorneni>;
  /** An edge for our `Upozorneni`. May be used by Relay 1. */
  upozorneniEdge: Maybe<UpozornenisEdge>;
  /** Reads a single `User` that is related to this `Upozorneni`. */
  userByUpKdo: Maybe<User>;
};


/** The output of our create `Upozorneni` mutation. */
export type CreateUpozorneniPayloadUpozorneniEdgeArgs = {
  orderBy?: InputMaybe<Array<UpozornenisOrderBy>>;
};

/** All input for the create `UpozorneniSkupiny` mutation. */
export type CreateUpozorneniSkupinyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `UpozorneniSkupiny` to be created by this mutation. */
  upozorneniSkupiny: UpozorneniSkupinyInput;
};

/** The output of our create `UpozorneniSkupiny` mutation. */
export type CreateUpozorneniSkupinyPayload = {
  __typename?: 'CreateUpozorneniSkupinyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
  skupinyByUpsIdSkupina: Maybe<Skupiny>;
  /** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
  upozorneniByUpsIdRodic: Maybe<Upozorneni>;
  /** The `UpozorneniSkupiny` that was created by this mutation. */
  upozorneniSkupiny: Maybe<UpozorneniSkupiny>;
  /** An edge for our `UpozorneniSkupiny`. May be used by Relay 1. */
  upozorneniSkupinyEdge: Maybe<UpozorneniSkupiniesEdge>;
};


/** The output of our create `UpozorneniSkupiny` mutation. */
export type CreateUpozorneniSkupinyPayloadUpozorneniSkupinyEdgeArgs = {
  orderBy?: InputMaybe<Array<UpozorneniSkupiniesOrderBy>>;
};

/** All input for the create `User` mutation. */
export type CreateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `User` to be created by this mutation. */
  user: UserInput;
};

/** The output of our create `User` mutation. */
export type CreateUserPayload = {
  __typename?: 'CreateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Permission` that is related to this `User`. */
  permissionByUGroup: Maybe<Permission>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `User`. */
  skupinyByUSkupina: Maybe<Skupiny>;
  /** The `User` that was created by this mutation. */
  user: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge: Maybe<UsersEdge>;
};


/** The output of our create `User` mutation. */
export type CreateUserPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the create `Video` mutation. */
export type CreateVideoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Video` to be created by this mutation. */
  video: VideoInput;
};

/** All input for the create `VideoList` mutation. */
export type CreateVideoListInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `VideoList` to be created by this mutation. */
  videoList: VideoListInput;
};

/** The output of our create `VideoList` mutation. */
export type CreateVideoListPayload = {
  __typename?: 'CreateVideoListPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `VideoList` that was created by this mutation. */
  videoList: Maybe<VideoList>;
  /** An edge for our `VideoList`. May be used by Relay 1. */
  videoListEdge: Maybe<VideoListsEdge>;
};


/** The output of our create `VideoList` mutation. */
export type CreateVideoListPayloadVideoListEdgeArgs = {
  orderBy?: InputMaybe<Array<VideoListsOrderBy>>;
};

/** The output of our create `Video` mutation. */
export type CreateVideoPayload = {
  __typename?: 'CreateVideoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Video` that was created by this mutation. */
  video: Maybe<Video>;
  /** An edge for our `Video`. May be used by Relay 1. */
  videoEdge: Maybe<VideosEdge>;
};


/** The output of our create `Video` mutation. */
export type CreateVideoPayloadVideoEdgeArgs = {
  orderBy?: InputMaybe<Array<VideosOrderBy>>;
};

/** All input for the create `VideoSource` mutation. */
export type CreateVideoSourceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `VideoSource` to be created by this mutation. */
  videoSource: VideoSourceInput;
};

/** The output of our create `VideoSource` mutation. */
export type CreateVideoSourcePayload = {
  __typename?: 'CreateVideoSourcePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `VideoSource` that was created by this mutation. */
  videoSource: Maybe<VideoSource>;
  /** An edge for our `VideoSource`. May be used by Relay 1. */
  videoSourceEdge: Maybe<VideoSourcesEdge>;
};


/** The output of our create `VideoSource` mutation. */
export type CreateVideoSourcePayloadVideoSourceEdgeArgs = {
  orderBy?: InputMaybe<Array<VideoSourcesOrderBy>>;
};

export type CrmCohort =
  | 'CONTACT_ME_LATER'
  | 'DANCER'
  | 'FREE_LESSON'
  | 'HOBBYIST'
  | 'SHOWDANCE';

/** A `BigInt` edge in the connection. */
export type CurrentCoupleIdEdge = {
  __typename?: 'CurrentCoupleIdEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `BigInt` at the end of the edge. */
  node: Maybe<Scalars['BigInt']>;
};

/** A connection to a list of `BigInt` values. */
export type CurrentCoupleIdsConnection = {
  __typename?: 'CurrentCoupleIdsConnection';
  /** A list of edges which contains the `BigInt` and cursor to aid in pagination. */
  edges: Array<CurrentCoupleIdEdge>;
  /** A list of `BigInt` objects. */
  nodes: Array<Maybe<Scalars['BigInt']>>;
  /** The count of *all* `BigInt` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** All input for the `deleteAktualityByNodeId` mutation. */
export type DeleteAktualityByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Aktuality` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteAktuality` mutation. */
export type DeleteAktualityInput = {
  atId: Scalars['BigInt'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** The output of our delete `Aktuality` mutation. */
export type DeleteAktualityPayload = {
  __typename?: 'DeleteAktualityPayload';
  /** The `Aktuality` that was deleted by this mutation. */
  aktuality: Maybe<Aktuality>;
  /** An edge for our `Aktuality`. May be used by Relay 1. */
  aktualityEdge: Maybe<AktualitiesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedAktualityNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
  galerieFotoByAtFotoMain: Maybe<GalerieFoto>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Aktuality`. */
  userByAtKdo: Maybe<User>;
};


/** The output of our delete `Aktuality` mutation. */
export type DeleteAktualityPayloadAktualityEdgeArgs = {
  orderBy?: InputMaybe<Array<AktualitiesOrderBy>>;
};

/** All input for the `deleteAttachmentByNodeId` mutation. */
export type DeleteAttachmentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Attachment` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteAttachment` mutation. */
export type DeleteAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  objectName: Scalars['String'];
};

/** The output of our delete `Attachment` mutation. */
export type DeleteAttachmentPayload = {
  __typename?: 'DeleteAttachmentPayload';
  /** The `Attachment` that was deleted by this mutation. */
  attachment: Maybe<Attachment>;
  /** An edge for our `Attachment`. May be used by Relay 1. */
  attachmentEdge: Maybe<AttachmentsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedAttachmentNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Attachment`. */
  userByUploadedBy: Maybe<User>;
};


/** The output of our delete `Attachment` mutation. */
export type DeleteAttachmentPayloadAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<AttachmentsOrderBy>>;
};

/** All input for the `deleteAttendeeExternalByNodeId` mutation. */
export type DeleteAttendeeExternalByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `AttendeeExternal` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteAttendeeExternal` mutation. */
export type DeleteAttendeeExternalInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `AttendeeExternal` mutation. */
export type DeleteAttendeeExternalPayload = {
  __typename?: 'DeleteAttendeeExternalPayload';
  /** The `AttendeeExternal` that was deleted by this mutation. */
  attendeeExternal: Maybe<AttendeeExternal>;
  /** An edge for our `AttendeeExternal`. May be used by Relay 1. */
  attendeeExternalEdge: Maybe<AttendeeExternalsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedAttendeeExternalNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `Event` that is related to this `AttendeeExternal`. */
  event: Maybe<Event>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `AttendeeExternal`. */
  userByConfirmedBy: Maybe<User>;
  /** Reads a single `User` that is related to this `AttendeeExternal`. */
  userByManagedBy: Maybe<User>;
};


/** The output of our delete `AttendeeExternal` mutation. */
export type DeleteAttendeeExternalPayloadAttendeeExternalEdgeArgs = {
  orderBy?: InputMaybe<Array<AttendeeExternalsOrderBy>>;
};

/** All input for the `deleteAttendeeUserByNodeId` mutation. */
export type DeleteAttendeeUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `AttendeeUser` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteAttendeeUserByUserIdAndEventId` mutation. */
export type DeleteAttendeeUserByUserIdAndEventIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  eventId: Scalars['BigInt'];
  userId: Scalars['BigInt'];
};

/** All input for the `deleteAttendeeUser` mutation. */
export type DeleteAttendeeUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `AttendeeUser` mutation. */
export type DeleteAttendeeUserPayload = {
  __typename?: 'DeleteAttendeeUserPayload';
  /** The `AttendeeUser` that was deleted by this mutation. */
  attendeeUser: Maybe<AttendeeUser>;
  /** An edge for our `AttendeeUser`. May be used by Relay 1. */
  attendeeUserEdge: Maybe<AttendeeUsersEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedAttendeeUserNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `Event` that is related to this `AttendeeUser`. */
  event: Maybe<Event>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `AttendeeUser`. */
  user: Maybe<User>;
};


/** The output of our delete `AttendeeUser` mutation. */
export type DeleteAttendeeUserPayloadAttendeeUserEdgeArgs = {
  orderBy?: InputMaybe<Array<AttendeeUsersOrderBy>>;
};

/** All input for the `deleteCohortGroupByNodeId` mutation. */
export type DeleteCohortGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CohortGroup` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCohortGroup` mutation. */
export type DeleteCohortGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `CohortGroup` mutation. */
export type DeleteCohortGroupPayload = {
  __typename?: 'DeleteCohortGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `CohortGroup` that was deleted by this mutation. */
  cohortGroup: Maybe<CohortGroup>;
  /** An edge for our `CohortGroup`. May be used by Relay 1. */
  cohortGroupEdge: Maybe<CohortGroupsEdge>;
  deletedCohortGroupNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `CohortGroup`. */
  tenantByTenant: Maybe<Tenant>;
};


/** The output of our delete `CohortGroup` mutation. */
export type DeleteCohortGroupPayloadCohortGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<CohortGroupsOrderBy>>;
};

/** All input for the `deleteDokumentyByNodeId` mutation. */
export type DeleteDokumentyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Dokumenty` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteDokumenty` mutation. */
export type DeleteDokumentyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  dId: Scalars['BigInt'];
};

/** The output of our delete `Dokumenty` mutation. */
export type DeleteDokumentyPayload = {
  __typename?: 'DeleteDokumentyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedDokumentyNodeId: Maybe<Scalars['ID']>;
  /** The `Dokumenty` that was deleted by this mutation. */
  dokumenty: Maybe<Dokumenty>;
  /** An edge for our `Dokumenty`. May be used by Relay 1. */
  dokumentyEdge: Maybe<DokumentiesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Dokumenty`. */
  userByDKdo: Maybe<User>;
};


/** The output of our delete `Dokumenty` mutation. */
export type DeleteDokumentyPayloadDokumentyEdgeArgs = {
  orderBy?: InputMaybe<Array<DokumentiesOrderBy>>;
};

/** All input for the `deleteEventByNodeId` mutation. */
export type DeleteEventByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Event` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteEvent` mutation. */
export type DeleteEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Event` mutation. */
export type DeleteEventPayload = {
  __typename?: 'DeleteEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedEventNodeId: Maybe<Scalars['ID']>;
  /** The `Event` that was deleted by this mutation. */
  event: Maybe<Event>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge: Maybe<EventsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Event` mutation. */
export type DeleteEventPayloadEventEdgeArgs = {
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};

/** All input for the `deleteFormResponseByNodeId` mutation. */
export type DeleteFormResponseByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `FormResponse` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteFormResponse` mutation. */
export type DeleteFormResponseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `FormResponse` mutation. */
export type DeleteFormResponsePayload = {
  __typename?: 'DeleteFormResponsePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedFormResponseNodeId: Maybe<Scalars['ID']>;
  /** The `FormResponse` that was deleted by this mutation. */
  formResponse: Maybe<FormResponse>;
  /** An edge for our `FormResponse`. May be used by Relay 1. */
  formResponseEdge: Maybe<FormResponsesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `FormResponse` mutation. */
export type DeleteFormResponsePayloadFormResponseEdgeArgs = {
  orderBy?: InputMaybe<Array<FormResponsesOrderBy>>;
};

/** All input for the `deleteGalerieDirByNodeId` mutation. */
export type DeleteGalerieDirByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GalerieDir` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteGalerieDir` mutation. */
export type DeleteGalerieDirInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  gdId: Scalars['BigInt'];
};

/** The output of our delete `GalerieDir` mutation. */
export type DeleteGalerieDirPayload = {
  __typename?: 'DeleteGalerieDirPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedGalerieDirNodeId: Maybe<Scalars['ID']>;
  /** The `GalerieDir` that was deleted by this mutation. */
  galerieDir: Maybe<GalerieDir>;
  /** An edge for our `GalerieDir`. May be used by Relay 1. */
  galerieDirEdge: Maybe<GalerieDirsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `GalerieDir` mutation. */
export type DeleteGalerieDirPayloadGalerieDirEdgeArgs = {
  orderBy?: InputMaybe<Array<GalerieDirsOrderBy>>;
};

/** All input for the `deleteGalerieFotoByNodeId` mutation. */
export type DeleteGalerieFotoByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GalerieFoto` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteGalerieFoto` mutation. */
export type DeleteGalerieFotoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  gfId: Scalars['BigInt'];
};

/** The output of our delete `GalerieFoto` mutation. */
export type DeleteGalerieFotoPayload = {
  __typename?: 'DeleteGalerieFotoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedGalerieFotoNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
  galerieDirByGfIdRodic: Maybe<GalerieDir>;
  /** The `GalerieFoto` that was deleted by this mutation. */
  galerieFoto: Maybe<GalerieFoto>;
  /** An edge for our `GalerieFoto`. May be used by Relay 1. */
  galerieFotoEdge: Maybe<GalerieFotosEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `GalerieFoto`. */
  userByGfKdo: Maybe<User>;
};


/** The output of our delete `GalerieFoto` mutation. */
export type DeleteGalerieFotoPayloadGalerieFotoEdgeArgs = {
  orderBy?: InputMaybe<Array<GalerieFotosOrderBy>>;
};

/** All input for the `deleteLocationAttachmentByNodeId` mutation. */
export type DeleteLocationAttachmentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LocationAttachment` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteLocationAttachment` mutation. */
export type DeleteLocationAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  locationId: Scalars['BigInt'];
  objectName: Scalars['String'];
};

/** The output of our delete `LocationAttachment` mutation. */
export type DeleteLocationAttachmentPayload = {
  __typename?: 'DeleteLocationAttachmentPayload';
  /** Reads a single `Attachment` that is related to this `LocationAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedLocationAttachmentNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `Location` that is related to this `LocationAttachment`. */
  location: Maybe<Location>;
  /** The `LocationAttachment` that was deleted by this mutation. */
  locationAttachment: Maybe<LocationAttachment>;
  /** An edge for our `LocationAttachment`. May be used by Relay 1. */
  locationAttachmentEdge: Maybe<LocationAttachmentsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `LocationAttachment` mutation. */
export type DeleteLocationAttachmentPayloadLocationAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<LocationAttachmentsOrderBy>>;
};

/** All input for the `deleteLocationByNodeId` mutation. */
export type DeleteLocationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Location` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteLocation` mutation. */
export type DeleteLocationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Location` mutation. */
export type DeleteLocationPayload = {
  __typename?: 'DeleteLocationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedLocationNodeId: Maybe<Scalars['ID']>;
  /** The `Location` that was deleted by this mutation. */
  location: Maybe<Location>;
  /** An edge for our `Location`. May be used by Relay 1. */
  locationEdge: Maybe<LocationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `Location`. */
  tenantByTenant: Maybe<Tenant>;
};


/** The output of our delete `Location` mutation. */
export type DeleteLocationPayloadLocationEdgeArgs = {
  orderBy?: InputMaybe<Array<LocationsOrderBy>>;
};

/** All input for the `deleteNabidkaByNodeId` mutation. */
export type DeleteNabidkaByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Nabidka` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteNabidka` mutation. */
export type DeleteNabidkaInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  nId: Scalars['BigInt'];
};

/** All input for the `deleteNabidkaItemByNiPartnerAndNiIdRodic` mutation. */
export type DeleteNabidkaItemByNiPartnerAndNiIdRodicInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  niIdRodic: Scalars['BigInt'];
  niPartner: Scalars['BigInt'];
};

/** All input for the `deleteNabidkaItemByNodeId` mutation. */
export type DeleteNabidkaItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `NabidkaItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteNabidkaItem` mutation. */
export type DeleteNabidkaItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  niId: Scalars['BigInt'];
};

/** The output of our delete `NabidkaItem` mutation. */
export type DeleteNabidkaItemPayload = {
  __typename?: 'DeleteNabidkaItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedNabidkaItemNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `Nabidka` that is related to this `NabidkaItem`. */
  nabidkaByNiIdRodic: Maybe<Nabidka>;
  /** The `NabidkaItem` that was deleted by this mutation. */
  nabidkaItem: Maybe<NabidkaItem>;
  /** An edge for our `NabidkaItem`. May be used by Relay 1. */
  nabidkaItemEdge: Maybe<NabidkaItemsEdge>;
  /** Reads a single `Pary` that is related to this `NabidkaItem`. */
  paryByNiPartner: Maybe<Pary>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `NabidkaItem` mutation. */
export type DeleteNabidkaItemPayloadNabidkaItemEdgeArgs = {
  orderBy?: InputMaybe<Array<NabidkaItemsOrderBy>>;
};

/** The output of our delete `Nabidka` mutation. */
export type DeleteNabidkaPayload = {
  __typename?: 'DeleteNabidkaPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedNabidkaNodeId: Maybe<Scalars['ID']>;
  /** The `Nabidka` that was deleted by this mutation. */
  nabidka: Maybe<Nabidka>;
  /** An edge for our `Nabidka`. May be used by Relay 1. */
  nabidkaEdge: Maybe<NabidkasEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Nabidka`. */
  userByNTrener: Maybe<User>;
};


/** The output of our delete `Nabidka` mutation. */
export type DeleteNabidkaPayloadNabidkaEdgeArgs = {
  orderBy?: InputMaybe<Array<NabidkasOrderBy>>;
};

/** All input for the `deleteParameterByNodeId` mutation. */
export type DeleteParameterByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Parameter` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteParameter` mutation. */
export type DeleteParameterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  paName: Scalars['String'];
};

/** The output of our delete `Parameter` mutation. */
export type DeleteParameterPayload = {
  __typename?: 'DeleteParameterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedParameterNodeId: Maybe<Scalars['ID']>;
  /** The `Parameter` that was deleted by this mutation. */
  parameter: Maybe<Parameter>;
  /** An edge for our `Parameter`. May be used by Relay 1. */
  parameterEdge: Maybe<ParametersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Parameter` mutation. */
export type DeleteParameterPayloadParameterEdgeArgs = {
  orderBy?: InputMaybe<Array<ParametersOrderBy>>;
};

/** All input for the `deleteParyByNodeId` mutation. */
export type DeleteParyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Pary` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePary` mutation. */
export type DeleteParyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  pId: Scalars['BigInt'];
};

/** All input for the `deleteParyNavrhByNodeId` mutation. */
export type DeleteParyNavrhByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ParyNavrh` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteParyNavrh` mutation. */
export type DeleteParyNavrhInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  pnId: Scalars['BigInt'];
};

/** The output of our delete `ParyNavrh` mutation. */
export type DeleteParyNavrhPayload = {
  __typename?: 'DeleteParyNavrhPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedParyNavrhNodeId: Maybe<Scalars['ID']>;
  /** The `ParyNavrh` that was deleted by this mutation. */
  paryNavrh: Maybe<ParyNavrh>;
  /** An edge for our `ParyNavrh`. May be used by Relay 1. */
  paryNavrhEdge: Maybe<ParyNavrhsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnNavrhl: Maybe<User>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnPartnerka: Maybe<User>;
};


/** The output of our delete `ParyNavrh` mutation. */
export type DeleteParyNavrhPayloadParyNavrhEdgeArgs = {
  orderBy?: InputMaybe<Array<ParyNavrhsOrderBy>>;
};

/** The output of our delete `Pary` mutation. */
export type DeleteParyPayload = {
  __typename?: 'DeleteParyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedParyNodeId: Maybe<Scalars['ID']>;
  /** The `Pary` that was deleted by this mutation. */
  pary: Maybe<Pary>;
  /** An edge for our `Pary`. May be used by Relay 1. */
  paryEdge: Maybe<PariesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartnerka: Maybe<User>;
};


/** The output of our delete `Pary` mutation. */
export type DeleteParyPayloadParyEdgeArgs = {
  orderBy?: InputMaybe<Array<PariesOrderBy>>;
};

/** All input for the `deletePermissionByNodeId` mutation. */
export type DeletePermissionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Permission` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePermission` mutation. */
export type DeletePermissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  peId: Scalars['BigInt'];
};

/** The output of our delete `Permission` mutation. */
export type DeletePermissionPayload = {
  __typename?: 'DeletePermissionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedPermissionNodeId: Maybe<Scalars['ID']>;
  /** The `Permission` that was deleted by this mutation. */
  permission: Maybe<Permission>;
  /** An edge for our `Permission`. May be used by Relay 1. */
  permissionEdge: Maybe<PermissionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Permission` mutation. */
export type DeletePermissionPayloadPermissionEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
};

/** All input for the `deletePersonByNodeId` mutation. */
export type DeletePersonByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Person` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePerson` mutation. */
export type DeletePersonInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Person` mutation. */
export type DeletePersonPayload = {
  __typename?: 'DeletePersonPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedPersonNodeId: Maybe<Scalars['ID']>;
  /** The `Person` that was deleted by this mutation. */
  person: Maybe<Person>;
  /** An edge for our `Person`. May be used by Relay 1. */
  personEdge: Maybe<PeopleEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Person` mutation. */
export type DeletePersonPayloadPersonEdgeArgs = {
  orderBy?: InputMaybe<Array<PeopleOrderBy>>;
};

/** All input for the `deletePlatbyCategoryByNodeId` mutation. */
export type DeletePlatbyCategoryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyCategory` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePlatbyCategoryGroupByNodeId` mutation. */
export type DeletePlatbyCategoryGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyCategoryGroup` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePlatbyCategoryGroup` mutation. */
export type DeletePlatbyCategoryGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  pcgId: Scalars['BigInt'];
};

/** The output of our delete `PlatbyCategoryGroup` mutation. */
export type DeletePlatbyCategoryGroupPayload = {
  __typename?: 'DeletePlatbyCategoryGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedPlatbyCategoryGroupNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyCategoryGroup`. */
  platbyCategoryByPcgIdCategory: Maybe<PlatbyCategory>;
  /** The `PlatbyCategoryGroup` that was deleted by this mutation. */
  platbyCategoryGroup: Maybe<PlatbyCategoryGroup>;
  /** An edge for our `PlatbyCategoryGroup`. May be used by Relay 1. */
  platbyCategoryGroupEdge: Maybe<PlatbyCategoryGroupsEdge>;
  /** Reads a single `PlatbyGroup` that is related to this `PlatbyCategoryGroup`. */
  platbyGroupByPcgIdGroup: Maybe<PlatbyGroup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `PlatbyCategoryGroup` mutation. */
export type DeletePlatbyCategoryGroupPayloadPlatbyCategoryGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyCategoryGroupsOrderBy>>;
};

/** All input for the `deletePlatbyCategory` mutation. */
export type DeletePlatbyCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  pcId: Scalars['BigInt'];
};

/** The output of our delete `PlatbyCategory` mutation. */
export type DeletePlatbyCategoryPayload = {
  __typename?: 'DeletePlatbyCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedPlatbyCategoryNodeId: Maybe<Scalars['ID']>;
  /** The `PlatbyCategory` that was deleted by this mutation. */
  platbyCategory: Maybe<PlatbyCategory>;
  /** An edge for our `PlatbyCategory`. May be used by Relay 1. */
  platbyCategoryEdge: Maybe<PlatbyCategoriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `PlatbyCategory` mutation. */
export type DeletePlatbyCategoryPayloadPlatbyCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyCategoriesOrderBy>>;
};

/** All input for the `deletePlatbyGroupByNodeId` mutation. */
export type DeletePlatbyGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyGroup` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePlatbyGroup` mutation. */
export type DeletePlatbyGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  pgId: Scalars['BigInt'];
};

/** The output of our delete `PlatbyGroup` mutation. */
export type DeletePlatbyGroupPayload = {
  __typename?: 'DeletePlatbyGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedPlatbyGroupNodeId: Maybe<Scalars['ID']>;
  /** The `PlatbyGroup` that was deleted by this mutation. */
  platbyGroup: Maybe<PlatbyGroup>;
  /** An edge for our `PlatbyGroup`. May be used by Relay 1. */
  platbyGroupEdge: Maybe<PlatbyGroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `PlatbyGroup` mutation. */
export type DeletePlatbyGroupPayloadPlatbyGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyGroupsOrderBy>>;
};

/** All input for the `deletePlatbyGroupSkupinaByNodeId` mutation. */
export type DeletePlatbyGroupSkupinaByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyGroupSkupina` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePlatbyGroupSkupina` mutation. */
export type DeletePlatbyGroupSkupinaInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  pgsId: Scalars['BigInt'];
};

/** The output of our delete `PlatbyGroupSkupina` mutation. */
export type DeletePlatbyGroupSkupinaPayload = {
  __typename?: 'DeletePlatbyGroupSkupinaPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedPlatbyGroupSkupinaNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `PlatbyGroup` that is related to this `PlatbyGroupSkupina`. */
  platbyGroupByPgsIdGroup: Maybe<PlatbyGroup>;
  /** The `PlatbyGroupSkupina` that was deleted by this mutation. */
  platbyGroupSkupina: Maybe<PlatbyGroupSkupina>;
  /** An edge for our `PlatbyGroupSkupina`. May be used by Relay 1. */
  platbyGroupSkupinaEdge: Maybe<PlatbyGroupSkupinasEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `PlatbyGroupSkupina`. */
  skupinyByPgsIdSkupina: Maybe<Skupiny>;
};


/** The output of our delete `PlatbyGroupSkupina` mutation. */
export type DeletePlatbyGroupSkupinaPayloadPlatbyGroupSkupinaEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyGroupSkupinasOrderBy>>;
};

/** All input for the `deletePlatbyItemByNodeId` mutation. */
export type DeletePlatbyItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePlatbyItem` mutation. */
export type DeletePlatbyItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  piId: Scalars['BigInt'];
};

/** The output of our delete `PlatbyItem` mutation. */
export type DeletePlatbyItemPayload = {
  __typename?: 'DeletePlatbyItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedPlatbyItemNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
  platbyCategoryByPiIdCategory: Maybe<PlatbyCategory>;
  /** The `PlatbyItem` that was deleted by this mutation. */
  platbyItem: Maybe<PlatbyItem>;
  /** An edge for our `PlatbyItem`. May be used by Relay 1. */
  platbyItemEdge: Maybe<PlatbyItemsEdge>;
  /** Reads a single `PlatbyRaw` that is related to this `PlatbyItem`. */
  platbyRawByPiIdRaw: Maybe<PlatbyRaw>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `PlatbyItem`. */
  userByPiIdUser: Maybe<User>;
};


/** The output of our delete `PlatbyItem` mutation. */
export type DeletePlatbyItemPayloadPlatbyItemEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyItemsOrderBy>>;
};

/** All input for the `deletePlatbyRawByNodeId` mutation. */
export type DeletePlatbyRawByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyRaw` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePlatbyRaw` mutation. */
export type DeletePlatbyRawInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  prId: Scalars['BigInt'];
};

/** The output of our delete `PlatbyRaw` mutation. */
export type DeletePlatbyRawPayload = {
  __typename?: 'DeletePlatbyRawPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedPlatbyRawNodeId: Maybe<Scalars['ID']>;
  /** The `PlatbyRaw` that was deleted by this mutation. */
  platbyRaw: Maybe<PlatbyRaw>;
  /** An edge for our `PlatbyRaw`. May be used by Relay 1. */
  platbyRawEdge: Maybe<PlatbyRawsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `PlatbyRaw` mutation. */
export type DeletePlatbyRawPayloadPlatbyRawEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyRawsOrderBy>>;
};

/** All input for the `deleteRoomAttachmentByNodeId` mutation. */
export type DeleteRoomAttachmentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `RoomAttachment` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteRoomAttachment` mutation. */
export type DeleteRoomAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  objectName: Scalars['String'];
  roomId: Scalars['BigInt'];
};

/** The output of our delete `RoomAttachment` mutation. */
export type DeleteRoomAttachmentPayload = {
  __typename?: 'DeleteRoomAttachmentPayload';
  /** Reads a single `Attachment` that is related to this `RoomAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedRoomAttachmentNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Room` that is related to this `RoomAttachment`. */
  room: Maybe<Room>;
  /** The `RoomAttachment` that was deleted by this mutation. */
  roomAttachment: Maybe<RoomAttachment>;
  /** An edge for our `RoomAttachment`. May be used by Relay 1. */
  roomAttachmentEdge: Maybe<RoomAttachmentsEdge>;
};


/** The output of our delete `RoomAttachment` mutation. */
export type DeleteRoomAttachmentPayloadRoomAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<RoomAttachmentsOrderBy>>;
};

/** All input for the `deleteRoomByNodeId` mutation. */
export type DeleteRoomByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Room` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteRoom` mutation. */
export type DeleteRoomInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Room` mutation. */
export type DeleteRoomPayload = {
  __typename?: 'DeleteRoomPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedRoomNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `Location` that is related to this `Room`. */
  locationByLocation: Maybe<Location>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Room` that was deleted by this mutation. */
  room: Maybe<Room>;
  /** An edge for our `Room`. May be used by Relay 1. */
  roomEdge: Maybe<RoomsEdge>;
};


/** The output of our delete `Room` mutation. */
export type DeleteRoomPayloadRoomEdgeArgs = {
  orderBy?: InputMaybe<Array<RoomsOrderBy>>;
};

/** All input for the `deleteRozpiByNodeId` mutation. */
export type DeleteRozpiByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Rozpi` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteRozpi` mutation. */
export type DeleteRozpiInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  rId: Scalars['BigInt'];
};

/** The output of our delete `Rozpi` mutation. */
export type DeleteRozpiPayload = {
  __typename?: 'DeleteRozpiPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedRozpiNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Rozpi` that was deleted by this mutation. */
  rozpi: Maybe<Rozpi>;
  /** An edge for our `Rozpi`. May be used by Relay 1. */
  rozpiEdge: Maybe<RozpisEdge>;
  /** Reads a single `User` that is related to this `Rozpi`. */
  userByRTrener: Maybe<User>;
};


/** The output of our delete `Rozpi` mutation. */
export type DeleteRozpiPayloadRozpiEdgeArgs = {
  orderBy?: InputMaybe<Array<RozpisOrderBy>>;
};

/** All input for the `deleteRozpisItemByNodeId` mutation. */
export type DeleteRozpisItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `RozpisItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteRozpisItem` mutation. */
export type DeleteRozpisItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  riId: Scalars['BigInt'];
};

/** The output of our delete `RozpisItem` mutation. */
export type DeleteRozpisItemPayload = {
  __typename?: 'DeleteRozpisItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedRozpisItemNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `Pary` that is related to this `RozpisItem`. */
  paryByRiPartner: Maybe<Pary>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Rozpi` that is related to this `RozpisItem`. */
  rozpiByRiIdRodic: Maybe<Rozpi>;
  /** The `RozpisItem` that was deleted by this mutation. */
  rozpisItem: Maybe<RozpisItem>;
  /** An edge for our `RozpisItem`. May be used by Relay 1. */
  rozpisItemEdge: Maybe<RozpisItemsEdge>;
};


/** The output of our delete `RozpisItem` mutation. */
export type DeleteRozpisItemPayloadRozpisItemEdgeArgs = {
  orderBy?: InputMaybe<Array<RozpisItemsOrderBy>>;
};

/** All input for the `deleteSessionByNodeId` mutation. */
export type DeleteSessionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Session` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteSession` mutation. */
export type DeleteSessionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  ssId: Scalars['String'];
};

/** The output of our delete `Session` mutation. */
export type DeleteSessionPayload = {
  __typename?: 'DeleteSessionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedSessionNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Session` that was deleted by this mutation. */
  session: Maybe<Session>;
  /** An edge for our `Session`. May be used by Relay 1. */
  sessionEdge: Maybe<SessionsEdge>;
  /** Reads a single `User` that is related to this `Session`. */
  userBySsUser: Maybe<User>;
};


/** The output of our delete `Session` mutation. */
export type DeleteSessionPayloadSessionEdgeArgs = {
  orderBy?: InputMaybe<Array<SessionsOrderBy>>;
};

/** All input for the `deleteSkupinyByNodeId` mutation. */
export type DeleteSkupinyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Skupiny` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteSkupiny` mutation. */
export type DeleteSkupinyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  sId: Scalars['BigInt'];
};

/** The output of our delete `Skupiny` mutation. */
export type DeleteSkupinyPayload = {
  __typename?: 'DeleteSkupinyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `CohortGroup` that is related to this `Skupiny`. */
  cohortGroupByCohortGroup: Maybe<CohortGroup>;
  deletedSkupinyNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Skupiny` that was deleted by this mutation. */
  skupiny: Maybe<Skupiny>;
  /** An edge for our `Skupiny`. May be used by Relay 1. */
  skupinyEdge: Maybe<SkupiniesEdge>;
};


/** The output of our delete `Skupiny` mutation. */
export type DeleteSkupinyPayloadSkupinyEdgeArgs = {
  orderBy?: InputMaybe<Array<SkupiniesOrderBy>>;
};

/** All input for the `deleteTenantAttachmentByNodeId` mutation. */
export type DeleteTenantAttachmentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TenantAttachment` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTenantAttachment` mutation. */
export type DeleteTenantAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  objectName: Scalars['String'];
  tenantId: Scalars['BigInt'];
};

/** The output of our delete `TenantAttachment` mutation. */
export type DeleteTenantAttachmentPayload = {
  __typename?: 'DeleteTenantAttachmentPayload';
  /** Reads a single `Attachment` that is related to this `TenantAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedTenantAttachmentNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `TenantAttachment`. */
  tenant: Maybe<Tenant>;
  /** The `TenantAttachment` that was deleted by this mutation. */
  tenantAttachment: Maybe<TenantAttachment>;
  /** An edge for our `TenantAttachment`. May be used by Relay 1. */
  tenantAttachmentEdge: Maybe<TenantAttachmentsEdge>;
};


/** The output of our delete `TenantAttachment` mutation. */
export type DeleteTenantAttachmentPayloadTenantAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<TenantAttachmentsOrderBy>>;
};

/** All input for the `deleteTenantByNodeId` mutation. */
export type DeleteTenantByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Tenant` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTenant` mutation. */
export type DeleteTenantInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Tenant` mutation. */
export type DeleteTenantPayload = {
  __typename?: 'DeleteTenantPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedTenantNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Tenant` that was deleted by this mutation. */
  tenant: Maybe<Tenant>;
  /** An edge for our `Tenant`. May be used by Relay 1. */
  tenantEdge: Maybe<TenantsEdge>;
};


/** The output of our delete `Tenant` mutation. */
export type DeleteTenantPayloadTenantEdgeArgs = {
  orderBy?: InputMaybe<Array<TenantsOrderBy>>;
};

/** All input for the `deleteTenantPersonByNodeId` mutation. */
export type DeleteTenantPersonByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TenantPerson` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTenantPerson` mutation. */
export type DeleteTenantPersonInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  personId: Scalars['BigInt'];
  tenantId: Scalars['BigInt'];
};

/** The output of our delete `TenantPerson` mutation. */
export type DeleteTenantPersonPayload = {
  __typename?: 'DeleteTenantPersonPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedTenantPersonNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `Person` that is related to this `TenantPerson`. */
  person: Maybe<Person>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `TenantPerson`. */
  tenant: Maybe<Tenant>;
  /** The `TenantPerson` that was deleted by this mutation. */
  tenantPerson: Maybe<TenantPerson>;
  /** An edge for our `TenantPerson`. May be used by Relay 1. */
  tenantPersonEdge: Maybe<TenantPeopleEdge>;
};


/** The output of our delete `TenantPerson` mutation. */
export type DeleteTenantPersonPayloadTenantPersonEdgeArgs = {
  orderBy?: InputMaybe<Array<TenantPeopleOrderBy>>;
};

/** All input for the `deleteUpozorneniByNodeId` mutation. */
export type DeleteUpozorneniByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Upozorneni` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteUpozorneni` mutation. */
export type DeleteUpozorneniInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  upId: Scalars['BigInt'];
};

/** The output of our delete `Upozorneni` mutation. */
export type DeleteUpozorneniPayload = {
  __typename?: 'DeleteUpozorneniPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedUpozorneniNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Upozorneni` that was deleted by this mutation. */
  upozorneni: Maybe<Upozorneni>;
  /** An edge for our `Upozorneni`. May be used by Relay 1. */
  upozorneniEdge: Maybe<UpozornenisEdge>;
  /** Reads a single `User` that is related to this `Upozorneni`. */
  userByUpKdo: Maybe<User>;
};


/** The output of our delete `Upozorneni` mutation. */
export type DeleteUpozorneniPayloadUpozorneniEdgeArgs = {
  orderBy?: InputMaybe<Array<UpozornenisOrderBy>>;
};

/** All input for the `deleteUpozorneniSkupinyByNodeId` mutation. */
export type DeleteUpozorneniSkupinyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `UpozorneniSkupiny` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteUpozorneniSkupiny` mutation. */
export type DeleteUpozorneniSkupinyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  upsId: Scalars['BigInt'];
};

/** The output of our delete `UpozorneniSkupiny` mutation. */
export type DeleteUpozorneniSkupinyPayload = {
  __typename?: 'DeleteUpozorneniSkupinyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedUpozorneniSkupinyNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
  skupinyByUpsIdSkupina: Maybe<Skupiny>;
  /** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
  upozorneniByUpsIdRodic: Maybe<Upozorneni>;
  /** The `UpozorneniSkupiny` that was deleted by this mutation. */
  upozorneniSkupiny: Maybe<UpozorneniSkupiny>;
  /** An edge for our `UpozorneniSkupiny`. May be used by Relay 1. */
  upozorneniSkupinyEdge: Maybe<UpozorneniSkupiniesEdge>;
};


/** The output of our delete `UpozorneniSkupiny` mutation. */
export type DeleteUpozorneniSkupinyPayloadUpozorneniSkupinyEdgeArgs = {
  orderBy?: InputMaybe<Array<UpozorneniSkupiniesOrderBy>>;
};

/** All input for the `deleteUserByNodeId` mutation. */
export type DeleteUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `User` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteUser` mutation. */
export type DeleteUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  uId: Scalars['BigInt'];
};

/** The output of our delete `User` mutation. */
export type DeleteUserPayload = {
  __typename?: 'DeleteUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedUserNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `Permission` that is related to this `User`. */
  permissionByUGroup: Maybe<Permission>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `User`. */
  skupinyByUSkupina: Maybe<Skupiny>;
  /** The `User` that was deleted by this mutation. */
  user: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge: Maybe<UsersEdge>;
};


/** The output of our delete `User` mutation. */
export type DeleteUserPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the `deleteVideoByNodeId` mutation. */
export type DeleteVideoByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Video` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteVideo` mutation. */
export type DeleteVideoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  vId: Scalars['BigInt'];
};

/** All input for the `deleteVideoListByNodeId` mutation. */
export type DeleteVideoListByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `VideoList` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteVideoList` mutation. */
export type DeleteVideoListInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  vlId: Scalars['BigInt'];
};

/** The output of our delete `VideoList` mutation. */
export type DeleteVideoListPayload = {
  __typename?: 'DeleteVideoListPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedVideoListNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `VideoList` that was deleted by this mutation. */
  videoList: Maybe<VideoList>;
  /** An edge for our `VideoList`. May be used by Relay 1. */
  videoListEdge: Maybe<VideoListsEdge>;
};


/** The output of our delete `VideoList` mutation. */
export type DeleteVideoListPayloadVideoListEdgeArgs = {
  orderBy?: InputMaybe<Array<VideoListsOrderBy>>;
};

/** The output of our delete `Video` mutation. */
export type DeleteVideoPayload = {
  __typename?: 'DeleteVideoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedVideoNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Video` that was deleted by this mutation. */
  video: Maybe<Video>;
  /** An edge for our `Video`. May be used by Relay 1. */
  videoEdge: Maybe<VideosEdge>;
};


/** The output of our delete `Video` mutation. */
export type DeleteVideoPayloadVideoEdgeArgs = {
  orderBy?: InputMaybe<Array<VideosOrderBy>>;
};

/** All input for the `deleteVideoSourceByNodeId` mutation. */
export type DeleteVideoSourceByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `VideoSource` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteVideoSource` mutation. */
export type DeleteVideoSourceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  vsId: Scalars['BigInt'];
};

/** The output of our delete `VideoSource` mutation. */
export type DeleteVideoSourcePayload = {
  __typename?: 'DeleteVideoSourcePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedVideoSourceNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `VideoSource` that was deleted by this mutation. */
  videoSource: Maybe<VideoSource>;
  /** An edge for our `VideoSource`. May be used by Relay 1. */
  videoSourceEdge: Maybe<VideoSourcesEdge>;
};


/** The output of our delete `VideoSource` mutation. */
export type DeleteVideoSourcePayloadVideoSourceEdgeArgs = {
  orderBy?: InputMaybe<Array<VideoSourcesOrderBy>>;
};

/** A connection to a list of `Dokumenty` values. */
export type DokumentiesConnection = {
  __typename?: 'DokumentiesConnection';
  /** A list of edges which contains the `Dokumenty` and cursor to aid in pagination. */
  edges: Array<DokumentiesEdge>;
  /** A list of `Dokumenty` objects. */
  nodes: Array<Dokumenty>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Dokumenty` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Dokumenty` edge in the connection. */
export type DokumentiesEdge = {
  __typename?: 'DokumentiesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Dokumenty` at the end of the edge. */
  node: Dokumenty;
};

/** Methods to use when ordering `Dokumenty`. */
export type DokumentiesOrderBy =
  | 'D_FILENAME_ASC'
  | 'D_FILENAME_DESC'
  | 'D_ID_ASC'
  | 'D_ID_DESC'
  | 'D_KATEGORIE_ASC'
  | 'D_KATEGORIE_DESC'
  | 'D_KDO_ASC'
  | 'D_KDO_DESC'
  | 'D_NAME_ASC'
  | 'D_NAME_DESC'
  | 'D_PATH_ASC'
  | 'D_PATH_DESC'
  | 'D_TIMESTAMP_ASC'
  | 'D_TIMESTAMP_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'USER_BY_D_KDO__U_BAN_ASC'
  | 'USER_BY_D_KDO__U_BAN_DESC'
  | 'USER_BY_D_KDO__U_CITY_ASC'
  | 'USER_BY_D_KDO__U_CITY_DESC'
  | 'USER_BY_D_KDO__U_CONFIRMED_ASC'
  | 'USER_BY_D_KDO__U_CONFIRMED_DESC'
  | 'USER_BY_D_KDO__U_CONSCRIPTION_NUMBER_ASC'
  | 'USER_BY_D_KDO__U_CONSCRIPTION_NUMBER_DESC'
  | 'USER_BY_D_KDO__U_CREATED_AT_ASC'
  | 'USER_BY_D_KDO__U_CREATED_AT_DESC'
  | 'USER_BY_D_KDO__U_DANCER_ASC'
  | 'USER_BY_D_KDO__U_DANCER_DESC'
  | 'USER_BY_D_KDO__U_DISTRICT_ASC'
  | 'USER_BY_D_KDO__U_DISTRICT_DESC'
  | 'USER_BY_D_KDO__U_EMAIL_ASC'
  | 'USER_BY_D_KDO__U_EMAIL_DESC'
  | 'USER_BY_D_KDO__U_GDPR_SIGNED_AT_ASC'
  | 'USER_BY_D_KDO__U_GDPR_SIGNED_AT_DESC'
  | 'USER_BY_D_KDO__U_GROUP_ASC'
  | 'USER_BY_D_KDO__U_GROUP_DESC'
  | 'USER_BY_D_KDO__U_ID_ASC'
  | 'USER_BY_D_KDO__U_ID_DESC'
  | 'USER_BY_D_KDO__U_JMENO_ASC'
  | 'USER_BY_D_KDO__U_JMENO_DESC'
  | 'USER_BY_D_KDO__U_LEVEL_ASC'
  | 'USER_BY_D_KDO__U_LEVEL_DESC'
  | 'USER_BY_D_KDO__U_LOCK_ASC'
  | 'USER_BY_D_KDO__U_LOCK_DESC'
  | 'USER_BY_D_KDO__U_LOGIN_ASC'
  | 'USER_BY_D_KDO__U_LOGIN_DESC'
  | 'USER_BY_D_KDO__U_MEMBER_SINCE_ASC'
  | 'USER_BY_D_KDO__U_MEMBER_SINCE_DESC'
  | 'USER_BY_D_KDO__U_MEMBER_UNTIL_ASC'
  | 'USER_BY_D_KDO__U_MEMBER_UNTIL_DESC'
  | 'USER_BY_D_KDO__U_NAROZENI_ASC'
  | 'USER_BY_D_KDO__U_NAROZENI_DESC'
  | 'USER_BY_D_KDO__U_NATIONALITY_ASC'
  | 'USER_BY_D_KDO__U_NATIONALITY_DESC'
  | 'USER_BY_D_KDO__U_ORIENTATION_NUMBER_ASC'
  | 'USER_BY_D_KDO__U_ORIENTATION_NUMBER_DESC'
  | 'USER_BY_D_KDO__U_PASS_ASC'
  | 'USER_BY_D_KDO__U_PASS_DESC'
  | 'USER_BY_D_KDO__U_POHLAVI_ASC'
  | 'USER_BY_D_KDO__U_POHLAVI_DESC'
  | 'USER_BY_D_KDO__U_POSTAL_CODE_ASC'
  | 'USER_BY_D_KDO__U_POSTAL_CODE_DESC'
  | 'USER_BY_D_KDO__U_POZNAMKY_ASC'
  | 'USER_BY_D_KDO__U_POZNAMKY_DESC'
  | 'USER_BY_D_KDO__U_PRIJMENI_ASC'
  | 'USER_BY_D_KDO__U_PRIJMENI_DESC'
  | 'USER_BY_D_KDO__U_RODNE_CISLO_ASC'
  | 'USER_BY_D_KDO__U_RODNE_CISLO_DESC'
  | 'USER_BY_D_KDO__U_SKUPINA_ASC'
  | 'USER_BY_D_KDO__U_SKUPINA_DESC'
  | 'USER_BY_D_KDO__U_STREET_ASC'
  | 'USER_BY_D_KDO__U_STREET_DESC'
  | 'USER_BY_D_KDO__U_SYSTEM_ASC'
  | 'USER_BY_D_KDO__U_SYSTEM_DESC'
  | 'USER_BY_D_KDO__U_TEACHER_ASC'
  | 'USER_BY_D_KDO__U_TEACHER_DESC'
  | 'USER_BY_D_KDO__U_TELEFON_ASC'
  | 'USER_BY_D_KDO__U_TELEFON_DESC'
  | 'USER_BY_D_KDO__U_TIMESTAMP_ASC'
  | 'USER_BY_D_KDO__U_TIMESTAMP_DESC';

export type Dokumenty = Node & {
  __typename?: 'Dokumenty';
  dFilename: Scalars['String'];
  dId: Scalars['BigInt'];
  dKategorie: Scalars['Int'];
  dKdo: Scalars['BigInt'];
  dName: Scalars['String'];
  dPath: Scalars['String'];
  dTimestamp: Maybe<Scalars['Datetime']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `User` that is related to this `Dokumenty`. */
  userByDKdo: Maybe<User>;
};

/**
 * A condition to be used against `Dokumenty` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type DokumentyCondition = {
  /** Checks for equality with the object’s `dFilename` field. */
  dFilename?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `dId` field. */
  dId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `dKategorie` field. */
  dKategorie?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `dKdo` field. */
  dKdo?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `dName` field. */
  dName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `dPath` field. */
  dPath?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `dTimestamp` field. */
  dTimestamp?: InputMaybe<Scalars['Datetime']>;
};

/** An input for mutations affecting `Dokumenty` */
export type DokumentyInput = {
  dFilename: Scalars['String'];
  dId?: InputMaybe<Scalars['BigInt']>;
  dKategorie: Scalars['Int'];
  dKdo: Scalars['BigInt'];
  dName: Scalars['String'];
  dPath: Scalars['String'];
  dTimestamp?: InputMaybe<Scalars['Datetime']>;
};

/** Represents an update to a `Dokumenty`. Fields that are set will be updated. */
export type DokumentyPatch = {
  dFilename?: InputMaybe<Scalars['String']>;
  dId?: InputMaybe<Scalars['BigInt']>;
  dKategorie?: InputMaybe<Scalars['Int']>;
  dKdo?: InputMaybe<Scalars['BigInt']>;
  dName?: InputMaybe<Scalars['String']>;
  dPath?: InputMaybe<Scalars['String']>;
  dTimestamp?: InputMaybe<Scalars['Datetime']>;
};

export type Event = Node & {
  __typename?: 'Event';
  /** Reads and enables pagination through a set of `AttendeeExternal`. */
  attendeeExternals: AttendeeExternalsConnection;
  /** Reads and enables pagination through a set of `AttendeeUser`. */
  attendeeUsers: AttendeeUsersConnection;
  capacity: Scalars['BigInt'];
  description: Scalars['String'];
  enableNotes: Scalars['Boolean'];
  filesLegacy: Scalars['String'];
  id: Scalars['BigInt'];
  isLocked: Scalars['Boolean'];
  isPublic: Scalars['Boolean'];
  isVisible: Scalars['Boolean'];
  locationText: Scalars['String'];
  name: Scalars['String'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  remainingSpots: Maybe<Scalars['Int']>;
  since: Scalars['Date'];
  summary: Scalars['String'];
  until: Scalars['Date'];
  updatedAt: Maybe<Scalars['Datetime']>;
};


export type EventAttendeeExternalsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AttendeeExternalCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AttendeeExternalsOrderBy>>;
};


export type EventAttendeeUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AttendeeUserCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AttendeeUsersOrderBy>>;
};

/** A condition to be used against `Event` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type EventCondition = {
  /** Checks for equality with the object’s `capacity` field. */
  capacity?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `enableNotes` field. */
  enableNotes?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `filesLegacy` field. */
  filesLegacy?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `isLocked` field. */
  isLocked?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `isPublic` field. */
  isPublic?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `isVisible` field. */
  isVisible?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `locationText` field. */
  locationText?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `since` field. */
  since?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `summary` field. */
  summary?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `until` field. */
  until?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']>;
};

/** An input for mutations affecting `Event` */
export type EventInput = {
  capacity?: InputMaybe<Scalars['BigInt']>;
  description: Scalars['String'];
  enableNotes?: InputMaybe<Scalars['Boolean']>;
  filesLegacy?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['BigInt']>;
  isLocked?: InputMaybe<Scalars['Boolean']>;
  isPublic?: InputMaybe<Scalars['Boolean']>;
  isVisible?: InputMaybe<Scalars['Boolean']>;
  locationText: Scalars['String'];
  name: Scalars['String'];
  since: Scalars['Date'];
  summary?: InputMaybe<Scalars['String']>;
  until: Scalars['Date'];
  updatedAt?: InputMaybe<Scalars['Datetime']>;
};

/** Represents an update to a `Event`. Fields that are set will be updated. */
export type EventPatch = {
  capacity?: InputMaybe<Scalars['BigInt']>;
  description?: InputMaybe<Scalars['String']>;
  enableNotes?: InputMaybe<Scalars['Boolean']>;
  filesLegacy?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['BigInt']>;
  isLocked?: InputMaybe<Scalars['Boolean']>;
  isPublic?: InputMaybe<Scalars['Boolean']>;
  isVisible?: InputMaybe<Scalars['Boolean']>;
  locationText?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  since?: InputMaybe<Scalars['Date']>;
  summary?: InputMaybe<Scalars['String']>;
  until?: InputMaybe<Scalars['Date']>;
  updatedAt?: InputMaybe<Scalars['Datetime']>;
};

/** A connection to a list of `Event` values. */
export type EventsConnection = {
  __typename?: 'EventsConnection';
  /** A list of edges which contains the `Event` and cursor to aid in pagination. */
  edges: Array<EventsEdge>;
  /** A list of `Event` objects. */
  nodes: Array<Event>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Event` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Event` edge in the connection. */
export type EventsEdge = {
  __typename?: 'EventsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Event` at the end of the edge. */
  node: Event;
};

/** Methods to use when ordering `Event`. */
export type EventsOrderBy =
  | 'ATTENDEE_EXTERNALS_BY_EVENT_ID__COUNT_ASC'
  | 'ATTENDEE_EXTERNALS_BY_EVENT_ID__COUNT_DESC'
  | 'ATTENDEE_USERS_BY_EVENT_ID__COUNT_ASC'
  | 'ATTENDEE_USERS_BY_EVENT_ID__COUNT_DESC'
  | 'CAPACITY_ASC'
  | 'CAPACITY_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'ENABLE_NOTES_ASC'
  | 'ENABLE_NOTES_DESC'
  | 'FILES_LEGACY_ASC'
  | 'FILES_LEGACY_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'IS_LOCKED_ASC'
  | 'IS_LOCKED_DESC'
  | 'IS_PUBLIC_ASC'
  | 'IS_PUBLIC_DESC'
  | 'IS_VISIBLE_ASC'
  | 'IS_VISIBLE_DESC'
  | 'LOCATION_TEXT_ASC'
  | 'LOCATION_TEXT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SINCE_ASC'
  | 'SINCE_DESC'
  | 'SUMMARY_ASC'
  | 'SUMMARY_DESC'
  | 'UNTIL_ASC'
  | 'UNTIL_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC';

/** All input for the `fixUnpairedCouples` mutation. */
export type FixUnpairedCouplesInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** The output of our `fixUnpairedCouples` mutation. */
export type FixUnpairedCouplesPayload = {
  __typename?: 'FixUnpairedCouplesPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  paries: Maybe<Array<Pary>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type FormResponse = Node & {
  __typename?: 'FormResponse';
  createdAt: Scalars['Datetime'];
  data: Scalars['JSON'];
  id: Scalars['BigInt'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  type: Scalars['String'];
  updatedAt: Scalars['Datetime'];
  url: Scalars['String'];
};

/**
 * A condition to be used against `FormResponse` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type FormResponseCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `data` field. */
  data?: InputMaybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `url` field. */
  url?: InputMaybe<Scalars['String']>;
};

/** An input for mutations affecting `FormResponse` */
export type FormResponseInput = {
  createdAt?: InputMaybe<Scalars['Datetime']>;
  data: Scalars['JSON'];
  id?: InputMaybe<Scalars['BigInt']>;
  type: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['Datetime']>;
  url: Scalars['String'];
};

/** Represents an update to a `FormResponse`. Fields that are set will be updated. */
export type FormResponsePatch = {
  createdAt?: InputMaybe<Scalars['Datetime']>;
  data?: InputMaybe<Scalars['JSON']>;
  id?: InputMaybe<Scalars['BigInt']>;
  type?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['Datetime']>;
  url?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `FormResponse` values. */
export type FormResponsesConnection = {
  __typename?: 'FormResponsesConnection';
  /** A list of edges which contains the `FormResponse` and cursor to aid in pagination. */
  edges: Array<FormResponsesEdge>;
  /** A list of `FormResponse` objects. */
  nodes: Array<FormResponse>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FormResponse` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `FormResponse` edge in the connection. */
export type FormResponsesEdge = {
  __typename?: 'FormResponsesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `FormResponse` at the end of the edge. */
  node: FormResponse;
};

/** Methods to use when ordering `FormResponse`. */
export type FormResponsesOrderBy =
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'DATA_ASC'
  | 'DATA_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC'
  | 'URL_ASC'
  | 'URL_DESC';

export type GalerieDir = Node & {
  __typename?: 'GalerieDir';
  /** Reads and enables pagination through a set of `GalerieFoto`. */
  galerieFotosByGfIdRodic: GalerieFotosConnection;
  gdHidden: Scalars['Boolean'];
  gdId: Scalars['BigInt'];
  gdIdRodic: Scalars['BigInt'];
  gdLevel: Scalars['Int'];
  gdName: Scalars['String'];
  gdPath: Scalars['String'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
};


export type GalerieDirGalerieFotosByGfIdRodicArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<GalerieFotoCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GalerieFotosOrderBy>>;
};

/**
 * A condition to be used against `GalerieDir` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type GalerieDirCondition = {
  /** Checks for equality with the object’s `gdHidden` field. */
  gdHidden?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `gdId` field. */
  gdId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `gdIdRodic` field. */
  gdIdRodic?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `gdLevel` field. */
  gdLevel?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gdName` field. */
  gdName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `gdPath` field. */
  gdPath?: InputMaybe<Scalars['String']>;
};

/** An input for mutations affecting `GalerieDir` */
export type GalerieDirInput = {
  gdHidden?: InputMaybe<Scalars['Boolean']>;
  gdId?: InputMaybe<Scalars['BigInt']>;
  gdIdRodic: Scalars['BigInt'];
  gdLevel?: InputMaybe<Scalars['Int']>;
  gdName: Scalars['String'];
  gdPath: Scalars['String'];
};

/** Represents an update to a `GalerieDir`. Fields that are set will be updated. */
export type GalerieDirPatch = {
  gdHidden?: InputMaybe<Scalars['Boolean']>;
  gdId?: InputMaybe<Scalars['BigInt']>;
  gdIdRodic?: InputMaybe<Scalars['BigInt']>;
  gdLevel?: InputMaybe<Scalars['Int']>;
  gdName?: InputMaybe<Scalars['String']>;
  gdPath?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `GalerieDir` values. */
export type GalerieDirsConnection = {
  __typename?: 'GalerieDirsConnection';
  /** A list of edges which contains the `GalerieDir` and cursor to aid in pagination. */
  edges: Array<GalerieDirsEdge>;
  /** A list of `GalerieDir` objects. */
  nodes: Array<GalerieDir>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `GalerieDir` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `GalerieDir` edge in the connection. */
export type GalerieDirsEdge = {
  __typename?: 'GalerieDirsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `GalerieDir` at the end of the edge. */
  node: GalerieDir;
};

/** Methods to use when ordering `GalerieDir`. */
export type GalerieDirsOrderBy =
  | 'GALERIE_FOTOS_BY_GF_ID_RODIC__COUNT_ASC'
  | 'GALERIE_FOTOS_BY_GF_ID_RODIC__COUNT_DESC'
  | 'GD_HIDDEN_ASC'
  | 'GD_HIDDEN_DESC'
  | 'GD_ID_ASC'
  | 'GD_ID_DESC'
  | 'GD_ID_RODIC_ASC'
  | 'GD_ID_RODIC_DESC'
  | 'GD_LEVEL_ASC'
  | 'GD_LEVEL_DESC'
  | 'GD_NAME_ASC'
  | 'GD_NAME_DESC'
  | 'GD_PATH_ASC'
  | 'GD_PATH_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

export type GalerieFoto = Node & {
  __typename?: 'GalerieFoto';
  /** Reads and enables pagination through a set of `Aktuality`. */
  aktualitiesByAtFotoMain: AktualitiesConnection;
  /** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
  galerieDirByGfIdRodic: Maybe<GalerieDir>;
  gfId: Scalars['BigInt'];
  gfIdRodic: Scalars['BigInt'];
  gfKdo: Scalars['BigInt'];
  gfName: Scalars['String'];
  gfPath: Scalars['String'];
  gfTimestamp: Maybe<Scalars['Datetime']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `User` that is related to this `GalerieFoto`. */
  userByGfKdo: Maybe<User>;
};


export type GalerieFotoAktualitiesByAtFotoMainArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AktualityCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AktualitiesOrderBy>>;
};

/**
 * A condition to be used against `GalerieFoto` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type GalerieFotoCondition = {
  /** Checks for equality with the object’s `gfId` field. */
  gfId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `gfIdRodic` field. */
  gfIdRodic?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `gfKdo` field. */
  gfKdo?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `gfName` field. */
  gfName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `gfPath` field. */
  gfPath?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `gfTimestamp` field. */
  gfTimestamp?: InputMaybe<Scalars['Datetime']>;
};

/** An input for mutations affecting `GalerieFoto` */
export type GalerieFotoInput = {
  gfId?: InputMaybe<Scalars['BigInt']>;
  gfIdRodic: Scalars['BigInt'];
  gfKdo: Scalars['BigInt'];
  gfName: Scalars['String'];
  gfPath: Scalars['String'];
  gfTimestamp?: InputMaybe<Scalars['Datetime']>;
};

/** Represents an update to a `GalerieFoto`. Fields that are set will be updated. */
export type GalerieFotoPatch = {
  gfId?: InputMaybe<Scalars['BigInt']>;
  gfIdRodic?: InputMaybe<Scalars['BigInt']>;
  gfKdo?: InputMaybe<Scalars['BigInt']>;
  gfName?: InputMaybe<Scalars['String']>;
  gfPath?: InputMaybe<Scalars['String']>;
  gfTimestamp?: InputMaybe<Scalars['Datetime']>;
};

/** A connection to a list of `GalerieFoto` values. */
export type GalerieFotosConnection = {
  __typename?: 'GalerieFotosConnection';
  /** A list of edges which contains the `GalerieFoto` and cursor to aid in pagination. */
  edges: Array<GalerieFotosEdge>;
  /** A list of `GalerieFoto` objects. */
  nodes: Array<GalerieFoto>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `GalerieFoto` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `GalerieFoto` edge in the connection. */
export type GalerieFotosEdge = {
  __typename?: 'GalerieFotosEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `GalerieFoto` at the end of the edge. */
  node: GalerieFoto;
};

/** Methods to use when ordering `GalerieFoto`. */
export type GalerieFotosOrderBy =
  | 'AKTUALITIES_BY_AT_FOTO_MAIN__COUNT_ASC'
  | 'AKTUALITIES_BY_AT_FOTO_MAIN__COUNT_DESC'
  | 'GALERIE_DIR_BY_GF_ID_RODIC__GD_HIDDEN_ASC'
  | 'GALERIE_DIR_BY_GF_ID_RODIC__GD_HIDDEN_DESC'
  | 'GALERIE_DIR_BY_GF_ID_RODIC__GD_ID_ASC'
  | 'GALERIE_DIR_BY_GF_ID_RODIC__GD_ID_DESC'
  | 'GALERIE_DIR_BY_GF_ID_RODIC__GD_ID_RODIC_ASC'
  | 'GALERIE_DIR_BY_GF_ID_RODIC__GD_ID_RODIC_DESC'
  | 'GALERIE_DIR_BY_GF_ID_RODIC__GD_LEVEL_ASC'
  | 'GALERIE_DIR_BY_GF_ID_RODIC__GD_LEVEL_DESC'
  | 'GALERIE_DIR_BY_GF_ID_RODIC__GD_NAME_ASC'
  | 'GALERIE_DIR_BY_GF_ID_RODIC__GD_NAME_DESC'
  | 'GALERIE_DIR_BY_GF_ID_RODIC__GD_PATH_ASC'
  | 'GALERIE_DIR_BY_GF_ID_RODIC__GD_PATH_DESC'
  | 'GF_ID_ASC'
  | 'GF_ID_DESC'
  | 'GF_ID_RODIC_ASC'
  | 'GF_ID_RODIC_DESC'
  | 'GF_KDO_ASC'
  | 'GF_KDO_DESC'
  | 'GF_NAME_ASC'
  | 'GF_NAME_DESC'
  | 'GF_PATH_ASC'
  | 'GF_PATH_DESC'
  | 'GF_TIMESTAMP_ASC'
  | 'GF_TIMESTAMP_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'USER_BY_GF_KDO__U_BAN_ASC'
  | 'USER_BY_GF_KDO__U_BAN_DESC'
  | 'USER_BY_GF_KDO__U_CITY_ASC'
  | 'USER_BY_GF_KDO__U_CITY_DESC'
  | 'USER_BY_GF_KDO__U_CONFIRMED_ASC'
  | 'USER_BY_GF_KDO__U_CONFIRMED_DESC'
  | 'USER_BY_GF_KDO__U_CONSCRIPTION_NUMBER_ASC'
  | 'USER_BY_GF_KDO__U_CONSCRIPTION_NUMBER_DESC'
  | 'USER_BY_GF_KDO__U_CREATED_AT_ASC'
  | 'USER_BY_GF_KDO__U_CREATED_AT_DESC'
  | 'USER_BY_GF_KDO__U_DANCER_ASC'
  | 'USER_BY_GF_KDO__U_DANCER_DESC'
  | 'USER_BY_GF_KDO__U_DISTRICT_ASC'
  | 'USER_BY_GF_KDO__U_DISTRICT_DESC'
  | 'USER_BY_GF_KDO__U_EMAIL_ASC'
  | 'USER_BY_GF_KDO__U_EMAIL_DESC'
  | 'USER_BY_GF_KDO__U_GDPR_SIGNED_AT_ASC'
  | 'USER_BY_GF_KDO__U_GDPR_SIGNED_AT_DESC'
  | 'USER_BY_GF_KDO__U_GROUP_ASC'
  | 'USER_BY_GF_KDO__U_GROUP_DESC'
  | 'USER_BY_GF_KDO__U_ID_ASC'
  | 'USER_BY_GF_KDO__U_ID_DESC'
  | 'USER_BY_GF_KDO__U_JMENO_ASC'
  | 'USER_BY_GF_KDO__U_JMENO_DESC'
  | 'USER_BY_GF_KDO__U_LEVEL_ASC'
  | 'USER_BY_GF_KDO__U_LEVEL_DESC'
  | 'USER_BY_GF_KDO__U_LOCK_ASC'
  | 'USER_BY_GF_KDO__U_LOCK_DESC'
  | 'USER_BY_GF_KDO__U_LOGIN_ASC'
  | 'USER_BY_GF_KDO__U_LOGIN_DESC'
  | 'USER_BY_GF_KDO__U_MEMBER_SINCE_ASC'
  | 'USER_BY_GF_KDO__U_MEMBER_SINCE_DESC'
  | 'USER_BY_GF_KDO__U_MEMBER_UNTIL_ASC'
  | 'USER_BY_GF_KDO__U_MEMBER_UNTIL_DESC'
  | 'USER_BY_GF_KDO__U_NAROZENI_ASC'
  | 'USER_BY_GF_KDO__U_NAROZENI_DESC'
  | 'USER_BY_GF_KDO__U_NATIONALITY_ASC'
  | 'USER_BY_GF_KDO__U_NATIONALITY_DESC'
  | 'USER_BY_GF_KDO__U_ORIENTATION_NUMBER_ASC'
  | 'USER_BY_GF_KDO__U_ORIENTATION_NUMBER_DESC'
  | 'USER_BY_GF_KDO__U_PASS_ASC'
  | 'USER_BY_GF_KDO__U_PASS_DESC'
  | 'USER_BY_GF_KDO__U_POHLAVI_ASC'
  | 'USER_BY_GF_KDO__U_POHLAVI_DESC'
  | 'USER_BY_GF_KDO__U_POSTAL_CODE_ASC'
  | 'USER_BY_GF_KDO__U_POSTAL_CODE_DESC'
  | 'USER_BY_GF_KDO__U_POZNAMKY_ASC'
  | 'USER_BY_GF_KDO__U_POZNAMKY_DESC'
  | 'USER_BY_GF_KDO__U_PRIJMENI_ASC'
  | 'USER_BY_GF_KDO__U_PRIJMENI_DESC'
  | 'USER_BY_GF_KDO__U_RODNE_CISLO_ASC'
  | 'USER_BY_GF_KDO__U_RODNE_CISLO_DESC'
  | 'USER_BY_GF_KDO__U_SKUPINA_ASC'
  | 'USER_BY_GF_KDO__U_SKUPINA_DESC'
  | 'USER_BY_GF_KDO__U_STREET_ASC'
  | 'USER_BY_GF_KDO__U_STREET_DESC'
  | 'USER_BY_GF_KDO__U_SYSTEM_ASC'
  | 'USER_BY_GF_KDO__U_SYSTEM_DESC'
  | 'USER_BY_GF_KDO__U_TEACHER_ASC'
  | 'USER_BY_GF_KDO__U_TEACHER_DESC'
  | 'USER_BY_GF_KDO__U_TELEFON_ASC'
  | 'USER_BY_GF_KDO__U_TELEFON_DESC'
  | 'USER_BY_GF_KDO__U_TIMESTAMP_ASC'
  | 'USER_BY_GF_KDO__U_TIMESTAMP_DESC';

export type GenderType =
  | 'MEN'
  | 'UNSPECIFIED'
  | 'WOMAN';

export type Location = Node & {
  __typename?: 'Location';
  description: Scalars['JSON'];
  id: Scalars['BigInt'];
  /** Reads and enables pagination through a set of `LocationAttachment`. */
  locationAttachments: LocationAttachmentsConnection;
  name: Scalars['String'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads and enables pagination through a set of `Room`. */
  roomsByLocation: RoomsConnection;
  tenant: Maybe<Scalars['BigInt']>;
  /** Reads a single `Tenant` that is related to this `Location`. */
  tenantByTenant: Maybe<Tenant>;
};


export type LocationLocationAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<LocationAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LocationAttachmentsOrderBy>>;
};


export type LocationRoomsByLocationArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<RoomCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RoomsOrderBy>>;
};

export type LocationAttachment = Node & {
  __typename?: 'LocationAttachment';
  /** Reads a single `Attachment` that is related to this `LocationAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /** Reads a single `Location` that is related to this `LocationAttachment`. */
  location: Maybe<Location>;
  locationId: Scalars['BigInt'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  objectName: Scalars['String'];
};

/**
 * A condition to be used against `LocationAttachment` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type LocationAttachmentCondition = {
  /** Checks for equality with the object’s `locationId` field. */
  locationId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `objectName` field. */
  objectName?: InputMaybe<Scalars['String']>;
};

/** An input for mutations affecting `LocationAttachment` */
export type LocationAttachmentInput = {
  locationId: Scalars['BigInt'];
  objectName: Scalars['String'];
};

/** Represents an update to a `LocationAttachment`. Fields that are set will be updated. */
export type LocationAttachmentPatch = {
  locationId?: InputMaybe<Scalars['BigInt']>;
  objectName?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `LocationAttachment` values. */
export type LocationAttachmentsConnection = {
  __typename?: 'LocationAttachmentsConnection';
  /** A list of edges which contains the `LocationAttachment` and cursor to aid in pagination. */
  edges: Array<LocationAttachmentsEdge>;
  /** A list of `LocationAttachment` objects. */
  nodes: Array<LocationAttachment>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `LocationAttachment` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `LocationAttachment` edge in the connection. */
export type LocationAttachmentsEdge = {
  __typename?: 'LocationAttachmentsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `LocationAttachment` at the end of the edge. */
  node: LocationAttachment;
};

/** Methods to use when ordering `LocationAttachment`. */
export type LocationAttachmentsOrderBy =
  | 'ATTACHMENT_BY_OBJECT_NAME__OBJECT_NAME_ASC'
  | 'ATTACHMENT_BY_OBJECT_NAME__OBJECT_NAME_DESC'
  | 'ATTACHMENT_BY_OBJECT_NAME__PREVIEW_OBJECT_NAME_ASC'
  | 'ATTACHMENT_BY_OBJECT_NAME__PREVIEW_OBJECT_NAME_DESC'
  | 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_AT_ASC'
  | 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_AT_DESC'
  | 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_BY_ASC'
  | 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_BY_DESC'
  | 'LOCATION_BY_LOCATION_ID__DESCRIPTION_ASC'
  | 'LOCATION_BY_LOCATION_ID__DESCRIPTION_DESC'
  | 'LOCATION_BY_LOCATION_ID__ID_ASC'
  | 'LOCATION_BY_LOCATION_ID__ID_DESC'
  | 'LOCATION_BY_LOCATION_ID__NAME_ASC'
  | 'LOCATION_BY_LOCATION_ID__NAME_DESC'
  | 'LOCATION_BY_LOCATION_ID__TENANT_ASC'
  | 'LOCATION_BY_LOCATION_ID__TENANT_DESC'
  | 'LOCATION_ID_ASC'
  | 'LOCATION_ID_DESC'
  | 'NATURAL'
  | 'OBJECT_NAME_ASC'
  | 'OBJECT_NAME_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Location` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type LocationCondition = {
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `tenant` field. */
  tenant?: InputMaybe<Scalars['BigInt']>;
};

/** An input for mutations affecting `Location` */
export type LocationInput = {
  description: Scalars['JSON'];
  id?: InputMaybe<Scalars['BigInt']>;
  name: Scalars['String'];
  tenant?: InputMaybe<Scalars['BigInt']>;
};

/** Represents an update to a `Location`. Fields that are set will be updated. */
export type LocationPatch = {
  description?: InputMaybe<Scalars['JSON']>;
  id?: InputMaybe<Scalars['BigInt']>;
  name?: InputMaybe<Scalars['String']>;
  tenant?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `Location` values. */
export type LocationsConnection = {
  __typename?: 'LocationsConnection';
  /** A list of edges which contains the `Location` and cursor to aid in pagination. */
  edges: Array<LocationsEdge>;
  /** A list of `Location` objects. */
  nodes: Array<Location>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Location` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Location` edge in the connection. */
export type LocationsEdge = {
  __typename?: 'LocationsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Location` at the end of the edge. */
  node: Location;
};

/** Methods to use when ordering `Location`. */
export type LocationsOrderBy =
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'LOCATION_ATTACHMENTS_BY_LOCATION_ID__COUNT_ASC'
  | 'LOCATION_ATTACHMENTS_BY_LOCATION_ID__COUNT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'ROOMS_BY_LOCATION__COUNT_ASC'
  | 'ROOMS_BY_LOCATION__COUNT_DESC'
  | 'TENANT_ASC'
  | 'TENANT_BY_TENANT__ID_ASC'
  | 'TENANT_BY_TENANT__ID_DESC'
  | 'TENANT_BY_TENANT__MEMBER_INFO_ASC'
  | 'TENANT_BY_TENANT__MEMBER_INFO_DESC'
  | 'TENANT_BY_TENANT__NAME_ASC'
  | 'TENANT_BY_TENANT__NAME_DESC'
  | 'TENANT_DESC';

/** All input for the `login` mutation. */
export type LoginInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  login: Scalars['String'];
  passwd: Scalars['String'];
};

/** The output of our `login` mutation. */
export type LoginPayload = {
  __typename?: 'LoginPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  result: Maybe<LoginRecord>;
};

/** The return type of our `login` mutation. */
export type LoginRecord = {
  __typename?: 'LoginRecord';
  couple: Maybe<Pary>;
  sess: Maybe<Session>;
  usr: Maybe<User>;
};

/** All input for the `logout` mutation. */
export type LogoutInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** The output of our `logout` mutation. */
export type LogoutPayload = {
  __typename?: 'LogoutPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type Member = {
  __typename?: 'Member';
  newestPayment: Maybe<Scalars['Date']>;
  oldestPayment: Maybe<Scalars['Date']>;
  paymentValid: Maybe<Scalars['Boolean']>;
  sColorRgb: Maybe<Scalars['String']>;
  sColorText: Maybe<Scalars['String']>;
  sDescription: Maybe<Scalars['String']>;
  sId: Maybe<Scalars['BigInt']>;
  sLocation: Maybe<Scalars['String']>;
  sName: Maybe<Scalars['String']>;
  sVisible: Maybe<Scalars['Boolean']>;
  uBan: Maybe<Scalars['Boolean']>;
  uCity: Maybe<Scalars['String']>;
  uConfirmed: Maybe<Scalars['Boolean']>;
  uConscriptionNumber: Maybe<Scalars['String']>;
  uCreatedAt: Maybe<Scalars['Datetime']>;
  uDancer: Maybe<Scalars['Boolean']>;
  uDistrict: Maybe<Scalars['String']>;
  uEmail: Maybe<Scalars['String']>;
  uGdprSignedAt: Maybe<Scalars['Datetime']>;
  uGroup: Maybe<Scalars['BigInt']>;
  uId: Maybe<Scalars['BigInt']>;
  uJmeno: Maybe<Scalars['String']>;
  uLevel: Maybe<Scalars['Int']>;
  uLock: Maybe<Scalars['Boolean']>;
  uLogin: Maybe<Scalars['String']>;
  uMemberSince: Maybe<Scalars['Datetime']>;
  uMemberUntil: Maybe<Scalars['Datetime']>;
  uNarozeni: Maybe<Scalars['Date']>;
  uNationality: Maybe<Scalars['String']>;
  uOrientationNumber: Maybe<Scalars['String']>;
  uPass: Maybe<Scalars['String']>;
  uPohlavi: Maybe<Scalars['String']>;
  uPostalCode: Maybe<Scalars['String']>;
  uPoznamky: Maybe<Scalars['String']>;
  uPrijmeni: Maybe<Scalars['String']>;
  uRodneCislo: Maybe<Scalars['String']>;
  uSkupina: Maybe<Scalars['BigInt']>;
  uStreet: Maybe<Scalars['String']>;
  uSystem: Maybe<Scalars['Boolean']>;
  uTeacher: Maybe<Scalars['Boolean']>;
  uTelefon: Maybe<Scalars['String']>;
  uTimestamp: Maybe<Scalars['Datetime']>;
};

/** A condition to be used against `Member` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type MemberCondition = {
  /** Checks for equality with the object’s `newestPayment` field. */
  newestPayment?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `oldestPayment` field. */
  oldestPayment?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `paymentValid` field. */
  paymentValid?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `sColorRgb` field. */
  sColorRgb?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sColorText` field. */
  sColorText?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sDescription` field. */
  sDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sId` field. */
  sId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `sLocation` field. */
  sLocation?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sName` field. */
  sName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sVisible` field. */
  sVisible?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uBan` field. */
  uBan?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uCity` field. */
  uCity?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uConfirmed` field. */
  uConfirmed?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uConscriptionNumber` field. */
  uConscriptionNumber?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uCreatedAt` field. */
  uCreatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `uDancer` field. */
  uDancer?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uDistrict` field. */
  uDistrict?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uEmail` field. */
  uEmail?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uGdprSignedAt` field. */
  uGdprSignedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `uGroup` field. */
  uGroup?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `uId` field. */
  uId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `uJmeno` field. */
  uJmeno?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uLevel` field. */
  uLevel?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uLock` field. */
  uLock?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uLogin` field. */
  uLogin?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uMemberSince` field. */
  uMemberSince?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `uMemberUntil` field. */
  uMemberUntil?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `uNarozeni` field. */
  uNarozeni?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `uNationality` field. */
  uNationality?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uOrientationNumber` field. */
  uOrientationNumber?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uPass` field. */
  uPass?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uPohlavi` field. */
  uPohlavi?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uPostalCode` field. */
  uPostalCode?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uPoznamky` field. */
  uPoznamky?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uPrijmeni` field. */
  uPrijmeni?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uRodneCislo` field. */
  uRodneCislo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uSkupina` field. */
  uSkupina?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `uStreet` field. */
  uStreet?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uSystem` field. */
  uSystem?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uTeacher` field. */
  uTeacher?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uTelefon` field. */
  uTelefon?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uTimestamp` field. */
  uTimestamp?: InputMaybe<Scalars['Datetime']>;
};

/** A connection to a list of `Member` values. */
export type MembersConnection = {
  __typename?: 'MembersConnection';
  /** A list of edges which contains the `Member` and cursor to aid in pagination. */
  edges: Array<MembersEdge>;
  /** A list of `Member` objects. */
  nodes: Array<Member>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Member` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Member` edge in the connection. */
export type MembersEdge = {
  __typename?: 'MembersEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Member` at the end of the edge. */
  node: Member;
};

/** Methods to use when ordering `Member`. */
export type MembersOrderBy =
  | 'NATURAL'
  | 'NEWEST_PAYMENT_ASC'
  | 'NEWEST_PAYMENT_DESC'
  | 'OLDEST_PAYMENT_ASC'
  | 'OLDEST_PAYMENT_DESC'
  | 'PAYMENT_VALID_ASC'
  | 'PAYMENT_VALID_DESC'
  | 'S_COLOR_RGB_ASC'
  | 'S_COLOR_RGB_DESC'
  | 'S_COLOR_TEXT_ASC'
  | 'S_COLOR_TEXT_DESC'
  | 'S_DESCRIPTION_ASC'
  | 'S_DESCRIPTION_DESC'
  | 'S_ID_ASC'
  | 'S_ID_DESC'
  | 'S_LOCATION_ASC'
  | 'S_LOCATION_DESC'
  | 'S_NAME_ASC'
  | 'S_NAME_DESC'
  | 'S_VISIBLE_ASC'
  | 'S_VISIBLE_DESC'
  | 'U_BAN_ASC'
  | 'U_BAN_DESC'
  | 'U_CITY_ASC'
  | 'U_CITY_DESC'
  | 'U_CONFIRMED_ASC'
  | 'U_CONFIRMED_DESC'
  | 'U_CONSCRIPTION_NUMBER_ASC'
  | 'U_CONSCRIPTION_NUMBER_DESC'
  | 'U_CREATED_AT_ASC'
  | 'U_CREATED_AT_DESC'
  | 'U_DANCER_ASC'
  | 'U_DANCER_DESC'
  | 'U_DISTRICT_ASC'
  | 'U_DISTRICT_DESC'
  | 'U_EMAIL_ASC'
  | 'U_EMAIL_DESC'
  | 'U_GDPR_SIGNED_AT_ASC'
  | 'U_GDPR_SIGNED_AT_DESC'
  | 'U_GROUP_ASC'
  | 'U_GROUP_DESC'
  | 'U_ID_ASC'
  | 'U_ID_DESC'
  | 'U_JMENO_ASC'
  | 'U_JMENO_DESC'
  | 'U_LEVEL_ASC'
  | 'U_LEVEL_DESC'
  | 'U_LOCK_ASC'
  | 'U_LOCK_DESC'
  | 'U_LOGIN_ASC'
  | 'U_LOGIN_DESC'
  | 'U_MEMBER_SINCE_ASC'
  | 'U_MEMBER_SINCE_DESC'
  | 'U_MEMBER_UNTIL_ASC'
  | 'U_MEMBER_UNTIL_DESC'
  | 'U_NAROZENI_ASC'
  | 'U_NAROZENI_DESC'
  | 'U_NATIONALITY_ASC'
  | 'U_NATIONALITY_DESC'
  | 'U_ORIENTATION_NUMBER_ASC'
  | 'U_ORIENTATION_NUMBER_DESC'
  | 'U_PASS_ASC'
  | 'U_PASS_DESC'
  | 'U_POHLAVI_ASC'
  | 'U_POHLAVI_DESC'
  | 'U_POSTAL_CODE_ASC'
  | 'U_POSTAL_CODE_DESC'
  | 'U_POZNAMKY_ASC'
  | 'U_POZNAMKY_DESC'
  | 'U_PRIJMENI_ASC'
  | 'U_PRIJMENI_DESC'
  | 'U_RODNE_CISLO_ASC'
  | 'U_RODNE_CISLO_DESC'
  | 'U_SKUPINA_ASC'
  | 'U_SKUPINA_DESC'
  | 'U_STREET_ASC'
  | 'U_STREET_DESC'
  | 'U_SYSTEM_ASC'
  | 'U_SYSTEM_DESC'
  | 'U_TEACHER_ASC'
  | 'U_TEACHER_DESC'
  | 'U_TELEFON_ASC'
  | 'U_TELEFON_DESC'
  | 'U_TIMESTAMP_ASC'
  | 'U_TIMESTAMP_DESC';

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  __typename?: 'Mutation';
  bookLesson: Maybe<BookLessonPayload>;
  cancelLesson: Maybe<CancelLessonPayload>;
  cancelParticipation: Maybe<CancelParticipationPayload>;
  changePassword: Maybe<ChangePasswordPayload>;
  confirmUser: Maybe<ConfirmUserPayload>;
  /** Creates a single `Akce`. */
  createAkce: Maybe<CreateAkcePayload>;
  /** Creates a single `AkceItem`. */
  createAkceItem: Maybe<CreateAkceItemPayload>;
  /** Creates a single `Aktuality`. */
  createAktuality: Maybe<CreateAktualityPayload>;
  /** Creates a single `Attachment`. */
  createAttachment: Maybe<CreateAttachmentPayload>;
  /** Creates a single `AttendeeExternal`. */
  createAttendeeExternal: Maybe<CreateAttendeeExternalPayload>;
  /** Creates a single `AttendeeUser`. */
  createAttendeeUser: Maybe<CreateAttendeeUserPayload>;
  /** Creates a single `CohortGroup`. */
  createCohortGroup: Maybe<CreateCohortGroupPayload>;
  createCouple: Maybe<CreateCouplePayload>;
  /** Creates a single `Dokumenty`. */
  createDokumenty: Maybe<CreateDokumentyPayload>;
  /** Creates a single `Event`. */
  createEvent: Maybe<CreateEventPayload>;
  /** Creates a single `FormResponse`. */
  createFormResponse: Maybe<CreateFormResponsePayload>;
  /** Creates a single `GalerieDir`. */
  createGalerieDir: Maybe<CreateGalerieDirPayload>;
  /** Creates a single `GalerieFoto`. */
  createGalerieFoto: Maybe<CreateGalerieFotoPayload>;
  /** Creates a single `Location`. */
  createLocation: Maybe<CreateLocationPayload>;
  /** Creates a single `LocationAttachment`. */
  createLocationAttachment: Maybe<CreateLocationAttachmentPayload>;
  /** Creates a single `Nabidka`. */
  createNabidka: Maybe<CreateNabidkaPayload>;
  /** Creates a single `NabidkaItem`. */
  createNabidkaItem: Maybe<CreateNabidkaItemPayload>;
  /** Creates a single `Page`. */
  createPage: Maybe<CreatePagePayload>;
  /** Creates a single `Parameter`. */
  createParameter: Maybe<CreateParameterPayload>;
  createParticipation: Maybe<CreateParticipationPayload>;
  createParticipationExternal: Maybe<CreateParticipationExternalPayload>;
  /** Creates a single `Pary`. */
  createPary: Maybe<CreateParyPayload>;
  /** Creates a single `ParyNavrh`. */
  createParyNavrh: Maybe<CreateParyNavrhPayload>;
  /** Creates a single `Permission`. */
  createPermission: Maybe<CreatePermissionPayload>;
  /** Creates a single `Person`. */
  createPerson: Maybe<CreatePersonPayload>;
  /** Creates a single `PlatbyCategory`. */
  createPlatbyCategory: Maybe<CreatePlatbyCategoryPayload>;
  /** Creates a single `PlatbyCategoryGroup`. */
  createPlatbyCategoryGroup: Maybe<CreatePlatbyCategoryGroupPayload>;
  /** Creates a single `PlatbyGroup`. */
  createPlatbyGroup: Maybe<CreatePlatbyGroupPayload>;
  /** Creates a single `PlatbyGroupSkupina`. */
  createPlatbyGroupSkupina: Maybe<CreatePlatbyGroupSkupinaPayload>;
  /** Creates a single `PlatbyItem`. */
  createPlatbyItem: Maybe<CreatePlatbyItemPayload>;
  /** Creates a single `PlatbyRaw`. */
  createPlatbyRaw: Maybe<CreatePlatbyRawPayload>;
  /** Creates a single `Room`. */
  createRoom: Maybe<CreateRoomPayload>;
  /** Creates a single `RoomAttachment`. */
  createRoomAttachment: Maybe<CreateRoomAttachmentPayload>;
  /** Creates a single `Rozpi`. */
  createRozpi: Maybe<CreateRozpiPayload>;
  /** Creates a single `RozpisItem`. */
  createRozpisItem: Maybe<CreateRozpisItemPayload>;
  /** Creates a single `Session`. */
  createSession: Maybe<CreateSessionPayload>;
  /** Creates a single `Skupiny`. */
  createSkupiny: Maybe<CreateSkupinyPayload>;
  /** Creates a single `Tenant`. */
  createTenant: Maybe<CreateTenantPayload>;
  /** Creates a single `TenantAttachment`. */
  createTenantAttachment: Maybe<CreateTenantAttachmentPayload>;
  /** Creates a single `TenantPerson`. */
  createTenantPerson: Maybe<CreateTenantPersonPayload>;
  /** Creates a single `Upozorneni`. */
  createUpozorneni: Maybe<CreateUpozorneniPayload>;
  /** Creates a single `UpozorneniSkupiny`. */
  createUpozorneniSkupiny: Maybe<CreateUpozorneniSkupinyPayload>;
  /** Creates a single `User`. */
  createUser: Maybe<CreateUserPayload>;
  /** Creates a single `Video`. */
  createVideo: Maybe<CreateVideoPayload>;
  /** Creates a single `VideoList`. */
  createVideoList: Maybe<CreateVideoListPayload>;
  /** Creates a single `VideoSource`. */
  createVideoSource: Maybe<CreateVideoSourcePayload>;
  /** Deletes a single `Aktuality` using a unique key. */
  deleteAktuality: Maybe<DeleteAktualityPayload>;
  /** Deletes a single `Aktuality` using its globally unique id. */
  deleteAktualityByNodeId: Maybe<DeleteAktualityPayload>;
  /** Deletes a single `Attachment` using a unique key. */
  deleteAttachment: Maybe<DeleteAttachmentPayload>;
  /** Deletes a single `Attachment` using its globally unique id. */
  deleteAttachmentByNodeId: Maybe<DeleteAttachmentPayload>;
  /** Deletes a single `AttendeeExternal` using a unique key. */
  deleteAttendeeExternal: Maybe<DeleteAttendeeExternalPayload>;
  /** Deletes a single `AttendeeExternal` using its globally unique id. */
  deleteAttendeeExternalByNodeId: Maybe<DeleteAttendeeExternalPayload>;
  /** Deletes a single `AttendeeUser` using a unique key. */
  deleteAttendeeUser: Maybe<DeleteAttendeeUserPayload>;
  /** Deletes a single `AttendeeUser` using its globally unique id. */
  deleteAttendeeUserByNodeId: Maybe<DeleteAttendeeUserPayload>;
  /** Deletes a single `AttendeeUser` using a unique key. */
  deleteAttendeeUserByUserIdAndEventId: Maybe<DeleteAttendeeUserPayload>;
  /** Deletes a single `CohortGroup` using a unique key. */
  deleteCohortGroup: Maybe<DeleteCohortGroupPayload>;
  /** Deletes a single `CohortGroup` using its globally unique id. */
  deleteCohortGroupByNodeId: Maybe<DeleteCohortGroupPayload>;
  /** Deletes a single `Dokumenty` using a unique key. */
  deleteDokumenty: Maybe<DeleteDokumentyPayload>;
  /** Deletes a single `Dokumenty` using its globally unique id. */
  deleteDokumentyByNodeId: Maybe<DeleteDokumentyPayload>;
  /** Deletes a single `Event` using a unique key. */
  deleteEvent: Maybe<DeleteEventPayload>;
  /** Deletes a single `Event` using its globally unique id. */
  deleteEventByNodeId: Maybe<DeleteEventPayload>;
  /** Deletes a single `FormResponse` using a unique key. */
  deleteFormResponse: Maybe<DeleteFormResponsePayload>;
  /** Deletes a single `FormResponse` using its globally unique id. */
  deleteFormResponseByNodeId: Maybe<DeleteFormResponsePayload>;
  /** Deletes a single `GalerieDir` using a unique key. */
  deleteGalerieDir: Maybe<DeleteGalerieDirPayload>;
  /** Deletes a single `GalerieDir` using its globally unique id. */
  deleteGalerieDirByNodeId: Maybe<DeleteGalerieDirPayload>;
  /** Deletes a single `GalerieFoto` using a unique key. */
  deleteGalerieFoto: Maybe<DeleteGalerieFotoPayload>;
  /** Deletes a single `GalerieFoto` using its globally unique id. */
  deleteGalerieFotoByNodeId: Maybe<DeleteGalerieFotoPayload>;
  /** Deletes a single `Location` using a unique key. */
  deleteLocation: Maybe<DeleteLocationPayload>;
  /** Deletes a single `LocationAttachment` using a unique key. */
  deleteLocationAttachment: Maybe<DeleteLocationAttachmentPayload>;
  /** Deletes a single `LocationAttachment` using its globally unique id. */
  deleteLocationAttachmentByNodeId: Maybe<DeleteLocationAttachmentPayload>;
  /** Deletes a single `Location` using its globally unique id. */
  deleteLocationByNodeId: Maybe<DeleteLocationPayload>;
  /** Deletes a single `Nabidka` using a unique key. */
  deleteNabidka: Maybe<DeleteNabidkaPayload>;
  /** Deletes a single `Nabidka` using its globally unique id. */
  deleteNabidkaByNodeId: Maybe<DeleteNabidkaPayload>;
  /** Deletes a single `NabidkaItem` using a unique key. */
  deleteNabidkaItem: Maybe<DeleteNabidkaItemPayload>;
  /** Deletes a single `NabidkaItem` using a unique key. */
  deleteNabidkaItemByNiPartnerAndNiIdRodic: Maybe<DeleteNabidkaItemPayload>;
  /** Deletes a single `NabidkaItem` using its globally unique id. */
  deleteNabidkaItemByNodeId: Maybe<DeleteNabidkaItemPayload>;
  /** Deletes a single `Parameter` using a unique key. */
  deleteParameter: Maybe<DeleteParameterPayload>;
  /** Deletes a single `Parameter` using its globally unique id. */
  deleteParameterByNodeId: Maybe<DeleteParameterPayload>;
  /** Deletes a single `Pary` using a unique key. */
  deletePary: Maybe<DeleteParyPayload>;
  /** Deletes a single `Pary` using its globally unique id. */
  deleteParyByNodeId: Maybe<DeleteParyPayload>;
  /** Deletes a single `ParyNavrh` using a unique key. */
  deleteParyNavrh: Maybe<DeleteParyNavrhPayload>;
  /** Deletes a single `ParyNavrh` using its globally unique id. */
  deleteParyNavrhByNodeId: Maybe<DeleteParyNavrhPayload>;
  /** Deletes a single `Permission` using a unique key. */
  deletePermission: Maybe<DeletePermissionPayload>;
  /** Deletes a single `Permission` using its globally unique id. */
  deletePermissionByNodeId: Maybe<DeletePermissionPayload>;
  /** Deletes a single `Person` using a unique key. */
  deletePerson: Maybe<DeletePersonPayload>;
  /** Deletes a single `Person` using its globally unique id. */
  deletePersonByNodeId: Maybe<DeletePersonPayload>;
  /** Deletes a single `PlatbyCategory` using a unique key. */
  deletePlatbyCategory: Maybe<DeletePlatbyCategoryPayload>;
  /** Deletes a single `PlatbyCategory` using its globally unique id. */
  deletePlatbyCategoryByNodeId: Maybe<DeletePlatbyCategoryPayload>;
  /** Deletes a single `PlatbyCategoryGroup` using a unique key. */
  deletePlatbyCategoryGroup: Maybe<DeletePlatbyCategoryGroupPayload>;
  /** Deletes a single `PlatbyCategoryGroup` using its globally unique id. */
  deletePlatbyCategoryGroupByNodeId: Maybe<DeletePlatbyCategoryGroupPayload>;
  /** Deletes a single `PlatbyGroup` using a unique key. */
  deletePlatbyGroup: Maybe<DeletePlatbyGroupPayload>;
  /** Deletes a single `PlatbyGroup` using its globally unique id. */
  deletePlatbyGroupByNodeId: Maybe<DeletePlatbyGroupPayload>;
  /** Deletes a single `PlatbyGroupSkupina` using a unique key. */
  deletePlatbyGroupSkupina: Maybe<DeletePlatbyGroupSkupinaPayload>;
  /** Deletes a single `PlatbyGroupSkupina` using its globally unique id. */
  deletePlatbyGroupSkupinaByNodeId: Maybe<DeletePlatbyGroupSkupinaPayload>;
  /** Deletes a single `PlatbyItem` using a unique key. */
  deletePlatbyItem: Maybe<DeletePlatbyItemPayload>;
  /** Deletes a single `PlatbyItem` using its globally unique id. */
  deletePlatbyItemByNodeId: Maybe<DeletePlatbyItemPayload>;
  /** Deletes a single `PlatbyRaw` using a unique key. */
  deletePlatbyRaw: Maybe<DeletePlatbyRawPayload>;
  /** Deletes a single `PlatbyRaw` using its globally unique id. */
  deletePlatbyRawByNodeId: Maybe<DeletePlatbyRawPayload>;
  /** Deletes a single `Room` using a unique key. */
  deleteRoom: Maybe<DeleteRoomPayload>;
  /** Deletes a single `RoomAttachment` using a unique key. */
  deleteRoomAttachment: Maybe<DeleteRoomAttachmentPayload>;
  /** Deletes a single `RoomAttachment` using its globally unique id. */
  deleteRoomAttachmentByNodeId: Maybe<DeleteRoomAttachmentPayload>;
  /** Deletes a single `Room` using its globally unique id. */
  deleteRoomByNodeId: Maybe<DeleteRoomPayload>;
  /** Deletes a single `Rozpi` using a unique key. */
  deleteRozpi: Maybe<DeleteRozpiPayload>;
  /** Deletes a single `Rozpi` using its globally unique id. */
  deleteRozpiByNodeId: Maybe<DeleteRozpiPayload>;
  /** Deletes a single `RozpisItem` using a unique key. */
  deleteRozpisItem: Maybe<DeleteRozpisItemPayload>;
  /** Deletes a single `RozpisItem` using its globally unique id. */
  deleteRozpisItemByNodeId: Maybe<DeleteRozpisItemPayload>;
  /** Deletes a single `Session` using a unique key. */
  deleteSession: Maybe<DeleteSessionPayload>;
  /** Deletes a single `Session` using its globally unique id. */
  deleteSessionByNodeId: Maybe<DeleteSessionPayload>;
  /** Deletes a single `Skupiny` using a unique key. */
  deleteSkupiny: Maybe<DeleteSkupinyPayload>;
  /** Deletes a single `Skupiny` using its globally unique id. */
  deleteSkupinyByNodeId: Maybe<DeleteSkupinyPayload>;
  /** Deletes a single `Tenant` using a unique key. */
  deleteTenant: Maybe<DeleteTenantPayload>;
  /** Deletes a single `TenantAttachment` using a unique key. */
  deleteTenantAttachment: Maybe<DeleteTenantAttachmentPayload>;
  /** Deletes a single `TenantAttachment` using its globally unique id. */
  deleteTenantAttachmentByNodeId: Maybe<DeleteTenantAttachmentPayload>;
  /** Deletes a single `Tenant` using its globally unique id. */
  deleteTenantByNodeId: Maybe<DeleteTenantPayload>;
  /** Deletes a single `TenantPerson` using a unique key. */
  deleteTenantPerson: Maybe<DeleteTenantPersonPayload>;
  /** Deletes a single `TenantPerson` using its globally unique id. */
  deleteTenantPersonByNodeId: Maybe<DeleteTenantPersonPayload>;
  /** Deletes a single `Upozorneni` using a unique key. */
  deleteUpozorneni: Maybe<DeleteUpozorneniPayload>;
  /** Deletes a single `Upozorneni` using its globally unique id. */
  deleteUpozorneniByNodeId: Maybe<DeleteUpozorneniPayload>;
  /** Deletes a single `UpozorneniSkupiny` using a unique key. */
  deleteUpozorneniSkupiny: Maybe<DeleteUpozorneniSkupinyPayload>;
  /** Deletes a single `UpozorneniSkupiny` using its globally unique id. */
  deleteUpozorneniSkupinyByNodeId: Maybe<DeleteUpozorneniSkupinyPayload>;
  /** Deletes a single `User` using a unique key. */
  deleteUser: Maybe<DeleteUserPayload>;
  /** Deletes a single `User` using its globally unique id. */
  deleteUserByNodeId: Maybe<DeleteUserPayload>;
  /** Deletes a single `Video` using a unique key. */
  deleteVideo: Maybe<DeleteVideoPayload>;
  /** Deletes a single `Video` using its globally unique id. */
  deleteVideoByNodeId: Maybe<DeleteVideoPayload>;
  /** Deletes a single `VideoList` using a unique key. */
  deleteVideoList: Maybe<DeleteVideoListPayload>;
  /** Deletes a single `VideoList` using its globally unique id. */
  deleteVideoListByNodeId: Maybe<DeleteVideoListPayload>;
  /** Deletes a single `VideoSource` using a unique key. */
  deleteVideoSource: Maybe<DeleteVideoSourcePayload>;
  /** Deletes a single `VideoSource` using its globally unique id. */
  deleteVideoSourceByNodeId: Maybe<DeleteVideoSourcePayload>;
  downloadFile: Scalars['String'];
  fixUnpairedCouples: Maybe<FixUnpairedCouplesPayload>;
  login: Maybe<LoginPayload>;
  logout: Maybe<LogoutPayload>;
  prospectFormDancer: Maybe<ProspectFormDancerPayload>;
  reservationSetDesiredLessons: Maybe<ReservationSetDesiredLessonsPayload>;
  resetPassword: Maybe<ResetPasswordPayload>;
  submitForm: Maybe<SubmitFormPayload>;
  /** Updates a single `Aktuality` using a unique key and a patch. */
  updateAktuality: Maybe<UpdateAktualityPayload>;
  /** Updates a single `Aktuality` using its globally unique id and a patch. */
  updateAktualityByNodeId: Maybe<UpdateAktualityPayload>;
  /** Updates a single `Attachment` using a unique key and a patch. */
  updateAttachment: Maybe<UpdateAttachmentPayload>;
  /** Updates a single `Attachment` using its globally unique id and a patch. */
  updateAttachmentByNodeId: Maybe<UpdateAttachmentPayload>;
  /** Updates a single `AttendeeExternal` using a unique key and a patch. */
  updateAttendeeExternal: Maybe<UpdateAttendeeExternalPayload>;
  /** Updates a single `AttendeeExternal` using its globally unique id and a patch. */
  updateAttendeeExternalByNodeId: Maybe<UpdateAttendeeExternalPayload>;
  /** Updates a single `AttendeeUser` using a unique key and a patch. */
  updateAttendeeUser: Maybe<UpdateAttendeeUserPayload>;
  /** Updates a single `AttendeeUser` using its globally unique id and a patch. */
  updateAttendeeUserByNodeId: Maybe<UpdateAttendeeUserPayload>;
  /** Updates a single `AttendeeUser` using a unique key and a patch. */
  updateAttendeeUserByUserIdAndEventId: Maybe<UpdateAttendeeUserPayload>;
  /** Updates a single `CohortGroup` using a unique key and a patch. */
  updateCohortGroup: Maybe<UpdateCohortGroupPayload>;
  /** Updates a single `CohortGroup` using its globally unique id and a patch. */
  updateCohortGroupByNodeId: Maybe<UpdateCohortGroupPayload>;
  /** Updates a single `Dokumenty` using a unique key and a patch. */
  updateDokumenty: Maybe<UpdateDokumentyPayload>;
  /** Updates a single `Dokumenty` using its globally unique id and a patch. */
  updateDokumentyByNodeId: Maybe<UpdateDokumentyPayload>;
  /** Updates a single `Event` using a unique key and a patch. */
  updateEvent: Maybe<UpdateEventPayload>;
  /** Updates a single `Event` using its globally unique id and a patch. */
  updateEventByNodeId: Maybe<UpdateEventPayload>;
  /** Updates a single `FormResponse` using a unique key and a patch. */
  updateFormResponse: Maybe<UpdateFormResponsePayload>;
  /** Updates a single `FormResponse` using its globally unique id and a patch. */
  updateFormResponseByNodeId: Maybe<UpdateFormResponsePayload>;
  /** Updates a single `GalerieDir` using a unique key and a patch. */
  updateGalerieDir: Maybe<UpdateGalerieDirPayload>;
  /** Updates a single `GalerieDir` using its globally unique id and a patch. */
  updateGalerieDirByNodeId: Maybe<UpdateGalerieDirPayload>;
  /** Updates a single `GalerieFoto` using a unique key and a patch. */
  updateGalerieFoto: Maybe<UpdateGalerieFotoPayload>;
  /** Updates a single `GalerieFoto` using its globally unique id and a patch. */
  updateGalerieFotoByNodeId: Maybe<UpdateGalerieFotoPayload>;
  /** Updates a single `Location` using a unique key and a patch. */
  updateLocation: Maybe<UpdateLocationPayload>;
  /** Updates a single `LocationAttachment` using a unique key and a patch. */
  updateLocationAttachment: Maybe<UpdateLocationAttachmentPayload>;
  /** Updates a single `LocationAttachment` using its globally unique id and a patch. */
  updateLocationAttachmentByNodeId: Maybe<UpdateLocationAttachmentPayload>;
  /** Updates a single `Location` using its globally unique id and a patch. */
  updateLocationByNodeId: Maybe<UpdateLocationPayload>;
  /** Updates a single `Nabidka` using a unique key and a patch. */
  updateNabidka: Maybe<UpdateNabidkaPayload>;
  /** Updates a single `Nabidka` using its globally unique id and a patch. */
  updateNabidkaByNodeId: Maybe<UpdateNabidkaPayload>;
  /** Updates a single `NabidkaItem` using a unique key and a patch. */
  updateNabidkaItem: Maybe<UpdateNabidkaItemPayload>;
  /** Updates a single `NabidkaItem` using a unique key and a patch. */
  updateNabidkaItemByNiPartnerAndNiIdRodic: Maybe<UpdateNabidkaItemPayload>;
  /** Updates a single `NabidkaItem` using its globally unique id and a patch. */
  updateNabidkaItemByNodeId: Maybe<UpdateNabidkaItemPayload>;
  /** Updates a single `Page` using a unique key and a patch. */
  updatePage: Maybe<UpdatePagePayload>;
  /** Updates a single `Page` using its globally unique id and a patch. */
  updatePageByNodeId: Maybe<UpdatePagePayload>;
  /** Updates a single `Page` using a unique key and a patch. */
  updatePageByUrl: Maybe<UpdatePagePayload>;
  /** Updates a single `Parameter` using a unique key and a patch. */
  updateParameter: Maybe<UpdateParameterPayload>;
  /** Updates a single `Parameter` using its globally unique id and a patch. */
  updateParameterByNodeId: Maybe<UpdateParameterPayload>;
  /** Updates a single `Pary` using a unique key and a patch. */
  updatePary: Maybe<UpdateParyPayload>;
  /** Updates a single `Pary` using its globally unique id and a patch. */
  updateParyByNodeId: Maybe<UpdateParyPayload>;
  /** Updates a single `ParyNavrh` using a unique key and a patch. */
  updateParyNavrh: Maybe<UpdateParyNavrhPayload>;
  /** Updates a single `ParyNavrh` using its globally unique id and a patch. */
  updateParyNavrhByNodeId: Maybe<UpdateParyNavrhPayload>;
  /** Updates a single `Permission` using a unique key and a patch. */
  updatePermission: Maybe<UpdatePermissionPayload>;
  /** Updates a single `Permission` using its globally unique id and a patch. */
  updatePermissionByNodeId: Maybe<UpdatePermissionPayload>;
  /** Updates a single `Person` using a unique key and a patch. */
  updatePerson: Maybe<UpdatePersonPayload>;
  /** Updates a single `Person` using its globally unique id and a patch. */
  updatePersonByNodeId: Maybe<UpdatePersonPayload>;
  /** Updates a single `PlatbyCategory` using a unique key and a patch. */
  updatePlatbyCategory: Maybe<UpdatePlatbyCategoryPayload>;
  /** Updates a single `PlatbyCategory` using its globally unique id and a patch. */
  updatePlatbyCategoryByNodeId: Maybe<UpdatePlatbyCategoryPayload>;
  /** Updates a single `PlatbyCategoryGroup` using a unique key and a patch. */
  updatePlatbyCategoryGroup: Maybe<UpdatePlatbyCategoryGroupPayload>;
  /** Updates a single `PlatbyCategoryGroup` using its globally unique id and a patch. */
  updatePlatbyCategoryGroupByNodeId: Maybe<UpdatePlatbyCategoryGroupPayload>;
  /** Updates a single `PlatbyGroup` using a unique key and a patch. */
  updatePlatbyGroup: Maybe<UpdatePlatbyGroupPayload>;
  /** Updates a single `PlatbyGroup` using its globally unique id and a patch. */
  updatePlatbyGroupByNodeId: Maybe<UpdatePlatbyGroupPayload>;
  /** Updates a single `PlatbyGroupSkupina` using a unique key and a patch. */
  updatePlatbyGroupSkupina: Maybe<UpdatePlatbyGroupSkupinaPayload>;
  /** Updates a single `PlatbyGroupSkupina` using its globally unique id and a patch. */
  updatePlatbyGroupSkupinaByNodeId: Maybe<UpdatePlatbyGroupSkupinaPayload>;
  /** Updates a single `PlatbyItem` using a unique key and a patch. */
  updatePlatbyItem: Maybe<UpdatePlatbyItemPayload>;
  /** Updates a single `PlatbyItem` using its globally unique id and a patch. */
  updatePlatbyItemByNodeId: Maybe<UpdatePlatbyItemPayload>;
  /** Updates a single `PlatbyRaw` using a unique key and a patch. */
  updatePlatbyRaw: Maybe<UpdatePlatbyRawPayload>;
  /** Updates a single `PlatbyRaw` using its globally unique id and a patch. */
  updatePlatbyRawByNodeId: Maybe<UpdatePlatbyRawPayload>;
  /** Updates a single `Room` using a unique key and a patch. */
  updateRoom: Maybe<UpdateRoomPayload>;
  /** Updates a single `RoomAttachment` using a unique key and a patch. */
  updateRoomAttachment: Maybe<UpdateRoomAttachmentPayload>;
  /** Updates a single `RoomAttachment` using its globally unique id and a patch. */
  updateRoomAttachmentByNodeId: Maybe<UpdateRoomAttachmentPayload>;
  /** Updates a single `Room` using its globally unique id and a patch. */
  updateRoomByNodeId: Maybe<UpdateRoomPayload>;
  /** Updates a single `Rozpi` using a unique key and a patch. */
  updateRozpi: Maybe<UpdateRozpiPayload>;
  /** Updates a single `Rozpi` using its globally unique id and a patch. */
  updateRozpiByNodeId: Maybe<UpdateRozpiPayload>;
  /** Updates a single `RozpisItem` using a unique key and a patch. */
  updateRozpisItem: Maybe<UpdateRozpisItemPayload>;
  /** Updates a single `RozpisItem` using its globally unique id and a patch. */
  updateRozpisItemByNodeId: Maybe<UpdateRozpisItemPayload>;
  /** Updates a single `Session` using a unique key and a patch. */
  updateSession: Maybe<UpdateSessionPayload>;
  /** Updates a single `Session` using its globally unique id and a patch. */
  updateSessionByNodeId: Maybe<UpdateSessionPayload>;
  /** Updates a single `Skupiny` using a unique key and a patch. */
  updateSkupiny: Maybe<UpdateSkupinyPayload>;
  /** Updates a single `Skupiny` using its globally unique id and a patch. */
  updateSkupinyByNodeId: Maybe<UpdateSkupinyPayload>;
  /** Updates a single `Tenant` using a unique key and a patch. */
  updateTenant: Maybe<UpdateTenantPayload>;
  /** Updates a single `TenantAttachment` using a unique key and a patch. */
  updateTenantAttachment: Maybe<UpdateTenantAttachmentPayload>;
  /** Updates a single `TenantAttachment` using its globally unique id and a patch. */
  updateTenantAttachmentByNodeId: Maybe<UpdateTenantAttachmentPayload>;
  /** Updates a single `Tenant` using its globally unique id and a patch. */
  updateTenantByNodeId: Maybe<UpdateTenantPayload>;
  /** Updates a single `TenantPerson` using a unique key and a patch. */
  updateTenantPerson: Maybe<UpdateTenantPersonPayload>;
  /** Updates a single `TenantPerson` using its globally unique id and a patch. */
  updateTenantPersonByNodeId: Maybe<UpdateTenantPersonPayload>;
  /** Updates a single `Upozorneni` using a unique key and a patch. */
  updateUpozorneni: Maybe<UpdateUpozorneniPayload>;
  /** Updates a single `Upozorneni` using its globally unique id and a patch. */
  updateUpozorneniByNodeId: Maybe<UpdateUpozorneniPayload>;
  /** Updates a single `UpozorneniSkupiny` using a unique key and a patch. */
  updateUpozorneniSkupiny: Maybe<UpdateUpozorneniSkupinyPayload>;
  /** Updates a single `UpozorneniSkupiny` using its globally unique id and a patch. */
  updateUpozorneniSkupinyByNodeId: Maybe<UpdateUpozorneniSkupinyPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUser: Maybe<UpdateUserPayload>;
  /** Updates a single `User` using its globally unique id and a patch. */
  updateUserByNodeId: Maybe<UpdateUserPayload>;
  /** Updates a single `Video` using a unique key and a patch. */
  updateVideo: Maybe<UpdateVideoPayload>;
  /** Updates a single `Video` using its globally unique id and a patch. */
  updateVideoByNodeId: Maybe<UpdateVideoPayload>;
  /** Updates a single `VideoList` using a unique key and a patch. */
  updateVideoList: Maybe<UpdateVideoListPayload>;
  /** Updates a single `VideoList` using its globally unique id and a patch. */
  updateVideoListByNodeId: Maybe<UpdateVideoListPayload>;
  /** Updates a single `VideoSource` using a unique key and a patch. */
  updateVideoSource: Maybe<UpdateVideoSourcePayload>;
  /** Updates a single `VideoSource` using its globally unique id and a patch. */
  updateVideoSourceByNodeId: Maybe<UpdateVideoSourcePayload>;
  uploadFile: UploadFilePayload;
  verifyFunction: Maybe<VerifyFunctionPayload>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBookLessonArgs = {
  input: BookLessonInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCancelLessonArgs = {
  input: CancelLessonInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCancelParticipationArgs = {
  input: CancelParticipationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationChangePasswordArgs = {
  input: ChangePasswordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationConfirmUserArgs = {
  input: ConfirmUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAkceArgs = {
  input: CreateAkceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAkceItemArgs = {
  input: CreateAkceItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAktualityArgs = {
  input: CreateAktualityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAttachmentArgs = {
  input: CreateAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAttendeeExternalArgs = {
  input: CreateAttendeeExternalInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAttendeeUserArgs = {
  input: CreateAttendeeUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCohortGroupArgs = {
  input: CreateCohortGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCoupleArgs = {
  input: CreateCoupleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDokumentyArgs = {
  input: CreateDokumentyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEventArgs = {
  input: CreateEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFormResponseArgs = {
  input: CreateFormResponseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGalerieDirArgs = {
  input: CreateGalerieDirInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGalerieFotoArgs = {
  input: CreateGalerieFotoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLocationArgs = {
  input: CreateLocationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLocationAttachmentArgs = {
  input: CreateLocationAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateNabidkaArgs = {
  input: CreateNabidkaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateNabidkaItemArgs = {
  input: CreateNabidkaItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePageArgs = {
  input: CreatePageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateParameterArgs = {
  input: CreateParameterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateParticipationArgs = {
  input: CreateParticipationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateParticipationExternalArgs = {
  input: CreateParticipationExternalInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateParyArgs = {
  input: CreateParyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateParyNavrhArgs = {
  input: CreateParyNavrhInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePermissionArgs = {
  input: CreatePermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePersonArgs = {
  input: CreatePersonInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlatbyCategoryArgs = {
  input: CreatePlatbyCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlatbyCategoryGroupArgs = {
  input: CreatePlatbyCategoryGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlatbyGroupArgs = {
  input: CreatePlatbyGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlatbyGroupSkupinaArgs = {
  input: CreatePlatbyGroupSkupinaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlatbyItemArgs = {
  input: CreatePlatbyItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlatbyRawArgs = {
  input: CreatePlatbyRawInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRoomArgs = {
  input: CreateRoomInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRoomAttachmentArgs = {
  input: CreateRoomAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRozpiArgs = {
  input: CreateRozpiInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRozpisItemArgs = {
  input: CreateRozpisItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSessionArgs = {
  input: CreateSessionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSkupinyArgs = {
  input: CreateSkupinyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTenantArgs = {
  input: CreateTenantInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTenantAttachmentArgs = {
  input: CreateTenantAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTenantPersonArgs = {
  input: CreateTenantPersonInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUpozorneniArgs = {
  input: CreateUpozorneniInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUpozorneniSkupinyArgs = {
  input: CreateUpozorneniSkupinyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserArgs = {
  input: CreateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVideoArgs = {
  input: CreateVideoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVideoListArgs = {
  input: CreateVideoListInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVideoSourceArgs = {
  input: CreateVideoSourceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAktualityArgs = {
  input: DeleteAktualityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAktualityByNodeIdArgs = {
  input: DeleteAktualityByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAttachmentArgs = {
  input: DeleteAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAttachmentByNodeIdArgs = {
  input: DeleteAttachmentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAttendeeExternalArgs = {
  input: DeleteAttendeeExternalInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAttendeeExternalByNodeIdArgs = {
  input: DeleteAttendeeExternalByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAttendeeUserArgs = {
  input: DeleteAttendeeUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAttendeeUserByNodeIdArgs = {
  input: DeleteAttendeeUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAttendeeUserByUserIdAndEventIdArgs = {
  input: DeleteAttendeeUserByUserIdAndEventIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCohortGroupArgs = {
  input: DeleteCohortGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCohortGroupByNodeIdArgs = {
  input: DeleteCohortGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDokumentyArgs = {
  input: DeleteDokumentyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDokumentyByNodeIdArgs = {
  input: DeleteDokumentyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEventArgs = {
  input: DeleteEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEventByNodeIdArgs = {
  input: DeleteEventByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFormResponseArgs = {
  input: DeleteFormResponseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFormResponseByNodeIdArgs = {
  input: DeleteFormResponseByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGalerieDirArgs = {
  input: DeleteGalerieDirInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGalerieDirByNodeIdArgs = {
  input: DeleteGalerieDirByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGalerieFotoArgs = {
  input: DeleteGalerieFotoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGalerieFotoByNodeIdArgs = {
  input: DeleteGalerieFotoByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLocationArgs = {
  input: DeleteLocationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLocationAttachmentArgs = {
  input: DeleteLocationAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLocationAttachmentByNodeIdArgs = {
  input: DeleteLocationAttachmentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLocationByNodeIdArgs = {
  input: DeleteLocationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNabidkaArgs = {
  input: DeleteNabidkaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNabidkaByNodeIdArgs = {
  input: DeleteNabidkaByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNabidkaItemArgs = {
  input: DeleteNabidkaItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNabidkaItemByNiPartnerAndNiIdRodicArgs = {
  input: DeleteNabidkaItemByNiPartnerAndNiIdRodicInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNabidkaItemByNodeIdArgs = {
  input: DeleteNabidkaItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteParameterArgs = {
  input: DeleteParameterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteParameterByNodeIdArgs = {
  input: DeleteParameterByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteParyArgs = {
  input: DeleteParyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteParyByNodeIdArgs = {
  input: DeleteParyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteParyNavrhArgs = {
  input: DeleteParyNavrhInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteParyNavrhByNodeIdArgs = {
  input: DeleteParyNavrhByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePermissionArgs = {
  input: DeletePermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePermissionByNodeIdArgs = {
  input: DeletePermissionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePersonArgs = {
  input: DeletePersonInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePersonByNodeIdArgs = {
  input: DeletePersonByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyCategoryArgs = {
  input: DeletePlatbyCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyCategoryByNodeIdArgs = {
  input: DeletePlatbyCategoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyCategoryGroupArgs = {
  input: DeletePlatbyCategoryGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyCategoryGroupByNodeIdArgs = {
  input: DeletePlatbyCategoryGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyGroupArgs = {
  input: DeletePlatbyGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyGroupByNodeIdArgs = {
  input: DeletePlatbyGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyGroupSkupinaArgs = {
  input: DeletePlatbyGroupSkupinaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyGroupSkupinaByNodeIdArgs = {
  input: DeletePlatbyGroupSkupinaByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyItemArgs = {
  input: DeletePlatbyItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyItemByNodeIdArgs = {
  input: DeletePlatbyItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyRawArgs = {
  input: DeletePlatbyRawInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyRawByNodeIdArgs = {
  input: DeletePlatbyRawByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoomArgs = {
  input: DeleteRoomInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoomAttachmentArgs = {
  input: DeleteRoomAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoomAttachmentByNodeIdArgs = {
  input: DeleteRoomAttachmentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoomByNodeIdArgs = {
  input: DeleteRoomByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRozpiArgs = {
  input: DeleteRozpiInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRozpiByNodeIdArgs = {
  input: DeleteRozpiByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRozpisItemArgs = {
  input: DeleteRozpisItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRozpisItemByNodeIdArgs = {
  input: DeleteRozpisItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSessionArgs = {
  input: DeleteSessionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSessionByNodeIdArgs = {
  input: DeleteSessionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSkupinyArgs = {
  input: DeleteSkupinyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSkupinyByNodeIdArgs = {
  input: DeleteSkupinyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTenantArgs = {
  input: DeleteTenantInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTenantAttachmentArgs = {
  input: DeleteTenantAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTenantAttachmentByNodeIdArgs = {
  input: DeleteTenantAttachmentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTenantByNodeIdArgs = {
  input: DeleteTenantByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTenantPersonArgs = {
  input: DeleteTenantPersonInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTenantPersonByNodeIdArgs = {
  input: DeleteTenantPersonByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUpozorneniArgs = {
  input: DeleteUpozorneniInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUpozorneniByNodeIdArgs = {
  input: DeleteUpozorneniByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUpozorneniSkupinyArgs = {
  input: DeleteUpozorneniSkupinyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUpozorneniSkupinyByNodeIdArgs = {
  input: DeleteUpozorneniSkupinyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserArgs = {
  input: DeleteUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserByNodeIdArgs = {
  input: DeleteUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVideoArgs = {
  input: DeleteVideoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVideoByNodeIdArgs = {
  input: DeleteVideoByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVideoListArgs = {
  input: DeleteVideoListInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVideoListByNodeIdArgs = {
  input: DeleteVideoListByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVideoSourceArgs = {
  input: DeleteVideoSourceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVideoSourceByNodeIdArgs = {
  input: DeleteVideoSourceByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDownloadFileArgs = {
  id: Scalars['Int'];
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationFixUnpairedCouplesArgs = {
  input: FixUnpairedCouplesInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationLoginArgs = {
  input: LoginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationLogoutArgs = {
  input: LogoutInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationProspectFormDancerArgs = {
  input: ProspectFormDancerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationReservationSetDesiredLessonsArgs = {
  input: ReservationSetDesiredLessonsInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationResetPasswordArgs = {
  input: ResetPasswordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationSubmitFormArgs = {
  input: SubmitFormInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAktualityArgs = {
  input: UpdateAktualityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAktualityByNodeIdArgs = {
  input: UpdateAktualityByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAttachmentArgs = {
  input: UpdateAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAttachmentByNodeIdArgs = {
  input: UpdateAttachmentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAttendeeExternalArgs = {
  input: UpdateAttendeeExternalInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAttendeeExternalByNodeIdArgs = {
  input: UpdateAttendeeExternalByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAttendeeUserArgs = {
  input: UpdateAttendeeUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAttendeeUserByNodeIdArgs = {
  input: UpdateAttendeeUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAttendeeUserByUserIdAndEventIdArgs = {
  input: UpdateAttendeeUserByUserIdAndEventIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCohortGroupArgs = {
  input: UpdateCohortGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCohortGroupByNodeIdArgs = {
  input: UpdateCohortGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDokumentyArgs = {
  input: UpdateDokumentyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDokumentyByNodeIdArgs = {
  input: UpdateDokumentyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEventArgs = {
  input: UpdateEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEventByNodeIdArgs = {
  input: UpdateEventByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFormResponseArgs = {
  input: UpdateFormResponseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFormResponseByNodeIdArgs = {
  input: UpdateFormResponseByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGalerieDirArgs = {
  input: UpdateGalerieDirInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGalerieDirByNodeIdArgs = {
  input: UpdateGalerieDirByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGalerieFotoArgs = {
  input: UpdateGalerieFotoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGalerieFotoByNodeIdArgs = {
  input: UpdateGalerieFotoByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLocationArgs = {
  input: UpdateLocationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLocationAttachmentArgs = {
  input: UpdateLocationAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLocationAttachmentByNodeIdArgs = {
  input: UpdateLocationAttachmentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLocationByNodeIdArgs = {
  input: UpdateLocationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNabidkaArgs = {
  input: UpdateNabidkaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNabidkaByNodeIdArgs = {
  input: UpdateNabidkaByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNabidkaItemArgs = {
  input: UpdateNabidkaItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNabidkaItemByNiPartnerAndNiIdRodicArgs = {
  input: UpdateNabidkaItemByNiPartnerAndNiIdRodicInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNabidkaItemByNodeIdArgs = {
  input: UpdateNabidkaItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePageArgs = {
  input: UpdatePageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePageByNodeIdArgs = {
  input: UpdatePageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePageByUrlArgs = {
  input: UpdatePageByUrlInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateParameterArgs = {
  input: UpdateParameterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateParameterByNodeIdArgs = {
  input: UpdateParameterByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateParyArgs = {
  input: UpdateParyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateParyByNodeIdArgs = {
  input: UpdateParyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateParyNavrhArgs = {
  input: UpdateParyNavrhInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateParyNavrhByNodeIdArgs = {
  input: UpdateParyNavrhByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePermissionArgs = {
  input: UpdatePermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePermissionByNodeIdArgs = {
  input: UpdatePermissionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePersonArgs = {
  input: UpdatePersonInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePersonByNodeIdArgs = {
  input: UpdatePersonByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyCategoryArgs = {
  input: UpdatePlatbyCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyCategoryByNodeIdArgs = {
  input: UpdatePlatbyCategoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyCategoryGroupArgs = {
  input: UpdatePlatbyCategoryGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyCategoryGroupByNodeIdArgs = {
  input: UpdatePlatbyCategoryGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyGroupArgs = {
  input: UpdatePlatbyGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyGroupByNodeIdArgs = {
  input: UpdatePlatbyGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyGroupSkupinaArgs = {
  input: UpdatePlatbyGroupSkupinaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyGroupSkupinaByNodeIdArgs = {
  input: UpdatePlatbyGroupSkupinaByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyItemArgs = {
  input: UpdatePlatbyItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyItemByNodeIdArgs = {
  input: UpdatePlatbyItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyRawArgs = {
  input: UpdatePlatbyRawInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyRawByNodeIdArgs = {
  input: UpdatePlatbyRawByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoomArgs = {
  input: UpdateRoomInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoomAttachmentArgs = {
  input: UpdateRoomAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoomAttachmentByNodeIdArgs = {
  input: UpdateRoomAttachmentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoomByNodeIdArgs = {
  input: UpdateRoomByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRozpiArgs = {
  input: UpdateRozpiInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRozpiByNodeIdArgs = {
  input: UpdateRozpiByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRozpisItemArgs = {
  input: UpdateRozpisItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRozpisItemByNodeIdArgs = {
  input: UpdateRozpisItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSessionArgs = {
  input: UpdateSessionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSessionByNodeIdArgs = {
  input: UpdateSessionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSkupinyArgs = {
  input: UpdateSkupinyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSkupinyByNodeIdArgs = {
  input: UpdateSkupinyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTenantArgs = {
  input: UpdateTenantInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTenantAttachmentArgs = {
  input: UpdateTenantAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTenantAttachmentByNodeIdArgs = {
  input: UpdateTenantAttachmentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTenantByNodeIdArgs = {
  input: UpdateTenantByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTenantPersonArgs = {
  input: UpdateTenantPersonInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTenantPersonByNodeIdArgs = {
  input: UpdateTenantPersonByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUpozorneniArgs = {
  input: UpdateUpozorneniInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUpozorneniByNodeIdArgs = {
  input: UpdateUpozorneniByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUpozorneniSkupinyArgs = {
  input: UpdateUpozorneniSkupinyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUpozorneniSkupinyByNodeIdArgs = {
  input: UpdateUpozorneniSkupinyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserArgs = {
  input: UpdateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByNodeIdArgs = {
  input: UpdateUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVideoArgs = {
  input: UpdateVideoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVideoByNodeIdArgs = {
  input: UpdateVideoByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVideoListArgs = {
  input: UpdateVideoListInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVideoListByNodeIdArgs = {
  input: UpdateVideoListByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVideoSourceArgs = {
  input: UpdateVideoSourceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVideoSourceByNodeIdArgs = {
  input: UpdateVideoSourceByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUploadFileArgs = {
  fileName: Scalars['String'];
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationVerifyFunctionArgs = {
  input: VerifyFunctionInput;
};

export type Nabidka = Node & {
  __typename?: 'Nabidka';
  freeLessons: Maybe<Scalars['Int']>;
  myLessons: Maybe<Scalars['Int']>;
  nDo: Scalars['Date'];
  nId: Scalars['BigInt'];
  nLock: Scalars['Boolean'];
  nMaxPocetHod: Scalars['Int'];
  nOd: Scalars['Date'];
  nPocetHod: Scalars['Int'];
  nTimestamp: Maybe<Scalars['Datetime']>;
  nTrener: Scalars['BigInt'];
  nVisible: Scalars['Boolean'];
  /** Reads and enables pagination through a set of `NabidkaItem`. */
  nabidkaItemsByNiIdRodic: NabidkaItemsConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `User` that is related to this `Nabidka`. */
  userByNTrener: Maybe<User>;
};


export type NabidkaNabidkaItemsByNiIdRodicArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<NabidkaItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<NabidkaItemsOrderBy>>;
};

/** A condition to be used against `Nabidka` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type NabidkaCondition = {
  /** Checks for equality with the object’s `nDo` field. */
  nDo?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `nId` field. */
  nId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `nLock` field. */
  nLock?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `nMaxPocetHod` field. */
  nMaxPocetHod?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `nOd` field. */
  nOd?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `nPocetHod` field. */
  nPocetHod?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `nTimestamp` field. */
  nTimestamp?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `nTrener` field. */
  nTrener?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `nVisible` field. */
  nVisible?: InputMaybe<Scalars['Boolean']>;
};

/** An input for mutations affecting `Nabidka` */
export type NabidkaInput = {
  nDo: Scalars['Date'];
  nId?: InputMaybe<Scalars['BigInt']>;
  nLock?: InputMaybe<Scalars['Boolean']>;
  nMaxPocetHod?: InputMaybe<Scalars['Int']>;
  nOd: Scalars['Date'];
  nPocetHod?: InputMaybe<Scalars['Int']>;
  nTimestamp?: InputMaybe<Scalars['Datetime']>;
  nTrener: Scalars['BigInt'];
  nVisible?: InputMaybe<Scalars['Boolean']>;
};

export type NabidkaItem = Node & {
  __typename?: 'NabidkaItem';
  /** Reads a single `Nabidka` that is related to this `NabidkaItem`. */
  nabidkaByNiIdRodic: Maybe<Nabidka>;
  niId: Scalars['BigInt'];
  niIdRodic: Scalars['BigInt'];
  niLock: Scalars['Boolean'];
  niPartner: Scalars['BigInt'];
  niPocetHod: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `Pary` that is related to this `NabidkaItem`. */
  paryByNiPartner: Maybe<Pary>;
};

/**
 * A condition to be used against `NabidkaItem` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type NabidkaItemCondition = {
  /** Checks for equality with the object’s `niId` field. */
  niId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `niIdRodic` field. */
  niIdRodic?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `niLock` field. */
  niLock?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `niPartner` field. */
  niPartner?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `niPocetHod` field. */
  niPocetHod?: InputMaybe<Scalars['Int']>;
};

/** An input for mutations affecting `NabidkaItem` */
export type NabidkaItemInput = {
  niId?: InputMaybe<Scalars['BigInt']>;
  niIdRodic: Scalars['BigInt'];
  niLock?: InputMaybe<Scalars['Boolean']>;
  niPartner: Scalars['BigInt'];
  niPocetHod?: InputMaybe<Scalars['Int']>;
};

/** Represents an update to a `NabidkaItem`. Fields that are set will be updated. */
export type NabidkaItemPatch = {
  niId?: InputMaybe<Scalars['BigInt']>;
  niIdRodic?: InputMaybe<Scalars['BigInt']>;
  niLock?: InputMaybe<Scalars['Boolean']>;
  niPartner?: InputMaybe<Scalars['BigInt']>;
  niPocetHod?: InputMaybe<Scalars['Int']>;
};

/** A connection to a list of `NabidkaItem` values. */
export type NabidkaItemsConnection = {
  __typename?: 'NabidkaItemsConnection';
  /** A list of edges which contains the `NabidkaItem` and cursor to aid in pagination. */
  edges: Array<NabidkaItemsEdge>;
  /** A list of `NabidkaItem` objects. */
  nodes: Array<NabidkaItem>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `NabidkaItem` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `NabidkaItem` edge in the connection. */
export type NabidkaItemsEdge = {
  __typename?: 'NabidkaItemsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `NabidkaItem` at the end of the edge. */
  node: NabidkaItem;
};

/** Methods to use when ordering `NabidkaItem`. */
export type NabidkaItemsOrderBy =
  | 'NABIDKA_BY_NI_ID_RODIC__N_DO_ASC'
  | 'NABIDKA_BY_NI_ID_RODIC__N_DO_DESC'
  | 'NABIDKA_BY_NI_ID_RODIC__N_ID_ASC'
  | 'NABIDKA_BY_NI_ID_RODIC__N_ID_DESC'
  | 'NABIDKA_BY_NI_ID_RODIC__N_LOCK_ASC'
  | 'NABIDKA_BY_NI_ID_RODIC__N_LOCK_DESC'
  | 'NABIDKA_BY_NI_ID_RODIC__N_MAX_POCET_HOD_ASC'
  | 'NABIDKA_BY_NI_ID_RODIC__N_MAX_POCET_HOD_DESC'
  | 'NABIDKA_BY_NI_ID_RODIC__N_OD_ASC'
  | 'NABIDKA_BY_NI_ID_RODIC__N_OD_DESC'
  | 'NABIDKA_BY_NI_ID_RODIC__N_POCET_HOD_ASC'
  | 'NABIDKA_BY_NI_ID_RODIC__N_POCET_HOD_DESC'
  | 'NABIDKA_BY_NI_ID_RODIC__N_TIMESTAMP_ASC'
  | 'NABIDKA_BY_NI_ID_RODIC__N_TIMESTAMP_DESC'
  | 'NABIDKA_BY_NI_ID_RODIC__N_TRENER_ASC'
  | 'NABIDKA_BY_NI_ID_RODIC__N_TRENER_DESC'
  | 'NABIDKA_BY_NI_ID_RODIC__N_VISIBLE_ASC'
  | 'NABIDKA_BY_NI_ID_RODIC__N_VISIBLE_DESC'
  | 'NATURAL'
  | 'NI_ID_ASC'
  | 'NI_ID_DESC'
  | 'NI_ID_RODIC_ASC'
  | 'NI_ID_RODIC_DESC'
  | 'NI_LOCK_ASC'
  | 'NI_LOCK_DESC'
  | 'NI_PARTNER_ASC'
  | 'NI_PARTNER_DESC'
  | 'NI_POCET_HOD_ASC'
  | 'NI_POCET_HOD_DESC'
  | 'PARY_BY_NI_PARTNER__P_ARCHIV_ASC'
  | 'PARY_BY_NI_PARTNER__P_ARCHIV_DESC'
  | 'PARY_BY_NI_PARTNER__P_HODNOCENI_ASC'
  | 'PARY_BY_NI_PARTNER__P_HODNOCENI_DESC'
  | 'PARY_BY_NI_PARTNER__P_ID_ASC'
  | 'PARY_BY_NI_PARTNER__P_ID_DESC'
  | 'PARY_BY_NI_PARTNER__P_ID_PARTNERKA_ASC'
  | 'PARY_BY_NI_PARTNER__P_ID_PARTNERKA_DESC'
  | 'PARY_BY_NI_PARTNER__P_ID_PARTNER_ASC'
  | 'PARY_BY_NI_PARTNER__P_ID_PARTNER_DESC'
  | 'PARY_BY_NI_PARTNER__P_LAT_BODY_ASC'
  | 'PARY_BY_NI_PARTNER__P_LAT_BODY_DESC'
  | 'PARY_BY_NI_PARTNER__P_LAT_FINALE_ASC'
  | 'PARY_BY_NI_PARTNER__P_LAT_FINALE_DESC'
  | 'PARY_BY_NI_PARTNER__P_LAT_TRIDA_ASC'
  | 'PARY_BY_NI_PARTNER__P_LAT_TRIDA_DESC'
  | 'PARY_BY_NI_PARTNER__P_STT_BODY_ASC'
  | 'PARY_BY_NI_PARTNER__P_STT_BODY_DESC'
  | 'PARY_BY_NI_PARTNER__P_STT_FINALE_ASC'
  | 'PARY_BY_NI_PARTNER__P_STT_FINALE_DESC'
  | 'PARY_BY_NI_PARTNER__P_STT_TRIDA_ASC'
  | 'PARY_BY_NI_PARTNER__P_STT_TRIDA_DESC'
  | 'PARY_BY_NI_PARTNER__P_TIMESTAMP_ADD_ASC'
  | 'PARY_BY_NI_PARTNER__P_TIMESTAMP_ADD_DESC'
  | 'PARY_BY_NI_PARTNER__P_TIMESTAMP_ARCHIVE_ASC'
  | 'PARY_BY_NI_PARTNER__P_TIMESTAMP_ARCHIVE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** Represents an update to a `Nabidka`. Fields that are set will be updated. */
export type NabidkaPatch = {
  nDo?: InputMaybe<Scalars['Date']>;
  nId?: InputMaybe<Scalars['BigInt']>;
  nLock?: InputMaybe<Scalars['Boolean']>;
  nMaxPocetHod?: InputMaybe<Scalars['Int']>;
  nOd?: InputMaybe<Scalars['Date']>;
  nPocetHod?: InputMaybe<Scalars['Int']>;
  nTimestamp?: InputMaybe<Scalars['Datetime']>;
  nTrener?: InputMaybe<Scalars['BigInt']>;
  nVisible?: InputMaybe<Scalars['Boolean']>;
};

/** A connection to a list of `Nabidka` values. */
export type NabidkasConnection = {
  __typename?: 'NabidkasConnection';
  /** A list of edges which contains the `Nabidka` and cursor to aid in pagination. */
  edges: Array<NabidkasEdge>;
  /** A list of `Nabidka` objects. */
  nodes: Array<Nabidka>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Nabidka` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Nabidka` edge in the connection. */
export type NabidkasEdge = {
  __typename?: 'NabidkasEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Nabidka` at the end of the edge. */
  node: Nabidka;
};

/** Methods to use when ordering `Nabidka`. */
export type NabidkasOrderBy =
  | 'NABIDKA_ITEMS_BY_NI_ID_RODIC__COUNT_ASC'
  | 'NABIDKA_ITEMS_BY_NI_ID_RODIC__COUNT_DESC'
  | 'NATURAL'
  | 'N_DO_ASC'
  | 'N_DO_DESC'
  | 'N_ID_ASC'
  | 'N_ID_DESC'
  | 'N_LOCK_ASC'
  | 'N_LOCK_DESC'
  | 'N_MAX_POCET_HOD_ASC'
  | 'N_MAX_POCET_HOD_DESC'
  | 'N_OD_ASC'
  | 'N_OD_DESC'
  | 'N_POCET_HOD_ASC'
  | 'N_POCET_HOD_DESC'
  | 'N_TIMESTAMP_ASC'
  | 'N_TIMESTAMP_DESC'
  | 'N_TRENER_ASC'
  | 'N_TRENER_DESC'
  | 'N_VISIBLE_ASC'
  | 'N_VISIBLE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'USER_BY_N_TRENER__U_BAN_ASC'
  | 'USER_BY_N_TRENER__U_BAN_DESC'
  | 'USER_BY_N_TRENER__U_CITY_ASC'
  | 'USER_BY_N_TRENER__U_CITY_DESC'
  | 'USER_BY_N_TRENER__U_CONFIRMED_ASC'
  | 'USER_BY_N_TRENER__U_CONFIRMED_DESC'
  | 'USER_BY_N_TRENER__U_CONSCRIPTION_NUMBER_ASC'
  | 'USER_BY_N_TRENER__U_CONSCRIPTION_NUMBER_DESC'
  | 'USER_BY_N_TRENER__U_CREATED_AT_ASC'
  | 'USER_BY_N_TRENER__U_CREATED_AT_DESC'
  | 'USER_BY_N_TRENER__U_DANCER_ASC'
  | 'USER_BY_N_TRENER__U_DANCER_DESC'
  | 'USER_BY_N_TRENER__U_DISTRICT_ASC'
  | 'USER_BY_N_TRENER__U_DISTRICT_DESC'
  | 'USER_BY_N_TRENER__U_EMAIL_ASC'
  | 'USER_BY_N_TRENER__U_EMAIL_DESC'
  | 'USER_BY_N_TRENER__U_GDPR_SIGNED_AT_ASC'
  | 'USER_BY_N_TRENER__U_GDPR_SIGNED_AT_DESC'
  | 'USER_BY_N_TRENER__U_GROUP_ASC'
  | 'USER_BY_N_TRENER__U_GROUP_DESC'
  | 'USER_BY_N_TRENER__U_ID_ASC'
  | 'USER_BY_N_TRENER__U_ID_DESC'
  | 'USER_BY_N_TRENER__U_JMENO_ASC'
  | 'USER_BY_N_TRENER__U_JMENO_DESC'
  | 'USER_BY_N_TRENER__U_LEVEL_ASC'
  | 'USER_BY_N_TRENER__U_LEVEL_DESC'
  | 'USER_BY_N_TRENER__U_LOCK_ASC'
  | 'USER_BY_N_TRENER__U_LOCK_DESC'
  | 'USER_BY_N_TRENER__U_LOGIN_ASC'
  | 'USER_BY_N_TRENER__U_LOGIN_DESC'
  | 'USER_BY_N_TRENER__U_MEMBER_SINCE_ASC'
  | 'USER_BY_N_TRENER__U_MEMBER_SINCE_DESC'
  | 'USER_BY_N_TRENER__U_MEMBER_UNTIL_ASC'
  | 'USER_BY_N_TRENER__U_MEMBER_UNTIL_DESC'
  | 'USER_BY_N_TRENER__U_NAROZENI_ASC'
  | 'USER_BY_N_TRENER__U_NAROZENI_DESC'
  | 'USER_BY_N_TRENER__U_NATIONALITY_ASC'
  | 'USER_BY_N_TRENER__U_NATIONALITY_DESC'
  | 'USER_BY_N_TRENER__U_ORIENTATION_NUMBER_ASC'
  | 'USER_BY_N_TRENER__U_ORIENTATION_NUMBER_DESC'
  | 'USER_BY_N_TRENER__U_PASS_ASC'
  | 'USER_BY_N_TRENER__U_PASS_DESC'
  | 'USER_BY_N_TRENER__U_POHLAVI_ASC'
  | 'USER_BY_N_TRENER__U_POHLAVI_DESC'
  | 'USER_BY_N_TRENER__U_POSTAL_CODE_ASC'
  | 'USER_BY_N_TRENER__U_POSTAL_CODE_DESC'
  | 'USER_BY_N_TRENER__U_POZNAMKY_ASC'
  | 'USER_BY_N_TRENER__U_POZNAMKY_DESC'
  | 'USER_BY_N_TRENER__U_PRIJMENI_ASC'
  | 'USER_BY_N_TRENER__U_PRIJMENI_DESC'
  | 'USER_BY_N_TRENER__U_RODNE_CISLO_ASC'
  | 'USER_BY_N_TRENER__U_RODNE_CISLO_DESC'
  | 'USER_BY_N_TRENER__U_SKUPINA_ASC'
  | 'USER_BY_N_TRENER__U_SKUPINA_DESC'
  | 'USER_BY_N_TRENER__U_STREET_ASC'
  | 'USER_BY_N_TRENER__U_STREET_DESC'
  | 'USER_BY_N_TRENER__U_SYSTEM_ASC'
  | 'USER_BY_N_TRENER__U_SYSTEM_DESC'
  | 'USER_BY_N_TRENER__U_TEACHER_ASC'
  | 'USER_BY_N_TRENER__U_TEACHER_DESC'
  | 'USER_BY_N_TRENER__U_TELEFON_ASC'
  | 'USER_BY_N_TRENER__U_TELEFON_DESC'
  | 'USER_BY_N_TRENER__U_TIMESTAMP_ASC'
  | 'USER_BY_N_TRENER__U_TIMESTAMP_DESC';

/** An object with a globally unique `ID`. */
export type Node = {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
};

export type Page = Node & {
  __typename?: 'Page';
  content: Scalars['JSON'];
  createdAt: Scalars['Datetime'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  title: Scalars['String'];
  updatedAt: Scalars['Datetime'];
  url: Scalars['String'];
};

/** A condition to be used against `Page` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PageCondition = {
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `url` field. */
  url?: InputMaybe<Scalars['String']>;
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor: Maybe<Scalars['Cursor']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor: Maybe<Scalars['Cursor']>;
};

/** An input for mutations affecting `Page` */
export type PageInput = {
  content: Scalars['JSON'];
  createdAt?: InputMaybe<Scalars['Datetime']>;
  id?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['Datetime']>;
  url: Scalars['String'];
};

/** Represents an update to a `Page`. Fields that are set will be updated. */
export type PagePatch = {
  content?: InputMaybe<Scalars['JSON']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  id?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['Datetime']>;
  url?: InputMaybe<Scalars['String']>;
};

export type PageRevision = Node & {
  __typename?: 'PageRevision';
  content: Scalars['JSON'];
  createdAt: Scalars['Datetime'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  revNumber: Scalars['Int'];
  revOperation: Scalars['String'];
  revTimestamp: Maybe<Scalars['Datetime']>;
  title: Scalars['String'];
  updatedAt: Scalars['Datetime'];
  url: Scalars['String'];
};

/**
 * A condition to be used against `PageRevision` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PageRevisionCondition = {
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `revNumber` field. */
  revNumber?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `revOperation` field. */
  revOperation?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `revTimestamp` field. */
  revTimestamp?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `url` field. */
  url?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `PageRevision` values. */
export type PageRevisionsConnection = {
  __typename?: 'PageRevisionsConnection';
  /** A list of edges which contains the `PageRevision` and cursor to aid in pagination. */
  edges: Array<PageRevisionsEdge>;
  /** A list of `PageRevision` objects. */
  nodes: Array<PageRevision>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PageRevision` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PageRevision` edge in the connection. */
export type PageRevisionsEdge = {
  __typename?: 'PageRevisionsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `PageRevision` at the end of the edge. */
  node: PageRevision;
};

/** Methods to use when ordering `PageRevision`. */
export type PageRevisionsOrderBy =
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'REV_NUMBER_ASC'
  | 'REV_NUMBER_DESC'
  | 'REV_OPERATION_ASC'
  | 'REV_OPERATION_DESC'
  | 'REV_TIMESTAMP_ASC'
  | 'REV_TIMESTAMP_DESC'
  | 'TITLE_ASC'
  | 'TITLE_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC'
  | 'URL_ASC'
  | 'URL_DESC';

/** A connection to a list of `Page` values. */
export type PagesConnection = {
  __typename?: 'PagesConnection';
  /** A list of edges which contains the `Page` and cursor to aid in pagination. */
  edges: Array<PagesEdge>;
  /** A list of `Page` objects. */
  nodes: Array<Page>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Page` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Page` edge in the connection. */
export type PagesEdge = {
  __typename?: 'PagesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Page` at the end of the edge. */
  node: Page;
};

/** Methods to use when ordering `Page`. */
export type PagesOrderBy =
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TITLE_ASC'
  | 'TITLE_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC'
  | 'URL_ASC'
  | 'URL_DESC';

export type Parameter = Node & {
  __typename?: 'Parameter';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  paName: Scalars['String'];
  paValue: Scalars['String'];
};

/**
 * A condition to be used against `Parameter` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ParameterCondition = {
  /** Checks for equality with the object’s `paName` field. */
  paName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `paValue` field. */
  paValue?: InputMaybe<Scalars['String']>;
};

/** An input for mutations affecting `Parameter` */
export type ParameterInput = {
  paName: Scalars['String'];
  paValue: Scalars['String'];
};

/** Represents an update to a `Parameter`. Fields that are set will be updated. */
export type ParameterPatch = {
  paName?: InputMaybe<Scalars['String']>;
  paValue?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Parameter` values. */
export type ParametersConnection = {
  __typename?: 'ParametersConnection';
  /** A list of edges which contains the `Parameter` and cursor to aid in pagination. */
  edges: Array<ParametersEdge>;
  /** A list of `Parameter` objects. */
  nodes: Array<Parameter>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Parameter` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Parameter` edge in the connection. */
export type ParametersEdge = {
  __typename?: 'ParametersEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Parameter` at the end of the edge. */
  node: Parameter;
};

/** Methods to use when ordering `Parameter`. */
export type ParametersOrderBy =
  | 'NATURAL'
  | 'PA_NAME_ASC'
  | 'PA_NAME_DESC'
  | 'PA_VALUE_ASC'
  | 'PA_VALUE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A connection to a list of `Pary` values. */
export type PariesConnection = {
  __typename?: 'PariesConnection';
  /** A list of edges which contains the `Pary` and cursor to aid in pagination. */
  edges: Array<PariesEdge>;
  /** A list of `Pary` objects. */
  nodes: Array<Pary>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Pary` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Pary` edge in the connection. */
export type PariesEdge = {
  __typename?: 'PariesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Pary` at the end of the edge. */
  node: Pary;
};

/** Methods to use when ordering `Pary`. */
export type PariesOrderBy =
  | 'NABIDKA_ITEMS_BY_NI_PARTNER__COUNT_ASC'
  | 'NABIDKA_ITEMS_BY_NI_PARTNER__COUNT_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'P_ARCHIV_ASC'
  | 'P_ARCHIV_DESC'
  | 'P_HODNOCENI_ASC'
  | 'P_HODNOCENI_DESC'
  | 'P_ID_ASC'
  | 'P_ID_DESC'
  | 'P_ID_PARTNERKA_ASC'
  | 'P_ID_PARTNERKA_DESC'
  | 'P_ID_PARTNER_ASC'
  | 'P_ID_PARTNER_DESC'
  | 'P_LAT_BODY_ASC'
  | 'P_LAT_BODY_DESC'
  | 'P_LAT_FINALE_ASC'
  | 'P_LAT_FINALE_DESC'
  | 'P_LAT_TRIDA_ASC'
  | 'P_LAT_TRIDA_DESC'
  | 'P_STT_BODY_ASC'
  | 'P_STT_BODY_DESC'
  | 'P_STT_FINALE_ASC'
  | 'P_STT_FINALE_DESC'
  | 'P_STT_TRIDA_ASC'
  | 'P_STT_TRIDA_DESC'
  | 'P_TIMESTAMP_ADD_ASC'
  | 'P_TIMESTAMP_ADD_DESC'
  | 'P_TIMESTAMP_ARCHIVE_ASC'
  | 'P_TIMESTAMP_ARCHIVE_DESC'
  | 'ROZPIS_ITEMS_BY_RI_PARTNER__COUNT_ASC'
  | 'ROZPIS_ITEMS_BY_RI_PARTNER__COUNT_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_BAN_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_BAN_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_CITY_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_CITY_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_CONFIRMED_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_CONFIRMED_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_CONSCRIPTION_NUMBER_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_CONSCRIPTION_NUMBER_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_CREATED_AT_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_CREATED_AT_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_DANCER_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_DANCER_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_DISTRICT_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_DISTRICT_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_EMAIL_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_EMAIL_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_GDPR_SIGNED_AT_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_GDPR_SIGNED_AT_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_GROUP_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_GROUP_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_ID_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_ID_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_JMENO_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_JMENO_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_LEVEL_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_LEVEL_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_LOCK_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_LOCK_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_LOGIN_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_LOGIN_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_MEMBER_SINCE_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_MEMBER_SINCE_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_MEMBER_UNTIL_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_MEMBER_UNTIL_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_NAROZENI_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_NAROZENI_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_NATIONALITY_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_NATIONALITY_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_ORIENTATION_NUMBER_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_ORIENTATION_NUMBER_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_PASS_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_PASS_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_POHLAVI_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_POHLAVI_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_POSTAL_CODE_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_POSTAL_CODE_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_POZNAMKY_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_POZNAMKY_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_PRIJMENI_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_PRIJMENI_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_RODNE_CISLO_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_RODNE_CISLO_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_SKUPINA_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_SKUPINA_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_STREET_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_STREET_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_SYSTEM_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_SYSTEM_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_TEACHER_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_TEACHER_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_TELEFON_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_TELEFON_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_TIMESTAMP_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_TIMESTAMP_DESC'
  | 'USER_BY_P_ID_PARTNER__U_BAN_ASC'
  | 'USER_BY_P_ID_PARTNER__U_BAN_DESC'
  | 'USER_BY_P_ID_PARTNER__U_CITY_ASC'
  | 'USER_BY_P_ID_PARTNER__U_CITY_DESC'
  | 'USER_BY_P_ID_PARTNER__U_CONFIRMED_ASC'
  | 'USER_BY_P_ID_PARTNER__U_CONFIRMED_DESC'
  | 'USER_BY_P_ID_PARTNER__U_CONSCRIPTION_NUMBER_ASC'
  | 'USER_BY_P_ID_PARTNER__U_CONSCRIPTION_NUMBER_DESC'
  | 'USER_BY_P_ID_PARTNER__U_CREATED_AT_ASC'
  | 'USER_BY_P_ID_PARTNER__U_CREATED_AT_DESC'
  | 'USER_BY_P_ID_PARTNER__U_DANCER_ASC'
  | 'USER_BY_P_ID_PARTNER__U_DANCER_DESC'
  | 'USER_BY_P_ID_PARTNER__U_DISTRICT_ASC'
  | 'USER_BY_P_ID_PARTNER__U_DISTRICT_DESC'
  | 'USER_BY_P_ID_PARTNER__U_EMAIL_ASC'
  | 'USER_BY_P_ID_PARTNER__U_EMAIL_DESC'
  | 'USER_BY_P_ID_PARTNER__U_GDPR_SIGNED_AT_ASC'
  | 'USER_BY_P_ID_PARTNER__U_GDPR_SIGNED_AT_DESC'
  | 'USER_BY_P_ID_PARTNER__U_GROUP_ASC'
  | 'USER_BY_P_ID_PARTNER__U_GROUP_DESC'
  | 'USER_BY_P_ID_PARTNER__U_ID_ASC'
  | 'USER_BY_P_ID_PARTNER__U_ID_DESC'
  | 'USER_BY_P_ID_PARTNER__U_JMENO_ASC'
  | 'USER_BY_P_ID_PARTNER__U_JMENO_DESC'
  | 'USER_BY_P_ID_PARTNER__U_LEVEL_ASC'
  | 'USER_BY_P_ID_PARTNER__U_LEVEL_DESC'
  | 'USER_BY_P_ID_PARTNER__U_LOCK_ASC'
  | 'USER_BY_P_ID_PARTNER__U_LOCK_DESC'
  | 'USER_BY_P_ID_PARTNER__U_LOGIN_ASC'
  | 'USER_BY_P_ID_PARTNER__U_LOGIN_DESC'
  | 'USER_BY_P_ID_PARTNER__U_MEMBER_SINCE_ASC'
  | 'USER_BY_P_ID_PARTNER__U_MEMBER_SINCE_DESC'
  | 'USER_BY_P_ID_PARTNER__U_MEMBER_UNTIL_ASC'
  | 'USER_BY_P_ID_PARTNER__U_MEMBER_UNTIL_DESC'
  | 'USER_BY_P_ID_PARTNER__U_NAROZENI_ASC'
  | 'USER_BY_P_ID_PARTNER__U_NAROZENI_DESC'
  | 'USER_BY_P_ID_PARTNER__U_NATIONALITY_ASC'
  | 'USER_BY_P_ID_PARTNER__U_NATIONALITY_DESC'
  | 'USER_BY_P_ID_PARTNER__U_ORIENTATION_NUMBER_ASC'
  | 'USER_BY_P_ID_PARTNER__U_ORIENTATION_NUMBER_DESC'
  | 'USER_BY_P_ID_PARTNER__U_PASS_ASC'
  | 'USER_BY_P_ID_PARTNER__U_PASS_DESC'
  | 'USER_BY_P_ID_PARTNER__U_POHLAVI_ASC'
  | 'USER_BY_P_ID_PARTNER__U_POHLAVI_DESC'
  | 'USER_BY_P_ID_PARTNER__U_POSTAL_CODE_ASC'
  | 'USER_BY_P_ID_PARTNER__U_POSTAL_CODE_DESC'
  | 'USER_BY_P_ID_PARTNER__U_POZNAMKY_ASC'
  | 'USER_BY_P_ID_PARTNER__U_POZNAMKY_DESC'
  | 'USER_BY_P_ID_PARTNER__U_PRIJMENI_ASC'
  | 'USER_BY_P_ID_PARTNER__U_PRIJMENI_DESC'
  | 'USER_BY_P_ID_PARTNER__U_RODNE_CISLO_ASC'
  | 'USER_BY_P_ID_PARTNER__U_RODNE_CISLO_DESC'
  | 'USER_BY_P_ID_PARTNER__U_SKUPINA_ASC'
  | 'USER_BY_P_ID_PARTNER__U_SKUPINA_DESC'
  | 'USER_BY_P_ID_PARTNER__U_STREET_ASC'
  | 'USER_BY_P_ID_PARTNER__U_STREET_DESC'
  | 'USER_BY_P_ID_PARTNER__U_SYSTEM_ASC'
  | 'USER_BY_P_ID_PARTNER__U_SYSTEM_DESC'
  | 'USER_BY_P_ID_PARTNER__U_TEACHER_ASC'
  | 'USER_BY_P_ID_PARTNER__U_TEACHER_DESC'
  | 'USER_BY_P_ID_PARTNER__U_TELEFON_ASC'
  | 'USER_BY_P_ID_PARTNER__U_TELEFON_DESC'
  | 'USER_BY_P_ID_PARTNER__U_TIMESTAMP_ASC'
  | 'USER_BY_P_ID_PARTNER__U_TIMESTAMP_DESC';

export type Pary = Node & {
  __typename?: 'Pary';
  /** Reads and enables pagination through a set of `NabidkaItem`. */
  nabidkaItemsByNiPartner: NabidkaItemsConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  pArchiv: Scalars['Boolean'];
  pHodnoceni: Scalars['Int'];
  pId: Scalars['BigInt'];
  pIdPartner: Scalars['BigInt'];
  pIdPartnerka: Maybe<Scalars['BigInt']>;
  pLatBody: Scalars['Int'];
  pLatFinale: Scalars['Boolean'];
  pLatTrida: ParyPLatTrida;
  pSttBody: Scalars['Int'];
  pSttFinale: Scalars['Boolean'];
  pSttTrida: ParyPSttTrida;
  pTimestampAdd: Scalars['Datetime'];
  pTimestampArchive: Maybe<Scalars['Datetime']>;
  /** Reads and enables pagination through a set of `RozpisItem`. */
  rozpisItemsByRiPartner: RozpisItemsConnection;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartnerka: Maybe<User>;
};


export type ParyNabidkaItemsByNiPartnerArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<NabidkaItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<NabidkaItemsOrderBy>>;
};


export type ParyRozpisItemsByRiPartnerArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<RozpisItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RozpisItemsOrderBy>>;
};

/** A condition to be used against `Pary` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ParyCondition = {
  /** Checks for equality with the object’s `pArchiv` field. */
  pArchiv?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `pHodnoceni` field. */
  pHodnoceni?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `pId` field. */
  pId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pIdPartner` field. */
  pIdPartner?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pIdPartnerka` field. */
  pIdPartnerka?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pLatBody` field. */
  pLatBody?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `pLatFinale` field. */
  pLatFinale?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `pLatTrida` field. */
  pLatTrida?: InputMaybe<ParyPLatTrida>;
  /** Checks for equality with the object’s `pSttBody` field. */
  pSttBody?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `pSttFinale` field. */
  pSttFinale?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `pSttTrida` field. */
  pSttTrida?: InputMaybe<ParyPSttTrida>;
  /** Checks for equality with the object’s `pTimestampAdd` field. */
  pTimestampAdd?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `pTimestampArchive` field. */
  pTimestampArchive?: InputMaybe<Scalars['Datetime']>;
};

/** An input for mutations affecting `Pary` */
export type ParyInput = {
  pArchiv?: InputMaybe<Scalars['Boolean']>;
  pHodnoceni?: InputMaybe<Scalars['Int']>;
  pId?: InputMaybe<Scalars['BigInt']>;
  pIdPartner: Scalars['BigInt'];
  pIdPartnerka?: InputMaybe<Scalars['BigInt']>;
  pLatBody?: InputMaybe<Scalars['Int']>;
  pLatFinale?: InputMaybe<Scalars['Boolean']>;
  pLatTrida?: InputMaybe<ParyPLatTrida>;
  pSttBody?: InputMaybe<Scalars['Int']>;
  pSttFinale?: InputMaybe<Scalars['Boolean']>;
  pSttTrida?: InputMaybe<ParyPSttTrida>;
  pTimestampAdd?: InputMaybe<Scalars['Datetime']>;
  pTimestampArchive?: InputMaybe<Scalars['Datetime']>;
};

export type ParyNavrh = Node & {
  __typename?: 'ParyNavrh';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  pnId: Scalars['BigInt'];
  pnNavrhl: Scalars['BigInt'];
  pnPartner: Scalars['BigInt'];
  pnPartnerka: Scalars['BigInt'];
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnNavrhl: Maybe<User>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnPartnerka: Maybe<User>;
};

/**
 * A condition to be used against `ParyNavrh` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ParyNavrhCondition = {
  /** Checks for equality with the object’s `pnId` field. */
  pnId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pnNavrhl` field. */
  pnNavrhl?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pnPartner` field. */
  pnPartner?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pnPartnerka` field. */
  pnPartnerka?: InputMaybe<Scalars['BigInt']>;
};

/** An input for mutations affecting `ParyNavrh` */
export type ParyNavrhInput = {
  pnId?: InputMaybe<Scalars['BigInt']>;
  pnNavrhl: Scalars['BigInt'];
  pnPartner: Scalars['BigInt'];
  pnPartnerka: Scalars['BigInt'];
};

/** Represents an update to a `ParyNavrh`. Fields that are set will be updated. */
export type ParyNavrhPatch = {
  pnId?: InputMaybe<Scalars['BigInt']>;
  pnNavrhl?: InputMaybe<Scalars['BigInt']>;
  pnPartner?: InputMaybe<Scalars['BigInt']>;
  pnPartnerka?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `ParyNavrh` values. */
export type ParyNavrhsConnection = {
  __typename?: 'ParyNavrhsConnection';
  /** A list of edges which contains the `ParyNavrh` and cursor to aid in pagination. */
  edges: Array<ParyNavrhsEdge>;
  /** A list of `ParyNavrh` objects. */
  nodes: Array<ParyNavrh>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ParyNavrh` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ParyNavrh` edge in the connection. */
export type ParyNavrhsEdge = {
  __typename?: 'ParyNavrhsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `ParyNavrh` at the end of the edge. */
  node: ParyNavrh;
};

/** Methods to use when ordering `ParyNavrh`. */
export type ParyNavrhsOrderBy =
  | 'NATURAL'
  | 'PN_ID_ASC'
  | 'PN_ID_DESC'
  | 'PN_NAVRHL_ASC'
  | 'PN_NAVRHL_DESC'
  | 'PN_PARTNERKA_ASC'
  | 'PN_PARTNERKA_DESC'
  | 'PN_PARTNER_ASC'
  | 'PN_PARTNER_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'USER_BY_PN_NAVRHL__U_BAN_ASC'
  | 'USER_BY_PN_NAVRHL__U_BAN_DESC'
  | 'USER_BY_PN_NAVRHL__U_CITY_ASC'
  | 'USER_BY_PN_NAVRHL__U_CITY_DESC'
  | 'USER_BY_PN_NAVRHL__U_CONFIRMED_ASC'
  | 'USER_BY_PN_NAVRHL__U_CONFIRMED_DESC'
  | 'USER_BY_PN_NAVRHL__U_CONSCRIPTION_NUMBER_ASC'
  | 'USER_BY_PN_NAVRHL__U_CONSCRIPTION_NUMBER_DESC'
  | 'USER_BY_PN_NAVRHL__U_CREATED_AT_ASC'
  | 'USER_BY_PN_NAVRHL__U_CREATED_AT_DESC'
  | 'USER_BY_PN_NAVRHL__U_DANCER_ASC'
  | 'USER_BY_PN_NAVRHL__U_DANCER_DESC'
  | 'USER_BY_PN_NAVRHL__U_DISTRICT_ASC'
  | 'USER_BY_PN_NAVRHL__U_DISTRICT_DESC'
  | 'USER_BY_PN_NAVRHL__U_EMAIL_ASC'
  | 'USER_BY_PN_NAVRHL__U_EMAIL_DESC'
  | 'USER_BY_PN_NAVRHL__U_GDPR_SIGNED_AT_ASC'
  | 'USER_BY_PN_NAVRHL__U_GDPR_SIGNED_AT_DESC'
  | 'USER_BY_PN_NAVRHL__U_GROUP_ASC'
  | 'USER_BY_PN_NAVRHL__U_GROUP_DESC'
  | 'USER_BY_PN_NAVRHL__U_ID_ASC'
  | 'USER_BY_PN_NAVRHL__U_ID_DESC'
  | 'USER_BY_PN_NAVRHL__U_JMENO_ASC'
  | 'USER_BY_PN_NAVRHL__U_JMENO_DESC'
  | 'USER_BY_PN_NAVRHL__U_LEVEL_ASC'
  | 'USER_BY_PN_NAVRHL__U_LEVEL_DESC'
  | 'USER_BY_PN_NAVRHL__U_LOCK_ASC'
  | 'USER_BY_PN_NAVRHL__U_LOCK_DESC'
  | 'USER_BY_PN_NAVRHL__U_LOGIN_ASC'
  | 'USER_BY_PN_NAVRHL__U_LOGIN_DESC'
  | 'USER_BY_PN_NAVRHL__U_MEMBER_SINCE_ASC'
  | 'USER_BY_PN_NAVRHL__U_MEMBER_SINCE_DESC'
  | 'USER_BY_PN_NAVRHL__U_MEMBER_UNTIL_ASC'
  | 'USER_BY_PN_NAVRHL__U_MEMBER_UNTIL_DESC'
  | 'USER_BY_PN_NAVRHL__U_NAROZENI_ASC'
  | 'USER_BY_PN_NAVRHL__U_NAROZENI_DESC'
  | 'USER_BY_PN_NAVRHL__U_NATIONALITY_ASC'
  | 'USER_BY_PN_NAVRHL__U_NATIONALITY_DESC'
  | 'USER_BY_PN_NAVRHL__U_ORIENTATION_NUMBER_ASC'
  | 'USER_BY_PN_NAVRHL__U_ORIENTATION_NUMBER_DESC'
  | 'USER_BY_PN_NAVRHL__U_PASS_ASC'
  | 'USER_BY_PN_NAVRHL__U_PASS_DESC'
  | 'USER_BY_PN_NAVRHL__U_POHLAVI_ASC'
  | 'USER_BY_PN_NAVRHL__U_POHLAVI_DESC'
  | 'USER_BY_PN_NAVRHL__U_POSTAL_CODE_ASC'
  | 'USER_BY_PN_NAVRHL__U_POSTAL_CODE_DESC'
  | 'USER_BY_PN_NAVRHL__U_POZNAMKY_ASC'
  | 'USER_BY_PN_NAVRHL__U_POZNAMKY_DESC'
  | 'USER_BY_PN_NAVRHL__U_PRIJMENI_ASC'
  | 'USER_BY_PN_NAVRHL__U_PRIJMENI_DESC'
  | 'USER_BY_PN_NAVRHL__U_RODNE_CISLO_ASC'
  | 'USER_BY_PN_NAVRHL__U_RODNE_CISLO_DESC'
  | 'USER_BY_PN_NAVRHL__U_SKUPINA_ASC'
  | 'USER_BY_PN_NAVRHL__U_SKUPINA_DESC'
  | 'USER_BY_PN_NAVRHL__U_STREET_ASC'
  | 'USER_BY_PN_NAVRHL__U_STREET_DESC'
  | 'USER_BY_PN_NAVRHL__U_SYSTEM_ASC'
  | 'USER_BY_PN_NAVRHL__U_SYSTEM_DESC'
  | 'USER_BY_PN_NAVRHL__U_TEACHER_ASC'
  | 'USER_BY_PN_NAVRHL__U_TEACHER_DESC'
  | 'USER_BY_PN_NAVRHL__U_TELEFON_ASC'
  | 'USER_BY_PN_NAVRHL__U_TELEFON_DESC'
  | 'USER_BY_PN_NAVRHL__U_TIMESTAMP_ASC'
  | 'USER_BY_PN_NAVRHL__U_TIMESTAMP_DESC'
  | 'USER_BY_PN_PARTNERKA__U_BAN_ASC'
  | 'USER_BY_PN_PARTNERKA__U_BAN_DESC'
  | 'USER_BY_PN_PARTNERKA__U_CITY_ASC'
  | 'USER_BY_PN_PARTNERKA__U_CITY_DESC'
  | 'USER_BY_PN_PARTNERKA__U_CONFIRMED_ASC'
  | 'USER_BY_PN_PARTNERKA__U_CONFIRMED_DESC'
  | 'USER_BY_PN_PARTNERKA__U_CONSCRIPTION_NUMBER_ASC'
  | 'USER_BY_PN_PARTNERKA__U_CONSCRIPTION_NUMBER_DESC'
  | 'USER_BY_PN_PARTNERKA__U_CREATED_AT_ASC'
  | 'USER_BY_PN_PARTNERKA__U_CREATED_AT_DESC'
  | 'USER_BY_PN_PARTNERKA__U_DANCER_ASC'
  | 'USER_BY_PN_PARTNERKA__U_DANCER_DESC'
  | 'USER_BY_PN_PARTNERKA__U_DISTRICT_ASC'
  | 'USER_BY_PN_PARTNERKA__U_DISTRICT_DESC'
  | 'USER_BY_PN_PARTNERKA__U_EMAIL_ASC'
  | 'USER_BY_PN_PARTNERKA__U_EMAIL_DESC'
  | 'USER_BY_PN_PARTNERKA__U_GDPR_SIGNED_AT_ASC'
  | 'USER_BY_PN_PARTNERKA__U_GDPR_SIGNED_AT_DESC'
  | 'USER_BY_PN_PARTNERKA__U_GROUP_ASC'
  | 'USER_BY_PN_PARTNERKA__U_GROUP_DESC'
  | 'USER_BY_PN_PARTNERKA__U_ID_ASC'
  | 'USER_BY_PN_PARTNERKA__U_ID_DESC'
  | 'USER_BY_PN_PARTNERKA__U_JMENO_ASC'
  | 'USER_BY_PN_PARTNERKA__U_JMENO_DESC'
  | 'USER_BY_PN_PARTNERKA__U_LEVEL_ASC'
  | 'USER_BY_PN_PARTNERKA__U_LEVEL_DESC'
  | 'USER_BY_PN_PARTNERKA__U_LOCK_ASC'
  | 'USER_BY_PN_PARTNERKA__U_LOCK_DESC'
  | 'USER_BY_PN_PARTNERKA__U_LOGIN_ASC'
  | 'USER_BY_PN_PARTNERKA__U_LOGIN_DESC'
  | 'USER_BY_PN_PARTNERKA__U_MEMBER_SINCE_ASC'
  | 'USER_BY_PN_PARTNERKA__U_MEMBER_SINCE_DESC'
  | 'USER_BY_PN_PARTNERKA__U_MEMBER_UNTIL_ASC'
  | 'USER_BY_PN_PARTNERKA__U_MEMBER_UNTIL_DESC'
  | 'USER_BY_PN_PARTNERKA__U_NAROZENI_ASC'
  | 'USER_BY_PN_PARTNERKA__U_NAROZENI_DESC'
  | 'USER_BY_PN_PARTNERKA__U_NATIONALITY_ASC'
  | 'USER_BY_PN_PARTNERKA__U_NATIONALITY_DESC'
  | 'USER_BY_PN_PARTNERKA__U_ORIENTATION_NUMBER_ASC'
  | 'USER_BY_PN_PARTNERKA__U_ORIENTATION_NUMBER_DESC'
  | 'USER_BY_PN_PARTNERKA__U_PASS_ASC'
  | 'USER_BY_PN_PARTNERKA__U_PASS_DESC'
  | 'USER_BY_PN_PARTNERKA__U_POHLAVI_ASC'
  | 'USER_BY_PN_PARTNERKA__U_POHLAVI_DESC'
  | 'USER_BY_PN_PARTNERKA__U_POSTAL_CODE_ASC'
  | 'USER_BY_PN_PARTNERKA__U_POSTAL_CODE_DESC'
  | 'USER_BY_PN_PARTNERKA__U_POZNAMKY_ASC'
  | 'USER_BY_PN_PARTNERKA__U_POZNAMKY_DESC'
  | 'USER_BY_PN_PARTNERKA__U_PRIJMENI_ASC'
  | 'USER_BY_PN_PARTNERKA__U_PRIJMENI_DESC'
  | 'USER_BY_PN_PARTNERKA__U_RODNE_CISLO_ASC'
  | 'USER_BY_PN_PARTNERKA__U_RODNE_CISLO_DESC'
  | 'USER_BY_PN_PARTNERKA__U_SKUPINA_ASC'
  | 'USER_BY_PN_PARTNERKA__U_SKUPINA_DESC'
  | 'USER_BY_PN_PARTNERKA__U_STREET_ASC'
  | 'USER_BY_PN_PARTNERKA__U_STREET_DESC'
  | 'USER_BY_PN_PARTNERKA__U_SYSTEM_ASC'
  | 'USER_BY_PN_PARTNERKA__U_SYSTEM_DESC'
  | 'USER_BY_PN_PARTNERKA__U_TEACHER_ASC'
  | 'USER_BY_PN_PARTNERKA__U_TEACHER_DESC'
  | 'USER_BY_PN_PARTNERKA__U_TELEFON_ASC'
  | 'USER_BY_PN_PARTNERKA__U_TELEFON_DESC'
  | 'USER_BY_PN_PARTNERKA__U_TIMESTAMP_ASC'
  | 'USER_BY_PN_PARTNERKA__U_TIMESTAMP_DESC'
  | 'USER_BY_PN_PARTNER__U_BAN_ASC'
  | 'USER_BY_PN_PARTNER__U_BAN_DESC'
  | 'USER_BY_PN_PARTNER__U_CITY_ASC'
  | 'USER_BY_PN_PARTNER__U_CITY_DESC'
  | 'USER_BY_PN_PARTNER__U_CONFIRMED_ASC'
  | 'USER_BY_PN_PARTNER__U_CONFIRMED_DESC'
  | 'USER_BY_PN_PARTNER__U_CONSCRIPTION_NUMBER_ASC'
  | 'USER_BY_PN_PARTNER__U_CONSCRIPTION_NUMBER_DESC'
  | 'USER_BY_PN_PARTNER__U_CREATED_AT_ASC'
  | 'USER_BY_PN_PARTNER__U_CREATED_AT_DESC'
  | 'USER_BY_PN_PARTNER__U_DANCER_ASC'
  | 'USER_BY_PN_PARTNER__U_DANCER_DESC'
  | 'USER_BY_PN_PARTNER__U_DISTRICT_ASC'
  | 'USER_BY_PN_PARTNER__U_DISTRICT_DESC'
  | 'USER_BY_PN_PARTNER__U_EMAIL_ASC'
  | 'USER_BY_PN_PARTNER__U_EMAIL_DESC'
  | 'USER_BY_PN_PARTNER__U_GDPR_SIGNED_AT_ASC'
  | 'USER_BY_PN_PARTNER__U_GDPR_SIGNED_AT_DESC'
  | 'USER_BY_PN_PARTNER__U_GROUP_ASC'
  | 'USER_BY_PN_PARTNER__U_GROUP_DESC'
  | 'USER_BY_PN_PARTNER__U_ID_ASC'
  | 'USER_BY_PN_PARTNER__U_ID_DESC'
  | 'USER_BY_PN_PARTNER__U_JMENO_ASC'
  | 'USER_BY_PN_PARTNER__U_JMENO_DESC'
  | 'USER_BY_PN_PARTNER__U_LEVEL_ASC'
  | 'USER_BY_PN_PARTNER__U_LEVEL_DESC'
  | 'USER_BY_PN_PARTNER__U_LOCK_ASC'
  | 'USER_BY_PN_PARTNER__U_LOCK_DESC'
  | 'USER_BY_PN_PARTNER__U_LOGIN_ASC'
  | 'USER_BY_PN_PARTNER__U_LOGIN_DESC'
  | 'USER_BY_PN_PARTNER__U_MEMBER_SINCE_ASC'
  | 'USER_BY_PN_PARTNER__U_MEMBER_SINCE_DESC'
  | 'USER_BY_PN_PARTNER__U_MEMBER_UNTIL_ASC'
  | 'USER_BY_PN_PARTNER__U_MEMBER_UNTIL_DESC'
  | 'USER_BY_PN_PARTNER__U_NAROZENI_ASC'
  | 'USER_BY_PN_PARTNER__U_NAROZENI_DESC'
  | 'USER_BY_PN_PARTNER__U_NATIONALITY_ASC'
  | 'USER_BY_PN_PARTNER__U_NATIONALITY_DESC'
  | 'USER_BY_PN_PARTNER__U_ORIENTATION_NUMBER_ASC'
  | 'USER_BY_PN_PARTNER__U_ORIENTATION_NUMBER_DESC'
  | 'USER_BY_PN_PARTNER__U_PASS_ASC'
  | 'USER_BY_PN_PARTNER__U_PASS_DESC'
  | 'USER_BY_PN_PARTNER__U_POHLAVI_ASC'
  | 'USER_BY_PN_PARTNER__U_POHLAVI_DESC'
  | 'USER_BY_PN_PARTNER__U_POSTAL_CODE_ASC'
  | 'USER_BY_PN_PARTNER__U_POSTAL_CODE_DESC'
  | 'USER_BY_PN_PARTNER__U_POZNAMKY_ASC'
  | 'USER_BY_PN_PARTNER__U_POZNAMKY_DESC'
  | 'USER_BY_PN_PARTNER__U_PRIJMENI_ASC'
  | 'USER_BY_PN_PARTNER__U_PRIJMENI_DESC'
  | 'USER_BY_PN_PARTNER__U_RODNE_CISLO_ASC'
  | 'USER_BY_PN_PARTNER__U_RODNE_CISLO_DESC'
  | 'USER_BY_PN_PARTNER__U_SKUPINA_ASC'
  | 'USER_BY_PN_PARTNER__U_SKUPINA_DESC'
  | 'USER_BY_PN_PARTNER__U_STREET_ASC'
  | 'USER_BY_PN_PARTNER__U_STREET_DESC'
  | 'USER_BY_PN_PARTNER__U_SYSTEM_ASC'
  | 'USER_BY_PN_PARTNER__U_SYSTEM_DESC'
  | 'USER_BY_PN_PARTNER__U_TEACHER_ASC'
  | 'USER_BY_PN_PARTNER__U_TEACHER_DESC'
  | 'USER_BY_PN_PARTNER__U_TELEFON_ASC'
  | 'USER_BY_PN_PARTNER__U_TELEFON_DESC'
  | 'USER_BY_PN_PARTNER__U_TIMESTAMP_ASC'
  | 'USER_BY_PN_PARTNER__U_TIMESTAMP_DESC';

export type ParyPLatTrida =
  | 'A'
  | 'B'
  | 'C'
  | 'D'
  | 'H'
  | 'M'
  | 'Z';

export type ParyPSttTrida =
  | 'A'
  | 'B'
  | 'C'
  | 'D'
  | 'H'
  | 'M'
  | 'Z';

/** Represents an update to a `Pary`. Fields that are set will be updated. */
export type ParyPatch = {
  pArchiv?: InputMaybe<Scalars['Boolean']>;
  pHodnoceni?: InputMaybe<Scalars['Int']>;
  pId?: InputMaybe<Scalars['BigInt']>;
  pIdPartner?: InputMaybe<Scalars['BigInt']>;
  pIdPartnerka?: InputMaybe<Scalars['BigInt']>;
  pLatBody?: InputMaybe<Scalars['Int']>;
  pLatFinale?: InputMaybe<Scalars['Boolean']>;
  pLatTrida?: InputMaybe<ParyPLatTrida>;
  pSttBody?: InputMaybe<Scalars['Int']>;
  pSttFinale?: InputMaybe<Scalars['Boolean']>;
  pSttTrida?: InputMaybe<ParyPSttTrida>;
  pTimestampAdd?: InputMaybe<Scalars['Datetime']>;
  pTimestampArchive?: InputMaybe<Scalars['Datetime']>;
};

/** A connection to a list of `Person` values. */
export type PeopleConnection = {
  __typename?: 'PeopleConnection';
  /** A list of edges which contains the `Person` and cursor to aid in pagination. */
  edges: Array<PeopleEdge>;
  /** A list of `Person` objects. */
  nodes: Array<Person>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Person` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Person` edge in the connection. */
export type PeopleEdge = {
  __typename?: 'PeopleEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Person` at the end of the edge. */
  node: Person;
};

/** Methods to use when ordering `Person`. */
export type PeopleOrderBy =
  | 'FIRST_NAME_ASC'
  | 'FIRST_NAME_DESC'
  | 'GENDER_ASC'
  | 'GENDER_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'LAST_NAME_ASC'
  | 'LAST_NAME_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TENANT_PEOPLE_BY_PERSON_ID__COUNT_ASC'
  | 'TENANT_PEOPLE_BY_PERSON_ID__COUNT_DESC';

export type Permission = Node & {
  __typename?: 'Permission';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  peAkce: Scalars['Int'];
  peAktuality: Scalars['Int'];
  peAnkety: Scalars['Int'];
  peDescription: Scalars['String'];
  peDokumenty: Scalars['Int'];
  peGalerie: Scalars['Int'];
  peId: Scalars['BigInt'];
  peInzerce: Scalars['Int'];
  peKonzole: Scalars['Int'];
  peMain: Scalars['Int'];
  peNabidka: Scalars['Int'];
  peName: Scalars['String'];
  peNastenka: Scalars['Int'];
  peNovinky: Scalars['Int'];
  pePary: Scalars['Int'];
  pePermissions: Scalars['Int'];
  pePlatby: Scalars['Int'];
  peRozpis: Scalars['Int'];
  peSkupiny: Scalars['Int'];
  peUsers: Scalars['Int'];
  /** Reads and enables pagination through a set of `User`. */
  usersByUGroup: UsersConnection;
};


export type PermissionUsersByUGroupArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<UserCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/**
 * A condition to be used against `Permission` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PermissionCondition = {
  /** Checks for equality with the object’s `peAkce` field. */
  peAkce?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peAktuality` field. */
  peAktuality?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peAnkety` field. */
  peAnkety?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peDescription` field. */
  peDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `peDokumenty` field. */
  peDokumenty?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peGalerie` field. */
  peGalerie?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peId` field. */
  peId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `peInzerce` field. */
  peInzerce?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peKonzole` field. */
  peKonzole?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peMain` field. */
  peMain?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peNabidka` field. */
  peNabidka?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peName` field. */
  peName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `peNastenka` field. */
  peNastenka?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peNovinky` field. */
  peNovinky?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `pePary` field. */
  pePary?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `pePermissions` field. */
  pePermissions?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `pePlatby` field. */
  pePlatby?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peRozpis` field. */
  peRozpis?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peSkupiny` field. */
  peSkupiny?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peUsers` field. */
  peUsers?: InputMaybe<Scalars['Int']>;
};

/** An input for mutations affecting `Permission` */
export type PermissionInput = {
  peAkce: Scalars['Int'];
  peAktuality: Scalars['Int'];
  peAnkety: Scalars['Int'];
  peDescription: Scalars['String'];
  peDokumenty: Scalars['Int'];
  peGalerie: Scalars['Int'];
  peId?: InputMaybe<Scalars['BigInt']>;
  peInzerce: Scalars['Int'];
  peKonzole: Scalars['Int'];
  peMain: Scalars['Int'];
  peNabidka: Scalars['Int'];
  peName: Scalars['String'];
  peNastenka: Scalars['Int'];
  peNovinky: Scalars['Int'];
  pePary: Scalars['Int'];
  pePermissions: Scalars['Int'];
  pePlatby: Scalars['Int'];
  peRozpis: Scalars['Int'];
  peSkupiny: Scalars['Int'];
  peUsers: Scalars['Int'];
};

/** Represents an update to a `Permission`. Fields that are set will be updated. */
export type PermissionPatch = {
  peAkce?: InputMaybe<Scalars['Int']>;
  peAktuality?: InputMaybe<Scalars['Int']>;
  peAnkety?: InputMaybe<Scalars['Int']>;
  peDescription?: InputMaybe<Scalars['String']>;
  peDokumenty?: InputMaybe<Scalars['Int']>;
  peGalerie?: InputMaybe<Scalars['Int']>;
  peId?: InputMaybe<Scalars['BigInt']>;
  peInzerce?: InputMaybe<Scalars['Int']>;
  peKonzole?: InputMaybe<Scalars['Int']>;
  peMain?: InputMaybe<Scalars['Int']>;
  peNabidka?: InputMaybe<Scalars['Int']>;
  peName?: InputMaybe<Scalars['String']>;
  peNastenka?: InputMaybe<Scalars['Int']>;
  peNovinky?: InputMaybe<Scalars['Int']>;
  pePary?: InputMaybe<Scalars['Int']>;
  pePermissions?: InputMaybe<Scalars['Int']>;
  pePlatby?: InputMaybe<Scalars['Int']>;
  peRozpis?: InputMaybe<Scalars['Int']>;
  peSkupiny?: InputMaybe<Scalars['Int']>;
  peUsers?: InputMaybe<Scalars['Int']>;
};

/** A connection to a list of `Permission` values. */
export type PermissionsConnection = {
  __typename?: 'PermissionsConnection';
  /** A list of edges which contains the `Permission` and cursor to aid in pagination. */
  edges: Array<PermissionsEdge>;
  /** A list of `Permission` objects. */
  nodes: Array<Permission>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Permission` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Permission` edge in the connection. */
export type PermissionsEdge = {
  __typename?: 'PermissionsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Permission` at the end of the edge. */
  node: Permission;
};

/** Methods to use when ordering `Permission`. */
export type PermissionsOrderBy =
  | 'NATURAL'
  | 'PE_AKCE_ASC'
  | 'PE_AKCE_DESC'
  | 'PE_AKTUALITY_ASC'
  | 'PE_AKTUALITY_DESC'
  | 'PE_ANKETY_ASC'
  | 'PE_ANKETY_DESC'
  | 'PE_DESCRIPTION_ASC'
  | 'PE_DESCRIPTION_DESC'
  | 'PE_DOKUMENTY_ASC'
  | 'PE_DOKUMENTY_DESC'
  | 'PE_GALERIE_ASC'
  | 'PE_GALERIE_DESC'
  | 'PE_ID_ASC'
  | 'PE_ID_DESC'
  | 'PE_INZERCE_ASC'
  | 'PE_INZERCE_DESC'
  | 'PE_KONZOLE_ASC'
  | 'PE_KONZOLE_DESC'
  | 'PE_MAIN_ASC'
  | 'PE_MAIN_DESC'
  | 'PE_NABIDKA_ASC'
  | 'PE_NABIDKA_DESC'
  | 'PE_NAME_ASC'
  | 'PE_NAME_DESC'
  | 'PE_NASTENKA_ASC'
  | 'PE_NASTENKA_DESC'
  | 'PE_NOVINKY_ASC'
  | 'PE_NOVINKY_DESC'
  | 'PE_PARY_ASC'
  | 'PE_PARY_DESC'
  | 'PE_PERMISSIONS_ASC'
  | 'PE_PERMISSIONS_DESC'
  | 'PE_PLATBY_ASC'
  | 'PE_PLATBY_DESC'
  | 'PE_ROZPIS_ASC'
  | 'PE_ROZPIS_DESC'
  | 'PE_SKUPINY_ASC'
  | 'PE_SKUPINY_DESC'
  | 'PE_USERS_ASC'
  | 'PE_USERS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'USERS_BY_U_GROUP__COUNT_ASC'
  | 'USERS_BY_U_GROUP__COUNT_DESC';

export type Person = Node & {
  __typename?: 'Person';
  firstName: Scalars['String'];
  gender: GenderType;
  id: Scalars['BigInt'];
  lastName: Scalars['String'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads and enables pagination through a set of `TenantPerson`. */
  tenantPeople: TenantPeopleConnection;
};


export type PersonTenantPeopleArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<TenantPersonCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TenantPeopleOrderBy>>;
};

/** A condition to be used against `Person` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PersonCondition = {
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `gender` field. */
  gender?: InputMaybe<GenderType>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: InputMaybe<Scalars['String']>;
};

/** An input for mutations affecting `Person` */
export type PersonInput = {
  firstName: Scalars['String'];
  gender: GenderType;
  id?: InputMaybe<Scalars['BigInt']>;
  lastName: Scalars['String'];
};

/** Represents an update to a `Person`. Fields that are set will be updated. */
export type PersonPatch = {
  firstName?: InputMaybe<Scalars['String']>;
  gender?: InputMaybe<GenderType>;
  id?: InputMaybe<Scalars['BigInt']>;
  lastName?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `PlatbyCategory` values. */
export type PlatbyCategoriesConnection = {
  __typename?: 'PlatbyCategoriesConnection';
  /** A list of edges which contains the `PlatbyCategory` and cursor to aid in pagination. */
  edges: Array<PlatbyCategoriesEdge>;
  /** A list of `PlatbyCategory` objects. */
  nodes: Array<PlatbyCategory>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PlatbyCategory` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PlatbyCategory` edge in the connection. */
export type PlatbyCategoriesEdge = {
  __typename?: 'PlatbyCategoriesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `PlatbyCategory` at the end of the edge. */
  node: PlatbyCategory;
};

/** Methods to use when ordering `PlatbyCategory`. */
export type PlatbyCategoriesOrderBy =
  | 'NATURAL'
  | 'PC_AMOUNT_ASC'
  | 'PC_AMOUNT_DESC'
  | 'PC_ARCHIVE_ASC'
  | 'PC_ARCHIVE_DESC'
  | 'PC_DATE_DUE_ASC'
  | 'PC_DATE_DUE_DESC'
  | 'PC_ID_ASC'
  | 'PC_ID_DESC'
  | 'PC_NAME_ASC'
  | 'PC_NAME_DESC'
  | 'PC_SYMBOL_ASC'
  | 'PC_SYMBOL_DESC'
  | 'PC_USE_BASE_ASC'
  | 'PC_USE_BASE_DESC'
  | 'PC_USE_PREFIX_ASC'
  | 'PC_USE_PREFIX_DESC'
  | 'PC_VALID_FROM_ASC'
  | 'PC_VALID_FROM_DESC'
  | 'PC_VALID_TO_ASC'
  | 'PC_VALID_TO_DESC'
  | 'PC_VISIBLE_ASC'
  | 'PC_VISIBLE_DESC'
  | 'PLATBY_CATEGORY_GROUPS_BY_PCG_ID_CATEGORY__COUNT_ASC'
  | 'PLATBY_CATEGORY_GROUPS_BY_PCG_ID_CATEGORY__COUNT_DESC'
  | 'PLATBY_ITEMS_BY_PI_ID_CATEGORY__COUNT_ASC'
  | 'PLATBY_ITEMS_BY_PI_ID_CATEGORY__COUNT_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

export type PlatbyCategory = Node & {
  __typename?: 'PlatbyCategory';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  pcAmount: Scalars['BigFloat'];
  pcArchive: Scalars['Boolean'];
  pcDateDue: Scalars['Date'];
  pcId: Scalars['BigInt'];
  pcName: Scalars['String'];
  pcSymbol: Scalars['BigInt'];
  pcUseBase: Scalars['Boolean'];
  pcUsePrefix: Scalars['Boolean'];
  pcValidFrom: Scalars['Date'];
  pcValidTo: Scalars['Date'];
  pcVisible: Scalars['Boolean'];
  /** Reads and enables pagination through a set of `PlatbyCategoryGroup`. */
  platbyCategoryGroupsByPcgIdCategory: PlatbyCategoryGroupsConnection;
  /** Reads and enables pagination through a set of `PlatbyItem`. */
  platbyItemsByPiIdCategory: PlatbyItemsConnection;
};


export type PlatbyCategoryPlatbyCategoryGroupsByPcgIdCategoryArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyCategoryGroupCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyCategoryGroupsOrderBy>>;
};


export type PlatbyCategoryPlatbyItemsByPiIdCategoryArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyItemsOrderBy>>;
};

/**
 * A condition to be used against `PlatbyCategory` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PlatbyCategoryCondition = {
  /** Checks for equality with the object’s `pcAmount` field. */
  pcAmount?: InputMaybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `pcArchive` field. */
  pcArchive?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `pcDateDue` field. */
  pcDateDue?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `pcId` field. */
  pcId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pcName` field. */
  pcName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `pcSymbol` field. */
  pcSymbol?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pcUseBase` field. */
  pcUseBase?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `pcUsePrefix` field. */
  pcUsePrefix?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `pcValidFrom` field. */
  pcValidFrom?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `pcValidTo` field. */
  pcValidTo?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `pcVisible` field. */
  pcVisible?: InputMaybe<Scalars['Boolean']>;
};

export type PlatbyCategoryGroup = Node & {
  __typename?: 'PlatbyCategoryGroup';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  pcgId: Scalars['BigInt'];
  pcgIdCategory: Scalars['BigInt'];
  pcgIdGroup: Scalars['BigInt'];
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyCategoryGroup`. */
  platbyCategoryByPcgIdCategory: Maybe<PlatbyCategory>;
  /** Reads a single `PlatbyGroup` that is related to this `PlatbyCategoryGroup`. */
  platbyGroupByPcgIdGroup: Maybe<PlatbyGroup>;
};

/**
 * A condition to be used against `PlatbyCategoryGroup` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type PlatbyCategoryGroupCondition = {
  /** Checks for equality with the object’s `pcgId` field. */
  pcgId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pcgIdCategory` field. */
  pcgIdCategory?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pcgIdGroup` field. */
  pcgIdGroup?: InputMaybe<Scalars['BigInt']>;
};

/** An input for mutations affecting `PlatbyCategoryGroup` */
export type PlatbyCategoryGroupInput = {
  pcgId?: InputMaybe<Scalars['BigInt']>;
  pcgIdCategory: Scalars['BigInt'];
  pcgIdGroup: Scalars['BigInt'];
};

/** Represents an update to a `PlatbyCategoryGroup`. Fields that are set will be updated. */
export type PlatbyCategoryGroupPatch = {
  pcgId?: InputMaybe<Scalars['BigInt']>;
  pcgIdCategory?: InputMaybe<Scalars['BigInt']>;
  pcgIdGroup?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `PlatbyCategoryGroup` values. */
export type PlatbyCategoryGroupsConnection = {
  __typename?: 'PlatbyCategoryGroupsConnection';
  /** A list of edges which contains the `PlatbyCategoryGroup` and cursor to aid in pagination. */
  edges: Array<PlatbyCategoryGroupsEdge>;
  /** A list of `PlatbyCategoryGroup` objects. */
  nodes: Array<PlatbyCategoryGroup>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PlatbyCategoryGroup` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PlatbyCategoryGroup` edge in the connection. */
export type PlatbyCategoryGroupsEdge = {
  __typename?: 'PlatbyCategoryGroupsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `PlatbyCategoryGroup` at the end of the edge. */
  node: PlatbyCategoryGroup;
};

/** Methods to use when ordering `PlatbyCategoryGroup`. */
export type PlatbyCategoryGroupsOrderBy =
  | 'NATURAL'
  | 'PCG_ID_ASC'
  | 'PCG_ID_CATEGORY_ASC'
  | 'PCG_ID_CATEGORY_DESC'
  | 'PCG_ID_DESC'
  | 'PCG_ID_GROUP_ASC'
  | 'PCG_ID_GROUP_DESC'
  | 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_AMOUNT_ASC'
  | 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_AMOUNT_DESC'
  | 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_ARCHIVE_ASC'
  | 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_ARCHIVE_DESC'
  | 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_DATE_DUE_ASC'
  | 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_DATE_DUE_DESC'
  | 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_ID_ASC'
  | 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_ID_DESC'
  | 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_NAME_ASC'
  | 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_NAME_DESC'
  | 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_SYMBOL_ASC'
  | 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_SYMBOL_DESC'
  | 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_USE_BASE_ASC'
  | 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_USE_BASE_DESC'
  | 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_USE_PREFIX_ASC'
  | 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_USE_PREFIX_DESC'
  | 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_VALID_FROM_ASC'
  | 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_VALID_FROM_DESC'
  | 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_VALID_TO_ASC'
  | 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_VALID_TO_DESC'
  | 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_VISIBLE_ASC'
  | 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_VISIBLE_DESC'
  | 'PLATBY_GROUP_BY_PCG_ID_GROUP__PG_BASE_ASC'
  | 'PLATBY_GROUP_BY_PCG_ID_GROUP__PG_BASE_DESC'
  | 'PLATBY_GROUP_BY_PCG_ID_GROUP__PG_DESCRIPTION_ASC'
  | 'PLATBY_GROUP_BY_PCG_ID_GROUP__PG_DESCRIPTION_DESC'
  | 'PLATBY_GROUP_BY_PCG_ID_GROUP__PG_ID_ASC'
  | 'PLATBY_GROUP_BY_PCG_ID_GROUP__PG_ID_DESC'
  | 'PLATBY_GROUP_BY_PCG_ID_GROUP__PG_NAME_ASC'
  | 'PLATBY_GROUP_BY_PCG_ID_GROUP__PG_NAME_DESC'
  | 'PLATBY_GROUP_BY_PCG_ID_GROUP__PG_TYPE_ASC'
  | 'PLATBY_GROUP_BY_PCG_ID_GROUP__PG_TYPE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** An input for mutations affecting `PlatbyCategory` */
export type PlatbyCategoryInput = {
  pcAmount: Scalars['BigFloat'];
  pcArchive?: InputMaybe<Scalars['Boolean']>;
  pcDateDue: Scalars['Date'];
  pcId?: InputMaybe<Scalars['BigInt']>;
  pcName: Scalars['String'];
  pcSymbol: Scalars['BigInt'];
  pcUseBase?: InputMaybe<Scalars['Boolean']>;
  pcUsePrefix?: InputMaybe<Scalars['Boolean']>;
  pcValidFrom: Scalars['Date'];
  pcValidTo: Scalars['Date'];
  pcVisible?: InputMaybe<Scalars['Boolean']>;
};

/** Represents an update to a `PlatbyCategory`. Fields that are set will be updated. */
export type PlatbyCategoryPatch = {
  pcAmount?: InputMaybe<Scalars['BigFloat']>;
  pcArchive?: InputMaybe<Scalars['Boolean']>;
  pcDateDue?: InputMaybe<Scalars['Date']>;
  pcId?: InputMaybe<Scalars['BigInt']>;
  pcName?: InputMaybe<Scalars['String']>;
  pcSymbol?: InputMaybe<Scalars['BigInt']>;
  pcUseBase?: InputMaybe<Scalars['Boolean']>;
  pcUsePrefix?: InputMaybe<Scalars['Boolean']>;
  pcValidFrom?: InputMaybe<Scalars['Date']>;
  pcValidTo?: InputMaybe<Scalars['Date']>;
  pcVisible?: InputMaybe<Scalars['Boolean']>;
};

export type PlatbyGroup = Node & {
  __typename?: 'PlatbyGroup';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  pgBase: Scalars['BigInt'];
  pgDescription: Scalars['String'];
  pgId: Scalars['BigInt'];
  pgName: Scalars['String'];
  pgType: Scalars['BigFloat'];
  /** Reads and enables pagination through a set of `PlatbyCategoryGroup`. */
  platbyCategoryGroupsByPcgIdGroup: PlatbyCategoryGroupsConnection;
  /** Reads and enables pagination through a set of `PlatbyGroupSkupina`. */
  platbyGroupSkupinasByPgsIdGroup: PlatbyGroupSkupinasConnection;
};


export type PlatbyGroupPlatbyCategoryGroupsByPcgIdGroupArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyCategoryGroupCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyCategoryGroupsOrderBy>>;
};


export type PlatbyGroupPlatbyGroupSkupinasByPgsIdGroupArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyGroupSkupinaCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyGroupSkupinasOrderBy>>;
};

/**
 * A condition to be used against `PlatbyGroup` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PlatbyGroupCondition = {
  /** Checks for equality with the object’s `pgBase` field. */
  pgBase?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pgDescription` field. */
  pgDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `pgId` field. */
  pgId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pgName` field. */
  pgName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `pgType` field. */
  pgType?: InputMaybe<Scalars['BigFloat']>;
};

/** An input for mutations affecting `PlatbyGroup` */
export type PlatbyGroupInput = {
  pgBase?: InputMaybe<Scalars['BigInt']>;
  pgDescription: Scalars['String'];
  pgId?: InputMaybe<Scalars['BigInt']>;
  pgName: Scalars['String'];
  pgType?: InputMaybe<Scalars['BigFloat']>;
};

/** Represents an update to a `PlatbyGroup`. Fields that are set will be updated. */
export type PlatbyGroupPatch = {
  pgBase?: InputMaybe<Scalars['BigInt']>;
  pgDescription?: InputMaybe<Scalars['String']>;
  pgId?: InputMaybe<Scalars['BigInt']>;
  pgName?: InputMaybe<Scalars['String']>;
  pgType?: InputMaybe<Scalars['BigFloat']>;
};

export type PlatbyGroupSkupina = Node & {
  __typename?: 'PlatbyGroupSkupina';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  pgsId: Scalars['BigInt'];
  pgsIdGroup: Scalars['BigInt'];
  pgsIdSkupina: Scalars['BigInt'];
  /** Reads a single `PlatbyGroup` that is related to this `PlatbyGroupSkupina`. */
  platbyGroupByPgsIdGroup: Maybe<PlatbyGroup>;
  /** Reads a single `Skupiny` that is related to this `PlatbyGroupSkupina`. */
  skupinyByPgsIdSkupina: Maybe<Skupiny>;
};

/**
 * A condition to be used against `PlatbyGroupSkupina` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PlatbyGroupSkupinaCondition = {
  /** Checks for equality with the object’s `pgsId` field. */
  pgsId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pgsIdGroup` field. */
  pgsIdGroup?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pgsIdSkupina` field. */
  pgsIdSkupina?: InputMaybe<Scalars['BigInt']>;
};

/** An input for mutations affecting `PlatbyGroupSkupina` */
export type PlatbyGroupSkupinaInput = {
  pgsId?: InputMaybe<Scalars['BigInt']>;
  pgsIdGroup: Scalars['BigInt'];
  pgsIdSkupina: Scalars['BigInt'];
};

/** Represents an update to a `PlatbyGroupSkupina`. Fields that are set will be updated. */
export type PlatbyGroupSkupinaPatch = {
  pgsId?: InputMaybe<Scalars['BigInt']>;
  pgsIdGroup?: InputMaybe<Scalars['BigInt']>;
  pgsIdSkupina?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `PlatbyGroupSkupina` values. */
export type PlatbyGroupSkupinasConnection = {
  __typename?: 'PlatbyGroupSkupinasConnection';
  /** A list of edges which contains the `PlatbyGroupSkupina` and cursor to aid in pagination. */
  edges: Array<PlatbyGroupSkupinasEdge>;
  /** A list of `PlatbyGroupSkupina` objects. */
  nodes: Array<PlatbyGroupSkupina>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PlatbyGroupSkupina` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PlatbyGroupSkupina` edge in the connection. */
export type PlatbyGroupSkupinasEdge = {
  __typename?: 'PlatbyGroupSkupinasEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `PlatbyGroupSkupina` at the end of the edge. */
  node: PlatbyGroupSkupina;
};

/** Methods to use when ordering `PlatbyGroupSkupina`. */
export type PlatbyGroupSkupinasOrderBy =
  | 'NATURAL'
  | 'PGS_ID_ASC'
  | 'PGS_ID_DESC'
  | 'PGS_ID_GROUP_ASC'
  | 'PGS_ID_GROUP_DESC'
  | 'PGS_ID_SKUPINA_ASC'
  | 'PGS_ID_SKUPINA_DESC'
  | 'PLATBY_GROUP_BY_PGS_ID_GROUP__PG_BASE_ASC'
  | 'PLATBY_GROUP_BY_PGS_ID_GROUP__PG_BASE_DESC'
  | 'PLATBY_GROUP_BY_PGS_ID_GROUP__PG_DESCRIPTION_ASC'
  | 'PLATBY_GROUP_BY_PGS_ID_GROUP__PG_DESCRIPTION_DESC'
  | 'PLATBY_GROUP_BY_PGS_ID_GROUP__PG_ID_ASC'
  | 'PLATBY_GROUP_BY_PGS_ID_GROUP__PG_ID_DESC'
  | 'PLATBY_GROUP_BY_PGS_ID_GROUP__PG_NAME_ASC'
  | 'PLATBY_GROUP_BY_PGS_ID_GROUP__PG_NAME_DESC'
  | 'PLATBY_GROUP_BY_PGS_ID_GROUP__PG_TYPE_ASC'
  | 'PLATBY_GROUP_BY_PGS_ID_GROUP__PG_TYPE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SKUPINY_BY_PGS_ID_SKUPINA__COHORT_GROUP_ASC'
  | 'SKUPINY_BY_PGS_ID_SKUPINA__COHORT_GROUP_DESC'
  | 'SKUPINY_BY_PGS_ID_SKUPINA__INTERNAL_INFO_ASC'
  | 'SKUPINY_BY_PGS_ID_SKUPINA__INTERNAL_INFO_DESC'
  | 'SKUPINY_BY_PGS_ID_SKUPINA__ORDERING_ASC'
  | 'SKUPINY_BY_PGS_ID_SKUPINA__ORDERING_DESC'
  | 'SKUPINY_BY_PGS_ID_SKUPINA__S_COLOR_RGB_ASC'
  | 'SKUPINY_BY_PGS_ID_SKUPINA__S_COLOR_RGB_DESC'
  | 'SKUPINY_BY_PGS_ID_SKUPINA__S_COLOR_TEXT_ASC'
  | 'SKUPINY_BY_PGS_ID_SKUPINA__S_COLOR_TEXT_DESC'
  | 'SKUPINY_BY_PGS_ID_SKUPINA__S_DESCRIPTION_ASC'
  | 'SKUPINY_BY_PGS_ID_SKUPINA__S_DESCRIPTION_DESC'
  | 'SKUPINY_BY_PGS_ID_SKUPINA__S_ID_ASC'
  | 'SKUPINY_BY_PGS_ID_SKUPINA__S_ID_DESC'
  | 'SKUPINY_BY_PGS_ID_SKUPINA__S_LOCATION_ASC'
  | 'SKUPINY_BY_PGS_ID_SKUPINA__S_LOCATION_DESC'
  | 'SKUPINY_BY_PGS_ID_SKUPINA__S_NAME_ASC'
  | 'SKUPINY_BY_PGS_ID_SKUPINA__S_NAME_DESC'
  | 'SKUPINY_BY_PGS_ID_SKUPINA__S_VISIBLE_ASC'
  | 'SKUPINY_BY_PGS_ID_SKUPINA__S_VISIBLE_DESC';

/** A connection to a list of `PlatbyGroup` values. */
export type PlatbyGroupsConnection = {
  __typename?: 'PlatbyGroupsConnection';
  /** A list of edges which contains the `PlatbyGroup` and cursor to aid in pagination. */
  edges: Array<PlatbyGroupsEdge>;
  /** A list of `PlatbyGroup` objects. */
  nodes: Array<PlatbyGroup>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PlatbyGroup` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PlatbyGroup` edge in the connection. */
export type PlatbyGroupsEdge = {
  __typename?: 'PlatbyGroupsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `PlatbyGroup` at the end of the edge. */
  node: PlatbyGroup;
};

/** Methods to use when ordering `PlatbyGroup`. */
export type PlatbyGroupsOrderBy =
  | 'NATURAL'
  | 'PG_BASE_ASC'
  | 'PG_BASE_DESC'
  | 'PG_DESCRIPTION_ASC'
  | 'PG_DESCRIPTION_DESC'
  | 'PG_ID_ASC'
  | 'PG_ID_DESC'
  | 'PG_NAME_ASC'
  | 'PG_NAME_DESC'
  | 'PG_TYPE_ASC'
  | 'PG_TYPE_DESC'
  | 'PLATBY_CATEGORY_GROUPS_BY_PCG_ID_GROUP__COUNT_ASC'
  | 'PLATBY_CATEGORY_GROUPS_BY_PCG_ID_GROUP__COUNT_DESC'
  | 'PLATBY_GROUP_SKUPINAS_BY_PGS_ID_GROUP__COUNT_ASC'
  | 'PLATBY_GROUP_SKUPINAS_BY_PGS_ID_GROUP__COUNT_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

export type PlatbyItem = Node & {
  __typename?: 'PlatbyItem';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  piAmount: Scalars['BigFloat'];
  piDate: Scalars['Date'];
  piId: Scalars['BigInt'];
  piIdCategory: Scalars['BigInt'];
  piIdRaw: Maybe<Scalars['BigInt']>;
  piIdUser: Maybe<Scalars['BigInt']>;
  piPrefix: Scalars['Int'];
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
  platbyCategoryByPiIdCategory: Maybe<PlatbyCategory>;
  /** Reads a single `PlatbyRaw` that is related to this `PlatbyItem`. */
  platbyRawByPiIdRaw: Maybe<PlatbyRaw>;
  /** Reads a single `User` that is related to this `PlatbyItem`. */
  userByPiIdUser: Maybe<User>;
};

/**
 * A condition to be used against `PlatbyItem` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PlatbyItemCondition = {
  /** Checks for equality with the object’s `piAmount` field. */
  piAmount?: InputMaybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `piDate` field. */
  piDate?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `piId` field. */
  piId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `piIdCategory` field. */
  piIdCategory?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `piIdRaw` field. */
  piIdRaw?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `piIdUser` field. */
  piIdUser?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `piPrefix` field. */
  piPrefix?: InputMaybe<Scalars['Int']>;
};

/** An input for mutations affecting `PlatbyItem` */
export type PlatbyItemInput = {
  piAmount: Scalars['BigFloat'];
  piDate: Scalars['Date'];
  piId?: InputMaybe<Scalars['BigInt']>;
  piIdCategory: Scalars['BigInt'];
  piIdRaw?: InputMaybe<Scalars['BigInt']>;
  piIdUser?: InputMaybe<Scalars['BigInt']>;
  piPrefix?: InputMaybe<Scalars['Int']>;
};

/** Represents an update to a `PlatbyItem`. Fields that are set will be updated. */
export type PlatbyItemPatch = {
  piAmount?: InputMaybe<Scalars['BigFloat']>;
  piDate?: InputMaybe<Scalars['Date']>;
  piId?: InputMaybe<Scalars['BigInt']>;
  piIdCategory?: InputMaybe<Scalars['BigInt']>;
  piIdRaw?: InputMaybe<Scalars['BigInt']>;
  piIdUser?: InputMaybe<Scalars['BigInt']>;
  piPrefix?: InputMaybe<Scalars['Int']>;
};

/** A connection to a list of `PlatbyItem` values. */
export type PlatbyItemsConnection = {
  __typename?: 'PlatbyItemsConnection';
  /** A list of edges which contains the `PlatbyItem` and cursor to aid in pagination. */
  edges: Array<PlatbyItemsEdge>;
  /** A list of `PlatbyItem` objects. */
  nodes: Array<PlatbyItem>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PlatbyItem` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PlatbyItem` edge in the connection. */
export type PlatbyItemsEdge = {
  __typename?: 'PlatbyItemsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `PlatbyItem` at the end of the edge. */
  node: PlatbyItem;
};

/** Methods to use when ordering `PlatbyItem`. */
export type PlatbyItemsOrderBy =
  | 'NATURAL'
  | 'PI_AMOUNT_ASC'
  | 'PI_AMOUNT_DESC'
  | 'PI_DATE_ASC'
  | 'PI_DATE_DESC'
  | 'PI_ID_ASC'
  | 'PI_ID_CATEGORY_ASC'
  | 'PI_ID_CATEGORY_DESC'
  | 'PI_ID_DESC'
  | 'PI_ID_RAW_ASC'
  | 'PI_ID_RAW_DESC'
  | 'PI_ID_USER_ASC'
  | 'PI_ID_USER_DESC'
  | 'PI_PREFIX_ASC'
  | 'PI_PREFIX_DESC'
  | 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_AMOUNT_ASC'
  | 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_AMOUNT_DESC'
  | 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_ARCHIVE_ASC'
  | 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_ARCHIVE_DESC'
  | 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_DATE_DUE_ASC'
  | 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_DATE_DUE_DESC'
  | 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_ID_ASC'
  | 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_ID_DESC'
  | 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_NAME_ASC'
  | 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_NAME_DESC'
  | 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_SYMBOL_ASC'
  | 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_SYMBOL_DESC'
  | 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_USE_BASE_ASC'
  | 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_USE_BASE_DESC'
  | 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_USE_PREFIX_ASC'
  | 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_USE_PREFIX_DESC'
  | 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_VALID_FROM_ASC'
  | 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_VALID_FROM_DESC'
  | 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_VALID_TO_ASC'
  | 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_VALID_TO_DESC'
  | 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_VISIBLE_ASC'
  | 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_VISIBLE_DESC'
  | 'PLATBY_RAW_BY_PI_ID_RAW__PR_DISCARDED_ASC'
  | 'PLATBY_RAW_BY_PI_ID_RAW__PR_DISCARDED_DESC'
  | 'PLATBY_RAW_BY_PI_ID_RAW__PR_HASH_ASC'
  | 'PLATBY_RAW_BY_PI_ID_RAW__PR_HASH_DESC'
  | 'PLATBY_RAW_BY_PI_ID_RAW__PR_ID_ASC'
  | 'PLATBY_RAW_BY_PI_ID_RAW__PR_ID_DESC'
  | 'PLATBY_RAW_BY_PI_ID_RAW__PR_RAW_ASC'
  | 'PLATBY_RAW_BY_PI_ID_RAW__PR_RAW_DESC'
  | 'PLATBY_RAW_BY_PI_ID_RAW__PR_SORTED_ASC'
  | 'PLATBY_RAW_BY_PI_ID_RAW__PR_SORTED_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'USER_BY_PI_ID_USER__U_BAN_ASC'
  | 'USER_BY_PI_ID_USER__U_BAN_DESC'
  | 'USER_BY_PI_ID_USER__U_CITY_ASC'
  | 'USER_BY_PI_ID_USER__U_CITY_DESC'
  | 'USER_BY_PI_ID_USER__U_CONFIRMED_ASC'
  | 'USER_BY_PI_ID_USER__U_CONFIRMED_DESC'
  | 'USER_BY_PI_ID_USER__U_CONSCRIPTION_NUMBER_ASC'
  | 'USER_BY_PI_ID_USER__U_CONSCRIPTION_NUMBER_DESC'
  | 'USER_BY_PI_ID_USER__U_CREATED_AT_ASC'
  | 'USER_BY_PI_ID_USER__U_CREATED_AT_DESC'
  | 'USER_BY_PI_ID_USER__U_DANCER_ASC'
  | 'USER_BY_PI_ID_USER__U_DANCER_DESC'
  | 'USER_BY_PI_ID_USER__U_DISTRICT_ASC'
  | 'USER_BY_PI_ID_USER__U_DISTRICT_DESC'
  | 'USER_BY_PI_ID_USER__U_EMAIL_ASC'
  | 'USER_BY_PI_ID_USER__U_EMAIL_DESC'
  | 'USER_BY_PI_ID_USER__U_GDPR_SIGNED_AT_ASC'
  | 'USER_BY_PI_ID_USER__U_GDPR_SIGNED_AT_DESC'
  | 'USER_BY_PI_ID_USER__U_GROUP_ASC'
  | 'USER_BY_PI_ID_USER__U_GROUP_DESC'
  | 'USER_BY_PI_ID_USER__U_ID_ASC'
  | 'USER_BY_PI_ID_USER__U_ID_DESC'
  | 'USER_BY_PI_ID_USER__U_JMENO_ASC'
  | 'USER_BY_PI_ID_USER__U_JMENO_DESC'
  | 'USER_BY_PI_ID_USER__U_LEVEL_ASC'
  | 'USER_BY_PI_ID_USER__U_LEVEL_DESC'
  | 'USER_BY_PI_ID_USER__U_LOCK_ASC'
  | 'USER_BY_PI_ID_USER__U_LOCK_DESC'
  | 'USER_BY_PI_ID_USER__U_LOGIN_ASC'
  | 'USER_BY_PI_ID_USER__U_LOGIN_DESC'
  | 'USER_BY_PI_ID_USER__U_MEMBER_SINCE_ASC'
  | 'USER_BY_PI_ID_USER__U_MEMBER_SINCE_DESC'
  | 'USER_BY_PI_ID_USER__U_MEMBER_UNTIL_ASC'
  | 'USER_BY_PI_ID_USER__U_MEMBER_UNTIL_DESC'
  | 'USER_BY_PI_ID_USER__U_NAROZENI_ASC'
  | 'USER_BY_PI_ID_USER__U_NAROZENI_DESC'
  | 'USER_BY_PI_ID_USER__U_NATIONALITY_ASC'
  | 'USER_BY_PI_ID_USER__U_NATIONALITY_DESC'
  | 'USER_BY_PI_ID_USER__U_ORIENTATION_NUMBER_ASC'
  | 'USER_BY_PI_ID_USER__U_ORIENTATION_NUMBER_DESC'
  | 'USER_BY_PI_ID_USER__U_PASS_ASC'
  | 'USER_BY_PI_ID_USER__U_PASS_DESC'
  | 'USER_BY_PI_ID_USER__U_POHLAVI_ASC'
  | 'USER_BY_PI_ID_USER__U_POHLAVI_DESC'
  | 'USER_BY_PI_ID_USER__U_POSTAL_CODE_ASC'
  | 'USER_BY_PI_ID_USER__U_POSTAL_CODE_DESC'
  | 'USER_BY_PI_ID_USER__U_POZNAMKY_ASC'
  | 'USER_BY_PI_ID_USER__U_POZNAMKY_DESC'
  | 'USER_BY_PI_ID_USER__U_PRIJMENI_ASC'
  | 'USER_BY_PI_ID_USER__U_PRIJMENI_DESC'
  | 'USER_BY_PI_ID_USER__U_RODNE_CISLO_ASC'
  | 'USER_BY_PI_ID_USER__U_RODNE_CISLO_DESC'
  | 'USER_BY_PI_ID_USER__U_SKUPINA_ASC'
  | 'USER_BY_PI_ID_USER__U_SKUPINA_DESC'
  | 'USER_BY_PI_ID_USER__U_STREET_ASC'
  | 'USER_BY_PI_ID_USER__U_STREET_DESC'
  | 'USER_BY_PI_ID_USER__U_SYSTEM_ASC'
  | 'USER_BY_PI_ID_USER__U_SYSTEM_DESC'
  | 'USER_BY_PI_ID_USER__U_TEACHER_ASC'
  | 'USER_BY_PI_ID_USER__U_TEACHER_DESC'
  | 'USER_BY_PI_ID_USER__U_TELEFON_ASC'
  | 'USER_BY_PI_ID_USER__U_TELEFON_DESC'
  | 'USER_BY_PI_ID_USER__U_TIMESTAMP_ASC'
  | 'USER_BY_PI_ID_USER__U_TIMESTAMP_DESC';

export type PlatbyRaw = Node & {
  __typename?: 'PlatbyRaw';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads and enables pagination through a set of `PlatbyItem`. */
  platbyItemsByPiIdRaw: PlatbyItemsConnection;
  prDiscarded: Scalars['Boolean'];
  prHash: Scalars['String'];
  prId: Scalars['BigInt'];
  prRaw: Scalars['String'];
  prSorted: Scalars['Boolean'];
};


export type PlatbyRawPlatbyItemsByPiIdRawArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyItemsOrderBy>>;
};

/**
 * A condition to be used against `PlatbyRaw` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PlatbyRawCondition = {
  /** Checks for equality with the object’s `prDiscarded` field. */
  prDiscarded?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `prHash` field. */
  prHash?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `prId` field. */
  prId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `prRaw` field. */
  prRaw?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `prSorted` field. */
  prSorted?: InputMaybe<Scalars['Boolean']>;
};

/** An input for mutations affecting `PlatbyRaw` */
export type PlatbyRawInput = {
  prDiscarded?: InputMaybe<Scalars['Boolean']>;
  prHash: Scalars['String'];
  prId?: InputMaybe<Scalars['BigInt']>;
  prRaw: Scalars['String'];
  prSorted?: InputMaybe<Scalars['Boolean']>;
};

/** Represents an update to a `PlatbyRaw`. Fields that are set will be updated. */
export type PlatbyRawPatch = {
  prDiscarded?: InputMaybe<Scalars['Boolean']>;
  prHash?: InputMaybe<Scalars['String']>;
  prId?: InputMaybe<Scalars['BigInt']>;
  prRaw?: InputMaybe<Scalars['String']>;
  prSorted?: InputMaybe<Scalars['Boolean']>;
};

/** A connection to a list of `PlatbyRaw` values. */
export type PlatbyRawsConnection = {
  __typename?: 'PlatbyRawsConnection';
  /** A list of edges which contains the `PlatbyRaw` and cursor to aid in pagination. */
  edges: Array<PlatbyRawsEdge>;
  /** A list of `PlatbyRaw` objects. */
  nodes: Array<PlatbyRaw>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PlatbyRaw` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PlatbyRaw` edge in the connection. */
export type PlatbyRawsEdge = {
  __typename?: 'PlatbyRawsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `PlatbyRaw` at the end of the edge. */
  node: PlatbyRaw;
};

/** Methods to use when ordering `PlatbyRaw`. */
export type PlatbyRawsOrderBy =
  | 'NATURAL'
  | 'PLATBY_ITEMS_BY_PI_ID_RAW__COUNT_ASC'
  | 'PLATBY_ITEMS_BY_PI_ID_RAW__COUNT_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'PR_DISCARDED_ASC'
  | 'PR_DISCARDED_DESC'
  | 'PR_HASH_ASC'
  | 'PR_HASH_DESC'
  | 'PR_ID_ASC'
  | 'PR_ID_DESC'
  | 'PR_RAW_ASC'
  | 'PR_RAW_DESC'
  | 'PR_SORTED_ASC'
  | 'PR_SORTED_DESC';

export type ProspectDatum = {
  __typename?: 'ProspectDatum';
  email: Maybe<Scalars['String']>;
  name: Maybe<Scalars['String']>;
  phone: Maybe<Scalars['String']>;
  surname: Maybe<Scalars['String']>;
  yearofbirth: Maybe<Scalars['String']>;
};

/** An input for mutations affecting `ProspectDatum` */
export type ProspectDatumInput = {
  email?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  phone?: InputMaybe<Scalars['String']>;
  surname?: InputMaybe<Scalars['String']>;
  yearofbirth?: InputMaybe<Scalars['String']>;
};

/** All input for the `prospectFormDancer` mutation. */
export type ProspectFormDancerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  cohort: CrmCohort;
  note: Scalars['String'];
  origin: Scalars['String'];
  prospectData: ProspectDatumInput;
};

/** The output of our `prospectFormDancer` mutation. */
export type ProspectFormDancerPayload = {
  __typename?: 'ProspectFormDancerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** The root query type which gives access points into the data universe. */
export type Query = Node & {
  __typename?: 'Query';
  /** Reads and enables pagination through a set of `Pary`. */
  activeCouples: Maybe<PariesConnection>;
  activeProspects: Maybe<ActiveProspectsConnection>;
  /** Reads and enables pagination through a set of `AkceItem`. */
  akceItems: Maybe<AkceItemsConnection>;
  /** Reads and enables pagination through a set of `Akce`. */
  akces: Maybe<AkcesConnection>;
  /** Reads and enables pagination through a set of `Aktuality`. */
  aktualities: Maybe<AktualitiesConnection>;
  aktuality: Maybe<Aktuality>;
  /** Reads a single `Aktuality` using its globally unique `ID`. */
  aktualityByNodeId: Maybe<Aktuality>;
  attachment: Maybe<Attachment>;
  /** Reads a single `Attachment` using its globally unique `ID`. */
  attachmentByNodeId: Maybe<Attachment>;
  /** Reads and enables pagination through a set of `Attachment`. */
  attachments: Maybe<AttachmentsConnection>;
  attendeeExternal: Maybe<AttendeeExternal>;
  /** Reads a single `AttendeeExternal` using its globally unique `ID`. */
  attendeeExternalByNodeId: Maybe<AttendeeExternal>;
  /** Reads and enables pagination through a set of `AttendeeExternal`. */
  attendeeExternals: Maybe<AttendeeExternalsConnection>;
  attendeeUser: Maybe<AttendeeUser>;
  /** Reads a single `AttendeeUser` using its globally unique `ID`. */
  attendeeUserByNodeId: Maybe<AttendeeUser>;
  attendeeUserByUserIdAndEventId: Maybe<AttendeeUser>;
  /** Reads and enables pagination through a set of `AttendeeUser`. */
  attendeeUsers: Maybe<AttendeeUsersConnection>;
  cohortGroup: Maybe<CohortGroup>;
  /** Reads a single `CohortGroup` using its globally unique `ID`. */
  cohortGroupByNodeId: Maybe<CohortGroup>;
  /** Reads and enables pagination through a set of `CohortGroup`. */
  cohortGroups: Maybe<CohortGroupsConnection>;
  currentCoupleIds: Maybe<CurrentCoupleIdsConnection>;
  /** Reads and enables pagination through a set of `Permission`. */
  currentPermissions: Maybe<PermissionsConnection>;
  currentSessionId: Maybe<Scalars['String']>;
  currentTenantId: Maybe<Scalars['BigInt']>;
  currentUserId: Maybe<Scalars['BigInt']>;
  /** Reads and enables pagination through a set of `Dokumenty`. */
  dokumenties: Maybe<DokumentiesConnection>;
  dokumenty: Maybe<Dokumenty>;
  /** Reads a single `Dokumenty` using its globally unique `ID`. */
  dokumentyByNodeId: Maybe<Dokumenty>;
  event: Maybe<Event>;
  /** Reads a single `Event` using its globally unique `ID`. */
  eventByNodeId: Maybe<Event>;
  /** Reads and enables pagination through a set of `Event`. */
  events: Maybe<EventsConnection>;
  formResponse: Maybe<FormResponse>;
  /** Reads a single `FormResponse` using its globally unique `ID`. */
  formResponseByNodeId: Maybe<FormResponse>;
  /** Reads and enables pagination through a set of `FormResponse`. */
  formResponses: Maybe<FormResponsesConnection>;
  galerieDir: Maybe<GalerieDir>;
  /** Reads a single `GalerieDir` using its globally unique `ID`. */
  galerieDirByNodeId: Maybe<GalerieDir>;
  /** Reads and enables pagination through a set of `GalerieDir`. */
  galerieDirs: Maybe<GalerieDirsConnection>;
  galerieFoto: Maybe<GalerieFoto>;
  /** Reads a single `GalerieFoto` using its globally unique `ID`. */
  galerieFotoByNodeId: Maybe<GalerieFoto>;
  /** Reads and enables pagination through a set of `GalerieFoto`. */
  galerieFotos: Maybe<GalerieFotosConnection>;
  getCurrentCouple: Maybe<Pary>;
  getCurrentTenant: Maybe<Tenant>;
  getCurrentUser: Maybe<User>;
  location: Maybe<Location>;
  locationAttachment: Maybe<LocationAttachment>;
  /** Reads a single `LocationAttachment` using its globally unique `ID`. */
  locationAttachmentByNodeId: Maybe<LocationAttachment>;
  /** Reads and enables pagination through a set of `LocationAttachment`. */
  locationAttachments: Maybe<LocationAttachmentsConnection>;
  /** Reads a single `Location` using its globally unique `ID`. */
  locationByNodeId: Maybe<Location>;
  /** Reads and enables pagination through a set of `Location`. */
  locations: Maybe<LocationsConnection>;
  /** Reads and enables pagination through a set of `Member`. */
  members: Maybe<MembersConnection>;
  /** Reads and enables pagination through a set of `Upozorneni`. */
  myAnnouncements: Maybe<UpozornenisConnection>;
  /** Reads and enables pagination through a set of `RozpisItem`. */
  myLessons: Maybe<RozpisItemsConnection>;
  nabidka: Maybe<Nabidka>;
  /** Reads a single `Nabidka` using its globally unique `ID`. */
  nabidkaByNodeId: Maybe<Nabidka>;
  nabidkaItem: Maybe<NabidkaItem>;
  nabidkaItemByNiPartnerAndNiIdRodic: Maybe<NabidkaItem>;
  /** Reads a single `NabidkaItem` using its globally unique `ID`. */
  nabidkaItemByNodeId: Maybe<NabidkaItem>;
  /** Reads and enables pagination through a set of `NabidkaItem`. */
  nabidkaItems: Maybe<NabidkaItemsConnection>;
  /** Reads and enables pagination through a set of `Nabidka`. */
  nabidkas: Maybe<NabidkasConnection>;
  /** Fetches an object given its globally unique `ID`. */
  node: Maybe<Node>;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID'];
  page: Maybe<Page>;
  /** Reads a single `Page` using its globally unique `ID`. */
  pageByNodeId: Maybe<Page>;
  pageByUrl: Maybe<Page>;
  pageRevision: Maybe<PageRevision>;
  /** Reads a single `PageRevision` using its globally unique `ID`. */
  pageRevisionByNodeId: Maybe<PageRevision>;
  /** Reads and enables pagination through a set of `PageRevision`. */
  pageRevisions: Maybe<PageRevisionsConnection>;
  /** Reads and enables pagination through a set of `Page`. */
  pages: Maybe<PagesConnection>;
  parameter: Maybe<Parameter>;
  /** Reads a single `Parameter` using its globally unique `ID`. */
  parameterByNodeId: Maybe<Parameter>;
  /** Reads and enables pagination through a set of `Parameter`. */
  parameters: Maybe<ParametersConnection>;
  /** Reads and enables pagination through a set of `Pary`. */
  paries: Maybe<PariesConnection>;
  pary: Maybe<Pary>;
  /** Reads a single `Pary` using its globally unique `ID`. */
  paryByNodeId: Maybe<Pary>;
  paryNavrh: Maybe<ParyNavrh>;
  /** Reads a single `ParyNavrh` using its globally unique `ID`. */
  paryNavrhByNodeId: Maybe<ParyNavrh>;
  /** Reads and enables pagination through a set of `ParyNavrh`. */
  paryNavrhs: Maybe<ParyNavrhsConnection>;
  /** Reads and enables pagination through a set of `Person`. */
  people: Maybe<PeopleConnection>;
  permission: Maybe<Permission>;
  /** Reads a single `Permission` using its globally unique `ID`. */
  permissionByNodeId: Maybe<Permission>;
  /** Reads and enables pagination through a set of `Permission`. */
  permissions: Maybe<PermissionsConnection>;
  person: Maybe<Person>;
  /** Reads a single `Person` using its globally unique `ID`. */
  personByNodeId: Maybe<Person>;
  /** Reads and enables pagination through a set of `PlatbyCategory`. */
  platbyCategories: Maybe<PlatbyCategoriesConnection>;
  platbyCategory: Maybe<PlatbyCategory>;
  /** Reads a single `PlatbyCategory` using its globally unique `ID`. */
  platbyCategoryByNodeId: Maybe<PlatbyCategory>;
  platbyCategoryGroup: Maybe<PlatbyCategoryGroup>;
  /** Reads a single `PlatbyCategoryGroup` using its globally unique `ID`. */
  platbyCategoryGroupByNodeId: Maybe<PlatbyCategoryGroup>;
  /** Reads and enables pagination through a set of `PlatbyCategoryGroup`. */
  platbyCategoryGroups: Maybe<PlatbyCategoryGroupsConnection>;
  platbyGroup: Maybe<PlatbyGroup>;
  /** Reads a single `PlatbyGroup` using its globally unique `ID`. */
  platbyGroupByNodeId: Maybe<PlatbyGroup>;
  platbyGroupSkupina: Maybe<PlatbyGroupSkupina>;
  /** Reads a single `PlatbyGroupSkupina` using its globally unique `ID`. */
  platbyGroupSkupinaByNodeId: Maybe<PlatbyGroupSkupina>;
  /** Reads and enables pagination through a set of `PlatbyGroupSkupina`. */
  platbyGroupSkupinas: Maybe<PlatbyGroupSkupinasConnection>;
  /** Reads and enables pagination through a set of `PlatbyGroup`. */
  platbyGroups: Maybe<PlatbyGroupsConnection>;
  platbyItem: Maybe<PlatbyItem>;
  /** Reads a single `PlatbyItem` using its globally unique `ID`. */
  platbyItemByNodeId: Maybe<PlatbyItem>;
  /** Reads and enables pagination through a set of `PlatbyItem`. */
  platbyItems: Maybe<PlatbyItemsConnection>;
  platbyRaw: Maybe<PlatbyRaw>;
  /** Reads a single `PlatbyRaw` using its globally unique `ID`. */
  platbyRawByNodeId: Maybe<PlatbyRaw>;
  /** Reads and enables pagination through a set of `PlatbyRaw`. */
  platbyRaws: Maybe<PlatbyRawsConnection>;
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
  /** Reads and enables pagination through a set of `Nabidka`. */
  reservationsForRange: Maybe<NabidkasConnection>;
  room: Maybe<Room>;
  roomAttachment: Maybe<RoomAttachment>;
  /** Reads a single `RoomAttachment` using its globally unique `ID`. */
  roomAttachmentByNodeId: Maybe<RoomAttachment>;
  /** Reads and enables pagination through a set of `RoomAttachment`. */
  roomAttachments: Maybe<RoomAttachmentsConnection>;
  /** Reads a single `Room` using its globally unique `ID`. */
  roomByNodeId: Maybe<Room>;
  /** Reads and enables pagination through a set of `Room`. */
  rooms: Maybe<RoomsConnection>;
  rozpi: Maybe<Rozpi>;
  /** Reads a single `Rozpi` using its globally unique `ID`. */
  rozpiByNodeId: Maybe<Rozpi>;
  /** Reads and enables pagination through a set of `Rozpi`. */
  rozpis: Maybe<RozpisConnection>;
  rozpisItem: Maybe<RozpisItem>;
  /** Reads a single `RozpisItem` using its globally unique `ID`. */
  rozpisItemByNodeId: Maybe<RozpisItem>;
  /** Reads and enables pagination through a set of `RozpisItem`. */
  rozpisItems: Maybe<RozpisItemsConnection>;
  /** Reads and enables pagination through a set of `Rozpi`. */
  schedulesForRange: Maybe<RozpisConnection>;
  session: Maybe<Session>;
  /** Reads a single `Session` using its globally unique `ID`. */
  sessionByNodeId: Maybe<Session>;
  /** Reads and enables pagination through a set of `Session`. */
  sessions: Maybe<SessionsConnection>;
  /** Reads and enables pagination through a set of `Skupiny`. */
  skupinies: Maybe<SkupiniesConnection>;
  skupiny: Maybe<Skupiny>;
  /** Reads a single `Skupiny` using its globally unique `ID`. */
  skupinyByNodeId: Maybe<Skupiny>;
  tenant: Maybe<Tenant>;
  tenantAttachment: Maybe<TenantAttachment>;
  /** Reads a single `TenantAttachment` using its globally unique `ID`. */
  tenantAttachmentByNodeId: Maybe<TenantAttachment>;
  /** Reads and enables pagination through a set of `TenantAttachment`. */
  tenantAttachments: Maybe<TenantAttachmentsConnection>;
  /** Reads a single `Tenant` using its globally unique `ID`. */
  tenantByNodeId: Maybe<Tenant>;
  /** Reads and enables pagination through a set of `TenantPerson`. */
  tenantPeople: Maybe<TenantPeopleConnection>;
  tenantPerson: Maybe<TenantPerson>;
  /** Reads a single `TenantPerson` using its globally unique `ID`. */
  tenantPersonByNodeId: Maybe<TenantPerson>;
  /** Reads and enables pagination through a set of `Tenant`. */
  tenants: Maybe<TenantsConnection>;
  /** Reads and enables pagination through a set of `Video`. */
  titleVideos: Maybe<VideosConnection>;
  /** Reads and enables pagination through a set of `User`. */
  trainers: Maybe<UsersConnection>;
  upozorneni: Maybe<Upozorneni>;
  /** Reads a single `Upozorneni` using its globally unique `ID`. */
  upozorneniByNodeId: Maybe<Upozorneni>;
  /** Reads and enables pagination through a set of `UpozorneniSkupiny`. */
  upozorneniSkupinies: Maybe<UpozorneniSkupiniesConnection>;
  upozorneniSkupiny: Maybe<UpozorneniSkupiny>;
  /** Reads a single `UpozorneniSkupiny` using its globally unique `ID`. */
  upozorneniSkupinyByNodeId: Maybe<UpozorneniSkupiny>;
  /** Reads and enables pagination through a set of `Upozorneni`. */
  upozornenis: Maybe<UpozornenisConnection>;
  user: Maybe<User>;
  /** Reads a single `User` using its globally unique `ID`. */
  userByNodeId: Maybe<User>;
  /** Reads and enables pagination through a set of `User`. */
  users: Maybe<UsersConnection>;
  video: Maybe<Video>;
  /** Reads a single `Video` using its globally unique `ID`. */
  videoByNodeId: Maybe<Video>;
  videoList: Maybe<VideoList>;
  /** Reads a single `VideoList` using its globally unique `ID`. */
  videoListByNodeId: Maybe<VideoList>;
  /** Reads and enables pagination through a set of `VideoList`. */
  videoLists: Maybe<VideoListsConnection>;
  videoSource: Maybe<VideoSource>;
  /** Reads a single `VideoSource` using its globally unique `ID`. */
  videoSourceByNodeId: Maybe<VideoSource>;
  /** Reads and enables pagination through a set of `VideoSource`. */
  videoSources: Maybe<VideoSourcesConnection>;
  /** Reads and enables pagination through a set of `Video`. */
  videos: Maybe<VideosConnection>;
};


/** The root query type which gives access points into the data universe. */
export type QueryActiveCouplesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryActiveProspectsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAkceItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AkceItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AkceItemsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAkcesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AkceCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AkcesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAktualitiesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AktualityCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AktualitiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAktualityArgs = {
  atId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAktualityByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAttachmentArgs = {
  objectName: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAttachmentByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AttachmentCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AttachmentsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAttendeeExternalArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAttendeeExternalByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAttendeeExternalsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AttendeeExternalCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AttendeeExternalsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAttendeeUserArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAttendeeUserByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAttendeeUserByUserIdAndEventIdArgs = {
  eventId: Scalars['BigInt'];
  userId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAttendeeUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AttendeeUserCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AttendeeUsersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCohortGroupArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCohortGroupByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCohortGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<CohortGroupCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CohortGroupsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCurrentCoupleIdsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCurrentPermissionsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDokumentiesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<DokumentyCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<DokumentiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDokumentyArgs = {
  dId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDokumentyByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<EventCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFormResponseArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFormResponseByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFormResponsesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<FormResponseCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<FormResponsesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGalerieDirArgs = {
  gdId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGalerieDirByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGalerieDirsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<GalerieDirCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GalerieDirsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGalerieFotoArgs = {
  gfId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGalerieFotoByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGalerieFotosArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<GalerieFotoCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GalerieFotosOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLocationArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLocationAttachmentArgs = {
  locationId: Scalars['BigInt'];
  objectName: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLocationAttachmentByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLocationAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<LocationAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LocationAttachmentsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLocationByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLocationsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<LocationCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LocationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMembersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<MemberCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<MembersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMyAnnouncementsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMyLessonsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  endDate?: InputMaybe<Scalars['Date']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  startDate?: InputMaybe<Scalars['Date']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNabidkaArgs = {
  nId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNabidkaByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNabidkaItemArgs = {
  niId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNabidkaItemByNiPartnerAndNiIdRodicArgs = {
  niIdRodic: Scalars['BigInt'];
  niPartner: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNabidkaItemByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNabidkaItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<NabidkaItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<NabidkaItemsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNabidkasArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<NabidkaCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<NabidkasOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNodeArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPageArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPageByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPageByUrlArgs = {
  url: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPageRevisionArgs = {
  id: Scalars['Int'];
  revNumber: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPageRevisionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPageRevisionsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PageRevisionCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PageRevisionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPagesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PageCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PagesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryParameterArgs = {
  paName: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryParameterByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryParametersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<ParameterCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ParametersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPariesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<ParyCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PariesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryParyArgs = {
  pId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryParyByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryParyNavrhArgs = {
  pnId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryParyNavrhByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryParyNavrhsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<ParyNavrhCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ParyNavrhsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPeopleArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PersonCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PeopleOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionArgs = {
  peId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PermissionCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPersonArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPersonByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyCategoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyCategoryCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyCategoriesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyCategoryArgs = {
  pcId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyCategoryByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyCategoryGroupArgs = {
  pcgId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyCategoryGroupByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyCategoryGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyCategoryGroupCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyCategoryGroupsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyGroupArgs = {
  pgId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyGroupByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyGroupSkupinaArgs = {
  pgsId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyGroupSkupinaByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyGroupSkupinasArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyGroupSkupinaCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyGroupSkupinasOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyGroupCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyGroupsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyItemArgs = {
  piId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyItemByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyItemsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyRawArgs = {
  prId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyRawByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyRawsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyRawCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyRawsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReservationsForRangeArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  endDate?: InputMaybe<Scalars['Date']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  startDate?: InputMaybe<Scalars['Date']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomAttachmentArgs = {
  objectName: Scalars['String'];
  roomId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomAttachmentByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<RoomAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RoomAttachmentsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<RoomCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RoomsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRozpiArgs = {
  rId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRozpiByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRozpisArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<RozpiCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RozpisOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRozpisItemArgs = {
  riId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRozpisItemByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRozpisItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<RozpisItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RozpisItemsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySchedulesForRangeArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  endDate?: InputMaybe<Scalars['Date']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  startDate?: InputMaybe<Scalars['Date']>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySessionArgs = {
  ssId: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySessionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySessionsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<SessionCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SessionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySkupiniesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<SkupinyCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SkupiniesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySkupinyArgs = {
  sId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySkupinyByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantAttachmentArgs = {
  objectName: Scalars['String'];
  tenantId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantAttachmentByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<TenantAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TenantAttachmentsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantPeopleArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<TenantPersonCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TenantPeopleOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantPersonArgs = {
  personId: Scalars['BigInt'];
  tenantId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantPersonByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<TenantCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TenantsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTitleVideosArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTrainersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUpozorneniArgs = {
  upId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUpozorneniByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUpozorneniSkupiniesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<UpozorneniSkupinyCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UpozorneniSkupiniesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUpozorneniSkupinyArgs = {
  upsId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUpozorneniSkupinyByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUpozornenisArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<UpozorneniCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UpozornenisOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserArgs = {
  uId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<UserCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVideoArgs = {
  vId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVideoByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVideoListArgs = {
  vlId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVideoListByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVideoListsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<VideoListCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VideoListsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVideoSourceArgs = {
  vsId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVideoSourceByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVideoSourcesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<VideoSourceCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VideoSourcesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVideosArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<VideoCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VideosOrderBy>>;
};

/** All input for the `reservationSetDesiredLessons` mutation. */
export type ReservationSetDesiredLessonsInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  lessonCount: Scalars['Int'];
  reservationId: Scalars['BigInt'];
};

/** The output of our `reservationSetDesiredLessons` mutation. */
export type ReservationSetDesiredLessonsPayload = {
  __typename?: 'ReservationSetDesiredLessonsPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** An edge for our `Nabidka`. May be used by Relay 1. */
  nabidkaEdge: Maybe<NabidkasEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  reservation: Maybe<Nabidka>;
  /** Reads a single `User` that is related to this `Nabidka`. */
  userByNTrener: Maybe<User>;
};


/** The output of our `reservationSetDesiredLessons` mutation. */
export type ReservationSetDesiredLessonsPayloadNabidkaEdgeArgs = {
  orderBy?: InputMaybe<Array<NabidkasOrderBy>>;
};

/** All input for the `resetPassword` mutation. */
export type ResetPasswordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  email: Scalars['String'];
  login: Scalars['String'];
};

/** The output of our `resetPassword` mutation. */
export type ResetPasswordPayload = {
  __typename?: 'ResetPasswordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type Room = Node & {
  __typename?: 'Room';
  description: Scalars['JSON'];
  id: Scalars['BigInt'];
  location: Maybe<Scalars['BigInt']>;
  /** Reads a single `Location` that is related to this `Room`. */
  locationByLocation: Maybe<Location>;
  name: Scalars['String'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads and enables pagination through a set of `RoomAttachment`. */
  roomAttachments: RoomAttachmentsConnection;
};


export type RoomRoomAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<RoomAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RoomAttachmentsOrderBy>>;
};

export type RoomAttachment = Node & {
  __typename?: 'RoomAttachment';
  /** Reads a single `Attachment` that is related to this `RoomAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  objectName: Scalars['String'];
  /** Reads a single `Room` that is related to this `RoomAttachment`. */
  room: Maybe<Room>;
  roomId: Scalars['BigInt'];
};

/**
 * A condition to be used against `RoomAttachment` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type RoomAttachmentCondition = {
  /** Checks for equality with the object’s `objectName` field. */
  objectName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `roomId` field. */
  roomId?: InputMaybe<Scalars['BigInt']>;
};

/** An input for mutations affecting `RoomAttachment` */
export type RoomAttachmentInput = {
  objectName: Scalars['String'];
  roomId: Scalars['BigInt'];
};

/** Represents an update to a `RoomAttachment`. Fields that are set will be updated. */
export type RoomAttachmentPatch = {
  objectName?: InputMaybe<Scalars['String']>;
  roomId?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `RoomAttachment` values. */
export type RoomAttachmentsConnection = {
  __typename?: 'RoomAttachmentsConnection';
  /** A list of edges which contains the `RoomAttachment` and cursor to aid in pagination. */
  edges: Array<RoomAttachmentsEdge>;
  /** A list of `RoomAttachment` objects. */
  nodes: Array<RoomAttachment>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `RoomAttachment` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `RoomAttachment` edge in the connection. */
export type RoomAttachmentsEdge = {
  __typename?: 'RoomAttachmentsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `RoomAttachment` at the end of the edge. */
  node: RoomAttachment;
};

/** Methods to use when ordering `RoomAttachment`. */
export type RoomAttachmentsOrderBy =
  | 'ATTACHMENT_BY_OBJECT_NAME__OBJECT_NAME_ASC'
  | 'ATTACHMENT_BY_OBJECT_NAME__OBJECT_NAME_DESC'
  | 'ATTACHMENT_BY_OBJECT_NAME__PREVIEW_OBJECT_NAME_ASC'
  | 'ATTACHMENT_BY_OBJECT_NAME__PREVIEW_OBJECT_NAME_DESC'
  | 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_AT_ASC'
  | 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_AT_DESC'
  | 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_BY_ASC'
  | 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_BY_DESC'
  | 'NATURAL'
  | 'OBJECT_NAME_ASC'
  | 'OBJECT_NAME_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'ROOM_BY_ROOM_ID__DESCRIPTION_ASC'
  | 'ROOM_BY_ROOM_ID__DESCRIPTION_DESC'
  | 'ROOM_BY_ROOM_ID__ID_ASC'
  | 'ROOM_BY_ROOM_ID__ID_DESC'
  | 'ROOM_BY_ROOM_ID__LOCATION_ASC'
  | 'ROOM_BY_ROOM_ID__LOCATION_DESC'
  | 'ROOM_BY_ROOM_ID__NAME_ASC'
  | 'ROOM_BY_ROOM_ID__NAME_DESC'
  | 'ROOM_ID_ASC'
  | 'ROOM_ID_DESC';

/** A condition to be used against `Room` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type RoomCondition = {
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `location` field. */
  location?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
};

/** An input for mutations affecting `Room` */
export type RoomInput = {
  description: Scalars['JSON'];
  id?: InputMaybe<Scalars['BigInt']>;
  location?: InputMaybe<Scalars['BigInt']>;
  name: Scalars['String'];
};

/** Represents an update to a `Room`. Fields that are set will be updated. */
export type RoomPatch = {
  description?: InputMaybe<Scalars['JSON']>;
  id?: InputMaybe<Scalars['BigInt']>;
  location?: InputMaybe<Scalars['BigInt']>;
  name?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Room` values. */
export type RoomsConnection = {
  __typename?: 'RoomsConnection';
  /** A list of edges which contains the `Room` and cursor to aid in pagination. */
  edges: Array<RoomsEdge>;
  /** A list of `Room` objects. */
  nodes: Array<Room>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Room` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Room` edge in the connection. */
export type RoomsEdge = {
  __typename?: 'RoomsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Room` at the end of the edge. */
  node: Room;
};

/** Methods to use when ordering `Room`. */
export type RoomsOrderBy =
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'LOCATION_ASC'
  | 'LOCATION_BY_LOCATION__DESCRIPTION_ASC'
  | 'LOCATION_BY_LOCATION__DESCRIPTION_DESC'
  | 'LOCATION_BY_LOCATION__ID_ASC'
  | 'LOCATION_BY_LOCATION__ID_DESC'
  | 'LOCATION_BY_LOCATION__NAME_ASC'
  | 'LOCATION_BY_LOCATION__NAME_DESC'
  | 'LOCATION_BY_LOCATION__TENANT_ASC'
  | 'LOCATION_BY_LOCATION__TENANT_DESC'
  | 'LOCATION_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'ROOM_ATTACHMENTS_BY_ROOM_ID__COUNT_ASC'
  | 'ROOM_ATTACHMENTS_BY_ROOM_ID__COUNT_DESC';

export type Rozpi = Node & {
  __typename?: 'Rozpi';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  rDatum: Scalars['Date'];
  rId: Scalars['BigInt'];
  rKde: Scalars['String'];
  rLock: Scalars['Boolean'];
  rTimestamp: Maybe<Scalars['Datetime']>;
  rTrener: Scalars['BigInt'];
  rVisible: Scalars['Boolean'];
  /** Reads and enables pagination through a set of `RozpisItem`. */
  rozpisItemsByRiIdRodic: RozpisItemsConnection;
  /** Reads a single `User` that is related to this `Rozpi`. */
  userByRTrener: Maybe<User>;
};


export type RozpiRozpisItemsByRiIdRodicArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<RozpisItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RozpisItemsOrderBy>>;
};

/** A condition to be used against `Rozpi` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type RozpiCondition = {
  /** Checks for equality with the object’s `rDatum` field. */
  rDatum?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `rId` field. */
  rId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `rKde` field. */
  rKde?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `rLock` field. */
  rLock?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `rTimestamp` field. */
  rTimestamp?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `rTrener` field. */
  rTrener?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `rVisible` field. */
  rVisible?: InputMaybe<Scalars['Boolean']>;
};

/** An input for mutations affecting `Rozpi` */
export type RozpiInput = {
  rDatum: Scalars['Date'];
  rId?: InputMaybe<Scalars['BigInt']>;
  rKde: Scalars['String'];
  rLock?: InputMaybe<Scalars['Boolean']>;
  rTimestamp?: InputMaybe<Scalars['Datetime']>;
  rTrener: Scalars['BigInt'];
  rVisible?: InputMaybe<Scalars['Boolean']>;
};

/** Represents an update to a `Rozpi`. Fields that are set will be updated. */
export type RozpiPatch = {
  rDatum?: InputMaybe<Scalars['Date']>;
  rId?: InputMaybe<Scalars['BigInt']>;
  rKde?: InputMaybe<Scalars['String']>;
  rLock?: InputMaybe<Scalars['Boolean']>;
  rTimestamp?: InputMaybe<Scalars['Datetime']>;
  rTrener?: InputMaybe<Scalars['BigInt']>;
  rVisible?: InputMaybe<Scalars['Boolean']>;
};

/** A connection to a list of `Rozpi` values. */
export type RozpisConnection = {
  __typename?: 'RozpisConnection';
  /** A list of edges which contains the `Rozpi` and cursor to aid in pagination. */
  edges: Array<RozpisEdge>;
  /** A list of `Rozpi` objects. */
  nodes: Array<Rozpi>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Rozpi` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Rozpi` edge in the connection. */
export type RozpisEdge = {
  __typename?: 'RozpisEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Rozpi` at the end of the edge. */
  node: Rozpi;
};

export type RozpisItem = Node & {
  __typename?: 'RozpisItem';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `Pary` that is related to this `RozpisItem`. */
  paryByRiPartner: Maybe<Pary>;
  riDo: Scalars['Time'];
  riId: Scalars['BigInt'];
  riIdRodic: Scalars['BigInt'];
  riLock: Scalars['Boolean'];
  riOd: Scalars['Time'];
  riPartner: Maybe<Scalars['BigInt']>;
  /** Reads a single `Rozpi` that is related to this `RozpisItem`. */
  rozpiByRiIdRodic: Maybe<Rozpi>;
};

/**
 * A condition to be used against `RozpisItem` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type RozpisItemCondition = {
  /** Checks for equality with the object’s `riDo` field. */
  riDo?: InputMaybe<Scalars['Time']>;
  /** Checks for equality with the object’s `riId` field. */
  riId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `riIdRodic` field. */
  riIdRodic?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `riLock` field. */
  riLock?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `riOd` field. */
  riOd?: InputMaybe<Scalars['Time']>;
  /** Checks for equality with the object’s `riPartner` field. */
  riPartner?: InputMaybe<Scalars['BigInt']>;
};

/** An input for mutations affecting `RozpisItem` */
export type RozpisItemInput = {
  riDo: Scalars['Time'];
  riId?: InputMaybe<Scalars['BigInt']>;
  riIdRodic: Scalars['BigInt'];
  riLock?: InputMaybe<Scalars['Boolean']>;
  riOd: Scalars['Time'];
  riPartner?: InputMaybe<Scalars['BigInt']>;
};

/** Represents an update to a `RozpisItem`. Fields that are set will be updated. */
export type RozpisItemPatch = {
  riDo?: InputMaybe<Scalars['Time']>;
  riId?: InputMaybe<Scalars['BigInt']>;
  riIdRodic?: InputMaybe<Scalars['BigInt']>;
  riLock?: InputMaybe<Scalars['Boolean']>;
  riOd?: InputMaybe<Scalars['Time']>;
  riPartner?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `RozpisItem` values. */
export type RozpisItemsConnection = {
  __typename?: 'RozpisItemsConnection';
  /** A list of edges which contains the `RozpisItem` and cursor to aid in pagination. */
  edges: Array<RozpisItemsEdge>;
  /** A list of `RozpisItem` objects. */
  nodes: Array<RozpisItem>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `RozpisItem` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `RozpisItem` edge in the connection. */
export type RozpisItemsEdge = {
  __typename?: 'RozpisItemsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `RozpisItem` at the end of the edge. */
  node: RozpisItem;
};

/** Methods to use when ordering `RozpisItem`. */
export type RozpisItemsOrderBy =
  | 'NATURAL'
  | 'PARY_BY_RI_PARTNER__P_ARCHIV_ASC'
  | 'PARY_BY_RI_PARTNER__P_ARCHIV_DESC'
  | 'PARY_BY_RI_PARTNER__P_HODNOCENI_ASC'
  | 'PARY_BY_RI_PARTNER__P_HODNOCENI_DESC'
  | 'PARY_BY_RI_PARTNER__P_ID_ASC'
  | 'PARY_BY_RI_PARTNER__P_ID_DESC'
  | 'PARY_BY_RI_PARTNER__P_ID_PARTNERKA_ASC'
  | 'PARY_BY_RI_PARTNER__P_ID_PARTNERKA_DESC'
  | 'PARY_BY_RI_PARTNER__P_ID_PARTNER_ASC'
  | 'PARY_BY_RI_PARTNER__P_ID_PARTNER_DESC'
  | 'PARY_BY_RI_PARTNER__P_LAT_BODY_ASC'
  | 'PARY_BY_RI_PARTNER__P_LAT_BODY_DESC'
  | 'PARY_BY_RI_PARTNER__P_LAT_FINALE_ASC'
  | 'PARY_BY_RI_PARTNER__P_LAT_FINALE_DESC'
  | 'PARY_BY_RI_PARTNER__P_LAT_TRIDA_ASC'
  | 'PARY_BY_RI_PARTNER__P_LAT_TRIDA_DESC'
  | 'PARY_BY_RI_PARTNER__P_STT_BODY_ASC'
  | 'PARY_BY_RI_PARTNER__P_STT_BODY_DESC'
  | 'PARY_BY_RI_PARTNER__P_STT_FINALE_ASC'
  | 'PARY_BY_RI_PARTNER__P_STT_FINALE_DESC'
  | 'PARY_BY_RI_PARTNER__P_STT_TRIDA_ASC'
  | 'PARY_BY_RI_PARTNER__P_STT_TRIDA_DESC'
  | 'PARY_BY_RI_PARTNER__P_TIMESTAMP_ADD_ASC'
  | 'PARY_BY_RI_PARTNER__P_TIMESTAMP_ADD_DESC'
  | 'PARY_BY_RI_PARTNER__P_TIMESTAMP_ARCHIVE_ASC'
  | 'PARY_BY_RI_PARTNER__P_TIMESTAMP_ARCHIVE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'RI_DO_ASC'
  | 'RI_DO_DESC'
  | 'RI_ID_ASC'
  | 'RI_ID_DESC'
  | 'RI_ID_RODIC_ASC'
  | 'RI_ID_RODIC_DESC'
  | 'RI_LOCK_ASC'
  | 'RI_LOCK_DESC'
  | 'RI_OD_ASC'
  | 'RI_OD_DESC'
  | 'RI_PARTNER_ASC'
  | 'RI_PARTNER_DESC'
  | 'ROZPI_BY_RI_ID_RODIC__R_DATUM_ASC'
  | 'ROZPI_BY_RI_ID_RODIC__R_DATUM_DESC'
  | 'ROZPI_BY_RI_ID_RODIC__R_ID_ASC'
  | 'ROZPI_BY_RI_ID_RODIC__R_ID_DESC'
  | 'ROZPI_BY_RI_ID_RODIC__R_KDE_ASC'
  | 'ROZPI_BY_RI_ID_RODIC__R_KDE_DESC'
  | 'ROZPI_BY_RI_ID_RODIC__R_LOCK_ASC'
  | 'ROZPI_BY_RI_ID_RODIC__R_LOCK_DESC'
  | 'ROZPI_BY_RI_ID_RODIC__R_TIMESTAMP_ASC'
  | 'ROZPI_BY_RI_ID_RODIC__R_TIMESTAMP_DESC'
  | 'ROZPI_BY_RI_ID_RODIC__R_TRENER_ASC'
  | 'ROZPI_BY_RI_ID_RODIC__R_TRENER_DESC'
  | 'ROZPI_BY_RI_ID_RODIC__R_VISIBLE_ASC'
  | 'ROZPI_BY_RI_ID_RODIC__R_VISIBLE_DESC';

/** Methods to use when ordering `Rozpi`. */
export type RozpisOrderBy =
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'ROZPIS_ITEMS_BY_RI_ID_RODIC__COUNT_ASC'
  | 'ROZPIS_ITEMS_BY_RI_ID_RODIC__COUNT_DESC'
  | 'R_DATUM_ASC'
  | 'R_DATUM_DESC'
  | 'R_ID_ASC'
  | 'R_ID_DESC'
  | 'R_KDE_ASC'
  | 'R_KDE_DESC'
  | 'R_LOCK_ASC'
  | 'R_LOCK_DESC'
  | 'R_TIMESTAMP_ASC'
  | 'R_TIMESTAMP_DESC'
  | 'R_TRENER_ASC'
  | 'R_TRENER_DESC'
  | 'R_VISIBLE_ASC'
  | 'R_VISIBLE_DESC'
  | 'USER_BY_R_TRENER__U_BAN_ASC'
  | 'USER_BY_R_TRENER__U_BAN_DESC'
  | 'USER_BY_R_TRENER__U_CITY_ASC'
  | 'USER_BY_R_TRENER__U_CITY_DESC'
  | 'USER_BY_R_TRENER__U_CONFIRMED_ASC'
  | 'USER_BY_R_TRENER__U_CONFIRMED_DESC'
  | 'USER_BY_R_TRENER__U_CONSCRIPTION_NUMBER_ASC'
  | 'USER_BY_R_TRENER__U_CONSCRIPTION_NUMBER_DESC'
  | 'USER_BY_R_TRENER__U_CREATED_AT_ASC'
  | 'USER_BY_R_TRENER__U_CREATED_AT_DESC'
  | 'USER_BY_R_TRENER__U_DANCER_ASC'
  | 'USER_BY_R_TRENER__U_DANCER_DESC'
  | 'USER_BY_R_TRENER__U_DISTRICT_ASC'
  | 'USER_BY_R_TRENER__U_DISTRICT_DESC'
  | 'USER_BY_R_TRENER__U_EMAIL_ASC'
  | 'USER_BY_R_TRENER__U_EMAIL_DESC'
  | 'USER_BY_R_TRENER__U_GDPR_SIGNED_AT_ASC'
  | 'USER_BY_R_TRENER__U_GDPR_SIGNED_AT_DESC'
  | 'USER_BY_R_TRENER__U_GROUP_ASC'
  | 'USER_BY_R_TRENER__U_GROUP_DESC'
  | 'USER_BY_R_TRENER__U_ID_ASC'
  | 'USER_BY_R_TRENER__U_ID_DESC'
  | 'USER_BY_R_TRENER__U_JMENO_ASC'
  | 'USER_BY_R_TRENER__U_JMENO_DESC'
  | 'USER_BY_R_TRENER__U_LEVEL_ASC'
  | 'USER_BY_R_TRENER__U_LEVEL_DESC'
  | 'USER_BY_R_TRENER__U_LOCK_ASC'
  | 'USER_BY_R_TRENER__U_LOCK_DESC'
  | 'USER_BY_R_TRENER__U_LOGIN_ASC'
  | 'USER_BY_R_TRENER__U_LOGIN_DESC'
  | 'USER_BY_R_TRENER__U_MEMBER_SINCE_ASC'
  | 'USER_BY_R_TRENER__U_MEMBER_SINCE_DESC'
  | 'USER_BY_R_TRENER__U_MEMBER_UNTIL_ASC'
  | 'USER_BY_R_TRENER__U_MEMBER_UNTIL_DESC'
  | 'USER_BY_R_TRENER__U_NAROZENI_ASC'
  | 'USER_BY_R_TRENER__U_NAROZENI_DESC'
  | 'USER_BY_R_TRENER__U_NATIONALITY_ASC'
  | 'USER_BY_R_TRENER__U_NATIONALITY_DESC'
  | 'USER_BY_R_TRENER__U_ORIENTATION_NUMBER_ASC'
  | 'USER_BY_R_TRENER__U_ORIENTATION_NUMBER_DESC'
  | 'USER_BY_R_TRENER__U_PASS_ASC'
  | 'USER_BY_R_TRENER__U_PASS_DESC'
  | 'USER_BY_R_TRENER__U_POHLAVI_ASC'
  | 'USER_BY_R_TRENER__U_POHLAVI_DESC'
  | 'USER_BY_R_TRENER__U_POSTAL_CODE_ASC'
  | 'USER_BY_R_TRENER__U_POSTAL_CODE_DESC'
  | 'USER_BY_R_TRENER__U_POZNAMKY_ASC'
  | 'USER_BY_R_TRENER__U_POZNAMKY_DESC'
  | 'USER_BY_R_TRENER__U_PRIJMENI_ASC'
  | 'USER_BY_R_TRENER__U_PRIJMENI_DESC'
  | 'USER_BY_R_TRENER__U_RODNE_CISLO_ASC'
  | 'USER_BY_R_TRENER__U_RODNE_CISLO_DESC'
  | 'USER_BY_R_TRENER__U_SKUPINA_ASC'
  | 'USER_BY_R_TRENER__U_SKUPINA_DESC'
  | 'USER_BY_R_TRENER__U_STREET_ASC'
  | 'USER_BY_R_TRENER__U_STREET_DESC'
  | 'USER_BY_R_TRENER__U_SYSTEM_ASC'
  | 'USER_BY_R_TRENER__U_SYSTEM_DESC'
  | 'USER_BY_R_TRENER__U_TEACHER_ASC'
  | 'USER_BY_R_TRENER__U_TEACHER_DESC'
  | 'USER_BY_R_TRENER__U_TELEFON_ASC'
  | 'USER_BY_R_TRENER__U_TELEFON_DESC'
  | 'USER_BY_R_TRENER__U_TIMESTAMP_ASC'
  | 'USER_BY_R_TRENER__U_TIMESTAMP_DESC';

export type Session = Node & {
  __typename?: 'Session';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  ssId: Scalars['String'];
  ssLifetime: Scalars['BigInt'];
  ssUpdatedAt: Scalars['Datetime'];
  ssUser: Maybe<Scalars['BigInt']>;
  /** Reads a single `User` that is related to this `Session`. */
  userBySsUser: Maybe<User>;
};

/** A condition to be used against `Session` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type SessionCondition = {
  /** Checks for equality with the object’s `ssId` field. */
  ssId?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `ssLifetime` field. */
  ssLifetime?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `ssUpdatedAt` field. */
  ssUpdatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `ssUser` field. */
  ssUser?: InputMaybe<Scalars['BigInt']>;
};

/** An input for mutations affecting `Session` */
export type SessionInput = {
  ssId: Scalars['String'];
  ssLifetime: Scalars['BigInt'];
  ssUpdatedAt?: InputMaybe<Scalars['Datetime']>;
  ssUser?: InputMaybe<Scalars['BigInt']>;
};

/** Represents an update to a `Session`. Fields that are set will be updated. */
export type SessionPatch = {
  ssId?: InputMaybe<Scalars['String']>;
  ssLifetime?: InputMaybe<Scalars['BigInt']>;
  ssUpdatedAt?: InputMaybe<Scalars['Datetime']>;
  ssUser?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `Session` values. */
export type SessionsConnection = {
  __typename?: 'SessionsConnection';
  /** A list of edges which contains the `Session` and cursor to aid in pagination. */
  edges: Array<SessionsEdge>;
  /** A list of `Session` objects. */
  nodes: Array<Session>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Session` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Session` edge in the connection. */
export type SessionsEdge = {
  __typename?: 'SessionsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Session` at the end of the edge. */
  node: Session;
};

/** Methods to use when ordering `Session`. */
export type SessionsOrderBy =
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SS_ID_ASC'
  | 'SS_ID_DESC'
  | 'SS_LIFETIME_ASC'
  | 'SS_LIFETIME_DESC'
  | 'SS_UPDATED_AT_ASC'
  | 'SS_UPDATED_AT_DESC'
  | 'SS_USER_ASC'
  | 'SS_USER_DESC'
  | 'USER_BY_SS_USER__U_BAN_ASC'
  | 'USER_BY_SS_USER__U_BAN_DESC'
  | 'USER_BY_SS_USER__U_CITY_ASC'
  | 'USER_BY_SS_USER__U_CITY_DESC'
  | 'USER_BY_SS_USER__U_CONFIRMED_ASC'
  | 'USER_BY_SS_USER__U_CONFIRMED_DESC'
  | 'USER_BY_SS_USER__U_CONSCRIPTION_NUMBER_ASC'
  | 'USER_BY_SS_USER__U_CONSCRIPTION_NUMBER_DESC'
  | 'USER_BY_SS_USER__U_CREATED_AT_ASC'
  | 'USER_BY_SS_USER__U_CREATED_AT_DESC'
  | 'USER_BY_SS_USER__U_DANCER_ASC'
  | 'USER_BY_SS_USER__U_DANCER_DESC'
  | 'USER_BY_SS_USER__U_DISTRICT_ASC'
  | 'USER_BY_SS_USER__U_DISTRICT_DESC'
  | 'USER_BY_SS_USER__U_EMAIL_ASC'
  | 'USER_BY_SS_USER__U_EMAIL_DESC'
  | 'USER_BY_SS_USER__U_GDPR_SIGNED_AT_ASC'
  | 'USER_BY_SS_USER__U_GDPR_SIGNED_AT_DESC'
  | 'USER_BY_SS_USER__U_GROUP_ASC'
  | 'USER_BY_SS_USER__U_GROUP_DESC'
  | 'USER_BY_SS_USER__U_ID_ASC'
  | 'USER_BY_SS_USER__U_ID_DESC'
  | 'USER_BY_SS_USER__U_JMENO_ASC'
  | 'USER_BY_SS_USER__U_JMENO_DESC'
  | 'USER_BY_SS_USER__U_LEVEL_ASC'
  | 'USER_BY_SS_USER__U_LEVEL_DESC'
  | 'USER_BY_SS_USER__U_LOCK_ASC'
  | 'USER_BY_SS_USER__U_LOCK_DESC'
  | 'USER_BY_SS_USER__U_LOGIN_ASC'
  | 'USER_BY_SS_USER__U_LOGIN_DESC'
  | 'USER_BY_SS_USER__U_MEMBER_SINCE_ASC'
  | 'USER_BY_SS_USER__U_MEMBER_SINCE_DESC'
  | 'USER_BY_SS_USER__U_MEMBER_UNTIL_ASC'
  | 'USER_BY_SS_USER__U_MEMBER_UNTIL_DESC'
  | 'USER_BY_SS_USER__U_NAROZENI_ASC'
  | 'USER_BY_SS_USER__U_NAROZENI_DESC'
  | 'USER_BY_SS_USER__U_NATIONALITY_ASC'
  | 'USER_BY_SS_USER__U_NATIONALITY_DESC'
  | 'USER_BY_SS_USER__U_ORIENTATION_NUMBER_ASC'
  | 'USER_BY_SS_USER__U_ORIENTATION_NUMBER_DESC'
  | 'USER_BY_SS_USER__U_PASS_ASC'
  | 'USER_BY_SS_USER__U_PASS_DESC'
  | 'USER_BY_SS_USER__U_POHLAVI_ASC'
  | 'USER_BY_SS_USER__U_POHLAVI_DESC'
  | 'USER_BY_SS_USER__U_POSTAL_CODE_ASC'
  | 'USER_BY_SS_USER__U_POSTAL_CODE_DESC'
  | 'USER_BY_SS_USER__U_POZNAMKY_ASC'
  | 'USER_BY_SS_USER__U_POZNAMKY_DESC'
  | 'USER_BY_SS_USER__U_PRIJMENI_ASC'
  | 'USER_BY_SS_USER__U_PRIJMENI_DESC'
  | 'USER_BY_SS_USER__U_RODNE_CISLO_ASC'
  | 'USER_BY_SS_USER__U_RODNE_CISLO_DESC'
  | 'USER_BY_SS_USER__U_SKUPINA_ASC'
  | 'USER_BY_SS_USER__U_SKUPINA_DESC'
  | 'USER_BY_SS_USER__U_STREET_ASC'
  | 'USER_BY_SS_USER__U_STREET_DESC'
  | 'USER_BY_SS_USER__U_SYSTEM_ASC'
  | 'USER_BY_SS_USER__U_SYSTEM_DESC'
  | 'USER_BY_SS_USER__U_TEACHER_ASC'
  | 'USER_BY_SS_USER__U_TEACHER_DESC'
  | 'USER_BY_SS_USER__U_TELEFON_ASC'
  | 'USER_BY_SS_USER__U_TELEFON_DESC'
  | 'USER_BY_SS_USER__U_TIMESTAMP_ASC'
  | 'USER_BY_SS_USER__U_TIMESTAMP_DESC';

/** A connection to a list of `Skupiny` values. */
export type SkupiniesConnection = {
  __typename?: 'SkupiniesConnection';
  /** A list of edges which contains the `Skupiny` and cursor to aid in pagination. */
  edges: Array<SkupiniesEdge>;
  /** A list of `Skupiny` objects. */
  nodes: Array<Skupiny>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Skupiny` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Skupiny` edge in the connection. */
export type SkupiniesEdge = {
  __typename?: 'SkupiniesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Skupiny` at the end of the edge. */
  node: Skupiny;
};

/** Methods to use when ordering `Skupiny`. */
export type SkupiniesOrderBy =
  | 'COHORT_GROUP_ASC'
  | 'COHORT_GROUP_BY_COHORT_GROUP__DESCRIPTION_ASC'
  | 'COHORT_GROUP_BY_COHORT_GROUP__DESCRIPTION_DESC'
  | 'COHORT_GROUP_BY_COHORT_GROUP__ID_ASC'
  | 'COHORT_GROUP_BY_COHORT_GROUP__ID_DESC'
  | 'COHORT_GROUP_BY_COHORT_GROUP__IS_PUBLIC_ASC'
  | 'COHORT_GROUP_BY_COHORT_GROUP__IS_PUBLIC_DESC'
  | 'COHORT_GROUP_BY_COHORT_GROUP__NAME_ASC'
  | 'COHORT_GROUP_BY_COHORT_GROUP__NAME_DESC'
  | 'COHORT_GROUP_BY_COHORT_GROUP__ORDERING_ASC'
  | 'COHORT_GROUP_BY_COHORT_GROUP__ORDERING_DESC'
  | 'COHORT_GROUP_BY_COHORT_GROUP__TENANT_ASC'
  | 'COHORT_GROUP_BY_COHORT_GROUP__TENANT_DESC'
  | 'COHORT_GROUP_DESC'
  | 'INTERNAL_INFO_ASC'
  | 'INTERNAL_INFO_DESC'
  | 'NATURAL'
  | 'ORDERING_ASC'
  | 'ORDERING_DESC'
  | 'PLATBY_GROUP_SKUPINAS_BY_PGS_ID_SKUPINA__COUNT_ASC'
  | 'PLATBY_GROUP_SKUPINAS_BY_PGS_ID_SKUPINA__COUNT_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'S_COLOR_RGB_ASC'
  | 'S_COLOR_RGB_DESC'
  | 'S_COLOR_TEXT_ASC'
  | 'S_COLOR_TEXT_DESC'
  | 'S_DESCRIPTION_ASC'
  | 'S_DESCRIPTION_DESC'
  | 'S_ID_ASC'
  | 'S_ID_DESC'
  | 'S_LOCATION_ASC'
  | 'S_LOCATION_DESC'
  | 'S_NAME_ASC'
  | 'S_NAME_DESC'
  | 'S_VISIBLE_ASC'
  | 'S_VISIBLE_DESC'
  | 'UPOZORNENI_SKUPINIES_BY_UPS_ID_SKUPINA__COUNT_ASC'
  | 'UPOZORNENI_SKUPINIES_BY_UPS_ID_SKUPINA__COUNT_DESC'
  | 'USERS_BY_U_SKUPINA__COUNT_ASC'
  | 'USERS_BY_U_SKUPINA__COUNT_DESC';

export type Skupiny = Node & {
  __typename?: 'Skupiny';
  cohortGroup: Maybe<Scalars['BigInt']>;
  /** Reads a single `CohortGroup` that is related to this `Skupiny`. */
  cohortGroupByCohortGroup: Maybe<CohortGroup>;
  internalInfo: Scalars['String'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  ordering: Scalars['Int'];
  /** Reads and enables pagination through a set of `PlatbyGroupSkupina`. */
  platbyGroupSkupinasByPgsIdSkupina: PlatbyGroupSkupinasConnection;
  sColorRgb: Scalars['String'];
  sColorText: Scalars['String'];
  sDescription: Scalars['String'];
  sId: Scalars['BigInt'];
  sLocation: Scalars['String'];
  sName: Scalars['String'];
  sVisible: Scalars['Boolean'];
  /** Reads and enables pagination through a set of `UpozorneniSkupiny`. */
  upozorneniSkupiniesByUpsIdSkupina: UpozorneniSkupiniesConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByUSkupina: UsersConnection;
};


export type SkupinyPlatbyGroupSkupinasByPgsIdSkupinaArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyGroupSkupinaCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyGroupSkupinasOrderBy>>;
};


export type SkupinyUpozorneniSkupiniesByUpsIdSkupinaArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<UpozorneniSkupinyCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UpozorneniSkupiniesOrderBy>>;
};


export type SkupinyUsersByUSkupinaArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<UserCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** A condition to be used against `Skupiny` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type SkupinyCondition = {
  /** Checks for equality with the object’s `cohortGroup` field. */
  cohortGroup?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `internalInfo` field. */
  internalInfo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `ordering` field. */
  ordering?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sColorRgb` field. */
  sColorRgb?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sColorText` field. */
  sColorText?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sDescription` field. */
  sDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sId` field. */
  sId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `sLocation` field. */
  sLocation?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sName` field. */
  sName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sVisible` field. */
  sVisible?: InputMaybe<Scalars['Boolean']>;
};

/** An input for mutations affecting `Skupiny` */
export type SkupinyInput = {
  cohortGroup?: InputMaybe<Scalars['BigInt']>;
  internalInfo?: InputMaybe<Scalars['String']>;
  ordering?: InputMaybe<Scalars['Int']>;
  sColorRgb: Scalars['String'];
  sColorText?: InputMaybe<Scalars['String']>;
  sDescription: Scalars['String'];
  sId?: InputMaybe<Scalars['BigInt']>;
  sLocation?: InputMaybe<Scalars['String']>;
  sName: Scalars['String'];
  sVisible?: InputMaybe<Scalars['Boolean']>;
};

/** Represents an update to a `Skupiny`. Fields that are set will be updated. */
export type SkupinyPatch = {
  cohortGroup?: InputMaybe<Scalars['BigInt']>;
  internalInfo?: InputMaybe<Scalars['String']>;
  ordering?: InputMaybe<Scalars['Int']>;
  sColorRgb?: InputMaybe<Scalars['String']>;
  sColorText?: InputMaybe<Scalars['String']>;
  sDescription?: InputMaybe<Scalars['String']>;
  sId?: InputMaybe<Scalars['BigInt']>;
  sLocation?: InputMaybe<Scalars['String']>;
  sName?: InputMaybe<Scalars['String']>;
  sVisible?: InputMaybe<Scalars['Boolean']>;
};

/** All input for the `submitForm` mutation. */
export type SubmitFormInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  data: Scalars['JSON'];
  type: Scalars['String'];
  url: Scalars['String'];
};

/** The output of our `submitForm` mutation. */
export type SubmitFormPayload = {
  __typename?: 'SubmitFormPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type Tenant = Node & {
  __typename?: 'Tenant';
  /** Reads and enables pagination through a set of `CohortGroup`. */
  cohortGroupsByTenant: CohortGroupsConnection;
  id: Scalars['BigInt'];
  /** Reads and enables pagination through a set of `Location`. */
  locationsByTenant: LocationsConnection;
  memberInfo: Scalars['String'];
  name: Scalars['String'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads and enables pagination through a set of `TenantAttachment`. */
  tenantAttachments: TenantAttachmentsConnection;
  /** Reads and enables pagination through a set of `TenantPerson`. */
  tenantPeople: TenantPeopleConnection;
};


export type TenantCohortGroupsByTenantArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<CohortGroupCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CohortGroupsOrderBy>>;
};


export type TenantLocationsByTenantArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<LocationCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LocationsOrderBy>>;
};


export type TenantTenantAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<TenantAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TenantAttachmentsOrderBy>>;
};


export type TenantTenantPeopleArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<TenantPersonCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TenantPeopleOrderBy>>;
};

export type TenantAttachment = Node & {
  __typename?: 'TenantAttachment';
  /** Reads a single `Attachment` that is related to this `TenantAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  objectName: Scalars['String'];
  /** Reads a single `Tenant` that is related to this `TenantAttachment`. */
  tenant: Maybe<Tenant>;
  tenantId: Scalars['BigInt'];
  type: Maybe<TenantAttachmentType>;
};

/**
 * A condition to be used against `TenantAttachment` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TenantAttachmentCondition = {
  /** Checks for equality with the object’s `objectName` field. */
  objectName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `tenantId` field. */
  tenantId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<TenantAttachmentType>;
};

/** An input for mutations affecting `TenantAttachment` */
export type TenantAttachmentInput = {
  objectName: Scalars['String'];
  tenantId: Scalars['BigInt'];
  type?: InputMaybe<TenantAttachmentType>;
};

/** Represents an update to a `TenantAttachment`. Fields that are set will be updated. */
export type TenantAttachmentPatch = {
  objectName?: InputMaybe<Scalars['String']>;
  tenantId?: InputMaybe<Scalars['BigInt']>;
  type?: InputMaybe<TenantAttachmentType>;
};

export type TenantAttachmentType =
  | 'LOGO'
  | 'MAP'
  | 'PHOTO';

/** A connection to a list of `TenantAttachment` values. */
export type TenantAttachmentsConnection = {
  __typename?: 'TenantAttachmentsConnection';
  /** A list of edges which contains the `TenantAttachment` and cursor to aid in pagination. */
  edges: Array<TenantAttachmentsEdge>;
  /** A list of `TenantAttachment` objects. */
  nodes: Array<TenantAttachment>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TenantAttachment` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `TenantAttachment` edge in the connection. */
export type TenantAttachmentsEdge = {
  __typename?: 'TenantAttachmentsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `TenantAttachment` at the end of the edge. */
  node: TenantAttachment;
};

/** Methods to use when ordering `TenantAttachment`. */
export type TenantAttachmentsOrderBy =
  | 'ATTACHMENT_BY_OBJECT_NAME__OBJECT_NAME_ASC'
  | 'ATTACHMENT_BY_OBJECT_NAME__OBJECT_NAME_DESC'
  | 'ATTACHMENT_BY_OBJECT_NAME__PREVIEW_OBJECT_NAME_ASC'
  | 'ATTACHMENT_BY_OBJECT_NAME__PREVIEW_OBJECT_NAME_DESC'
  | 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_AT_ASC'
  | 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_AT_DESC'
  | 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_BY_ASC'
  | 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_BY_DESC'
  | 'NATURAL'
  | 'OBJECT_NAME_ASC'
  | 'OBJECT_NAME_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TENANT_BY_TENANT_ID__ID_ASC'
  | 'TENANT_BY_TENANT_ID__ID_DESC'
  | 'TENANT_BY_TENANT_ID__MEMBER_INFO_ASC'
  | 'TENANT_BY_TENANT_ID__MEMBER_INFO_DESC'
  | 'TENANT_BY_TENANT_ID__NAME_ASC'
  | 'TENANT_BY_TENANT_ID__NAME_DESC'
  | 'TENANT_ID_ASC'
  | 'TENANT_ID_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC';

/** A condition to be used against `Tenant` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TenantCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `memberInfo` field. */
  memberInfo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
};

/** An input for mutations affecting `Tenant` */
export type TenantInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  memberInfo: Scalars['String'];
  name: Scalars['String'];
};

/** Represents an update to a `Tenant`. Fields that are set will be updated. */
export type TenantPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  memberInfo?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `TenantPerson` values. */
export type TenantPeopleConnection = {
  __typename?: 'TenantPeopleConnection';
  /** A list of edges which contains the `TenantPerson` and cursor to aid in pagination. */
  edges: Array<TenantPeopleEdge>;
  /** A list of `TenantPerson` objects. */
  nodes: Array<TenantPerson>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TenantPerson` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `TenantPerson` edge in the connection. */
export type TenantPeopleEdge = {
  __typename?: 'TenantPeopleEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `TenantPerson` at the end of the edge. */
  node: TenantPerson;
};

/** Methods to use when ordering `TenantPerson`. */
export type TenantPeopleOrderBy =
  | 'NATURAL'
  | 'PERSON_BY_PERSON_ID__FIRST_NAME_ASC'
  | 'PERSON_BY_PERSON_ID__FIRST_NAME_DESC'
  | 'PERSON_BY_PERSON_ID__GENDER_ASC'
  | 'PERSON_BY_PERSON_ID__GENDER_DESC'
  | 'PERSON_BY_PERSON_ID__ID_ASC'
  | 'PERSON_BY_PERSON_ID__ID_DESC'
  | 'PERSON_BY_PERSON_ID__LAST_NAME_ASC'
  | 'PERSON_BY_PERSON_ID__LAST_NAME_DESC'
  | 'PERSON_ID_ASC'
  | 'PERSON_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TENANT_BY_TENANT_ID__ID_ASC'
  | 'TENANT_BY_TENANT_ID__ID_DESC'
  | 'TENANT_BY_TENANT_ID__MEMBER_INFO_ASC'
  | 'TENANT_BY_TENANT_ID__MEMBER_INFO_DESC'
  | 'TENANT_BY_TENANT_ID__NAME_ASC'
  | 'TENANT_BY_TENANT_ID__NAME_DESC'
  | 'TENANT_ID_ASC'
  | 'TENANT_ID_DESC';

export type TenantPerson = Node & {
  __typename?: 'TenantPerson';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `Person` that is related to this `TenantPerson`. */
  person: Maybe<Person>;
  personId: Scalars['BigInt'];
  /** Reads a single `Tenant` that is related to this `TenantPerson`. */
  tenant: Maybe<Tenant>;
  tenantId: Scalars['BigInt'];
};

/**
 * A condition to be used against `TenantPerson` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TenantPersonCondition = {
  /** Checks for equality with the object’s `personId` field. */
  personId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `tenantId` field. */
  tenantId?: InputMaybe<Scalars['BigInt']>;
};

/** An input for mutations affecting `TenantPerson` */
export type TenantPersonInput = {
  personId: Scalars['BigInt'];
  tenantId: Scalars['BigInt'];
};

/** Represents an update to a `TenantPerson`. Fields that are set will be updated. */
export type TenantPersonPatch = {
  personId?: InputMaybe<Scalars['BigInt']>;
  tenantId?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `Tenant` values. */
export type TenantsConnection = {
  __typename?: 'TenantsConnection';
  /** A list of edges which contains the `Tenant` and cursor to aid in pagination. */
  edges: Array<TenantsEdge>;
  /** A list of `Tenant` objects. */
  nodes: Array<Tenant>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Tenant` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Tenant` edge in the connection. */
export type TenantsEdge = {
  __typename?: 'TenantsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Tenant` at the end of the edge. */
  node: Tenant;
};

/** Methods to use when ordering `Tenant`. */
export type TenantsOrderBy =
  | 'COHORT_GROUPS_BY_TENANT__COUNT_ASC'
  | 'COHORT_GROUPS_BY_TENANT__COUNT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'LOCATIONS_BY_TENANT__COUNT_ASC'
  | 'LOCATIONS_BY_TENANT__COUNT_DESC'
  | 'MEMBER_INFO_ASC'
  | 'MEMBER_INFO_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TENANT_ATTACHMENTS_BY_TENANT_ID__COUNT_ASC'
  | 'TENANT_ATTACHMENTS_BY_TENANT_ID__COUNT_DESC'
  | 'TENANT_PEOPLE_BY_TENANT_ID__COUNT_ASC'
  | 'TENANT_PEOPLE_BY_TENANT_ID__COUNT_DESC';

/** All input for the `updateAktualityByNodeId` mutation. */
export type UpdateAktualityByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Aktuality` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Aktuality` being updated. */
  patch: AktualityPatch;
};

/** All input for the `updateAktuality` mutation. */
export type UpdateAktualityInput = {
  atId: Scalars['BigInt'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Aktuality` being updated. */
  patch: AktualityPatch;
};

/** The output of our update `Aktuality` mutation. */
export type UpdateAktualityPayload = {
  __typename?: 'UpdateAktualityPayload';
  /** The `Aktuality` that was updated by this mutation. */
  aktuality: Maybe<Aktuality>;
  /** An edge for our `Aktuality`. May be used by Relay 1. */
  aktualityEdge: Maybe<AktualitiesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
  galerieFotoByAtFotoMain: Maybe<GalerieFoto>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Aktuality`. */
  userByAtKdo: Maybe<User>;
};


/** The output of our update `Aktuality` mutation. */
export type UpdateAktualityPayloadAktualityEdgeArgs = {
  orderBy?: InputMaybe<Array<AktualitiesOrderBy>>;
};

/** All input for the `updateAttachmentByNodeId` mutation. */
export type UpdateAttachmentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Attachment` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Attachment` being updated. */
  patch: AttachmentPatch;
};

/** All input for the `updateAttachment` mutation. */
export type UpdateAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  objectName: Scalars['String'];
  /** An object where the defined keys will be set on the `Attachment` being updated. */
  patch: AttachmentPatch;
};

/** The output of our update `Attachment` mutation. */
export type UpdateAttachmentPayload = {
  __typename?: 'UpdateAttachmentPayload';
  /** The `Attachment` that was updated by this mutation. */
  attachment: Maybe<Attachment>;
  /** An edge for our `Attachment`. May be used by Relay 1. */
  attachmentEdge: Maybe<AttachmentsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Attachment`. */
  userByUploadedBy: Maybe<User>;
};


/** The output of our update `Attachment` mutation. */
export type UpdateAttachmentPayloadAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<AttachmentsOrderBy>>;
};

/** All input for the `updateAttendeeExternalByNodeId` mutation. */
export type UpdateAttendeeExternalByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `AttendeeExternal` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `AttendeeExternal` being updated. */
  patch: AttendeeExternalPatch;
};

/** All input for the `updateAttendeeExternal` mutation. */
export type UpdateAttendeeExternalInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `AttendeeExternal` being updated. */
  patch: AttendeeExternalPatch;
};

/** The output of our update `AttendeeExternal` mutation. */
export type UpdateAttendeeExternalPayload = {
  __typename?: 'UpdateAttendeeExternalPayload';
  /** The `AttendeeExternal` that was updated by this mutation. */
  attendeeExternal: Maybe<AttendeeExternal>;
  /** An edge for our `AttendeeExternal`. May be used by Relay 1. */
  attendeeExternalEdge: Maybe<AttendeeExternalsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Event` that is related to this `AttendeeExternal`. */
  event: Maybe<Event>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `AttendeeExternal`. */
  userByConfirmedBy: Maybe<User>;
  /** Reads a single `User` that is related to this `AttendeeExternal`. */
  userByManagedBy: Maybe<User>;
};


/** The output of our update `AttendeeExternal` mutation. */
export type UpdateAttendeeExternalPayloadAttendeeExternalEdgeArgs = {
  orderBy?: InputMaybe<Array<AttendeeExternalsOrderBy>>;
};

/** All input for the `updateAttendeeUserByNodeId` mutation. */
export type UpdateAttendeeUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `AttendeeUser` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `AttendeeUser` being updated. */
  patch: AttendeeUserPatch;
};

/** All input for the `updateAttendeeUserByUserIdAndEventId` mutation. */
export type UpdateAttendeeUserByUserIdAndEventIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  eventId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `AttendeeUser` being updated. */
  patch: AttendeeUserPatch;
  userId: Scalars['BigInt'];
};

/** All input for the `updateAttendeeUser` mutation. */
export type UpdateAttendeeUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `AttendeeUser` being updated. */
  patch: AttendeeUserPatch;
};

/** The output of our update `AttendeeUser` mutation. */
export type UpdateAttendeeUserPayload = {
  __typename?: 'UpdateAttendeeUserPayload';
  /** The `AttendeeUser` that was updated by this mutation. */
  attendeeUser: Maybe<AttendeeUser>;
  /** An edge for our `AttendeeUser`. May be used by Relay 1. */
  attendeeUserEdge: Maybe<AttendeeUsersEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Event` that is related to this `AttendeeUser`. */
  event: Maybe<Event>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `AttendeeUser`. */
  user: Maybe<User>;
};


/** The output of our update `AttendeeUser` mutation. */
export type UpdateAttendeeUserPayloadAttendeeUserEdgeArgs = {
  orderBy?: InputMaybe<Array<AttendeeUsersOrderBy>>;
};

/** All input for the `updateCohortGroupByNodeId` mutation. */
export type UpdateCohortGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CohortGroup` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CohortGroup` being updated. */
  patch: CohortGroupPatch;
};

/** All input for the `updateCohortGroup` mutation. */
export type UpdateCohortGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `CohortGroup` being updated. */
  patch: CohortGroupPatch;
};

/** The output of our update `CohortGroup` mutation. */
export type UpdateCohortGroupPayload = {
  __typename?: 'UpdateCohortGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `CohortGroup` that was updated by this mutation. */
  cohortGroup: Maybe<CohortGroup>;
  /** An edge for our `CohortGroup`. May be used by Relay 1. */
  cohortGroupEdge: Maybe<CohortGroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `CohortGroup`. */
  tenantByTenant: Maybe<Tenant>;
};


/** The output of our update `CohortGroup` mutation. */
export type UpdateCohortGroupPayloadCohortGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<CohortGroupsOrderBy>>;
};

/** All input for the `updateDokumentyByNodeId` mutation. */
export type UpdateDokumentyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Dokumenty` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Dokumenty` being updated. */
  patch: DokumentyPatch;
};

/** All input for the `updateDokumenty` mutation. */
export type UpdateDokumentyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  dId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `Dokumenty` being updated. */
  patch: DokumentyPatch;
};

/** The output of our update `Dokumenty` mutation. */
export type UpdateDokumentyPayload = {
  __typename?: 'UpdateDokumentyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Dokumenty` that was updated by this mutation. */
  dokumenty: Maybe<Dokumenty>;
  /** An edge for our `Dokumenty`. May be used by Relay 1. */
  dokumentyEdge: Maybe<DokumentiesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Dokumenty`. */
  userByDKdo: Maybe<User>;
};


/** The output of our update `Dokumenty` mutation. */
export type UpdateDokumentyPayloadDokumentyEdgeArgs = {
  orderBy?: InputMaybe<Array<DokumentiesOrderBy>>;
};

/** All input for the `updateEventByNodeId` mutation. */
export type UpdateEventByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Event` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Event` being updated. */
  patch: EventPatch;
};

/** All input for the `updateEvent` mutation. */
export type UpdateEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `Event` being updated. */
  patch: EventPatch;
};

/** The output of our update `Event` mutation. */
export type UpdateEventPayload = {
  __typename?: 'UpdateEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Event` that was updated by this mutation. */
  event: Maybe<Event>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge: Maybe<EventsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Event` mutation. */
export type UpdateEventPayloadEventEdgeArgs = {
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};

/** All input for the `updateFormResponseByNodeId` mutation. */
export type UpdateFormResponseByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `FormResponse` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `FormResponse` being updated. */
  patch: FormResponsePatch;
};

/** All input for the `updateFormResponse` mutation. */
export type UpdateFormResponseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `FormResponse` being updated. */
  patch: FormResponsePatch;
};

/** The output of our update `FormResponse` mutation. */
export type UpdateFormResponsePayload = {
  __typename?: 'UpdateFormResponsePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `FormResponse` that was updated by this mutation. */
  formResponse: Maybe<FormResponse>;
  /** An edge for our `FormResponse`. May be used by Relay 1. */
  formResponseEdge: Maybe<FormResponsesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `FormResponse` mutation. */
export type UpdateFormResponsePayloadFormResponseEdgeArgs = {
  orderBy?: InputMaybe<Array<FormResponsesOrderBy>>;
};

/** All input for the `updateGalerieDirByNodeId` mutation. */
export type UpdateGalerieDirByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GalerieDir` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `GalerieDir` being updated. */
  patch: GalerieDirPatch;
};

/** All input for the `updateGalerieDir` mutation. */
export type UpdateGalerieDirInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  gdId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `GalerieDir` being updated. */
  patch: GalerieDirPatch;
};

/** The output of our update `GalerieDir` mutation. */
export type UpdateGalerieDirPayload = {
  __typename?: 'UpdateGalerieDirPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GalerieDir` that was updated by this mutation. */
  galerieDir: Maybe<GalerieDir>;
  /** An edge for our `GalerieDir`. May be used by Relay 1. */
  galerieDirEdge: Maybe<GalerieDirsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `GalerieDir` mutation. */
export type UpdateGalerieDirPayloadGalerieDirEdgeArgs = {
  orderBy?: InputMaybe<Array<GalerieDirsOrderBy>>;
};

/** All input for the `updateGalerieFotoByNodeId` mutation. */
export type UpdateGalerieFotoByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GalerieFoto` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `GalerieFoto` being updated. */
  patch: GalerieFotoPatch;
};

/** All input for the `updateGalerieFoto` mutation. */
export type UpdateGalerieFotoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  gfId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `GalerieFoto` being updated. */
  patch: GalerieFotoPatch;
};

/** The output of our update `GalerieFoto` mutation. */
export type UpdateGalerieFotoPayload = {
  __typename?: 'UpdateGalerieFotoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
  galerieDirByGfIdRodic: Maybe<GalerieDir>;
  /** The `GalerieFoto` that was updated by this mutation. */
  galerieFoto: Maybe<GalerieFoto>;
  /** An edge for our `GalerieFoto`. May be used by Relay 1. */
  galerieFotoEdge: Maybe<GalerieFotosEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `GalerieFoto`. */
  userByGfKdo: Maybe<User>;
};


/** The output of our update `GalerieFoto` mutation. */
export type UpdateGalerieFotoPayloadGalerieFotoEdgeArgs = {
  orderBy?: InputMaybe<Array<GalerieFotosOrderBy>>;
};

/** All input for the `updateLocationAttachmentByNodeId` mutation. */
export type UpdateLocationAttachmentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LocationAttachment` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `LocationAttachment` being updated. */
  patch: LocationAttachmentPatch;
};

/** All input for the `updateLocationAttachment` mutation. */
export type UpdateLocationAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  locationId: Scalars['BigInt'];
  objectName: Scalars['String'];
  /** An object where the defined keys will be set on the `LocationAttachment` being updated. */
  patch: LocationAttachmentPatch;
};

/** The output of our update `LocationAttachment` mutation. */
export type UpdateLocationAttachmentPayload = {
  __typename?: 'UpdateLocationAttachmentPayload';
  /** Reads a single `Attachment` that is related to this `LocationAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Location` that is related to this `LocationAttachment`. */
  location: Maybe<Location>;
  /** The `LocationAttachment` that was updated by this mutation. */
  locationAttachment: Maybe<LocationAttachment>;
  /** An edge for our `LocationAttachment`. May be used by Relay 1. */
  locationAttachmentEdge: Maybe<LocationAttachmentsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `LocationAttachment` mutation. */
export type UpdateLocationAttachmentPayloadLocationAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<LocationAttachmentsOrderBy>>;
};

/** All input for the `updateLocationByNodeId` mutation. */
export type UpdateLocationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Location` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Location` being updated. */
  patch: LocationPatch;
};

/** All input for the `updateLocation` mutation. */
export type UpdateLocationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `Location` being updated. */
  patch: LocationPatch;
};

/** The output of our update `Location` mutation. */
export type UpdateLocationPayload = {
  __typename?: 'UpdateLocationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Location` that was updated by this mutation. */
  location: Maybe<Location>;
  /** An edge for our `Location`. May be used by Relay 1. */
  locationEdge: Maybe<LocationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `Location`. */
  tenantByTenant: Maybe<Tenant>;
};


/** The output of our update `Location` mutation. */
export type UpdateLocationPayloadLocationEdgeArgs = {
  orderBy?: InputMaybe<Array<LocationsOrderBy>>;
};

/** All input for the `updateNabidkaByNodeId` mutation. */
export type UpdateNabidkaByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Nabidka` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Nabidka` being updated. */
  patch: NabidkaPatch;
};

/** All input for the `updateNabidka` mutation. */
export type UpdateNabidkaInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  nId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `Nabidka` being updated. */
  patch: NabidkaPatch;
};

/** All input for the `updateNabidkaItemByNiPartnerAndNiIdRodic` mutation. */
export type UpdateNabidkaItemByNiPartnerAndNiIdRodicInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  niIdRodic: Scalars['BigInt'];
  niPartner: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `NabidkaItem` being updated. */
  patch: NabidkaItemPatch;
};

/** All input for the `updateNabidkaItemByNodeId` mutation. */
export type UpdateNabidkaItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `NabidkaItem` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `NabidkaItem` being updated. */
  patch: NabidkaItemPatch;
};

/** All input for the `updateNabidkaItem` mutation. */
export type UpdateNabidkaItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  niId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `NabidkaItem` being updated. */
  patch: NabidkaItemPatch;
};

/** The output of our update `NabidkaItem` mutation. */
export type UpdateNabidkaItemPayload = {
  __typename?: 'UpdateNabidkaItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Nabidka` that is related to this `NabidkaItem`. */
  nabidkaByNiIdRodic: Maybe<Nabidka>;
  /** The `NabidkaItem` that was updated by this mutation. */
  nabidkaItem: Maybe<NabidkaItem>;
  /** An edge for our `NabidkaItem`. May be used by Relay 1. */
  nabidkaItemEdge: Maybe<NabidkaItemsEdge>;
  /** Reads a single `Pary` that is related to this `NabidkaItem`. */
  paryByNiPartner: Maybe<Pary>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `NabidkaItem` mutation. */
export type UpdateNabidkaItemPayloadNabidkaItemEdgeArgs = {
  orderBy?: InputMaybe<Array<NabidkaItemsOrderBy>>;
};

/** The output of our update `Nabidka` mutation. */
export type UpdateNabidkaPayload = {
  __typename?: 'UpdateNabidkaPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Nabidka` that was updated by this mutation. */
  nabidka: Maybe<Nabidka>;
  /** An edge for our `Nabidka`. May be used by Relay 1. */
  nabidkaEdge: Maybe<NabidkasEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Nabidka`. */
  userByNTrener: Maybe<User>;
};


/** The output of our update `Nabidka` mutation. */
export type UpdateNabidkaPayloadNabidkaEdgeArgs = {
  orderBy?: InputMaybe<Array<NabidkasOrderBy>>;
};

/** All input for the `updatePageByNodeId` mutation. */
export type UpdatePageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Page` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Page` being updated. */
  patch: PagePatch;
};

/** All input for the `updatePageByUrl` mutation. */
export type UpdatePageByUrlInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Page` being updated. */
  patch: PagePatch;
  url: Scalars['String'];
};

/** All input for the `updatePage` mutation. */
export type UpdatePageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `Page` being updated. */
  patch: PagePatch;
};

/** The output of our update `Page` mutation. */
export type UpdatePagePayload = {
  __typename?: 'UpdatePagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Page` that was updated by this mutation. */
  page: Maybe<Page>;
  /** An edge for our `Page`. May be used by Relay 1. */
  pageEdge: Maybe<PagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Page` mutation. */
export type UpdatePagePayloadPageEdgeArgs = {
  orderBy?: InputMaybe<Array<PagesOrderBy>>;
};

/** All input for the `updateParameterByNodeId` mutation. */
export type UpdateParameterByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Parameter` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Parameter` being updated. */
  patch: ParameterPatch;
};

/** All input for the `updateParameter` mutation. */
export type UpdateParameterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  paName: Scalars['String'];
  /** An object where the defined keys will be set on the `Parameter` being updated. */
  patch: ParameterPatch;
};

/** The output of our update `Parameter` mutation. */
export type UpdateParameterPayload = {
  __typename?: 'UpdateParameterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Parameter` that was updated by this mutation. */
  parameter: Maybe<Parameter>;
  /** An edge for our `Parameter`. May be used by Relay 1. */
  parameterEdge: Maybe<ParametersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Parameter` mutation. */
export type UpdateParameterPayloadParameterEdgeArgs = {
  orderBy?: InputMaybe<Array<ParametersOrderBy>>;
};

/** All input for the `updateParyByNodeId` mutation. */
export type UpdateParyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Pary` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Pary` being updated. */
  patch: ParyPatch;
};

/** All input for the `updatePary` mutation. */
export type UpdateParyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  pId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `Pary` being updated. */
  patch: ParyPatch;
};

/** All input for the `updateParyNavrhByNodeId` mutation. */
export type UpdateParyNavrhByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ParyNavrh` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ParyNavrh` being updated. */
  patch: ParyNavrhPatch;
};

/** All input for the `updateParyNavrh` mutation. */
export type UpdateParyNavrhInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ParyNavrh` being updated. */
  patch: ParyNavrhPatch;
  pnId: Scalars['BigInt'];
};

/** The output of our update `ParyNavrh` mutation. */
export type UpdateParyNavrhPayload = {
  __typename?: 'UpdateParyNavrhPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ParyNavrh` that was updated by this mutation. */
  paryNavrh: Maybe<ParyNavrh>;
  /** An edge for our `ParyNavrh`. May be used by Relay 1. */
  paryNavrhEdge: Maybe<ParyNavrhsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnNavrhl: Maybe<User>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnPartnerka: Maybe<User>;
};


/** The output of our update `ParyNavrh` mutation. */
export type UpdateParyNavrhPayloadParyNavrhEdgeArgs = {
  orderBy?: InputMaybe<Array<ParyNavrhsOrderBy>>;
};

/** The output of our update `Pary` mutation. */
export type UpdateParyPayload = {
  __typename?: 'UpdateParyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Pary` that was updated by this mutation. */
  pary: Maybe<Pary>;
  /** An edge for our `Pary`. May be used by Relay 1. */
  paryEdge: Maybe<PariesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartnerka: Maybe<User>;
};


/** The output of our update `Pary` mutation. */
export type UpdateParyPayloadParyEdgeArgs = {
  orderBy?: InputMaybe<Array<PariesOrderBy>>;
};

/** All input for the `updatePermissionByNodeId` mutation. */
export type UpdatePermissionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Permission` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Permission` being updated. */
  patch: PermissionPatch;
};

/** All input for the `updatePermission` mutation. */
export type UpdatePermissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Permission` being updated. */
  patch: PermissionPatch;
  peId: Scalars['BigInt'];
};

/** The output of our update `Permission` mutation. */
export type UpdatePermissionPayload = {
  __typename?: 'UpdatePermissionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Permission` that was updated by this mutation. */
  permission: Maybe<Permission>;
  /** An edge for our `Permission`. May be used by Relay 1. */
  permissionEdge: Maybe<PermissionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Permission` mutation. */
export type UpdatePermissionPayloadPermissionEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
};

/** All input for the `updatePersonByNodeId` mutation. */
export type UpdatePersonByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Person` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Person` being updated. */
  patch: PersonPatch;
};

/** All input for the `updatePerson` mutation. */
export type UpdatePersonInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `Person` being updated. */
  patch: PersonPatch;
};

/** The output of our update `Person` mutation. */
export type UpdatePersonPayload = {
  __typename?: 'UpdatePersonPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Person` that was updated by this mutation. */
  person: Maybe<Person>;
  /** An edge for our `Person`. May be used by Relay 1. */
  personEdge: Maybe<PeopleEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Person` mutation. */
export type UpdatePersonPayloadPersonEdgeArgs = {
  orderBy?: InputMaybe<Array<PeopleOrderBy>>;
};

/** All input for the `updatePlatbyCategoryByNodeId` mutation. */
export type UpdatePlatbyCategoryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyCategory` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PlatbyCategory` being updated. */
  patch: PlatbyCategoryPatch;
};

/** All input for the `updatePlatbyCategoryGroupByNodeId` mutation. */
export type UpdatePlatbyCategoryGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyCategoryGroup` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PlatbyCategoryGroup` being updated. */
  patch: PlatbyCategoryGroupPatch;
};

/** All input for the `updatePlatbyCategoryGroup` mutation. */
export type UpdatePlatbyCategoryGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PlatbyCategoryGroup` being updated. */
  patch: PlatbyCategoryGroupPatch;
  pcgId: Scalars['BigInt'];
};

/** The output of our update `PlatbyCategoryGroup` mutation. */
export type UpdatePlatbyCategoryGroupPayload = {
  __typename?: 'UpdatePlatbyCategoryGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyCategoryGroup`. */
  platbyCategoryByPcgIdCategory: Maybe<PlatbyCategory>;
  /** The `PlatbyCategoryGroup` that was updated by this mutation. */
  platbyCategoryGroup: Maybe<PlatbyCategoryGroup>;
  /** An edge for our `PlatbyCategoryGroup`. May be used by Relay 1. */
  platbyCategoryGroupEdge: Maybe<PlatbyCategoryGroupsEdge>;
  /** Reads a single `PlatbyGroup` that is related to this `PlatbyCategoryGroup`. */
  platbyGroupByPcgIdGroup: Maybe<PlatbyGroup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `PlatbyCategoryGroup` mutation. */
export type UpdatePlatbyCategoryGroupPayloadPlatbyCategoryGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyCategoryGroupsOrderBy>>;
};

/** All input for the `updatePlatbyCategory` mutation. */
export type UpdatePlatbyCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PlatbyCategory` being updated. */
  patch: PlatbyCategoryPatch;
  pcId: Scalars['BigInt'];
};

/** The output of our update `PlatbyCategory` mutation. */
export type UpdatePlatbyCategoryPayload = {
  __typename?: 'UpdatePlatbyCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlatbyCategory` that was updated by this mutation. */
  platbyCategory: Maybe<PlatbyCategory>;
  /** An edge for our `PlatbyCategory`. May be used by Relay 1. */
  platbyCategoryEdge: Maybe<PlatbyCategoriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `PlatbyCategory` mutation. */
export type UpdatePlatbyCategoryPayloadPlatbyCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyCategoriesOrderBy>>;
};

/** All input for the `updatePlatbyGroupByNodeId` mutation. */
export type UpdatePlatbyGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyGroup` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PlatbyGroup` being updated. */
  patch: PlatbyGroupPatch;
};

/** All input for the `updatePlatbyGroup` mutation. */
export type UpdatePlatbyGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PlatbyGroup` being updated. */
  patch: PlatbyGroupPatch;
  pgId: Scalars['BigInt'];
};

/** The output of our update `PlatbyGroup` mutation. */
export type UpdatePlatbyGroupPayload = {
  __typename?: 'UpdatePlatbyGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlatbyGroup` that was updated by this mutation. */
  platbyGroup: Maybe<PlatbyGroup>;
  /** An edge for our `PlatbyGroup`. May be used by Relay 1. */
  platbyGroupEdge: Maybe<PlatbyGroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `PlatbyGroup` mutation. */
export type UpdatePlatbyGroupPayloadPlatbyGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyGroupsOrderBy>>;
};

/** All input for the `updatePlatbyGroupSkupinaByNodeId` mutation. */
export type UpdatePlatbyGroupSkupinaByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyGroupSkupina` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PlatbyGroupSkupina` being updated. */
  patch: PlatbyGroupSkupinaPatch;
};

/** All input for the `updatePlatbyGroupSkupina` mutation. */
export type UpdatePlatbyGroupSkupinaInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PlatbyGroupSkupina` being updated. */
  patch: PlatbyGroupSkupinaPatch;
  pgsId: Scalars['BigInt'];
};

/** The output of our update `PlatbyGroupSkupina` mutation. */
export type UpdatePlatbyGroupSkupinaPayload = {
  __typename?: 'UpdatePlatbyGroupSkupinaPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `PlatbyGroup` that is related to this `PlatbyGroupSkupina`. */
  platbyGroupByPgsIdGroup: Maybe<PlatbyGroup>;
  /** The `PlatbyGroupSkupina` that was updated by this mutation. */
  platbyGroupSkupina: Maybe<PlatbyGroupSkupina>;
  /** An edge for our `PlatbyGroupSkupina`. May be used by Relay 1. */
  platbyGroupSkupinaEdge: Maybe<PlatbyGroupSkupinasEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `PlatbyGroupSkupina`. */
  skupinyByPgsIdSkupina: Maybe<Skupiny>;
};


/** The output of our update `PlatbyGroupSkupina` mutation. */
export type UpdatePlatbyGroupSkupinaPayloadPlatbyGroupSkupinaEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyGroupSkupinasOrderBy>>;
};

/** All input for the `updatePlatbyItemByNodeId` mutation. */
export type UpdatePlatbyItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyItem` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PlatbyItem` being updated. */
  patch: PlatbyItemPatch;
};

/** All input for the `updatePlatbyItem` mutation. */
export type UpdatePlatbyItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PlatbyItem` being updated. */
  patch: PlatbyItemPatch;
  piId: Scalars['BigInt'];
};

/** The output of our update `PlatbyItem` mutation. */
export type UpdatePlatbyItemPayload = {
  __typename?: 'UpdatePlatbyItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
  platbyCategoryByPiIdCategory: Maybe<PlatbyCategory>;
  /** The `PlatbyItem` that was updated by this mutation. */
  platbyItem: Maybe<PlatbyItem>;
  /** An edge for our `PlatbyItem`. May be used by Relay 1. */
  platbyItemEdge: Maybe<PlatbyItemsEdge>;
  /** Reads a single `PlatbyRaw` that is related to this `PlatbyItem`. */
  platbyRawByPiIdRaw: Maybe<PlatbyRaw>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `PlatbyItem`. */
  userByPiIdUser: Maybe<User>;
};


/** The output of our update `PlatbyItem` mutation. */
export type UpdatePlatbyItemPayloadPlatbyItemEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyItemsOrderBy>>;
};

/** All input for the `updatePlatbyRawByNodeId` mutation. */
export type UpdatePlatbyRawByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyRaw` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PlatbyRaw` being updated. */
  patch: PlatbyRawPatch;
};

/** All input for the `updatePlatbyRaw` mutation. */
export type UpdatePlatbyRawInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PlatbyRaw` being updated. */
  patch: PlatbyRawPatch;
  prId: Scalars['BigInt'];
};

/** The output of our update `PlatbyRaw` mutation. */
export type UpdatePlatbyRawPayload = {
  __typename?: 'UpdatePlatbyRawPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlatbyRaw` that was updated by this mutation. */
  platbyRaw: Maybe<PlatbyRaw>;
  /** An edge for our `PlatbyRaw`. May be used by Relay 1. */
  platbyRawEdge: Maybe<PlatbyRawsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `PlatbyRaw` mutation. */
export type UpdatePlatbyRawPayloadPlatbyRawEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyRawsOrderBy>>;
};

/** All input for the `updateRoomAttachmentByNodeId` mutation. */
export type UpdateRoomAttachmentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `RoomAttachment` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `RoomAttachment` being updated. */
  patch: RoomAttachmentPatch;
};

/** All input for the `updateRoomAttachment` mutation. */
export type UpdateRoomAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  objectName: Scalars['String'];
  /** An object where the defined keys will be set on the `RoomAttachment` being updated. */
  patch: RoomAttachmentPatch;
  roomId: Scalars['BigInt'];
};

/** The output of our update `RoomAttachment` mutation. */
export type UpdateRoomAttachmentPayload = {
  __typename?: 'UpdateRoomAttachmentPayload';
  /** Reads a single `Attachment` that is related to this `RoomAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Room` that is related to this `RoomAttachment`. */
  room: Maybe<Room>;
  /** The `RoomAttachment` that was updated by this mutation. */
  roomAttachment: Maybe<RoomAttachment>;
  /** An edge for our `RoomAttachment`. May be used by Relay 1. */
  roomAttachmentEdge: Maybe<RoomAttachmentsEdge>;
};


/** The output of our update `RoomAttachment` mutation. */
export type UpdateRoomAttachmentPayloadRoomAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<RoomAttachmentsOrderBy>>;
};

/** All input for the `updateRoomByNodeId` mutation. */
export type UpdateRoomByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Room` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Room` being updated. */
  patch: RoomPatch;
};

/** All input for the `updateRoom` mutation. */
export type UpdateRoomInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `Room` being updated. */
  patch: RoomPatch;
};

/** The output of our update `Room` mutation. */
export type UpdateRoomPayload = {
  __typename?: 'UpdateRoomPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Location` that is related to this `Room`. */
  locationByLocation: Maybe<Location>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Room` that was updated by this mutation. */
  room: Maybe<Room>;
  /** An edge for our `Room`. May be used by Relay 1. */
  roomEdge: Maybe<RoomsEdge>;
};


/** The output of our update `Room` mutation. */
export type UpdateRoomPayloadRoomEdgeArgs = {
  orderBy?: InputMaybe<Array<RoomsOrderBy>>;
};

/** All input for the `updateRozpiByNodeId` mutation. */
export type UpdateRozpiByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Rozpi` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Rozpi` being updated. */
  patch: RozpiPatch;
};

/** All input for the `updateRozpi` mutation. */
export type UpdateRozpiInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Rozpi` being updated. */
  patch: RozpiPatch;
  rId: Scalars['BigInt'];
};

/** The output of our update `Rozpi` mutation. */
export type UpdateRozpiPayload = {
  __typename?: 'UpdateRozpiPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Rozpi` that was updated by this mutation. */
  rozpi: Maybe<Rozpi>;
  /** An edge for our `Rozpi`. May be used by Relay 1. */
  rozpiEdge: Maybe<RozpisEdge>;
  /** Reads a single `User` that is related to this `Rozpi`. */
  userByRTrener: Maybe<User>;
};


/** The output of our update `Rozpi` mutation. */
export type UpdateRozpiPayloadRozpiEdgeArgs = {
  orderBy?: InputMaybe<Array<RozpisOrderBy>>;
};

/** All input for the `updateRozpisItemByNodeId` mutation. */
export type UpdateRozpisItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `RozpisItem` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `RozpisItem` being updated. */
  patch: RozpisItemPatch;
};

/** All input for the `updateRozpisItem` mutation. */
export type UpdateRozpisItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `RozpisItem` being updated. */
  patch: RozpisItemPatch;
  riId: Scalars['BigInt'];
};

/** The output of our update `RozpisItem` mutation. */
export type UpdateRozpisItemPayload = {
  __typename?: 'UpdateRozpisItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Pary` that is related to this `RozpisItem`. */
  paryByRiPartner: Maybe<Pary>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Rozpi` that is related to this `RozpisItem`. */
  rozpiByRiIdRodic: Maybe<Rozpi>;
  /** The `RozpisItem` that was updated by this mutation. */
  rozpisItem: Maybe<RozpisItem>;
  /** An edge for our `RozpisItem`. May be used by Relay 1. */
  rozpisItemEdge: Maybe<RozpisItemsEdge>;
};


/** The output of our update `RozpisItem` mutation. */
export type UpdateRozpisItemPayloadRozpisItemEdgeArgs = {
  orderBy?: InputMaybe<Array<RozpisItemsOrderBy>>;
};

/** All input for the `updateSessionByNodeId` mutation. */
export type UpdateSessionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Session` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Session` being updated. */
  patch: SessionPatch;
};

/** All input for the `updateSession` mutation. */
export type UpdateSessionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Session` being updated. */
  patch: SessionPatch;
  ssId: Scalars['String'];
};

/** The output of our update `Session` mutation. */
export type UpdateSessionPayload = {
  __typename?: 'UpdateSessionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Session` that was updated by this mutation. */
  session: Maybe<Session>;
  /** An edge for our `Session`. May be used by Relay 1. */
  sessionEdge: Maybe<SessionsEdge>;
  /** Reads a single `User` that is related to this `Session`. */
  userBySsUser: Maybe<User>;
};


/** The output of our update `Session` mutation. */
export type UpdateSessionPayloadSessionEdgeArgs = {
  orderBy?: InputMaybe<Array<SessionsOrderBy>>;
};

/** All input for the `updateSkupinyByNodeId` mutation. */
export type UpdateSkupinyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Skupiny` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Skupiny` being updated. */
  patch: SkupinyPatch;
};

/** All input for the `updateSkupiny` mutation. */
export type UpdateSkupinyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Skupiny` being updated. */
  patch: SkupinyPatch;
  sId: Scalars['BigInt'];
};

/** The output of our update `Skupiny` mutation. */
export type UpdateSkupinyPayload = {
  __typename?: 'UpdateSkupinyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `CohortGroup` that is related to this `Skupiny`. */
  cohortGroupByCohortGroup: Maybe<CohortGroup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Skupiny` that was updated by this mutation. */
  skupiny: Maybe<Skupiny>;
  /** An edge for our `Skupiny`. May be used by Relay 1. */
  skupinyEdge: Maybe<SkupiniesEdge>;
};


/** The output of our update `Skupiny` mutation. */
export type UpdateSkupinyPayloadSkupinyEdgeArgs = {
  orderBy?: InputMaybe<Array<SkupiniesOrderBy>>;
};

/** All input for the `updateTenantAttachmentByNodeId` mutation. */
export type UpdateTenantAttachmentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TenantAttachment` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `TenantAttachment` being updated. */
  patch: TenantAttachmentPatch;
};

/** All input for the `updateTenantAttachment` mutation. */
export type UpdateTenantAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  objectName: Scalars['String'];
  /** An object where the defined keys will be set on the `TenantAttachment` being updated. */
  patch: TenantAttachmentPatch;
  tenantId: Scalars['BigInt'];
};

/** The output of our update `TenantAttachment` mutation. */
export type UpdateTenantAttachmentPayload = {
  __typename?: 'UpdateTenantAttachmentPayload';
  /** Reads a single `Attachment` that is related to this `TenantAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `TenantAttachment`. */
  tenant: Maybe<Tenant>;
  /** The `TenantAttachment` that was updated by this mutation. */
  tenantAttachment: Maybe<TenantAttachment>;
  /** An edge for our `TenantAttachment`. May be used by Relay 1. */
  tenantAttachmentEdge: Maybe<TenantAttachmentsEdge>;
};


/** The output of our update `TenantAttachment` mutation. */
export type UpdateTenantAttachmentPayloadTenantAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<TenantAttachmentsOrderBy>>;
};

/** All input for the `updateTenantByNodeId` mutation. */
export type UpdateTenantByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Tenant` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Tenant` being updated. */
  patch: TenantPatch;
};

/** All input for the `updateTenant` mutation. */
export type UpdateTenantInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `Tenant` being updated. */
  patch: TenantPatch;
};

/** The output of our update `Tenant` mutation. */
export type UpdateTenantPayload = {
  __typename?: 'UpdateTenantPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Tenant` that was updated by this mutation. */
  tenant: Maybe<Tenant>;
  /** An edge for our `Tenant`. May be used by Relay 1. */
  tenantEdge: Maybe<TenantsEdge>;
};


/** The output of our update `Tenant` mutation. */
export type UpdateTenantPayloadTenantEdgeArgs = {
  orderBy?: InputMaybe<Array<TenantsOrderBy>>;
};

/** All input for the `updateTenantPersonByNodeId` mutation. */
export type UpdateTenantPersonByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TenantPerson` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `TenantPerson` being updated. */
  patch: TenantPersonPatch;
};

/** All input for the `updateTenantPerson` mutation. */
export type UpdateTenantPersonInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `TenantPerson` being updated. */
  patch: TenantPersonPatch;
  personId: Scalars['BigInt'];
  tenantId: Scalars['BigInt'];
};

/** The output of our update `TenantPerson` mutation. */
export type UpdateTenantPersonPayload = {
  __typename?: 'UpdateTenantPersonPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Person` that is related to this `TenantPerson`. */
  person: Maybe<Person>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `TenantPerson`. */
  tenant: Maybe<Tenant>;
  /** The `TenantPerson` that was updated by this mutation. */
  tenantPerson: Maybe<TenantPerson>;
  /** An edge for our `TenantPerson`. May be used by Relay 1. */
  tenantPersonEdge: Maybe<TenantPeopleEdge>;
};


/** The output of our update `TenantPerson` mutation. */
export type UpdateTenantPersonPayloadTenantPersonEdgeArgs = {
  orderBy?: InputMaybe<Array<TenantPeopleOrderBy>>;
};

/** All input for the `updateUpozorneniByNodeId` mutation. */
export type UpdateUpozorneniByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Upozorneni` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Upozorneni` being updated. */
  patch: UpozorneniPatch;
};

/** All input for the `updateUpozorneni` mutation. */
export type UpdateUpozorneniInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Upozorneni` being updated. */
  patch: UpozorneniPatch;
  upId: Scalars['BigInt'];
};

/** The output of our update `Upozorneni` mutation. */
export type UpdateUpozorneniPayload = {
  __typename?: 'UpdateUpozorneniPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Upozorneni` that was updated by this mutation. */
  upozorneni: Maybe<Upozorneni>;
  /** An edge for our `Upozorneni`. May be used by Relay 1. */
  upozorneniEdge: Maybe<UpozornenisEdge>;
  /** Reads a single `User` that is related to this `Upozorneni`. */
  userByUpKdo: Maybe<User>;
};


/** The output of our update `Upozorneni` mutation. */
export type UpdateUpozorneniPayloadUpozorneniEdgeArgs = {
  orderBy?: InputMaybe<Array<UpozornenisOrderBy>>;
};

/** All input for the `updateUpozorneniSkupinyByNodeId` mutation. */
export type UpdateUpozorneniSkupinyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `UpozorneniSkupiny` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `UpozorneniSkupiny` being updated. */
  patch: UpozorneniSkupinyPatch;
};

/** All input for the `updateUpozorneniSkupiny` mutation. */
export type UpdateUpozorneniSkupinyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `UpozorneniSkupiny` being updated. */
  patch: UpozorneniSkupinyPatch;
  upsId: Scalars['BigInt'];
};

/** The output of our update `UpozorneniSkupiny` mutation. */
export type UpdateUpozorneniSkupinyPayload = {
  __typename?: 'UpdateUpozorneniSkupinyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
  skupinyByUpsIdSkupina: Maybe<Skupiny>;
  /** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
  upozorneniByUpsIdRodic: Maybe<Upozorneni>;
  /** The `UpozorneniSkupiny` that was updated by this mutation. */
  upozorneniSkupiny: Maybe<UpozorneniSkupiny>;
  /** An edge for our `UpozorneniSkupiny`. May be used by Relay 1. */
  upozorneniSkupinyEdge: Maybe<UpozorneniSkupiniesEdge>;
};


/** The output of our update `UpozorneniSkupiny` mutation. */
export type UpdateUpozorneniSkupinyPayloadUpozorneniSkupinyEdgeArgs = {
  orderBy?: InputMaybe<Array<UpozorneniSkupiniesOrderBy>>;
};

/** All input for the `updateUserByNodeId` mutation. */
export type UpdateUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `User` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
};

/** All input for the `updateUser` mutation. */
export type UpdateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
  uId: Scalars['BigInt'];
};

/** The output of our update `User` mutation. */
export type UpdateUserPayload = {
  __typename?: 'UpdateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Permission` that is related to this `User`. */
  permissionByUGroup: Maybe<Permission>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `User`. */
  skupinyByUSkupina: Maybe<Skupiny>;
  /** The `User` that was updated by this mutation. */
  user: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge: Maybe<UsersEdge>;
};


/** The output of our update `User` mutation. */
export type UpdateUserPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the `updateVideoByNodeId` mutation. */
export type UpdateVideoByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Video` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Video` being updated. */
  patch: VideoPatch;
};

/** All input for the `updateVideo` mutation. */
export type UpdateVideoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Video` being updated. */
  patch: VideoPatch;
  vId: Scalars['BigInt'];
};

/** All input for the `updateVideoListByNodeId` mutation. */
export type UpdateVideoListByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `VideoList` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `VideoList` being updated. */
  patch: VideoListPatch;
};

/** All input for the `updateVideoList` mutation. */
export type UpdateVideoListInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `VideoList` being updated. */
  patch: VideoListPatch;
  vlId: Scalars['BigInt'];
};

/** The output of our update `VideoList` mutation. */
export type UpdateVideoListPayload = {
  __typename?: 'UpdateVideoListPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `VideoList` that was updated by this mutation. */
  videoList: Maybe<VideoList>;
  /** An edge for our `VideoList`. May be used by Relay 1. */
  videoListEdge: Maybe<VideoListsEdge>;
};


/** The output of our update `VideoList` mutation. */
export type UpdateVideoListPayloadVideoListEdgeArgs = {
  orderBy?: InputMaybe<Array<VideoListsOrderBy>>;
};

/** The output of our update `Video` mutation. */
export type UpdateVideoPayload = {
  __typename?: 'UpdateVideoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Video` that was updated by this mutation. */
  video: Maybe<Video>;
  /** An edge for our `Video`. May be used by Relay 1. */
  videoEdge: Maybe<VideosEdge>;
};


/** The output of our update `Video` mutation. */
export type UpdateVideoPayloadVideoEdgeArgs = {
  orderBy?: InputMaybe<Array<VideosOrderBy>>;
};

/** All input for the `updateVideoSourceByNodeId` mutation. */
export type UpdateVideoSourceByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `VideoSource` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `VideoSource` being updated. */
  patch: VideoSourcePatch;
};

/** All input for the `updateVideoSource` mutation. */
export type UpdateVideoSourceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `VideoSource` being updated. */
  patch: VideoSourcePatch;
  vsId: Scalars['BigInt'];
};

/** The output of our update `VideoSource` mutation. */
export type UpdateVideoSourcePayload = {
  __typename?: 'UpdateVideoSourcePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `VideoSource` that was updated by this mutation. */
  videoSource: Maybe<VideoSource>;
  /** An edge for our `VideoSource`. May be used by Relay 1. */
  videoSourceEdge: Maybe<VideoSourcesEdge>;
};


/** The output of our update `VideoSource` mutation. */
export type UpdateVideoSourcePayloadVideoSourceEdgeArgs = {
  orderBy?: InputMaybe<Array<VideoSourcesOrderBy>>;
};

export type UploadFilePayload = {
  __typename?: 'UploadFilePayload';
  objectName: Scalars['String'];
  uploadUrl: Scalars['String'];
};

export type Upozorneni = Node & {
  __typename?: 'Upozorneni';
  isVisible: Maybe<Scalars['Boolean']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  scheduledSince: Maybe<Scalars['Datetime']>;
  scheduledUntil: Maybe<Scalars['Datetime']>;
  upBarvy: Scalars['BigInt'];
  upId: Scalars['BigInt'];
  upKdo: Maybe<Scalars['BigInt']>;
  upLock: Scalars['Boolean'];
  upNadpis: Scalars['String'];
  upText: Scalars['String'];
  upTimestamp: Maybe<Scalars['Datetime']>;
  upTimestampAdd: Scalars['Datetime'];
  /** Reads and enables pagination through a set of `UpozorneniSkupiny`. */
  upozorneniSkupiniesByUpsIdRodic: UpozorneniSkupiniesConnection;
  /** Reads a single `User` that is related to this `Upozorneni`. */
  userByUpKdo: Maybe<User>;
};


export type UpozorneniUpozorneniSkupiniesByUpsIdRodicArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<UpozorneniSkupinyCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UpozorneniSkupiniesOrderBy>>;
};

/**
 * A condition to be used against `Upozorneni` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type UpozorneniCondition = {
  /** Checks for equality with the object’s `isVisible` field. */
  isVisible?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `scheduledSince` field. */
  scheduledSince?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `scheduledUntil` field. */
  scheduledUntil?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `upBarvy` field. */
  upBarvy?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `upId` field. */
  upId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `upKdo` field. */
  upKdo?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `upLock` field. */
  upLock?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `upNadpis` field. */
  upNadpis?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `upText` field. */
  upText?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `upTimestamp` field. */
  upTimestamp?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `upTimestampAdd` field. */
  upTimestampAdd?: InputMaybe<Scalars['Datetime']>;
};

/** An input for mutations affecting `Upozorneni` */
export type UpozorneniInput = {
  isVisible?: InputMaybe<Scalars['Boolean']>;
  scheduledSince?: InputMaybe<Scalars['Datetime']>;
  scheduledUntil?: InputMaybe<Scalars['Datetime']>;
  upBarvy?: InputMaybe<Scalars['BigInt']>;
  upId?: InputMaybe<Scalars['BigInt']>;
  upKdo?: InputMaybe<Scalars['BigInt']>;
  upLock?: InputMaybe<Scalars['Boolean']>;
  upNadpis: Scalars['String'];
  upText: Scalars['String'];
  upTimestamp?: InputMaybe<Scalars['Datetime']>;
  upTimestampAdd?: InputMaybe<Scalars['Datetime']>;
};

/** Represents an update to a `Upozorneni`. Fields that are set will be updated. */
export type UpozorneniPatch = {
  isVisible?: InputMaybe<Scalars['Boolean']>;
  scheduledSince?: InputMaybe<Scalars['Datetime']>;
  scheduledUntil?: InputMaybe<Scalars['Datetime']>;
  upBarvy?: InputMaybe<Scalars['BigInt']>;
  upId?: InputMaybe<Scalars['BigInt']>;
  upKdo?: InputMaybe<Scalars['BigInt']>;
  upLock?: InputMaybe<Scalars['Boolean']>;
  upNadpis?: InputMaybe<Scalars['String']>;
  upText?: InputMaybe<Scalars['String']>;
  upTimestamp?: InputMaybe<Scalars['Datetime']>;
  upTimestampAdd?: InputMaybe<Scalars['Datetime']>;
};

/** A connection to a list of `UpozorneniSkupiny` values. */
export type UpozorneniSkupiniesConnection = {
  __typename?: 'UpozorneniSkupiniesConnection';
  /** A list of edges which contains the `UpozorneniSkupiny` and cursor to aid in pagination. */
  edges: Array<UpozorneniSkupiniesEdge>;
  /** A list of `UpozorneniSkupiny` objects. */
  nodes: Array<UpozorneniSkupiny>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UpozorneniSkupiny` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `UpozorneniSkupiny` edge in the connection. */
export type UpozorneniSkupiniesEdge = {
  __typename?: 'UpozorneniSkupiniesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `UpozorneniSkupiny` at the end of the edge. */
  node: UpozorneniSkupiny;
};

/** Methods to use when ordering `UpozorneniSkupiny`. */
export type UpozorneniSkupiniesOrderBy =
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__COHORT_GROUP_ASC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__COHORT_GROUP_DESC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__INTERNAL_INFO_ASC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__INTERNAL_INFO_DESC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__ORDERING_ASC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__ORDERING_DESC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__S_COLOR_RGB_ASC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__S_COLOR_RGB_DESC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__S_COLOR_TEXT_ASC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__S_COLOR_TEXT_DESC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__S_DESCRIPTION_ASC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__S_DESCRIPTION_DESC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__S_ID_ASC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__S_ID_DESC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__S_LOCATION_ASC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__S_LOCATION_DESC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__S_NAME_ASC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__S_NAME_DESC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__S_VISIBLE_ASC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__S_VISIBLE_DESC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__IS_VISIBLE_ASC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__IS_VISIBLE_DESC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__SCHEDULED_SINCE_ASC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__SCHEDULED_SINCE_DESC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__SCHEDULED_UNTIL_ASC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__SCHEDULED_UNTIL_DESC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__UP_BARVY_ASC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__UP_BARVY_DESC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__UP_ID_ASC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__UP_ID_DESC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__UP_KDO_ASC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__UP_KDO_DESC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__UP_LOCK_ASC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__UP_LOCK_DESC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__UP_NADPIS_ASC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__UP_NADPIS_DESC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__UP_TEXT_ASC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__UP_TEXT_DESC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__UP_TIMESTAMP_ADD_ASC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__UP_TIMESTAMP_ADD_DESC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__UP_TIMESTAMP_ASC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__UP_TIMESTAMP_DESC'
  | 'UPS_COLOR_ASC'
  | 'UPS_COLOR_DESC'
  | 'UPS_ID_ASC'
  | 'UPS_ID_DESC'
  | 'UPS_ID_RODIC_ASC'
  | 'UPS_ID_RODIC_DESC'
  | 'UPS_ID_SKUPINA_ASC'
  | 'UPS_ID_SKUPINA_DESC'
  | 'UPS_POPIS_ASC'
  | 'UPS_POPIS_DESC';

export type UpozorneniSkupiny = Node & {
  __typename?: 'UpozorneniSkupiny';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
  skupinyByUpsIdSkupina: Maybe<Skupiny>;
  /** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
  upozorneniByUpsIdRodic: Maybe<Upozorneni>;
  upsColor: Scalars['String'];
  upsId: Scalars['BigInt'];
  upsIdRodic: Scalars['BigInt'];
  upsIdSkupina: Scalars['BigInt'];
  upsPopis: Scalars['String'];
};

/**
 * A condition to be used against `UpozorneniSkupiny` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type UpozorneniSkupinyCondition = {
  /** Checks for equality with the object’s `upsColor` field. */
  upsColor?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `upsId` field. */
  upsId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `upsIdRodic` field. */
  upsIdRodic?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `upsIdSkupina` field. */
  upsIdSkupina?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `upsPopis` field. */
  upsPopis?: InputMaybe<Scalars['String']>;
};

/** An input for mutations affecting `UpozorneniSkupiny` */
export type UpozorneniSkupinyInput = {
  upsColor: Scalars['String'];
  upsId?: InputMaybe<Scalars['BigInt']>;
  upsIdRodic: Scalars['BigInt'];
  upsIdSkupina: Scalars['BigInt'];
  upsPopis: Scalars['String'];
};

/** Represents an update to a `UpozorneniSkupiny`. Fields that are set will be updated. */
export type UpozorneniSkupinyPatch = {
  upsColor?: InputMaybe<Scalars['String']>;
  upsId?: InputMaybe<Scalars['BigInt']>;
  upsIdRodic?: InputMaybe<Scalars['BigInt']>;
  upsIdSkupina?: InputMaybe<Scalars['BigInt']>;
  upsPopis?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Upozorneni` values. */
export type UpozornenisConnection = {
  __typename?: 'UpozornenisConnection';
  /** A list of edges which contains the `Upozorneni` and cursor to aid in pagination. */
  edges: Array<UpozornenisEdge>;
  /** A list of `Upozorneni` objects. */
  nodes: Array<Upozorneni>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Upozorneni` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Upozorneni` edge in the connection. */
export type UpozornenisEdge = {
  __typename?: 'UpozornenisEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Upozorneni` at the end of the edge. */
  node: Upozorneni;
};

/** Methods to use when ordering `Upozorneni`. */
export type UpozornenisOrderBy =
  | 'IS_VISIBLE_ASC'
  | 'IS_VISIBLE_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SCHEDULED_SINCE_ASC'
  | 'SCHEDULED_SINCE_DESC'
  | 'SCHEDULED_UNTIL_ASC'
  | 'SCHEDULED_UNTIL_DESC'
  | 'UPOZORNENI_SKUPINIES_BY_UPS_ID_RODIC__COUNT_ASC'
  | 'UPOZORNENI_SKUPINIES_BY_UPS_ID_RODIC__COUNT_DESC'
  | 'UP_BARVY_ASC'
  | 'UP_BARVY_DESC'
  | 'UP_ID_ASC'
  | 'UP_ID_DESC'
  | 'UP_KDO_ASC'
  | 'UP_KDO_DESC'
  | 'UP_LOCK_ASC'
  | 'UP_LOCK_DESC'
  | 'UP_NADPIS_ASC'
  | 'UP_NADPIS_DESC'
  | 'UP_TEXT_ASC'
  | 'UP_TEXT_DESC'
  | 'UP_TIMESTAMP_ADD_ASC'
  | 'UP_TIMESTAMP_ADD_DESC'
  | 'UP_TIMESTAMP_ASC'
  | 'UP_TIMESTAMP_DESC'
  | 'USER_BY_UP_KDO__U_BAN_ASC'
  | 'USER_BY_UP_KDO__U_BAN_DESC'
  | 'USER_BY_UP_KDO__U_CITY_ASC'
  | 'USER_BY_UP_KDO__U_CITY_DESC'
  | 'USER_BY_UP_KDO__U_CONFIRMED_ASC'
  | 'USER_BY_UP_KDO__U_CONFIRMED_DESC'
  | 'USER_BY_UP_KDO__U_CONSCRIPTION_NUMBER_ASC'
  | 'USER_BY_UP_KDO__U_CONSCRIPTION_NUMBER_DESC'
  | 'USER_BY_UP_KDO__U_CREATED_AT_ASC'
  | 'USER_BY_UP_KDO__U_CREATED_AT_DESC'
  | 'USER_BY_UP_KDO__U_DANCER_ASC'
  | 'USER_BY_UP_KDO__U_DANCER_DESC'
  | 'USER_BY_UP_KDO__U_DISTRICT_ASC'
  | 'USER_BY_UP_KDO__U_DISTRICT_DESC'
  | 'USER_BY_UP_KDO__U_EMAIL_ASC'
  | 'USER_BY_UP_KDO__U_EMAIL_DESC'
  | 'USER_BY_UP_KDO__U_GDPR_SIGNED_AT_ASC'
  | 'USER_BY_UP_KDO__U_GDPR_SIGNED_AT_DESC'
  | 'USER_BY_UP_KDO__U_GROUP_ASC'
  | 'USER_BY_UP_KDO__U_GROUP_DESC'
  | 'USER_BY_UP_KDO__U_ID_ASC'
  | 'USER_BY_UP_KDO__U_ID_DESC'
  | 'USER_BY_UP_KDO__U_JMENO_ASC'
  | 'USER_BY_UP_KDO__U_JMENO_DESC'
  | 'USER_BY_UP_KDO__U_LEVEL_ASC'
  | 'USER_BY_UP_KDO__U_LEVEL_DESC'
  | 'USER_BY_UP_KDO__U_LOCK_ASC'
  | 'USER_BY_UP_KDO__U_LOCK_DESC'
  | 'USER_BY_UP_KDO__U_LOGIN_ASC'
  | 'USER_BY_UP_KDO__U_LOGIN_DESC'
  | 'USER_BY_UP_KDO__U_MEMBER_SINCE_ASC'
  | 'USER_BY_UP_KDO__U_MEMBER_SINCE_DESC'
  | 'USER_BY_UP_KDO__U_MEMBER_UNTIL_ASC'
  | 'USER_BY_UP_KDO__U_MEMBER_UNTIL_DESC'
  | 'USER_BY_UP_KDO__U_NAROZENI_ASC'
  | 'USER_BY_UP_KDO__U_NAROZENI_DESC'
  | 'USER_BY_UP_KDO__U_NATIONALITY_ASC'
  | 'USER_BY_UP_KDO__U_NATIONALITY_DESC'
  | 'USER_BY_UP_KDO__U_ORIENTATION_NUMBER_ASC'
  | 'USER_BY_UP_KDO__U_ORIENTATION_NUMBER_DESC'
  | 'USER_BY_UP_KDO__U_PASS_ASC'
  | 'USER_BY_UP_KDO__U_PASS_DESC'
  | 'USER_BY_UP_KDO__U_POHLAVI_ASC'
  | 'USER_BY_UP_KDO__U_POHLAVI_DESC'
  | 'USER_BY_UP_KDO__U_POSTAL_CODE_ASC'
  | 'USER_BY_UP_KDO__U_POSTAL_CODE_DESC'
  | 'USER_BY_UP_KDO__U_POZNAMKY_ASC'
  | 'USER_BY_UP_KDO__U_POZNAMKY_DESC'
  | 'USER_BY_UP_KDO__U_PRIJMENI_ASC'
  | 'USER_BY_UP_KDO__U_PRIJMENI_DESC'
  | 'USER_BY_UP_KDO__U_RODNE_CISLO_ASC'
  | 'USER_BY_UP_KDO__U_RODNE_CISLO_DESC'
  | 'USER_BY_UP_KDO__U_SKUPINA_ASC'
  | 'USER_BY_UP_KDO__U_SKUPINA_DESC'
  | 'USER_BY_UP_KDO__U_STREET_ASC'
  | 'USER_BY_UP_KDO__U_STREET_DESC'
  | 'USER_BY_UP_KDO__U_SYSTEM_ASC'
  | 'USER_BY_UP_KDO__U_SYSTEM_DESC'
  | 'USER_BY_UP_KDO__U_TEACHER_ASC'
  | 'USER_BY_UP_KDO__U_TEACHER_DESC'
  | 'USER_BY_UP_KDO__U_TELEFON_ASC'
  | 'USER_BY_UP_KDO__U_TELEFON_DESC'
  | 'USER_BY_UP_KDO__U_TIMESTAMP_ASC'
  | 'USER_BY_UP_KDO__U_TIMESTAMP_DESC';

export type User = Node & {
  __typename?: 'User';
  /** Reads and enables pagination through a set of `AkceItem`. */
  akceItemsByAiUser: AkceItemsConnection;
  /** Reads and enables pagination through a set of `Aktuality`. */
  aktualitiesByAtKdo: AktualitiesConnection;
  /** Reads and enables pagination through a set of `Attachment`. */
  attachmentsByUploadedBy: AttachmentsConnection;
  /** Reads and enables pagination through a set of `AttendeeExternal`. */
  attendeeExternalsByConfirmedBy: AttendeeExternalsConnection;
  /** Reads and enables pagination through a set of `AttendeeExternal`. */
  attendeeExternalsByManagedBy: AttendeeExternalsConnection;
  /** Reads and enables pagination through a set of `AttendeeUser`. */
  attendeeUsers: AttendeeUsersConnection;
  /** Reads and enables pagination through a set of `Dokumenty`. */
  dokumentiesByDKdo: DokumentiesConnection;
  fullName: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `GalerieFoto`. */
  galerieFotosByGfKdo: GalerieFotosConnection;
  /** Reads and enables pagination through a set of `Nabidka`. */
  nabidkasByNTrener: NabidkasConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads and enables pagination through a set of `Pary`. */
  pariesByPIdPartner: PariesConnection;
  /** Reads and enables pagination through a set of `Pary`. */
  pariesByPIdPartnerka: PariesConnection;
  /** Reads and enables pagination through a set of `ParyNavrh`. */
  paryNavrhsByPnNavrhl: ParyNavrhsConnection;
  /** Reads and enables pagination through a set of `ParyNavrh`. */
  paryNavrhsByPnPartner: ParyNavrhsConnection;
  /** Reads and enables pagination through a set of `ParyNavrh`. */
  paryNavrhsByPnPartnerka: ParyNavrhsConnection;
  /** Reads a single `Permission` that is related to this `User`. */
  permissionByUGroup: Maybe<Permission>;
  /** Reads and enables pagination through a set of `PlatbyItem`. */
  platbyItemsByPiIdUser: PlatbyItemsConnection;
  /** Reads and enables pagination through a set of `Rozpi`. */
  rozpisByRTrener: RozpisConnection;
  /** Reads and enables pagination through a set of `Session`. */
  sessionsBySsUser: SessionsConnection;
  /** Reads a single `Skupiny` that is related to this `User`. */
  skupinyByUSkupina: Maybe<Skupiny>;
  uBan: Scalars['Boolean'];
  uCity: Scalars['String'];
  uConfirmed: Scalars['Boolean'];
  uConscriptionNumber: Scalars['String'];
  uCreatedAt: Scalars['Datetime'];
  uDancer: Scalars['Boolean'];
  uDistrict: Scalars['String'];
  uEmail: Scalars['String'];
  uGdprSignedAt: Maybe<Scalars['Datetime']>;
  uGroup: Scalars['BigInt'];
  uId: Scalars['BigInt'];
  uJmeno: Scalars['String'];
  uLevel: Scalars['Int'];
  uLock: Scalars['Boolean'];
  uLogin: Scalars['String'];
  uMemberSince: Maybe<Scalars['Datetime']>;
  uMemberUntil: Maybe<Scalars['Datetime']>;
  uNarozeni: Scalars['Date'];
  uNationality: Scalars['String'];
  uOrientationNumber: Scalars['String'];
  uPass: Scalars['String'];
  uPohlavi: Scalars['String'];
  uPostalCode: Scalars['String'];
  uPoznamky: Scalars['String'];
  uPrijmeni: Scalars['String'];
  uRodneCislo: Maybe<Scalars['String']>;
  uSkupina: Scalars['BigInt'];
  uStreet: Scalars['String'];
  uSystem: Scalars['Boolean'];
  uTeacher: Scalars['Boolean'];
  uTelefon: Scalars['String'];
  uTimestamp: Scalars['Datetime'];
  /** Reads and enables pagination through a set of `Upozorneni`. */
  upozornenisByUpKdo: UpozornenisConnection;
};


export type UserAkceItemsByAiUserArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AkceItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AkceItemsOrderBy>>;
};


export type UserAktualitiesByAtKdoArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AktualityCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AktualitiesOrderBy>>;
};


export type UserAttachmentsByUploadedByArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AttachmentCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AttachmentsOrderBy>>;
};


export type UserAttendeeExternalsByConfirmedByArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AttendeeExternalCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AttendeeExternalsOrderBy>>;
};


export type UserAttendeeExternalsByManagedByArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AttendeeExternalCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AttendeeExternalsOrderBy>>;
};


export type UserAttendeeUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AttendeeUserCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AttendeeUsersOrderBy>>;
};


export type UserDokumentiesByDKdoArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<DokumentyCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<DokumentiesOrderBy>>;
};


export type UserGalerieFotosByGfKdoArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<GalerieFotoCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GalerieFotosOrderBy>>;
};


export type UserNabidkasByNTrenerArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<NabidkaCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<NabidkasOrderBy>>;
};


export type UserPariesByPIdPartnerArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<ParyCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PariesOrderBy>>;
};


export type UserPariesByPIdPartnerkaArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<ParyCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PariesOrderBy>>;
};


export type UserParyNavrhsByPnNavrhlArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<ParyNavrhCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ParyNavrhsOrderBy>>;
};


export type UserParyNavrhsByPnPartnerArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<ParyNavrhCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ParyNavrhsOrderBy>>;
};


export type UserParyNavrhsByPnPartnerkaArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<ParyNavrhCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ParyNavrhsOrderBy>>;
};


export type UserPlatbyItemsByPiIdUserArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyItemsOrderBy>>;
};


export type UserRozpisByRTrenerArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<RozpiCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RozpisOrderBy>>;
};


export type UserSessionsBySsUserArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<SessionCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SessionsOrderBy>>;
};


export type UserUpozornenisByUpKdoArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<UpozorneniCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UpozornenisOrderBy>>;
};

/** A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UserCondition = {
  /** Checks for equality with the object’s `uBan` field. */
  uBan?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uCity` field. */
  uCity?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uConfirmed` field. */
  uConfirmed?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uConscriptionNumber` field. */
  uConscriptionNumber?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uCreatedAt` field. */
  uCreatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `uDancer` field. */
  uDancer?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uDistrict` field. */
  uDistrict?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uEmail` field. */
  uEmail?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uGdprSignedAt` field. */
  uGdprSignedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `uGroup` field. */
  uGroup?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `uId` field. */
  uId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `uJmeno` field. */
  uJmeno?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uLevel` field. */
  uLevel?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uLock` field. */
  uLock?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uLogin` field. */
  uLogin?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uMemberSince` field. */
  uMemberSince?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `uMemberUntil` field. */
  uMemberUntil?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `uNarozeni` field. */
  uNarozeni?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `uNationality` field. */
  uNationality?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uOrientationNumber` field. */
  uOrientationNumber?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uPass` field. */
  uPass?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uPohlavi` field. */
  uPohlavi?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uPostalCode` field. */
  uPostalCode?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uPoznamky` field. */
  uPoznamky?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uPrijmeni` field. */
  uPrijmeni?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uRodneCislo` field. */
  uRodneCislo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uSkupina` field. */
  uSkupina?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `uStreet` field. */
  uStreet?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uSystem` field. */
  uSystem?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uTeacher` field. */
  uTeacher?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uTelefon` field. */
  uTelefon?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uTimestamp` field. */
  uTimestamp?: InputMaybe<Scalars['Datetime']>;
};

/** An input for mutations affecting `User` */
export type UserInput = {
  uBan?: InputMaybe<Scalars['Boolean']>;
  uCity: Scalars['String'];
  uConfirmed?: InputMaybe<Scalars['Boolean']>;
  uConscriptionNumber?: InputMaybe<Scalars['String']>;
  uCreatedAt?: InputMaybe<Scalars['Datetime']>;
  uDancer?: InputMaybe<Scalars['Boolean']>;
  uDistrict?: InputMaybe<Scalars['String']>;
  uEmail: Scalars['String'];
  uGdprSignedAt?: InputMaybe<Scalars['Datetime']>;
  uGroup?: InputMaybe<Scalars['BigInt']>;
  uId?: InputMaybe<Scalars['BigInt']>;
  uJmeno: Scalars['String'];
  uLevel?: InputMaybe<Scalars['Int']>;
  uLock?: InputMaybe<Scalars['Boolean']>;
  uLogin: Scalars['String'];
  uMemberSince?: InputMaybe<Scalars['Datetime']>;
  uMemberUntil?: InputMaybe<Scalars['Datetime']>;
  uNarozeni: Scalars['Date'];
  uNationality: Scalars['String'];
  uOrientationNumber?: InputMaybe<Scalars['String']>;
  uPass: Scalars['String'];
  uPohlavi: Scalars['String'];
  uPostalCode: Scalars['String'];
  uPoznamky?: InputMaybe<Scalars['String']>;
  uPrijmeni: Scalars['String'];
  uRodneCislo?: InputMaybe<Scalars['String']>;
  uSkupina?: InputMaybe<Scalars['BigInt']>;
  uStreet: Scalars['String'];
  uSystem?: InputMaybe<Scalars['Boolean']>;
  uTeacher?: InputMaybe<Scalars['Boolean']>;
  uTelefon: Scalars['String'];
  uTimestamp?: InputMaybe<Scalars['Datetime']>;
};

/** Represents an update to a `User`. Fields that are set will be updated. */
export type UserPatch = {
  uBan?: InputMaybe<Scalars['Boolean']>;
  uCity?: InputMaybe<Scalars['String']>;
  uConfirmed?: InputMaybe<Scalars['Boolean']>;
  uConscriptionNumber?: InputMaybe<Scalars['String']>;
  uCreatedAt?: InputMaybe<Scalars['Datetime']>;
  uDancer?: InputMaybe<Scalars['Boolean']>;
  uDistrict?: InputMaybe<Scalars['String']>;
  uEmail?: InputMaybe<Scalars['String']>;
  uGdprSignedAt?: InputMaybe<Scalars['Datetime']>;
  uGroup?: InputMaybe<Scalars['BigInt']>;
  uId?: InputMaybe<Scalars['BigInt']>;
  uJmeno?: InputMaybe<Scalars['String']>;
  uLevel?: InputMaybe<Scalars['Int']>;
  uLock?: InputMaybe<Scalars['Boolean']>;
  uLogin?: InputMaybe<Scalars['String']>;
  uMemberSince?: InputMaybe<Scalars['Datetime']>;
  uMemberUntil?: InputMaybe<Scalars['Datetime']>;
  uNarozeni?: InputMaybe<Scalars['Date']>;
  uNationality?: InputMaybe<Scalars['String']>;
  uOrientationNumber?: InputMaybe<Scalars['String']>;
  uPass?: InputMaybe<Scalars['String']>;
  uPohlavi?: InputMaybe<Scalars['String']>;
  uPostalCode?: InputMaybe<Scalars['String']>;
  uPoznamky?: InputMaybe<Scalars['String']>;
  uPrijmeni?: InputMaybe<Scalars['String']>;
  uRodneCislo?: InputMaybe<Scalars['String']>;
  uSkupina?: InputMaybe<Scalars['BigInt']>;
  uStreet?: InputMaybe<Scalars['String']>;
  uSystem?: InputMaybe<Scalars['Boolean']>;
  uTeacher?: InputMaybe<Scalars['Boolean']>;
  uTelefon?: InputMaybe<Scalars['String']>;
  uTimestamp?: InputMaybe<Scalars['Datetime']>;
};

/** A connection to a list of `User` values. */
export type UsersConnection = {
  __typename?: 'UsersConnection';
  /** A list of edges which contains the `User` and cursor to aid in pagination. */
  edges: Array<UsersEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `User` edge in the connection. */
export type UsersEdge = {
  __typename?: 'UsersEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `User` at the end of the edge. */
  node: User;
};

/** Methods to use when ordering `User`. */
export type UsersOrderBy =
  | 'AKCE_ITEMS_BY_AI_USER__COUNT_ASC'
  | 'AKCE_ITEMS_BY_AI_USER__COUNT_DESC'
  | 'AKTUALITIES_BY_AT_KDO__COUNT_ASC'
  | 'AKTUALITIES_BY_AT_KDO__COUNT_DESC'
  | 'ATTACHMENTS_BY_UPLOADED_BY__COUNT_ASC'
  | 'ATTACHMENTS_BY_UPLOADED_BY__COUNT_DESC'
  | 'ATTENDEE_EXTERNALS_BY_CONFIRMED_BY__COUNT_ASC'
  | 'ATTENDEE_EXTERNALS_BY_CONFIRMED_BY__COUNT_DESC'
  | 'ATTENDEE_EXTERNALS_BY_MANAGED_BY__COUNT_ASC'
  | 'ATTENDEE_EXTERNALS_BY_MANAGED_BY__COUNT_DESC'
  | 'ATTENDEE_USERS_BY_USER_ID__COUNT_ASC'
  | 'ATTENDEE_USERS_BY_USER_ID__COUNT_DESC'
  | 'DOKUMENTIES_BY_D_KDO__COUNT_ASC'
  | 'DOKUMENTIES_BY_D_KDO__COUNT_DESC'
  | 'GALERIE_FOTOS_BY_GF_KDO__COUNT_ASC'
  | 'GALERIE_FOTOS_BY_GF_KDO__COUNT_DESC'
  | 'NABIDKAS_BY_N_TRENER__COUNT_ASC'
  | 'NABIDKAS_BY_N_TRENER__COUNT_DESC'
  | 'NATURAL'
  | 'PARIES_BY_P_ID_PARTNERKA__COUNT_ASC'
  | 'PARIES_BY_P_ID_PARTNERKA__COUNT_DESC'
  | 'PARIES_BY_P_ID_PARTNER__COUNT_ASC'
  | 'PARIES_BY_P_ID_PARTNER__COUNT_DESC'
  | 'PARY_NAVRHS_BY_PN_NAVRHL__COUNT_ASC'
  | 'PARY_NAVRHS_BY_PN_NAVRHL__COUNT_DESC'
  | 'PARY_NAVRHS_BY_PN_PARTNERKA__COUNT_ASC'
  | 'PARY_NAVRHS_BY_PN_PARTNERKA__COUNT_DESC'
  | 'PARY_NAVRHS_BY_PN_PARTNER__COUNT_ASC'
  | 'PARY_NAVRHS_BY_PN_PARTNER__COUNT_DESC'
  | 'PERMISSION_BY_U_GROUP__PE_AKCE_ASC'
  | 'PERMISSION_BY_U_GROUP__PE_AKCE_DESC'
  | 'PERMISSION_BY_U_GROUP__PE_AKTUALITY_ASC'
  | 'PERMISSION_BY_U_GROUP__PE_AKTUALITY_DESC'
  | 'PERMISSION_BY_U_GROUP__PE_ANKETY_ASC'
  | 'PERMISSION_BY_U_GROUP__PE_ANKETY_DESC'
  | 'PERMISSION_BY_U_GROUP__PE_DESCRIPTION_ASC'
  | 'PERMISSION_BY_U_GROUP__PE_DESCRIPTION_DESC'
  | 'PERMISSION_BY_U_GROUP__PE_DOKUMENTY_ASC'
  | 'PERMISSION_BY_U_GROUP__PE_DOKUMENTY_DESC'
  | 'PERMISSION_BY_U_GROUP__PE_GALERIE_ASC'
  | 'PERMISSION_BY_U_GROUP__PE_GALERIE_DESC'
  | 'PERMISSION_BY_U_GROUP__PE_ID_ASC'
  | 'PERMISSION_BY_U_GROUP__PE_ID_DESC'
  | 'PERMISSION_BY_U_GROUP__PE_INZERCE_ASC'
  | 'PERMISSION_BY_U_GROUP__PE_INZERCE_DESC'
  | 'PERMISSION_BY_U_GROUP__PE_KONZOLE_ASC'
  | 'PERMISSION_BY_U_GROUP__PE_KONZOLE_DESC'
  | 'PERMISSION_BY_U_GROUP__PE_MAIN_ASC'
  | 'PERMISSION_BY_U_GROUP__PE_MAIN_DESC'
  | 'PERMISSION_BY_U_GROUP__PE_NABIDKA_ASC'
  | 'PERMISSION_BY_U_GROUP__PE_NABIDKA_DESC'
  | 'PERMISSION_BY_U_GROUP__PE_NAME_ASC'
  | 'PERMISSION_BY_U_GROUP__PE_NAME_DESC'
  | 'PERMISSION_BY_U_GROUP__PE_NASTENKA_ASC'
  | 'PERMISSION_BY_U_GROUP__PE_NASTENKA_DESC'
  | 'PERMISSION_BY_U_GROUP__PE_NOVINKY_ASC'
  | 'PERMISSION_BY_U_GROUP__PE_NOVINKY_DESC'
  | 'PERMISSION_BY_U_GROUP__PE_PARY_ASC'
  | 'PERMISSION_BY_U_GROUP__PE_PARY_DESC'
  | 'PERMISSION_BY_U_GROUP__PE_PERMISSIONS_ASC'
  | 'PERMISSION_BY_U_GROUP__PE_PERMISSIONS_DESC'
  | 'PERMISSION_BY_U_GROUP__PE_PLATBY_ASC'
  | 'PERMISSION_BY_U_GROUP__PE_PLATBY_DESC'
  | 'PERMISSION_BY_U_GROUP__PE_ROZPIS_ASC'
  | 'PERMISSION_BY_U_GROUP__PE_ROZPIS_DESC'
  | 'PERMISSION_BY_U_GROUP__PE_SKUPINY_ASC'
  | 'PERMISSION_BY_U_GROUP__PE_SKUPINY_DESC'
  | 'PERMISSION_BY_U_GROUP__PE_USERS_ASC'
  | 'PERMISSION_BY_U_GROUP__PE_USERS_DESC'
  | 'PLATBY_ITEMS_BY_PI_ID_USER__COUNT_ASC'
  | 'PLATBY_ITEMS_BY_PI_ID_USER__COUNT_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'ROZPIS_BY_R_TRENER__COUNT_ASC'
  | 'ROZPIS_BY_R_TRENER__COUNT_DESC'
  | 'SESSIONS_BY_SS_USER__COUNT_ASC'
  | 'SESSIONS_BY_SS_USER__COUNT_DESC'
  | 'SKUPINY_BY_U_SKUPINA__COHORT_GROUP_ASC'
  | 'SKUPINY_BY_U_SKUPINA__COHORT_GROUP_DESC'
  | 'SKUPINY_BY_U_SKUPINA__INTERNAL_INFO_ASC'
  | 'SKUPINY_BY_U_SKUPINA__INTERNAL_INFO_DESC'
  | 'SKUPINY_BY_U_SKUPINA__ORDERING_ASC'
  | 'SKUPINY_BY_U_SKUPINA__ORDERING_DESC'
  | 'SKUPINY_BY_U_SKUPINA__S_COLOR_RGB_ASC'
  | 'SKUPINY_BY_U_SKUPINA__S_COLOR_RGB_DESC'
  | 'SKUPINY_BY_U_SKUPINA__S_COLOR_TEXT_ASC'
  | 'SKUPINY_BY_U_SKUPINA__S_COLOR_TEXT_DESC'
  | 'SKUPINY_BY_U_SKUPINA__S_DESCRIPTION_ASC'
  | 'SKUPINY_BY_U_SKUPINA__S_DESCRIPTION_DESC'
  | 'SKUPINY_BY_U_SKUPINA__S_ID_ASC'
  | 'SKUPINY_BY_U_SKUPINA__S_ID_DESC'
  | 'SKUPINY_BY_U_SKUPINA__S_LOCATION_ASC'
  | 'SKUPINY_BY_U_SKUPINA__S_LOCATION_DESC'
  | 'SKUPINY_BY_U_SKUPINA__S_NAME_ASC'
  | 'SKUPINY_BY_U_SKUPINA__S_NAME_DESC'
  | 'SKUPINY_BY_U_SKUPINA__S_VISIBLE_ASC'
  | 'SKUPINY_BY_U_SKUPINA__S_VISIBLE_DESC'
  | 'UPOZORNENIS_BY_UP_KDO__COUNT_ASC'
  | 'UPOZORNENIS_BY_UP_KDO__COUNT_DESC'
  | 'U_BAN_ASC'
  | 'U_BAN_DESC'
  | 'U_CITY_ASC'
  | 'U_CITY_DESC'
  | 'U_CONFIRMED_ASC'
  | 'U_CONFIRMED_DESC'
  | 'U_CONSCRIPTION_NUMBER_ASC'
  | 'U_CONSCRIPTION_NUMBER_DESC'
  | 'U_CREATED_AT_ASC'
  | 'U_CREATED_AT_DESC'
  | 'U_DANCER_ASC'
  | 'U_DANCER_DESC'
  | 'U_DISTRICT_ASC'
  | 'U_DISTRICT_DESC'
  | 'U_EMAIL_ASC'
  | 'U_EMAIL_DESC'
  | 'U_GDPR_SIGNED_AT_ASC'
  | 'U_GDPR_SIGNED_AT_DESC'
  | 'U_GROUP_ASC'
  | 'U_GROUP_DESC'
  | 'U_ID_ASC'
  | 'U_ID_DESC'
  | 'U_JMENO_ASC'
  | 'U_JMENO_DESC'
  | 'U_LEVEL_ASC'
  | 'U_LEVEL_DESC'
  | 'U_LOCK_ASC'
  | 'U_LOCK_DESC'
  | 'U_LOGIN_ASC'
  | 'U_LOGIN_DESC'
  | 'U_MEMBER_SINCE_ASC'
  | 'U_MEMBER_SINCE_DESC'
  | 'U_MEMBER_UNTIL_ASC'
  | 'U_MEMBER_UNTIL_DESC'
  | 'U_NAROZENI_ASC'
  | 'U_NAROZENI_DESC'
  | 'U_NATIONALITY_ASC'
  | 'U_NATIONALITY_DESC'
  | 'U_ORIENTATION_NUMBER_ASC'
  | 'U_ORIENTATION_NUMBER_DESC'
  | 'U_PASS_ASC'
  | 'U_PASS_DESC'
  | 'U_POHLAVI_ASC'
  | 'U_POHLAVI_DESC'
  | 'U_POSTAL_CODE_ASC'
  | 'U_POSTAL_CODE_DESC'
  | 'U_POZNAMKY_ASC'
  | 'U_POZNAMKY_DESC'
  | 'U_PRIJMENI_ASC'
  | 'U_PRIJMENI_DESC'
  | 'U_RODNE_CISLO_ASC'
  | 'U_RODNE_CISLO_DESC'
  | 'U_SKUPINA_ASC'
  | 'U_SKUPINA_DESC'
  | 'U_STREET_ASC'
  | 'U_STREET_DESC'
  | 'U_SYSTEM_ASC'
  | 'U_SYSTEM_DESC'
  | 'U_TEACHER_ASC'
  | 'U_TEACHER_DESC'
  | 'U_TELEFON_ASC'
  | 'U_TELEFON_DESC'
  | 'U_TIMESTAMP_ASC'
  | 'U_TIMESTAMP_DESC';

/** All input for the `verifyFunction` mutation. */
export type VerifyFunctionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  f?: InputMaybe<Scalars['RegProc']>;
  relid?: InputMaybe<Scalars['RegClass']>;
};

/** The output of our `verifyFunction` mutation. */
export type VerifyFunctionPayload = {
  __typename?: 'VerifyFunctionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type Video = Node & {
  __typename?: 'Video';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  vAuthor: Scalars['String'];
  vCreatedAt: Scalars['Datetime'];
  vDescription: Scalars['String'];
  vId: Scalars['BigInt'];
  vPlaylist: Maybe<Scalars['String']>;
  vTitle: Scalars['String'];
  vUpdatedAt: Scalars['Datetime'];
  vUri: Scalars['String'];
};

/** A condition to be used against `Video` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type VideoCondition = {
  /** Checks for equality with the object’s `vAuthor` field. */
  vAuthor?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `vCreatedAt` field. */
  vCreatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `vDescription` field. */
  vDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `vId` field. */
  vId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vPlaylist` field. */
  vPlaylist?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `vTitle` field. */
  vTitle?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `vUpdatedAt` field. */
  vUpdatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `vUri` field. */
  vUri?: InputMaybe<Scalars['String']>;
};

/** An input for mutations affecting `Video` */
export type VideoInput = {
  vAuthor: Scalars['String'];
  vCreatedAt?: InputMaybe<Scalars['Datetime']>;
  vDescription: Scalars['String'];
  vId?: InputMaybe<Scalars['BigInt']>;
  vPlaylist?: InputMaybe<Scalars['String']>;
  vTitle: Scalars['String'];
  vUpdatedAt?: InputMaybe<Scalars['Datetime']>;
  vUri: Scalars['String'];
};

export type VideoList = Node & {
  __typename?: 'VideoList';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  vlCount: Scalars['BigInt'];
  vlCreatedAt: Scalars['Datetime'];
  vlDescription: Scalars['String'];
  vlId: Scalars['BigInt'];
  vlLastChecked: Maybe<Scalars['Datetime']>;
  vlTitle: Scalars['String'];
  vlUrl: Scalars['String'];
};

/**
 * A condition to be used against `VideoList` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type VideoListCondition = {
  /** Checks for equality with the object’s `vlCount` field. */
  vlCount?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vlCreatedAt` field. */
  vlCreatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `vlDescription` field. */
  vlDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `vlId` field. */
  vlId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vlLastChecked` field. */
  vlLastChecked?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `vlTitle` field. */
  vlTitle?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `vlUrl` field. */
  vlUrl?: InputMaybe<Scalars['String']>;
};

/** An input for mutations affecting `VideoList` */
export type VideoListInput = {
  vlCount: Scalars['BigInt'];
  vlCreatedAt: Scalars['Datetime'];
  vlDescription: Scalars['String'];
  vlId?: InputMaybe<Scalars['BigInt']>;
  vlLastChecked?: InputMaybe<Scalars['Datetime']>;
  vlTitle: Scalars['String'];
  vlUrl: Scalars['String'];
};

/** Represents an update to a `VideoList`. Fields that are set will be updated. */
export type VideoListPatch = {
  vlCount?: InputMaybe<Scalars['BigInt']>;
  vlCreatedAt?: InputMaybe<Scalars['Datetime']>;
  vlDescription?: InputMaybe<Scalars['String']>;
  vlId?: InputMaybe<Scalars['BigInt']>;
  vlLastChecked?: InputMaybe<Scalars['Datetime']>;
  vlTitle?: InputMaybe<Scalars['String']>;
  vlUrl?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `VideoList` values. */
export type VideoListsConnection = {
  __typename?: 'VideoListsConnection';
  /** A list of edges which contains the `VideoList` and cursor to aid in pagination. */
  edges: Array<VideoListsEdge>;
  /** A list of `VideoList` objects. */
  nodes: Array<VideoList>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VideoList` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `VideoList` edge in the connection. */
export type VideoListsEdge = {
  __typename?: 'VideoListsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `VideoList` at the end of the edge. */
  node: VideoList;
};

/** Methods to use when ordering `VideoList`. */
export type VideoListsOrderBy =
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'VL_COUNT_ASC'
  | 'VL_COUNT_DESC'
  | 'VL_CREATED_AT_ASC'
  | 'VL_CREATED_AT_DESC'
  | 'VL_DESCRIPTION_ASC'
  | 'VL_DESCRIPTION_DESC'
  | 'VL_ID_ASC'
  | 'VL_ID_DESC'
  | 'VL_LAST_CHECKED_ASC'
  | 'VL_LAST_CHECKED_DESC'
  | 'VL_TITLE_ASC'
  | 'VL_TITLE_DESC'
  | 'VL_URL_ASC'
  | 'VL_URL_DESC';

/** Represents an update to a `Video`. Fields that are set will be updated. */
export type VideoPatch = {
  vAuthor?: InputMaybe<Scalars['String']>;
  vCreatedAt?: InputMaybe<Scalars['Datetime']>;
  vDescription?: InputMaybe<Scalars['String']>;
  vId?: InputMaybe<Scalars['BigInt']>;
  vPlaylist?: InputMaybe<Scalars['String']>;
  vTitle?: InputMaybe<Scalars['String']>;
  vUpdatedAt?: InputMaybe<Scalars['Datetime']>;
  vUri?: InputMaybe<Scalars['String']>;
};

export type VideoSource = Node & {
  __typename?: 'VideoSource';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  vsCreatedAt: Scalars['Datetime'];
  vsDescription: Maybe<Scalars['String']>;
  vsId: Scalars['BigInt'];
  vsLastChecked: Maybe<Scalars['Datetime']>;
  vsTitle: Maybe<Scalars['String']>;
  vsUrl: Scalars['String'];
};

/**
 * A condition to be used against `VideoSource` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type VideoSourceCondition = {
  /** Checks for equality with the object’s `vsCreatedAt` field. */
  vsCreatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `vsDescription` field. */
  vsDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `vsId` field. */
  vsId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vsLastChecked` field. */
  vsLastChecked?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `vsTitle` field. */
  vsTitle?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `vsUrl` field. */
  vsUrl?: InputMaybe<Scalars['String']>;
};

/** An input for mutations affecting `VideoSource` */
export type VideoSourceInput = {
  vsCreatedAt?: InputMaybe<Scalars['Datetime']>;
  vsDescription?: InputMaybe<Scalars['String']>;
  vsId?: InputMaybe<Scalars['BigInt']>;
  vsLastChecked?: InputMaybe<Scalars['Datetime']>;
  vsTitle?: InputMaybe<Scalars['String']>;
  vsUrl: Scalars['String'];
};

/** Represents an update to a `VideoSource`. Fields that are set will be updated. */
export type VideoSourcePatch = {
  vsCreatedAt?: InputMaybe<Scalars['Datetime']>;
  vsDescription?: InputMaybe<Scalars['String']>;
  vsId?: InputMaybe<Scalars['BigInt']>;
  vsLastChecked?: InputMaybe<Scalars['Datetime']>;
  vsTitle?: InputMaybe<Scalars['String']>;
  vsUrl?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `VideoSource` values. */
export type VideoSourcesConnection = {
  __typename?: 'VideoSourcesConnection';
  /** A list of edges which contains the `VideoSource` and cursor to aid in pagination. */
  edges: Array<VideoSourcesEdge>;
  /** A list of `VideoSource` objects. */
  nodes: Array<VideoSource>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VideoSource` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `VideoSource` edge in the connection. */
export type VideoSourcesEdge = {
  __typename?: 'VideoSourcesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `VideoSource` at the end of the edge. */
  node: VideoSource;
};

/** Methods to use when ordering `VideoSource`. */
export type VideoSourcesOrderBy =
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'VS_CREATED_AT_ASC'
  | 'VS_CREATED_AT_DESC'
  | 'VS_DESCRIPTION_ASC'
  | 'VS_DESCRIPTION_DESC'
  | 'VS_ID_ASC'
  | 'VS_ID_DESC'
  | 'VS_LAST_CHECKED_ASC'
  | 'VS_LAST_CHECKED_DESC'
  | 'VS_TITLE_ASC'
  | 'VS_TITLE_DESC'
  | 'VS_URL_ASC'
  | 'VS_URL_DESC';

/** A connection to a list of `Video` values. */
export type VideosConnection = {
  __typename?: 'VideosConnection';
  /** A list of edges which contains the `Video` and cursor to aid in pagination. */
  edges: Array<VideosEdge>;
  /** A list of `Video` objects. */
  nodes: Array<Video>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Video` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Video` edge in the connection. */
export type VideosEdge = {
  __typename?: 'VideosEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Video` at the end of the edge. */
  node: Video;
};

/** Methods to use when ordering `Video`. */
export type VideosOrderBy =
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'V_AUTHOR_ASC'
  | 'V_AUTHOR_DESC'
  | 'V_CREATED_AT_ASC'
  | 'V_CREATED_AT_DESC'
  | 'V_DESCRIPTION_ASC'
  | 'V_DESCRIPTION_DESC'
  | 'V_ID_ASC'
  | 'V_ID_DESC'
  | 'V_PLAYLIST_ASC'
  | 'V_PLAYLIST_DESC'
  | 'V_TITLE_ASC'
  | 'V_TITLE_DESC'
  | 'V_UPDATED_AT_ASC'
  | 'V_UPDATED_AT_DESC'
  | 'V_URI_ASC'
  | 'V_URI_DESC';
