/* DO NOT EDIT! This file is auto-generated by graphql-code-generator - see `codegen.yml` */
/* eslint-disable */
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** A floating point number that requires more precision than IEEE 754 binary 64 */
  BigFloat: any;
  /**
   * A signed eight-byte integer. The upper big integer values are greater than the
   * max value for a JavaScript number. Therefore all big integers will be output as
   * strings and not numbers.
   */
  BigInt: string;
  /** A location in a connection that can be used for resuming pagination. */
  Cursor: any;
  /** The day, does not include a time. */
  Date: string;
  /**
   * A point in time as described by the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
   */
  Datetime: string;
  /** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
  JSON: { [key: string]: any };
  /** A builtin object identifier type for a relation name */
  RegClass: any;
  /** A builtin object identifier type for a function name */
  RegProc: any;
  /** The exact time of day, does not include the date. May or may not have a timezone offset. */
  Time: string;
};

/** A `ActiveProspectsRecord` edge in the connection. */
export type ActiveProspectEdge = {
  __typename?: 'ActiveProspectEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `ActiveProspectsRecord` at the end of the edge. */
  node: ActiveProspectsRecord;
};

/** A connection to a list of `ActiveProspectsRecord` values. */
export type ActiveProspectsConnection = {
  __typename?: 'ActiveProspectsConnection';
  /** A list of edges which contains the `ActiveProspectsRecord` and cursor to aid in pagination. */
  edges: Array<ActiveProspectEdge>;
  /** A list of `ActiveProspectsRecord` objects. */
  nodes: Array<ActiveProspectsRecord>;
  /** The count of *all* `ActiveProspectsRecord` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** The return type of our `activeProspects` query. */
export type ActiveProspectsRecord = {
  __typename?: 'ActiveProspectsRecord';
  cohort: Maybe<CrmCohort>;
  data: Maybe<ProspectDatum>;
  id: Maybe<Scalars['BigInt']>;
  updatedAt: Maybe<Scalars['Datetime']>;
};

export type Akce = {
  __typename?: 'Akce';
  aDo: Maybe<Scalars['Date']>;
  aDokumenty: Maybe<Scalars['String']>;
  aId: Maybe<Scalars['BigInt']>;
  aInfo: Maybe<Scalars['String']>;
  aJmeno: Maybe<Scalars['String']>;
  aKapacita: Maybe<Scalars['BigInt']>;
  aKde: Maybe<Scalars['String']>;
  aLock: Maybe<Scalars['Boolean']>;
  aOd: Maybe<Scalars['Date']>;
  aTimestamp: Maybe<Scalars['Datetime']>;
  aVisible: Maybe<Scalars['Boolean']>;
  enableNotes: Maybe<Scalars['Boolean']>;
  isPublic: Maybe<Scalars['Boolean']>;
  summary: Maybe<Scalars['JSON']>;
};

/** A condition to be used against `Akce` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type AkceCondition = {
  /** Checks for equality with the object’s `aDo` field. */
  aDo?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `aDokumenty` field. */
  aDokumenty?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `aId` field. */
  aId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `aInfo` field. */
  aInfo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `aJmeno` field. */
  aJmeno?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `aKapacita` field. */
  aKapacita?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `aKde` field. */
  aKde?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `aLock` field. */
  aLock?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `aOd` field. */
  aOd?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `aTimestamp` field. */
  aTimestamp?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `aVisible` field. */
  aVisible?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `enableNotes` field. */
  enableNotes?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `isPublic` field. */
  isPublic?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `summary` field. */
  summary?: InputMaybe<Scalars['JSON']>;
};

/** An input for mutations affecting `Akce` */
export type AkceInput = {
  aDo?: InputMaybe<Scalars['Date']>;
  aDokumenty?: InputMaybe<Scalars['String']>;
  aId?: InputMaybe<Scalars['BigInt']>;
  aInfo?: InputMaybe<Scalars['String']>;
  aJmeno?: InputMaybe<Scalars['String']>;
  aKapacita?: InputMaybe<Scalars['BigInt']>;
  aKde?: InputMaybe<Scalars['String']>;
  aLock?: InputMaybe<Scalars['Boolean']>;
  aOd?: InputMaybe<Scalars['Date']>;
  aTimestamp?: InputMaybe<Scalars['Datetime']>;
  aVisible?: InputMaybe<Scalars['Boolean']>;
  enableNotes?: InputMaybe<Scalars['Boolean']>;
  isPublic?: InputMaybe<Scalars['Boolean']>;
  summary?: InputMaybe<Scalars['JSON']>;
};

export type AkceItem = {
  __typename?: 'AkceItem';
  aiId: Maybe<Scalars['BigInt']>;
  aiIdRodic: Maybe<Scalars['BigInt']>;
  aiRokNarozeni: Maybe<Scalars['Int']>;
  aiUser: Maybe<Scalars['BigInt']>;
  notes: Maybe<Scalars['String']>;
};

/**
 * A condition to be used against `AkceItem` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type AkceItemCondition = {
  /** Checks for equality with the object’s `aiId` field. */
  aiId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `aiIdRodic` field. */
  aiIdRodic?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `aiRokNarozeni` field. */
  aiRokNarozeni?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `aiUser` field. */
  aiUser?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: InputMaybe<Scalars['String']>;
};

/** An input for mutations affecting `AkceItem` */
export type AkceItemInput = {
  aiId?: InputMaybe<Scalars['BigInt']>;
  aiIdRodic?: InputMaybe<Scalars['BigInt']>;
  aiRokNarozeni?: InputMaybe<Scalars['Int']>;
  aiUser?: InputMaybe<Scalars['BigInt']>;
  notes?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `AkceItem` values. */
export type AkceItemsConnection = {
  __typename?: 'AkceItemsConnection';
  /** A list of edges which contains the `AkceItem` and cursor to aid in pagination. */
  edges: Array<AkceItemsEdge>;
  /** A list of `AkceItem` objects. */
  nodes: Array<AkceItem>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AkceItem` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `AkceItem` edge in the connection. */
export type AkceItemsEdge = {
  __typename?: 'AkceItemsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `AkceItem` at the end of the edge. */
  node: AkceItem;
};

/** Methods to use when ordering `AkceItem`. */
export enum AkceItemsOrderBy {
  AiIdAsc = 'AI_ID_ASC',
  AiIdDesc = 'AI_ID_DESC',
  AiIdRodicAsc = 'AI_ID_RODIC_ASC',
  AiIdRodicDesc = 'AI_ID_RODIC_DESC',
  AiRokNarozeniAsc = 'AI_ROK_NAROZENI_ASC',
  AiRokNarozeniDesc = 'AI_ROK_NAROZENI_DESC',
  AiUserAsc = 'AI_USER_ASC',
  AiUserDesc = 'AI_USER_DESC',
  Natural = 'NATURAL',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC'
}

/** A connection to a list of `Akce` values. */
export type AkcesConnection = {
  __typename?: 'AkcesConnection';
  /** A list of edges which contains the `Akce` and cursor to aid in pagination. */
  edges: Array<AkcesEdge>;
  /** A list of `Akce` objects. */
  nodes: Array<Akce>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Akce` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Akce` edge in the connection. */
export type AkcesEdge = {
  __typename?: 'AkcesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Akce` at the end of the edge. */
  node: Akce;
};

/** Methods to use when ordering `Akce`. */
export enum AkcesOrderBy {
  ADoAsc = 'A_DO_ASC',
  ADoDesc = 'A_DO_DESC',
  ADokumentyAsc = 'A_DOKUMENTY_ASC',
  ADokumentyDesc = 'A_DOKUMENTY_DESC',
  AIdAsc = 'A_ID_ASC',
  AIdDesc = 'A_ID_DESC',
  AInfoAsc = 'A_INFO_ASC',
  AInfoDesc = 'A_INFO_DESC',
  AJmenoAsc = 'A_JMENO_ASC',
  AJmenoDesc = 'A_JMENO_DESC',
  AKapacitaAsc = 'A_KAPACITA_ASC',
  AKapacitaDesc = 'A_KAPACITA_DESC',
  AKdeAsc = 'A_KDE_ASC',
  AKdeDesc = 'A_KDE_DESC',
  ALockAsc = 'A_LOCK_ASC',
  ALockDesc = 'A_LOCK_DESC',
  AOdAsc = 'A_OD_ASC',
  AOdDesc = 'A_OD_DESC',
  ATimestampAsc = 'A_TIMESTAMP_ASC',
  ATimestampDesc = 'A_TIMESTAMP_DESC',
  AVisibleAsc = 'A_VISIBLE_ASC',
  AVisibleDesc = 'A_VISIBLE_DESC',
  EnableNotesAsc = 'ENABLE_NOTES_ASC',
  EnableNotesDesc = 'ENABLE_NOTES_DESC',
  IsPublicAsc = 'IS_PUBLIC_ASC',
  IsPublicDesc = 'IS_PUBLIC_DESC',
  Natural = 'NATURAL',
  SummaryAsc = 'SUMMARY_ASC',
  SummaryDesc = 'SUMMARY_DESC'
}

/** A connection to a list of `Aktuality` values. */
export type AktualitiesConnection = {
  __typename?: 'AktualitiesConnection';
  /** A list of edges which contains the `Aktuality` and cursor to aid in pagination. */
  edges: Array<AktualitiesEdge>;
  /** A list of `Aktuality` objects. */
  nodes: Array<Aktuality>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Aktuality` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Aktuality` edge in the connection. */
export type AktualitiesEdge = {
  __typename?: 'AktualitiesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Aktuality` at the end of the edge. */
  node: Aktuality;
};

/** Methods to use when ordering `Aktuality`. */
export enum AktualitiesOrderBy {
  AtFotoAsc = 'AT_FOTO_ASC',
  AtFotoDesc = 'AT_FOTO_DESC',
  AtFotoMainAsc = 'AT_FOTO_MAIN_ASC',
  AtFotoMainDesc = 'AT_FOTO_MAIN_DESC',
  AtIdAsc = 'AT_ID_ASC',
  AtIdDesc = 'AT_ID_DESC',
  AtJmenoAsc = 'AT_JMENO_ASC',
  AtJmenoDesc = 'AT_JMENO_DESC',
  AtKatAsc = 'AT_KAT_ASC',
  AtKatDesc = 'AT_KAT_DESC',
  AtKdoAsc = 'AT_KDO_ASC',
  AtKdoDesc = 'AT_KDO_DESC',
  AtPreviewAsc = 'AT_PREVIEW_ASC',
  AtPreviewDesc = 'AT_PREVIEW_DESC',
  AtTextAsc = 'AT_TEXT_ASC',
  AtTextDesc = 'AT_TEXT_DESC',
  AtTimestampAddAsc = 'AT_TIMESTAMP_ADD_ASC',
  AtTimestampAddDesc = 'AT_TIMESTAMP_ADD_DESC',
  AtTimestampAsc = 'AT_TIMESTAMP_ASC',
  AtTimestampDesc = 'AT_TIMESTAMP_DESC',
  GalerieFotoByAtFotoMainGfIdAsc = 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_ID_ASC',
  GalerieFotoByAtFotoMainGfIdDesc = 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_ID_DESC',
  GalerieFotoByAtFotoMainGfIdRodicAsc = 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_ID_RODIC_ASC',
  GalerieFotoByAtFotoMainGfIdRodicDesc = 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_ID_RODIC_DESC',
  GalerieFotoByAtFotoMainGfKdoAsc = 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_KDO_ASC',
  GalerieFotoByAtFotoMainGfKdoDesc = 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_KDO_DESC',
  GalerieFotoByAtFotoMainGfNameAsc = 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_NAME_ASC',
  GalerieFotoByAtFotoMainGfNameDesc = 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_NAME_DESC',
  GalerieFotoByAtFotoMainGfPathAsc = 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_PATH_ASC',
  GalerieFotoByAtFotoMainGfPathDesc = 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_PATH_DESC',
  GalerieFotoByAtFotoMainGfTimestampAsc = 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_TIMESTAMP_ASC',
  GalerieFotoByAtFotoMainGfTimestampDesc = 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_TIMESTAMP_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserByAtKdoUBanAsc = 'USER_BY_AT_KDO__U_BAN_ASC',
  UserByAtKdoUBanDesc = 'USER_BY_AT_KDO__U_BAN_DESC',
  UserByAtKdoUCityAsc = 'USER_BY_AT_KDO__U_CITY_ASC',
  UserByAtKdoUCityDesc = 'USER_BY_AT_KDO__U_CITY_DESC',
  UserByAtKdoUConfirmedAsc = 'USER_BY_AT_KDO__U_CONFIRMED_ASC',
  UserByAtKdoUConfirmedDesc = 'USER_BY_AT_KDO__U_CONFIRMED_DESC',
  UserByAtKdoUConscriptionNumberAsc = 'USER_BY_AT_KDO__U_CONSCRIPTION_NUMBER_ASC',
  UserByAtKdoUConscriptionNumberDesc = 'USER_BY_AT_KDO__U_CONSCRIPTION_NUMBER_DESC',
  UserByAtKdoUCreatedAtAsc = 'USER_BY_AT_KDO__U_CREATED_AT_ASC',
  UserByAtKdoUCreatedAtDesc = 'USER_BY_AT_KDO__U_CREATED_AT_DESC',
  UserByAtKdoUDancerAsc = 'USER_BY_AT_KDO__U_DANCER_ASC',
  UserByAtKdoUDancerDesc = 'USER_BY_AT_KDO__U_DANCER_DESC',
  UserByAtKdoUDistrictAsc = 'USER_BY_AT_KDO__U_DISTRICT_ASC',
  UserByAtKdoUDistrictDesc = 'USER_BY_AT_KDO__U_DISTRICT_DESC',
  UserByAtKdoUEmailAsc = 'USER_BY_AT_KDO__U_EMAIL_ASC',
  UserByAtKdoUEmailDesc = 'USER_BY_AT_KDO__U_EMAIL_DESC',
  UserByAtKdoUGdprSignedAtAsc = 'USER_BY_AT_KDO__U_GDPR_SIGNED_AT_ASC',
  UserByAtKdoUGdprSignedAtDesc = 'USER_BY_AT_KDO__U_GDPR_SIGNED_AT_DESC',
  UserByAtKdoUGroupAsc = 'USER_BY_AT_KDO__U_GROUP_ASC',
  UserByAtKdoUGroupDesc = 'USER_BY_AT_KDO__U_GROUP_DESC',
  UserByAtKdoUIdAsc = 'USER_BY_AT_KDO__U_ID_ASC',
  UserByAtKdoUIdDesc = 'USER_BY_AT_KDO__U_ID_DESC',
  UserByAtKdoUJmenoAsc = 'USER_BY_AT_KDO__U_JMENO_ASC',
  UserByAtKdoUJmenoDesc = 'USER_BY_AT_KDO__U_JMENO_DESC',
  UserByAtKdoULevelAsc = 'USER_BY_AT_KDO__U_LEVEL_ASC',
  UserByAtKdoULevelDesc = 'USER_BY_AT_KDO__U_LEVEL_DESC',
  UserByAtKdoULockAsc = 'USER_BY_AT_KDO__U_LOCK_ASC',
  UserByAtKdoULockDesc = 'USER_BY_AT_KDO__U_LOCK_DESC',
  UserByAtKdoULoginAsc = 'USER_BY_AT_KDO__U_LOGIN_ASC',
  UserByAtKdoULoginDesc = 'USER_BY_AT_KDO__U_LOGIN_DESC',
  UserByAtKdoUMemberSinceAsc = 'USER_BY_AT_KDO__U_MEMBER_SINCE_ASC',
  UserByAtKdoUMemberSinceDesc = 'USER_BY_AT_KDO__U_MEMBER_SINCE_DESC',
  UserByAtKdoUMemberUntilAsc = 'USER_BY_AT_KDO__U_MEMBER_UNTIL_ASC',
  UserByAtKdoUMemberUntilDesc = 'USER_BY_AT_KDO__U_MEMBER_UNTIL_DESC',
  UserByAtKdoUNarozeniAsc = 'USER_BY_AT_KDO__U_NAROZENI_ASC',
  UserByAtKdoUNarozeniDesc = 'USER_BY_AT_KDO__U_NAROZENI_DESC',
  UserByAtKdoUNationalityAsc = 'USER_BY_AT_KDO__U_NATIONALITY_ASC',
  UserByAtKdoUNationalityDesc = 'USER_BY_AT_KDO__U_NATIONALITY_DESC',
  UserByAtKdoUOrientationNumberAsc = 'USER_BY_AT_KDO__U_ORIENTATION_NUMBER_ASC',
  UserByAtKdoUOrientationNumberDesc = 'USER_BY_AT_KDO__U_ORIENTATION_NUMBER_DESC',
  UserByAtKdoUPassAsc = 'USER_BY_AT_KDO__U_PASS_ASC',
  UserByAtKdoUPassDesc = 'USER_BY_AT_KDO__U_PASS_DESC',
  UserByAtKdoUPohlaviAsc = 'USER_BY_AT_KDO__U_POHLAVI_ASC',
  UserByAtKdoUPohlaviDesc = 'USER_BY_AT_KDO__U_POHLAVI_DESC',
  UserByAtKdoUPostalCodeAsc = 'USER_BY_AT_KDO__U_POSTAL_CODE_ASC',
  UserByAtKdoUPostalCodeDesc = 'USER_BY_AT_KDO__U_POSTAL_CODE_DESC',
  UserByAtKdoUPoznamkyAsc = 'USER_BY_AT_KDO__U_POZNAMKY_ASC',
  UserByAtKdoUPoznamkyDesc = 'USER_BY_AT_KDO__U_POZNAMKY_DESC',
  UserByAtKdoUPrijmeniAsc = 'USER_BY_AT_KDO__U_PRIJMENI_ASC',
  UserByAtKdoUPrijmeniDesc = 'USER_BY_AT_KDO__U_PRIJMENI_DESC',
  UserByAtKdoURodneCisloAsc = 'USER_BY_AT_KDO__U_RODNE_CISLO_ASC',
  UserByAtKdoURodneCisloDesc = 'USER_BY_AT_KDO__U_RODNE_CISLO_DESC',
  UserByAtKdoUSkupinaAsc = 'USER_BY_AT_KDO__U_SKUPINA_ASC',
  UserByAtKdoUSkupinaDesc = 'USER_BY_AT_KDO__U_SKUPINA_DESC',
  UserByAtKdoUStreetAsc = 'USER_BY_AT_KDO__U_STREET_ASC',
  UserByAtKdoUStreetDesc = 'USER_BY_AT_KDO__U_STREET_DESC',
  UserByAtKdoUSystemAsc = 'USER_BY_AT_KDO__U_SYSTEM_ASC',
  UserByAtKdoUSystemDesc = 'USER_BY_AT_KDO__U_SYSTEM_DESC',
  UserByAtKdoUTeacherAsc = 'USER_BY_AT_KDO__U_TEACHER_ASC',
  UserByAtKdoUTeacherDesc = 'USER_BY_AT_KDO__U_TEACHER_DESC',
  UserByAtKdoUTelefonAsc = 'USER_BY_AT_KDO__U_TELEFON_ASC',
  UserByAtKdoUTelefonDesc = 'USER_BY_AT_KDO__U_TELEFON_DESC',
  UserByAtKdoUTimestampAsc = 'USER_BY_AT_KDO__U_TIMESTAMP_ASC',
  UserByAtKdoUTimestampDesc = 'USER_BY_AT_KDO__U_TIMESTAMP_DESC'
}

export type Aktuality = Node & {
  __typename?: 'Aktuality';
  atFoto: Maybe<Scalars['BigInt']>;
  atFotoMain: Maybe<Scalars['BigInt']>;
  atId: Scalars['BigInt'];
  atJmeno: Scalars['String'];
  atKat: Scalars['String'];
  atKdo: Maybe<Scalars['BigInt']>;
  atPreview: Scalars['String'];
  atText: Scalars['String'];
  atTimestamp: Maybe<Scalars['Datetime']>;
  atTimestampAdd: Maybe<Scalars['Datetime']>;
  /** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
  galerieFotoByAtFotoMain: Maybe<GalerieFoto>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `User` that is related to this `Aktuality`. */
  userByAtKdo: Maybe<User>;
};

/**
 * A condition to be used against `Aktuality` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type AktualityCondition = {
  /** Checks for equality with the object’s `atFoto` field. */
  atFoto?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `atFotoMain` field. */
  atFotoMain?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `atId` field. */
  atId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `atJmeno` field. */
  atJmeno?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `atKat` field. */
  atKat?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `atKdo` field. */
  atKdo?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `atPreview` field. */
  atPreview?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `atText` field. */
  atText?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `atTimestamp` field. */
  atTimestamp?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `atTimestampAdd` field. */
  atTimestampAdd?: InputMaybe<Scalars['Datetime']>;
};

/** An input for mutations affecting `Aktuality` */
export type AktualityInput = {
  atFoto?: InputMaybe<Scalars['BigInt']>;
  atFotoMain?: InputMaybe<Scalars['BigInt']>;
  atId?: InputMaybe<Scalars['BigInt']>;
  atJmeno: Scalars['String'];
  atKat: Scalars['String'];
  atKdo?: InputMaybe<Scalars['BigInt']>;
  atPreview: Scalars['String'];
  atText: Scalars['String'];
  atTimestamp?: InputMaybe<Scalars['Datetime']>;
  atTimestampAdd?: InputMaybe<Scalars['Datetime']>;
};

/** Represents an update to a `Aktuality`. Fields that are set will be updated. */
export type AktualityPatch = {
  atFoto?: InputMaybe<Scalars['BigInt']>;
  atFotoMain?: InputMaybe<Scalars['BigInt']>;
  atId?: InputMaybe<Scalars['BigInt']>;
  atJmeno?: InputMaybe<Scalars['String']>;
  atKat?: InputMaybe<Scalars['String']>;
  atKdo?: InputMaybe<Scalars['BigInt']>;
  atPreview?: InputMaybe<Scalars['String']>;
  atText?: InputMaybe<Scalars['String']>;
  atTimestamp?: InputMaybe<Scalars['Datetime']>;
  atTimestampAdd?: InputMaybe<Scalars['Datetime']>;
};

export type Attachment = Node & {
  __typename?: 'Attachment';
  /** Reads and enables pagination through a set of `LocationAttachment`. */
  locationAttachmentsByObjectName: LocationAttachmentsConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  objectName: Scalars['String'];
  previewObjectName: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `RoomAttachment`. */
  roomAttachmentsByObjectName: RoomAttachmentsConnection;
  /** Reads and enables pagination through a set of `TenantAttachment`. */
  tenantAttachmentsByObjectName: TenantAttachmentsConnection;
  uploadedAt: Scalars['Datetime'];
  uploadedBy: Maybe<Scalars['BigInt']>;
  /** Reads a single `User` that is related to this `Attachment`. */
  userByUploadedBy: Maybe<User>;
};


export type AttachmentLocationAttachmentsByObjectNameArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<LocationAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LocationAttachmentsOrderBy>>;
};


export type AttachmentRoomAttachmentsByObjectNameArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<RoomAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RoomAttachmentsOrderBy>>;
};


export type AttachmentTenantAttachmentsByObjectNameArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<TenantAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TenantAttachmentsOrderBy>>;
};

/**
 * A condition to be used against `Attachment` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type AttachmentCondition = {
  /** Checks for equality with the object’s `objectName` field. */
  objectName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `previewObjectName` field. */
  previewObjectName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uploadedAt` field. */
  uploadedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `uploadedBy` field. */
  uploadedBy?: InputMaybe<Scalars['BigInt']>;
};

/** An input for mutations affecting `Attachment` */
export type AttachmentInput = {
  objectName: Scalars['String'];
  previewObjectName?: InputMaybe<Scalars['String']>;
  uploadedAt?: InputMaybe<Scalars['Datetime']>;
  uploadedBy?: InputMaybe<Scalars['BigInt']>;
};

/** Represents an update to a `Attachment`. Fields that are set will be updated. */
export type AttachmentPatch = {
  objectName?: InputMaybe<Scalars['String']>;
  previewObjectName?: InputMaybe<Scalars['String']>;
  uploadedAt?: InputMaybe<Scalars['Datetime']>;
  uploadedBy?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `Attachment` values. */
export type AttachmentsConnection = {
  __typename?: 'AttachmentsConnection';
  /** A list of edges which contains the `Attachment` and cursor to aid in pagination. */
  edges: Array<AttachmentsEdge>;
  /** A list of `Attachment` objects. */
  nodes: Array<Attachment>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Attachment` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Attachment` edge in the connection. */
export type AttachmentsEdge = {
  __typename?: 'AttachmentsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Attachment` at the end of the edge. */
  node: Attachment;
};

/** Methods to use when ordering `Attachment`. */
export enum AttachmentsOrderBy {
  LocationAttachmentsByObjectNameCountAsc = 'LOCATION_ATTACHMENTS_BY_OBJECT_NAME__COUNT_ASC',
  LocationAttachmentsByObjectNameCountDesc = 'LOCATION_ATTACHMENTS_BY_OBJECT_NAME__COUNT_DESC',
  Natural = 'NATURAL',
  ObjectNameAsc = 'OBJECT_NAME_ASC',
  ObjectNameDesc = 'OBJECT_NAME_DESC',
  PreviewObjectNameAsc = 'PREVIEW_OBJECT_NAME_ASC',
  PreviewObjectNameDesc = 'PREVIEW_OBJECT_NAME_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RoomAttachmentsByObjectNameCountAsc = 'ROOM_ATTACHMENTS_BY_OBJECT_NAME__COUNT_ASC',
  RoomAttachmentsByObjectNameCountDesc = 'ROOM_ATTACHMENTS_BY_OBJECT_NAME__COUNT_DESC',
  TenantAttachmentsByObjectNameCountAsc = 'TENANT_ATTACHMENTS_BY_OBJECT_NAME__COUNT_ASC',
  TenantAttachmentsByObjectNameCountDesc = 'TENANT_ATTACHMENTS_BY_OBJECT_NAME__COUNT_DESC',
  UploadedAtAsc = 'UPLOADED_AT_ASC',
  UploadedAtDesc = 'UPLOADED_AT_DESC',
  UploadedByAsc = 'UPLOADED_BY_ASC',
  UploadedByDesc = 'UPLOADED_BY_DESC',
  UserByUploadedByUBanAsc = 'USER_BY_UPLOADED_BY__U_BAN_ASC',
  UserByUploadedByUBanDesc = 'USER_BY_UPLOADED_BY__U_BAN_DESC',
  UserByUploadedByUCityAsc = 'USER_BY_UPLOADED_BY__U_CITY_ASC',
  UserByUploadedByUCityDesc = 'USER_BY_UPLOADED_BY__U_CITY_DESC',
  UserByUploadedByUConfirmedAsc = 'USER_BY_UPLOADED_BY__U_CONFIRMED_ASC',
  UserByUploadedByUConfirmedDesc = 'USER_BY_UPLOADED_BY__U_CONFIRMED_DESC',
  UserByUploadedByUConscriptionNumberAsc = 'USER_BY_UPLOADED_BY__U_CONSCRIPTION_NUMBER_ASC',
  UserByUploadedByUConscriptionNumberDesc = 'USER_BY_UPLOADED_BY__U_CONSCRIPTION_NUMBER_DESC',
  UserByUploadedByUCreatedAtAsc = 'USER_BY_UPLOADED_BY__U_CREATED_AT_ASC',
  UserByUploadedByUCreatedAtDesc = 'USER_BY_UPLOADED_BY__U_CREATED_AT_DESC',
  UserByUploadedByUDancerAsc = 'USER_BY_UPLOADED_BY__U_DANCER_ASC',
  UserByUploadedByUDancerDesc = 'USER_BY_UPLOADED_BY__U_DANCER_DESC',
  UserByUploadedByUDistrictAsc = 'USER_BY_UPLOADED_BY__U_DISTRICT_ASC',
  UserByUploadedByUDistrictDesc = 'USER_BY_UPLOADED_BY__U_DISTRICT_DESC',
  UserByUploadedByUEmailAsc = 'USER_BY_UPLOADED_BY__U_EMAIL_ASC',
  UserByUploadedByUEmailDesc = 'USER_BY_UPLOADED_BY__U_EMAIL_DESC',
  UserByUploadedByUGdprSignedAtAsc = 'USER_BY_UPLOADED_BY__U_GDPR_SIGNED_AT_ASC',
  UserByUploadedByUGdprSignedAtDesc = 'USER_BY_UPLOADED_BY__U_GDPR_SIGNED_AT_DESC',
  UserByUploadedByUGroupAsc = 'USER_BY_UPLOADED_BY__U_GROUP_ASC',
  UserByUploadedByUGroupDesc = 'USER_BY_UPLOADED_BY__U_GROUP_DESC',
  UserByUploadedByUIdAsc = 'USER_BY_UPLOADED_BY__U_ID_ASC',
  UserByUploadedByUIdDesc = 'USER_BY_UPLOADED_BY__U_ID_DESC',
  UserByUploadedByUJmenoAsc = 'USER_BY_UPLOADED_BY__U_JMENO_ASC',
  UserByUploadedByUJmenoDesc = 'USER_BY_UPLOADED_BY__U_JMENO_DESC',
  UserByUploadedByULevelAsc = 'USER_BY_UPLOADED_BY__U_LEVEL_ASC',
  UserByUploadedByULevelDesc = 'USER_BY_UPLOADED_BY__U_LEVEL_DESC',
  UserByUploadedByULockAsc = 'USER_BY_UPLOADED_BY__U_LOCK_ASC',
  UserByUploadedByULockDesc = 'USER_BY_UPLOADED_BY__U_LOCK_DESC',
  UserByUploadedByULoginAsc = 'USER_BY_UPLOADED_BY__U_LOGIN_ASC',
  UserByUploadedByULoginDesc = 'USER_BY_UPLOADED_BY__U_LOGIN_DESC',
  UserByUploadedByUMemberSinceAsc = 'USER_BY_UPLOADED_BY__U_MEMBER_SINCE_ASC',
  UserByUploadedByUMemberSinceDesc = 'USER_BY_UPLOADED_BY__U_MEMBER_SINCE_DESC',
  UserByUploadedByUMemberUntilAsc = 'USER_BY_UPLOADED_BY__U_MEMBER_UNTIL_ASC',
  UserByUploadedByUMemberUntilDesc = 'USER_BY_UPLOADED_BY__U_MEMBER_UNTIL_DESC',
  UserByUploadedByUNarozeniAsc = 'USER_BY_UPLOADED_BY__U_NAROZENI_ASC',
  UserByUploadedByUNarozeniDesc = 'USER_BY_UPLOADED_BY__U_NAROZENI_DESC',
  UserByUploadedByUNationalityAsc = 'USER_BY_UPLOADED_BY__U_NATIONALITY_ASC',
  UserByUploadedByUNationalityDesc = 'USER_BY_UPLOADED_BY__U_NATIONALITY_DESC',
  UserByUploadedByUOrientationNumberAsc = 'USER_BY_UPLOADED_BY__U_ORIENTATION_NUMBER_ASC',
  UserByUploadedByUOrientationNumberDesc = 'USER_BY_UPLOADED_BY__U_ORIENTATION_NUMBER_DESC',
  UserByUploadedByUPassAsc = 'USER_BY_UPLOADED_BY__U_PASS_ASC',
  UserByUploadedByUPassDesc = 'USER_BY_UPLOADED_BY__U_PASS_DESC',
  UserByUploadedByUPohlaviAsc = 'USER_BY_UPLOADED_BY__U_POHLAVI_ASC',
  UserByUploadedByUPohlaviDesc = 'USER_BY_UPLOADED_BY__U_POHLAVI_DESC',
  UserByUploadedByUPostalCodeAsc = 'USER_BY_UPLOADED_BY__U_POSTAL_CODE_ASC',
  UserByUploadedByUPostalCodeDesc = 'USER_BY_UPLOADED_BY__U_POSTAL_CODE_DESC',
  UserByUploadedByUPoznamkyAsc = 'USER_BY_UPLOADED_BY__U_POZNAMKY_ASC',
  UserByUploadedByUPoznamkyDesc = 'USER_BY_UPLOADED_BY__U_POZNAMKY_DESC',
  UserByUploadedByUPrijmeniAsc = 'USER_BY_UPLOADED_BY__U_PRIJMENI_ASC',
  UserByUploadedByUPrijmeniDesc = 'USER_BY_UPLOADED_BY__U_PRIJMENI_DESC',
  UserByUploadedByURodneCisloAsc = 'USER_BY_UPLOADED_BY__U_RODNE_CISLO_ASC',
  UserByUploadedByURodneCisloDesc = 'USER_BY_UPLOADED_BY__U_RODNE_CISLO_DESC',
  UserByUploadedByUSkupinaAsc = 'USER_BY_UPLOADED_BY__U_SKUPINA_ASC',
  UserByUploadedByUSkupinaDesc = 'USER_BY_UPLOADED_BY__U_SKUPINA_DESC',
  UserByUploadedByUStreetAsc = 'USER_BY_UPLOADED_BY__U_STREET_ASC',
  UserByUploadedByUStreetDesc = 'USER_BY_UPLOADED_BY__U_STREET_DESC',
  UserByUploadedByUSystemAsc = 'USER_BY_UPLOADED_BY__U_SYSTEM_ASC',
  UserByUploadedByUSystemDesc = 'USER_BY_UPLOADED_BY__U_SYSTEM_DESC',
  UserByUploadedByUTeacherAsc = 'USER_BY_UPLOADED_BY__U_TEACHER_ASC',
  UserByUploadedByUTeacherDesc = 'USER_BY_UPLOADED_BY__U_TEACHER_DESC',
  UserByUploadedByUTelefonAsc = 'USER_BY_UPLOADED_BY__U_TELEFON_ASC',
  UserByUploadedByUTelefonDesc = 'USER_BY_UPLOADED_BY__U_TELEFON_DESC',
  UserByUploadedByUTimestampAsc = 'USER_BY_UPLOADED_BY__U_TIMESTAMP_ASC',
  UserByUploadedByUTimestampDesc = 'USER_BY_UPLOADED_BY__U_TIMESTAMP_DESC'
}

export type AttendeeExternal = Node & {
  __typename?: 'AttendeeExternal';
  birthNumber: Maybe<Scalars['String']>;
  confirmedAt: Maybe<Scalars['Datetime']>;
  confirmedBy: Maybe<Scalars['BigInt']>;
  createdAt: Scalars['Datetime'];
  email: Scalars['String'];
  /** Reads a single `Event` that is related to this `AttendeeExternal`. */
  event: Maybe<Event>;
  eventId: Maybe<Scalars['BigInt']>;
  firstName: Scalars['String'];
  guardianName: Scalars['String'];
  id: Scalars['BigInt'];
  lastName: Scalars['String'];
  managedBy: Maybe<Scalars['BigInt']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  notes: Scalars['String'];
  phone: Scalars['String'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `User` that is related to this `AttendeeExternal`. */
  userByConfirmedBy: Maybe<User>;
  /** Reads a single `User` that is related to this `AttendeeExternal`. */
  userByManagedBy: Maybe<User>;
};

/**
 * A condition to be used against `AttendeeExternal` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type AttendeeExternalCondition = {
  /** Checks for equality with the object’s `birthNumber` field. */
  birthNumber?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `confirmedAt` field. */
  confirmedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `confirmedBy` field. */
  confirmedBy?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `eventId` field. */
  eventId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `guardianName` field. */
  guardianName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `managedBy` field. */
  managedBy?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `phone` field. */
  phone?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']>;
};

/** An input for mutations affecting `AttendeeExternal` */
export type AttendeeExternalInput = {
  birthNumber?: InputMaybe<Scalars['String']>;
  confirmedAt?: InputMaybe<Scalars['Datetime']>;
  confirmedBy?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  email: Scalars['String'];
  eventId?: InputMaybe<Scalars['BigInt']>;
  firstName: Scalars['String'];
  guardianName?: InputMaybe<Scalars['String']>;
  lastName: Scalars['String'];
  managedBy?: InputMaybe<Scalars['BigInt']>;
  notes?: InputMaybe<Scalars['String']>;
  phone: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['Datetime']>;
};

/** Represents an update to a `AttendeeExternal`. Fields that are set will be updated. */
export type AttendeeExternalPatch = {
  birthNumber?: InputMaybe<Scalars['String']>;
  confirmedAt?: InputMaybe<Scalars['Datetime']>;
  confirmedBy?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  email?: InputMaybe<Scalars['String']>;
  eventId?: InputMaybe<Scalars['BigInt']>;
  firstName?: InputMaybe<Scalars['String']>;
  guardianName?: InputMaybe<Scalars['String']>;
  lastName?: InputMaybe<Scalars['String']>;
  managedBy?: InputMaybe<Scalars['BigInt']>;
  notes?: InputMaybe<Scalars['String']>;
  phone?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['Datetime']>;
};

/** A connection to a list of `AttendeeExternal` values. */
export type AttendeeExternalsConnection = {
  __typename?: 'AttendeeExternalsConnection';
  /** A list of edges which contains the `AttendeeExternal` and cursor to aid in pagination. */
  edges: Array<AttendeeExternalsEdge>;
  /** A list of `AttendeeExternal` objects. */
  nodes: Array<AttendeeExternal>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AttendeeExternal` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `AttendeeExternal` edge in the connection. */
export type AttendeeExternalsEdge = {
  __typename?: 'AttendeeExternalsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `AttendeeExternal` at the end of the edge. */
  node: AttendeeExternal;
};

/** Methods to use when ordering `AttendeeExternal`. */
export enum AttendeeExternalsOrderBy {
  BirthNumberAsc = 'BIRTH_NUMBER_ASC',
  BirthNumberDesc = 'BIRTH_NUMBER_DESC',
  ConfirmedAtAsc = 'CONFIRMED_AT_ASC',
  ConfirmedAtDesc = 'CONFIRMED_AT_DESC',
  ConfirmedByAsc = 'CONFIRMED_BY_ASC',
  ConfirmedByDesc = 'CONFIRMED_BY_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  EventByEventIdCapacityAsc = 'EVENT_BY_EVENT_ID__CAPACITY_ASC',
  EventByEventIdCapacityDesc = 'EVENT_BY_EVENT_ID__CAPACITY_DESC',
  EventByEventIdDescriptionAsc = 'EVENT_BY_EVENT_ID__DESCRIPTION_ASC',
  EventByEventIdDescriptionDesc = 'EVENT_BY_EVENT_ID__DESCRIPTION_DESC',
  EventByEventIdEnableNotesAsc = 'EVENT_BY_EVENT_ID__ENABLE_NOTES_ASC',
  EventByEventIdEnableNotesDesc = 'EVENT_BY_EVENT_ID__ENABLE_NOTES_DESC',
  EventByEventIdFilesLegacyAsc = 'EVENT_BY_EVENT_ID__FILES_LEGACY_ASC',
  EventByEventIdFilesLegacyDesc = 'EVENT_BY_EVENT_ID__FILES_LEGACY_DESC',
  EventByEventIdIdAsc = 'EVENT_BY_EVENT_ID__ID_ASC',
  EventByEventIdIdDesc = 'EVENT_BY_EVENT_ID__ID_DESC',
  EventByEventIdIsLockedAsc = 'EVENT_BY_EVENT_ID__IS_LOCKED_ASC',
  EventByEventIdIsLockedDesc = 'EVENT_BY_EVENT_ID__IS_LOCKED_DESC',
  EventByEventIdIsPublicAsc = 'EVENT_BY_EVENT_ID__IS_PUBLIC_ASC',
  EventByEventIdIsPublicDesc = 'EVENT_BY_EVENT_ID__IS_PUBLIC_DESC',
  EventByEventIdIsVisibleAsc = 'EVENT_BY_EVENT_ID__IS_VISIBLE_ASC',
  EventByEventIdIsVisibleDesc = 'EVENT_BY_EVENT_ID__IS_VISIBLE_DESC',
  EventByEventIdLocationTextAsc = 'EVENT_BY_EVENT_ID__LOCATION_TEXT_ASC',
  EventByEventIdLocationTextDesc = 'EVENT_BY_EVENT_ID__LOCATION_TEXT_DESC',
  EventByEventIdNameAsc = 'EVENT_BY_EVENT_ID__NAME_ASC',
  EventByEventIdNameDesc = 'EVENT_BY_EVENT_ID__NAME_DESC',
  EventByEventIdSinceAsc = 'EVENT_BY_EVENT_ID__SINCE_ASC',
  EventByEventIdSinceDesc = 'EVENT_BY_EVENT_ID__SINCE_DESC',
  EventByEventIdSummaryAsc = 'EVENT_BY_EVENT_ID__SUMMARY_ASC',
  EventByEventIdSummaryDesc = 'EVENT_BY_EVENT_ID__SUMMARY_DESC',
  EventByEventIdUntilAsc = 'EVENT_BY_EVENT_ID__UNTIL_ASC',
  EventByEventIdUntilDesc = 'EVENT_BY_EVENT_ID__UNTIL_DESC',
  EventByEventIdUpdatedAtAsc = 'EVENT_BY_EVENT_ID__UPDATED_AT_ASC',
  EventByEventIdUpdatedAtDesc = 'EVENT_BY_EVENT_ID__UPDATED_AT_DESC',
  EventIdAsc = 'EVENT_ID_ASC',
  EventIdDesc = 'EVENT_ID_DESC',
  FirstNameAsc = 'FIRST_NAME_ASC',
  FirstNameDesc = 'FIRST_NAME_DESC',
  GuardianNameAsc = 'GUARDIAN_NAME_ASC',
  GuardianNameDesc = 'GUARDIAN_NAME_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LastNameAsc = 'LAST_NAME_ASC',
  LastNameDesc = 'LAST_NAME_DESC',
  ManagedByAsc = 'MANAGED_BY_ASC',
  ManagedByDesc = 'MANAGED_BY_DESC',
  Natural = 'NATURAL',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  PhoneAsc = 'PHONE_ASC',
  PhoneDesc = 'PHONE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UserByConfirmedByUBanAsc = 'USER_BY_CONFIRMED_BY__U_BAN_ASC',
  UserByConfirmedByUBanDesc = 'USER_BY_CONFIRMED_BY__U_BAN_DESC',
  UserByConfirmedByUCityAsc = 'USER_BY_CONFIRMED_BY__U_CITY_ASC',
  UserByConfirmedByUCityDesc = 'USER_BY_CONFIRMED_BY__U_CITY_DESC',
  UserByConfirmedByUConfirmedAsc = 'USER_BY_CONFIRMED_BY__U_CONFIRMED_ASC',
  UserByConfirmedByUConfirmedDesc = 'USER_BY_CONFIRMED_BY__U_CONFIRMED_DESC',
  UserByConfirmedByUConscriptionNumberAsc = 'USER_BY_CONFIRMED_BY__U_CONSCRIPTION_NUMBER_ASC',
  UserByConfirmedByUConscriptionNumberDesc = 'USER_BY_CONFIRMED_BY__U_CONSCRIPTION_NUMBER_DESC',
  UserByConfirmedByUCreatedAtAsc = 'USER_BY_CONFIRMED_BY__U_CREATED_AT_ASC',
  UserByConfirmedByUCreatedAtDesc = 'USER_BY_CONFIRMED_BY__U_CREATED_AT_DESC',
  UserByConfirmedByUDancerAsc = 'USER_BY_CONFIRMED_BY__U_DANCER_ASC',
  UserByConfirmedByUDancerDesc = 'USER_BY_CONFIRMED_BY__U_DANCER_DESC',
  UserByConfirmedByUDistrictAsc = 'USER_BY_CONFIRMED_BY__U_DISTRICT_ASC',
  UserByConfirmedByUDistrictDesc = 'USER_BY_CONFIRMED_BY__U_DISTRICT_DESC',
  UserByConfirmedByUEmailAsc = 'USER_BY_CONFIRMED_BY__U_EMAIL_ASC',
  UserByConfirmedByUEmailDesc = 'USER_BY_CONFIRMED_BY__U_EMAIL_DESC',
  UserByConfirmedByUGdprSignedAtAsc = 'USER_BY_CONFIRMED_BY__U_GDPR_SIGNED_AT_ASC',
  UserByConfirmedByUGdprSignedAtDesc = 'USER_BY_CONFIRMED_BY__U_GDPR_SIGNED_AT_DESC',
  UserByConfirmedByUGroupAsc = 'USER_BY_CONFIRMED_BY__U_GROUP_ASC',
  UserByConfirmedByUGroupDesc = 'USER_BY_CONFIRMED_BY__U_GROUP_DESC',
  UserByConfirmedByUIdAsc = 'USER_BY_CONFIRMED_BY__U_ID_ASC',
  UserByConfirmedByUIdDesc = 'USER_BY_CONFIRMED_BY__U_ID_DESC',
  UserByConfirmedByUJmenoAsc = 'USER_BY_CONFIRMED_BY__U_JMENO_ASC',
  UserByConfirmedByUJmenoDesc = 'USER_BY_CONFIRMED_BY__U_JMENO_DESC',
  UserByConfirmedByULevelAsc = 'USER_BY_CONFIRMED_BY__U_LEVEL_ASC',
  UserByConfirmedByULevelDesc = 'USER_BY_CONFIRMED_BY__U_LEVEL_DESC',
  UserByConfirmedByULockAsc = 'USER_BY_CONFIRMED_BY__U_LOCK_ASC',
  UserByConfirmedByULockDesc = 'USER_BY_CONFIRMED_BY__U_LOCK_DESC',
  UserByConfirmedByULoginAsc = 'USER_BY_CONFIRMED_BY__U_LOGIN_ASC',
  UserByConfirmedByULoginDesc = 'USER_BY_CONFIRMED_BY__U_LOGIN_DESC',
  UserByConfirmedByUMemberSinceAsc = 'USER_BY_CONFIRMED_BY__U_MEMBER_SINCE_ASC',
  UserByConfirmedByUMemberSinceDesc = 'USER_BY_CONFIRMED_BY__U_MEMBER_SINCE_DESC',
  UserByConfirmedByUMemberUntilAsc = 'USER_BY_CONFIRMED_BY__U_MEMBER_UNTIL_ASC',
  UserByConfirmedByUMemberUntilDesc = 'USER_BY_CONFIRMED_BY__U_MEMBER_UNTIL_DESC',
  UserByConfirmedByUNarozeniAsc = 'USER_BY_CONFIRMED_BY__U_NAROZENI_ASC',
  UserByConfirmedByUNarozeniDesc = 'USER_BY_CONFIRMED_BY__U_NAROZENI_DESC',
  UserByConfirmedByUNationalityAsc = 'USER_BY_CONFIRMED_BY__U_NATIONALITY_ASC',
  UserByConfirmedByUNationalityDesc = 'USER_BY_CONFIRMED_BY__U_NATIONALITY_DESC',
  UserByConfirmedByUOrientationNumberAsc = 'USER_BY_CONFIRMED_BY__U_ORIENTATION_NUMBER_ASC',
  UserByConfirmedByUOrientationNumberDesc = 'USER_BY_CONFIRMED_BY__U_ORIENTATION_NUMBER_DESC',
  UserByConfirmedByUPassAsc = 'USER_BY_CONFIRMED_BY__U_PASS_ASC',
  UserByConfirmedByUPassDesc = 'USER_BY_CONFIRMED_BY__U_PASS_DESC',
  UserByConfirmedByUPohlaviAsc = 'USER_BY_CONFIRMED_BY__U_POHLAVI_ASC',
  UserByConfirmedByUPohlaviDesc = 'USER_BY_CONFIRMED_BY__U_POHLAVI_DESC',
  UserByConfirmedByUPostalCodeAsc = 'USER_BY_CONFIRMED_BY__U_POSTAL_CODE_ASC',
  UserByConfirmedByUPostalCodeDesc = 'USER_BY_CONFIRMED_BY__U_POSTAL_CODE_DESC',
  UserByConfirmedByUPoznamkyAsc = 'USER_BY_CONFIRMED_BY__U_POZNAMKY_ASC',
  UserByConfirmedByUPoznamkyDesc = 'USER_BY_CONFIRMED_BY__U_POZNAMKY_DESC',
  UserByConfirmedByUPrijmeniAsc = 'USER_BY_CONFIRMED_BY__U_PRIJMENI_ASC',
  UserByConfirmedByUPrijmeniDesc = 'USER_BY_CONFIRMED_BY__U_PRIJMENI_DESC',
  UserByConfirmedByURodneCisloAsc = 'USER_BY_CONFIRMED_BY__U_RODNE_CISLO_ASC',
  UserByConfirmedByURodneCisloDesc = 'USER_BY_CONFIRMED_BY__U_RODNE_CISLO_DESC',
  UserByConfirmedByUSkupinaAsc = 'USER_BY_CONFIRMED_BY__U_SKUPINA_ASC',
  UserByConfirmedByUSkupinaDesc = 'USER_BY_CONFIRMED_BY__U_SKUPINA_DESC',
  UserByConfirmedByUStreetAsc = 'USER_BY_CONFIRMED_BY__U_STREET_ASC',
  UserByConfirmedByUStreetDesc = 'USER_BY_CONFIRMED_BY__U_STREET_DESC',
  UserByConfirmedByUSystemAsc = 'USER_BY_CONFIRMED_BY__U_SYSTEM_ASC',
  UserByConfirmedByUSystemDesc = 'USER_BY_CONFIRMED_BY__U_SYSTEM_DESC',
  UserByConfirmedByUTeacherAsc = 'USER_BY_CONFIRMED_BY__U_TEACHER_ASC',
  UserByConfirmedByUTeacherDesc = 'USER_BY_CONFIRMED_BY__U_TEACHER_DESC',
  UserByConfirmedByUTelefonAsc = 'USER_BY_CONFIRMED_BY__U_TELEFON_ASC',
  UserByConfirmedByUTelefonDesc = 'USER_BY_CONFIRMED_BY__U_TELEFON_DESC',
  UserByConfirmedByUTimestampAsc = 'USER_BY_CONFIRMED_BY__U_TIMESTAMP_ASC',
  UserByConfirmedByUTimestampDesc = 'USER_BY_CONFIRMED_BY__U_TIMESTAMP_DESC',
  UserByManagedByUBanAsc = 'USER_BY_MANAGED_BY__U_BAN_ASC',
  UserByManagedByUBanDesc = 'USER_BY_MANAGED_BY__U_BAN_DESC',
  UserByManagedByUCityAsc = 'USER_BY_MANAGED_BY__U_CITY_ASC',
  UserByManagedByUCityDesc = 'USER_BY_MANAGED_BY__U_CITY_DESC',
  UserByManagedByUConfirmedAsc = 'USER_BY_MANAGED_BY__U_CONFIRMED_ASC',
  UserByManagedByUConfirmedDesc = 'USER_BY_MANAGED_BY__U_CONFIRMED_DESC',
  UserByManagedByUConscriptionNumberAsc = 'USER_BY_MANAGED_BY__U_CONSCRIPTION_NUMBER_ASC',
  UserByManagedByUConscriptionNumberDesc = 'USER_BY_MANAGED_BY__U_CONSCRIPTION_NUMBER_DESC',
  UserByManagedByUCreatedAtAsc = 'USER_BY_MANAGED_BY__U_CREATED_AT_ASC',
  UserByManagedByUCreatedAtDesc = 'USER_BY_MANAGED_BY__U_CREATED_AT_DESC',
  UserByManagedByUDancerAsc = 'USER_BY_MANAGED_BY__U_DANCER_ASC',
  UserByManagedByUDancerDesc = 'USER_BY_MANAGED_BY__U_DANCER_DESC',
  UserByManagedByUDistrictAsc = 'USER_BY_MANAGED_BY__U_DISTRICT_ASC',
  UserByManagedByUDistrictDesc = 'USER_BY_MANAGED_BY__U_DISTRICT_DESC',
  UserByManagedByUEmailAsc = 'USER_BY_MANAGED_BY__U_EMAIL_ASC',
  UserByManagedByUEmailDesc = 'USER_BY_MANAGED_BY__U_EMAIL_DESC',
  UserByManagedByUGdprSignedAtAsc = 'USER_BY_MANAGED_BY__U_GDPR_SIGNED_AT_ASC',
  UserByManagedByUGdprSignedAtDesc = 'USER_BY_MANAGED_BY__U_GDPR_SIGNED_AT_DESC',
  UserByManagedByUGroupAsc = 'USER_BY_MANAGED_BY__U_GROUP_ASC',
  UserByManagedByUGroupDesc = 'USER_BY_MANAGED_BY__U_GROUP_DESC',
  UserByManagedByUIdAsc = 'USER_BY_MANAGED_BY__U_ID_ASC',
  UserByManagedByUIdDesc = 'USER_BY_MANAGED_BY__U_ID_DESC',
  UserByManagedByUJmenoAsc = 'USER_BY_MANAGED_BY__U_JMENO_ASC',
  UserByManagedByUJmenoDesc = 'USER_BY_MANAGED_BY__U_JMENO_DESC',
  UserByManagedByULevelAsc = 'USER_BY_MANAGED_BY__U_LEVEL_ASC',
  UserByManagedByULevelDesc = 'USER_BY_MANAGED_BY__U_LEVEL_DESC',
  UserByManagedByULockAsc = 'USER_BY_MANAGED_BY__U_LOCK_ASC',
  UserByManagedByULockDesc = 'USER_BY_MANAGED_BY__U_LOCK_DESC',
  UserByManagedByULoginAsc = 'USER_BY_MANAGED_BY__U_LOGIN_ASC',
  UserByManagedByULoginDesc = 'USER_BY_MANAGED_BY__U_LOGIN_DESC',
  UserByManagedByUMemberSinceAsc = 'USER_BY_MANAGED_BY__U_MEMBER_SINCE_ASC',
  UserByManagedByUMemberSinceDesc = 'USER_BY_MANAGED_BY__U_MEMBER_SINCE_DESC',
  UserByManagedByUMemberUntilAsc = 'USER_BY_MANAGED_BY__U_MEMBER_UNTIL_ASC',
  UserByManagedByUMemberUntilDesc = 'USER_BY_MANAGED_BY__U_MEMBER_UNTIL_DESC',
  UserByManagedByUNarozeniAsc = 'USER_BY_MANAGED_BY__U_NAROZENI_ASC',
  UserByManagedByUNarozeniDesc = 'USER_BY_MANAGED_BY__U_NAROZENI_DESC',
  UserByManagedByUNationalityAsc = 'USER_BY_MANAGED_BY__U_NATIONALITY_ASC',
  UserByManagedByUNationalityDesc = 'USER_BY_MANAGED_BY__U_NATIONALITY_DESC',
  UserByManagedByUOrientationNumberAsc = 'USER_BY_MANAGED_BY__U_ORIENTATION_NUMBER_ASC',
  UserByManagedByUOrientationNumberDesc = 'USER_BY_MANAGED_BY__U_ORIENTATION_NUMBER_DESC',
  UserByManagedByUPassAsc = 'USER_BY_MANAGED_BY__U_PASS_ASC',
  UserByManagedByUPassDesc = 'USER_BY_MANAGED_BY__U_PASS_DESC',
  UserByManagedByUPohlaviAsc = 'USER_BY_MANAGED_BY__U_POHLAVI_ASC',
  UserByManagedByUPohlaviDesc = 'USER_BY_MANAGED_BY__U_POHLAVI_DESC',
  UserByManagedByUPostalCodeAsc = 'USER_BY_MANAGED_BY__U_POSTAL_CODE_ASC',
  UserByManagedByUPostalCodeDesc = 'USER_BY_MANAGED_BY__U_POSTAL_CODE_DESC',
  UserByManagedByUPoznamkyAsc = 'USER_BY_MANAGED_BY__U_POZNAMKY_ASC',
  UserByManagedByUPoznamkyDesc = 'USER_BY_MANAGED_BY__U_POZNAMKY_DESC',
  UserByManagedByUPrijmeniAsc = 'USER_BY_MANAGED_BY__U_PRIJMENI_ASC',
  UserByManagedByUPrijmeniDesc = 'USER_BY_MANAGED_BY__U_PRIJMENI_DESC',
  UserByManagedByURodneCisloAsc = 'USER_BY_MANAGED_BY__U_RODNE_CISLO_ASC',
  UserByManagedByURodneCisloDesc = 'USER_BY_MANAGED_BY__U_RODNE_CISLO_DESC',
  UserByManagedByUSkupinaAsc = 'USER_BY_MANAGED_BY__U_SKUPINA_ASC',
  UserByManagedByUSkupinaDesc = 'USER_BY_MANAGED_BY__U_SKUPINA_DESC',
  UserByManagedByUStreetAsc = 'USER_BY_MANAGED_BY__U_STREET_ASC',
  UserByManagedByUStreetDesc = 'USER_BY_MANAGED_BY__U_STREET_DESC',
  UserByManagedByUSystemAsc = 'USER_BY_MANAGED_BY__U_SYSTEM_ASC',
  UserByManagedByUSystemDesc = 'USER_BY_MANAGED_BY__U_SYSTEM_DESC',
  UserByManagedByUTeacherAsc = 'USER_BY_MANAGED_BY__U_TEACHER_ASC',
  UserByManagedByUTeacherDesc = 'USER_BY_MANAGED_BY__U_TEACHER_DESC',
  UserByManagedByUTelefonAsc = 'USER_BY_MANAGED_BY__U_TELEFON_ASC',
  UserByManagedByUTelefonDesc = 'USER_BY_MANAGED_BY__U_TELEFON_DESC',
  UserByManagedByUTimestampAsc = 'USER_BY_MANAGED_BY__U_TIMESTAMP_ASC',
  UserByManagedByUTimestampDesc = 'USER_BY_MANAGED_BY__U_TIMESTAMP_DESC'
}

export type AttendeeUser = Node & {
  __typename?: 'AttendeeUser';
  birthYear: Scalars['Int'];
  /** Reads a single `Event` that is related to this `AttendeeUser`. */
  event: Maybe<Event>;
  eventId: Scalars['BigInt'];
  id: Scalars['BigInt'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  notes: Scalars['String'];
  /** Reads a single `User` that is related to this `AttendeeUser`. */
  user: Maybe<User>;
  userId: Scalars['BigInt'];
};

/**
 * A condition to be used against `AttendeeUser` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type AttendeeUserCondition = {
  /** Checks for equality with the object’s `birthYear` field. */
  birthYear?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `eventId` field. */
  eventId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']>;
};

/** An input for mutations affecting `AttendeeUser` */
export type AttendeeUserInput = {
  birthYear: Scalars['Int'];
  eventId: Scalars['BigInt'];
  id?: InputMaybe<Scalars['BigInt']>;
  notes?: InputMaybe<Scalars['String']>;
  userId: Scalars['BigInt'];
};

/** Represents an update to a `AttendeeUser`. Fields that are set will be updated. */
export type AttendeeUserPatch = {
  birthYear?: InputMaybe<Scalars['Int']>;
  eventId?: InputMaybe<Scalars['BigInt']>;
  id?: InputMaybe<Scalars['BigInt']>;
  notes?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `AttendeeUser` values. */
export type AttendeeUsersConnection = {
  __typename?: 'AttendeeUsersConnection';
  /** A list of edges which contains the `AttendeeUser` and cursor to aid in pagination. */
  edges: Array<AttendeeUsersEdge>;
  /** A list of `AttendeeUser` objects. */
  nodes: Array<AttendeeUser>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AttendeeUser` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `AttendeeUser` edge in the connection. */
export type AttendeeUsersEdge = {
  __typename?: 'AttendeeUsersEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `AttendeeUser` at the end of the edge. */
  node: AttendeeUser;
};

/** Methods to use when ordering `AttendeeUser`. */
export enum AttendeeUsersOrderBy {
  BirthYearAsc = 'BIRTH_YEAR_ASC',
  BirthYearDesc = 'BIRTH_YEAR_DESC',
  EventByEventIdCapacityAsc = 'EVENT_BY_EVENT_ID__CAPACITY_ASC',
  EventByEventIdCapacityDesc = 'EVENT_BY_EVENT_ID__CAPACITY_DESC',
  EventByEventIdDescriptionAsc = 'EVENT_BY_EVENT_ID__DESCRIPTION_ASC',
  EventByEventIdDescriptionDesc = 'EVENT_BY_EVENT_ID__DESCRIPTION_DESC',
  EventByEventIdEnableNotesAsc = 'EVENT_BY_EVENT_ID__ENABLE_NOTES_ASC',
  EventByEventIdEnableNotesDesc = 'EVENT_BY_EVENT_ID__ENABLE_NOTES_DESC',
  EventByEventIdFilesLegacyAsc = 'EVENT_BY_EVENT_ID__FILES_LEGACY_ASC',
  EventByEventIdFilesLegacyDesc = 'EVENT_BY_EVENT_ID__FILES_LEGACY_DESC',
  EventByEventIdIdAsc = 'EVENT_BY_EVENT_ID__ID_ASC',
  EventByEventIdIdDesc = 'EVENT_BY_EVENT_ID__ID_DESC',
  EventByEventIdIsLockedAsc = 'EVENT_BY_EVENT_ID__IS_LOCKED_ASC',
  EventByEventIdIsLockedDesc = 'EVENT_BY_EVENT_ID__IS_LOCKED_DESC',
  EventByEventIdIsPublicAsc = 'EVENT_BY_EVENT_ID__IS_PUBLIC_ASC',
  EventByEventIdIsPublicDesc = 'EVENT_BY_EVENT_ID__IS_PUBLIC_DESC',
  EventByEventIdIsVisibleAsc = 'EVENT_BY_EVENT_ID__IS_VISIBLE_ASC',
  EventByEventIdIsVisibleDesc = 'EVENT_BY_EVENT_ID__IS_VISIBLE_DESC',
  EventByEventIdLocationTextAsc = 'EVENT_BY_EVENT_ID__LOCATION_TEXT_ASC',
  EventByEventIdLocationTextDesc = 'EVENT_BY_EVENT_ID__LOCATION_TEXT_DESC',
  EventByEventIdNameAsc = 'EVENT_BY_EVENT_ID__NAME_ASC',
  EventByEventIdNameDesc = 'EVENT_BY_EVENT_ID__NAME_DESC',
  EventByEventIdSinceAsc = 'EVENT_BY_EVENT_ID__SINCE_ASC',
  EventByEventIdSinceDesc = 'EVENT_BY_EVENT_ID__SINCE_DESC',
  EventByEventIdSummaryAsc = 'EVENT_BY_EVENT_ID__SUMMARY_ASC',
  EventByEventIdSummaryDesc = 'EVENT_BY_EVENT_ID__SUMMARY_DESC',
  EventByEventIdUntilAsc = 'EVENT_BY_EVENT_ID__UNTIL_ASC',
  EventByEventIdUntilDesc = 'EVENT_BY_EVENT_ID__UNTIL_DESC',
  EventByEventIdUpdatedAtAsc = 'EVENT_BY_EVENT_ID__UPDATED_AT_ASC',
  EventByEventIdUpdatedAtDesc = 'EVENT_BY_EVENT_ID__UPDATED_AT_DESC',
  EventIdAsc = 'EVENT_ID_ASC',
  EventIdDesc = 'EVENT_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserByUserIdUBanAsc = 'USER_BY_USER_ID__U_BAN_ASC',
  UserByUserIdUBanDesc = 'USER_BY_USER_ID__U_BAN_DESC',
  UserByUserIdUCityAsc = 'USER_BY_USER_ID__U_CITY_ASC',
  UserByUserIdUCityDesc = 'USER_BY_USER_ID__U_CITY_DESC',
  UserByUserIdUConfirmedAsc = 'USER_BY_USER_ID__U_CONFIRMED_ASC',
  UserByUserIdUConfirmedDesc = 'USER_BY_USER_ID__U_CONFIRMED_DESC',
  UserByUserIdUConscriptionNumberAsc = 'USER_BY_USER_ID__U_CONSCRIPTION_NUMBER_ASC',
  UserByUserIdUConscriptionNumberDesc = 'USER_BY_USER_ID__U_CONSCRIPTION_NUMBER_DESC',
  UserByUserIdUCreatedAtAsc = 'USER_BY_USER_ID__U_CREATED_AT_ASC',
  UserByUserIdUCreatedAtDesc = 'USER_BY_USER_ID__U_CREATED_AT_DESC',
  UserByUserIdUDancerAsc = 'USER_BY_USER_ID__U_DANCER_ASC',
  UserByUserIdUDancerDesc = 'USER_BY_USER_ID__U_DANCER_DESC',
  UserByUserIdUDistrictAsc = 'USER_BY_USER_ID__U_DISTRICT_ASC',
  UserByUserIdUDistrictDesc = 'USER_BY_USER_ID__U_DISTRICT_DESC',
  UserByUserIdUEmailAsc = 'USER_BY_USER_ID__U_EMAIL_ASC',
  UserByUserIdUEmailDesc = 'USER_BY_USER_ID__U_EMAIL_DESC',
  UserByUserIdUGdprSignedAtAsc = 'USER_BY_USER_ID__U_GDPR_SIGNED_AT_ASC',
  UserByUserIdUGdprSignedAtDesc = 'USER_BY_USER_ID__U_GDPR_SIGNED_AT_DESC',
  UserByUserIdUGroupAsc = 'USER_BY_USER_ID__U_GROUP_ASC',
  UserByUserIdUGroupDesc = 'USER_BY_USER_ID__U_GROUP_DESC',
  UserByUserIdUIdAsc = 'USER_BY_USER_ID__U_ID_ASC',
  UserByUserIdUIdDesc = 'USER_BY_USER_ID__U_ID_DESC',
  UserByUserIdUJmenoAsc = 'USER_BY_USER_ID__U_JMENO_ASC',
  UserByUserIdUJmenoDesc = 'USER_BY_USER_ID__U_JMENO_DESC',
  UserByUserIdULevelAsc = 'USER_BY_USER_ID__U_LEVEL_ASC',
  UserByUserIdULevelDesc = 'USER_BY_USER_ID__U_LEVEL_DESC',
  UserByUserIdULockAsc = 'USER_BY_USER_ID__U_LOCK_ASC',
  UserByUserIdULockDesc = 'USER_BY_USER_ID__U_LOCK_DESC',
  UserByUserIdULoginAsc = 'USER_BY_USER_ID__U_LOGIN_ASC',
  UserByUserIdULoginDesc = 'USER_BY_USER_ID__U_LOGIN_DESC',
  UserByUserIdUMemberSinceAsc = 'USER_BY_USER_ID__U_MEMBER_SINCE_ASC',
  UserByUserIdUMemberSinceDesc = 'USER_BY_USER_ID__U_MEMBER_SINCE_DESC',
  UserByUserIdUMemberUntilAsc = 'USER_BY_USER_ID__U_MEMBER_UNTIL_ASC',
  UserByUserIdUMemberUntilDesc = 'USER_BY_USER_ID__U_MEMBER_UNTIL_DESC',
  UserByUserIdUNarozeniAsc = 'USER_BY_USER_ID__U_NAROZENI_ASC',
  UserByUserIdUNarozeniDesc = 'USER_BY_USER_ID__U_NAROZENI_DESC',
  UserByUserIdUNationalityAsc = 'USER_BY_USER_ID__U_NATIONALITY_ASC',
  UserByUserIdUNationalityDesc = 'USER_BY_USER_ID__U_NATIONALITY_DESC',
  UserByUserIdUOrientationNumberAsc = 'USER_BY_USER_ID__U_ORIENTATION_NUMBER_ASC',
  UserByUserIdUOrientationNumberDesc = 'USER_BY_USER_ID__U_ORIENTATION_NUMBER_DESC',
  UserByUserIdUPassAsc = 'USER_BY_USER_ID__U_PASS_ASC',
  UserByUserIdUPassDesc = 'USER_BY_USER_ID__U_PASS_DESC',
  UserByUserIdUPohlaviAsc = 'USER_BY_USER_ID__U_POHLAVI_ASC',
  UserByUserIdUPohlaviDesc = 'USER_BY_USER_ID__U_POHLAVI_DESC',
  UserByUserIdUPostalCodeAsc = 'USER_BY_USER_ID__U_POSTAL_CODE_ASC',
  UserByUserIdUPostalCodeDesc = 'USER_BY_USER_ID__U_POSTAL_CODE_DESC',
  UserByUserIdUPoznamkyAsc = 'USER_BY_USER_ID__U_POZNAMKY_ASC',
  UserByUserIdUPoznamkyDesc = 'USER_BY_USER_ID__U_POZNAMKY_DESC',
  UserByUserIdUPrijmeniAsc = 'USER_BY_USER_ID__U_PRIJMENI_ASC',
  UserByUserIdUPrijmeniDesc = 'USER_BY_USER_ID__U_PRIJMENI_DESC',
  UserByUserIdURodneCisloAsc = 'USER_BY_USER_ID__U_RODNE_CISLO_ASC',
  UserByUserIdURodneCisloDesc = 'USER_BY_USER_ID__U_RODNE_CISLO_DESC',
  UserByUserIdUSkupinaAsc = 'USER_BY_USER_ID__U_SKUPINA_ASC',
  UserByUserIdUSkupinaDesc = 'USER_BY_USER_ID__U_SKUPINA_DESC',
  UserByUserIdUStreetAsc = 'USER_BY_USER_ID__U_STREET_ASC',
  UserByUserIdUStreetDesc = 'USER_BY_USER_ID__U_STREET_DESC',
  UserByUserIdUSystemAsc = 'USER_BY_USER_ID__U_SYSTEM_ASC',
  UserByUserIdUSystemDesc = 'USER_BY_USER_ID__U_SYSTEM_DESC',
  UserByUserIdUTeacherAsc = 'USER_BY_USER_ID__U_TEACHER_ASC',
  UserByUserIdUTeacherDesc = 'USER_BY_USER_ID__U_TEACHER_DESC',
  UserByUserIdUTelefonAsc = 'USER_BY_USER_ID__U_TELEFON_ASC',
  UserByUserIdUTelefonDesc = 'USER_BY_USER_ID__U_TELEFON_DESC',
  UserByUserIdUTimestampAsc = 'USER_BY_USER_ID__U_TIMESTAMP_ASC',
  UserByUserIdUTimestampDesc = 'USER_BY_USER_ID__U_TIMESTAMP_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** All input for the `bookLesson` mutation. */
export type BookLessonInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  lessonId: Scalars['BigInt'];
};

/** The output of our `bookLesson` mutation. */
export type BookLessonPayload = {
  __typename?: 'BookLessonPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  rozpisItems: Maybe<Array<RozpisItem>>;
};

/** All input for the `cancelLesson` mutation. */
export type CancelLessonInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  lessonId: Scalars['BigInt'];
};

/** The output of our `cancelLesson` mutation. */
export type CancelLessonPayload = {
  __typename?: 'CancelLessonPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  rozpisItems: Maybe<Array<RozpisItem>>;
};

/** All input for the `cancelParticipation` mutation. */
export type CancelParticipationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  eventId: Scalars['BigInt'];
};

/** The output of our `cancelParticipation` mutation. */
export type CancelParticipationPayload = {
  __typename?: 'CancelParticipationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `changePassword` mutation. */
export type ChangePasswordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  newPass: Scalars['String'];
  oldPass: Scalars['String'];
};

/** The output of our `changePassword` mutation. */
export type ChangePasswordPayload = {
  __typename?: 'ChangePasswordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type CohortGroup = Node & {
  __typename?: 'CohortGroup';
  description: Scalars['JSON'];
  id: Scalars['BigInt'];
  isPublic: Scalars['Boolean'];
  name: Scalars['String'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  ordering: Scalars['Int'];
  /** Reads and enables pagination through a set of `Skupiny`. */
  skupiniesByCohortGroup: SkupiniesConnection;
  tenant: Maybe<Scalars['BigInt']>;
  /** Reads a single `Tenant` that is related to this `CohortGroup`. */
  tenantByTenant: Maybe<Tenant>;
};


export type CohortGroupSkupiniesByCohortGroupArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<SkupinyCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SkupiniesOrderBy>>;
};

/**
 * A condition to be used against `CohortGroup` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type CohortGroupCondition = {
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `isPublic` field. */
  isPublic?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `ordering` field. */
  ordering?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `tenant` field. */
  tenant?: InputMaybe<Scalars['BigInt']>;
};

/** An input for mutations affecting `CohortGroup` */
export type CohortGroupInput = {
  description?: InputMaybe<Scalars['JSON']>;
  id?: InputMaybe<Scalars['BigInt']>;
  isPublic?: InputMaybe<Scalars['Boolean']>;
  name: Scalars['String'];
  ordering?: InputMaybe<Scalars['Int']>;
  tenant?: InputMaybe<Scalars['BigInt']>;
};

/** Represents an update to a `CohortGroup`. Fields that are set will be updated. */
export type CohortGroupPatch = {
  description?: InputMaybe<Scalars['JSON']>;
  id?: InputMaybe<Scalars['BigInt']>;
  isPublic?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  ordering?: InputMaybe<Scalars['Int']>;
  tenant?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `CohortGroup` values. */
export type CohortGroupsConnection = {
  __typename?: 'CohortGroupsConnection';
  /** A list of edges which contains the `CohortGroup` and cursor to aid in pagination. */
  edges: Array<CohortGroupsEdge>;
  /** A list of `CohortGroup` objects. */
  nodes: Array<CohortGroup>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CohortGroup` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CohortGroup` edge in the connection. */
export type CohortGroupsEdge = {
  __typename?: 'CohortGroupsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `CohortGroup` at the end of the edge. */
  node: CohortGroup;
};

/** Methods to use when ordering `CohortGroup`. */
export enum CohortGroupsOrderBy {
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsPublicAsc = 'IS_PUBLIC_ASC',
  IsPublicDesc = 'IS_PUBLIC_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OrderingAsc = 'ORDERING_ASC',
  OrderingDesc = 'ORDERING_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SkupiniesByCohortGroupCountAsc = 'SKUPINIES_BY_COHORT_GROUP__COUNT_ASC',
  SkupiniesByCohortGroupCountDesc = 'SKUPINIES_BY_COHORT_GROUP__COUNT_DESC',
  TenantAsc = 'TENANT_ASC',
  TenantByTenantIdAsc = 'TENANT_BY_TENANT__ID_ASC',
  TenantByTenantIdDesc = 'TENANT_BY_TENANT__ID_DESC',
  TenantByTenantMemberInfoAsc = 'TENANT_BY_TENANT__MEMBER_INFO_ASC',
  TenantByTenantMemberInfoDesc = 'TENANT_BY_TENANT__MEMBER_INFO_DESC',
  TenantByTenantNameAsc = 'TENANT_BY_TENANT__NAME_ASC',
  TenantByTenantNameDesc = 'TENANT_BY_TENANT__NAME_DESC',
  TenantDesc = 'TENANT_DESC'
}

/** All input for the `confirmUser` mutation. */
export type ConfirmUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  cohort: Scalars['BigInt'];
  grp: Scalars['BigInt'];
  id: Scalars['BigInt'];
};

/** The output of our `confirmUser` mutation. */
export type ConfirmUserPayload = {
  __typename?: 'ConfirmUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `Akce` mutation. */
export type CreateAkceInput = {
  /** The `Akce` to be created by this mutation. */
  akce: AkceInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** All input for the create `AkceItem` mutation. */
export type CreateAkceItemInput = {
  /** The `AkceItem` to be created by this mutation. */
  akceItem: AkceItemInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** The output of our create `AkceItem` mutation. */
export type CreateAkceItemPayload = {
  __typename?: 'CreateAkceItemPayload';
  /** The `AkceItem` that was created by this mutation. */
  akceItem: Maybe<AkceItem>;
  /** An edge for our `AkceItem`. May be used by Relay 1. */
  akceItemEdge: Maybe<AkceItemsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `AkceItem` mutation. */
export type CreateAkceItemPayloadAkceItemEdgeArgs = {
  orderBy?: InputMaybe<Array<AkceItemsOrderBy>>;
};

/** The output of our create `Akce` mutation. */
export type CreateAkcePayload = {
  __typename?: 'CreateAkcePayload';
  /** The `Akce` that was created by this mutation. */
  akce: Maybe<Akce>;
  /** An edge for our `Akce`. May be used by Relay 1. */
  akceEdge: Maybe<AkcesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Akce` mutation. */
export type CreateAkcePayloadAkceEdgeArgs = {
  orderBy?: InputMaybe<Array<AkcesOrderBy>>;
};

/** All input for the create `Aktuality` mutation. */
export type CreateAktualityInput = {
  /** The `Aktuality` to be created by this mutation. */
  aktuality: AktualityInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Aktuality` mutation. */
export type CreateAktualityPayload = {
  __typename?: 'CreateAktualityPayload';
  /** The `Aktuality` that was created by this mutation. */
  aktuality: Maybe<Aktuality>;
  /** An edge for our `Aktuality`. May be used by Relay 1. */
  aktualityEdge: Maybe<AktualitiesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
  galerieFotoByAtFotoMain: Maybe<GalerieFoto>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Aktuality`. */
  userByAtKdo: Maybe<User>;
};


/** The output of our create `Aktuality` mutation. */
export type CreateAktualityPayloadAktualityEdgeArgs = {
  orderBy?: InputMaybe<Array<AktualitiesOrderBy>>;
};

/** All input for the create `Attachment` mutation. */
export type CreateAttachmentInput = {
  /** The `Attachment` to be created by this mutation. */
  attachment: AttachmentInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Attachment` mutation. */
export type CreateAttachmentPayload = {
  __typename?: 'CreateAttachmentPayload';
  /** The `Attachment` that was created by this mutation. */
  attachment: Maybe<Attachment>;
  /** An edge for our `Attachment`. May be used by Relay 1. */
  attachmentEdge: Maybe<AttachmentsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Attachment`. */
  userByUploadedBy: Maybe<User>;
};


/** The output of our create `Attachment` mutation. */
export type CreateAttachmentPayloadAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<AttachmentsOrderBy>>;
};

/** All input for the create `AttendeeExternal` mutation. */
export type CreateAttendeeExternalInput = {
  /** The `AttendeeExternal` to be created by this mutation. */
  attendeeExternal: AttendeeExternalInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** The output of our create `AttendeeExternal` mutation. */
export type CreateAttendeeExternalPayload = {
  __typename?: 'CreateAttendeeExternalPayload';
  /** The `AttendeeExternal` that was created by this mutation. */
  attendeeExternal: Maybe<AttendeeExternal>;
  /** An edge for our `AttendeeExternal`. May be used by Relay 1. */
  attendeeExternalEdge: Maybe<AttendeeExternalsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Event` that is related to this `AttendeeExternal`. */
  event: Maybe<Event>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `AttendeeExternal`. */
  userByConfirmedBy: Maybe<User>;
  /** Reads a single `User` that is related to this `AttendeeExternal`. */
  userByManagedBy: Maybe<User>;
};


/** The output of our create `AttendeeExternal` mutation. */
export type CreateAttendeeExternalPayloadAttendeeExternalEdgeArgs = {
  orderBy?: InputMaybe<Array<AttendeeExternalsOrderBy>>;
};

/** All input for the create `AttendeeUser` mutation. */
export type CreateAttendeeUserInput = {
  /** The `AttendeeUser` to be created by this mutation. */
  attendeeUser: AttendeeUserInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** The output of our create `AttendeeUser` mutation. */
export type CreateAttendeeUserPayload = {
  __typename?: 'CreateAttendeeUserPayload';
  /** The `AttendeeUser` that was created by this mutation. */
  attendeeUser: Maybe<AttendeeUser>;
  /** An edge for our `AttendeeUser`. May be used by Relay 1. */
  attendeeUserEdge: Maybe<AttendeeUsersEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Event` that is related to this `AttendeeUser`. */
  event: Maybe<Event>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `AttendeeUser`. */
  user: Maybe<User>;
};


/** The output of our create `AttendeeUser` mutation. */
export type CreateAttendeeUserPayloadAttendeeUserEdgeArgs = {
  orderBy?: InputMaybe<Array<AttendeeUsersOrderBy>>;
};

/** All input for the create `CohortGroup` mutation. */
export type CreateCohortGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `CohortGroup` to be created by this mutation. */
  cohortGroup: CohortGroupInput;
};

/** The output of our create `CohortGroup` mutation. */
export type CreateCohortGroupPayload = {
  __typename?: 'CreateCohortGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `CohortGroup` that was created by this mutation. */
  cohortGroup: Maybe<CohortGroup>;
  /** An edge for our `CohortGroup`. May be used by Relay 1. */
  cohortGroupEdge: Maybe<CohortGroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `CohortGroup`. */
  tenantByTenant: Maybe<Tenant>;
};


/** The output of our create `CohortGroup` mutation. */
export type CreateCohortGroupPayloadCohortGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<CohortGroupsOrderBy>>;
};

/** All input for the `createCouple` mutation. */
export type CreateCoupleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  man: Scalars['BigInt'];
  woman: Scalars['BigInt'];
};

/** The output of our `createCouple` mutation. */
export type CreateCouplePayload = {
  __typename?: 'CreateCouplePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  paries: Maybe<Array<Pary>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `Dokumenty` mutation. */
export type CreateDokumentyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Dokumenty` to be created by this mutation. */
  dokumenty: DokumentyInput;
};

/** The output of our create `Dokumenty` mutation. */
export type CreateDokumentyPayload = {
  __typename?: 'CreateDokumentyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Dokumenty` that was created by this mutation. */
  dokumenty: Maybe<Dokumenty>;
  /** An edge for our `Dokumenty`. May be used by Relay 1. */
  dokumentyEdge: Maybe<DokumentiesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Dokumenty`. */
  userByDKdo: Maybe<User>;
};


/** The output of our create `Dokumenty` mutation. */
export type CreateDokumentyPayloadDokumentyEdgeArgs = {
  orderBy?: InputMaybe<Array<DokumentiesOrderBy>>;
};

/** All input for the create `Event` mutation. */
export type CreateEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Event` to be created by this mutation. */
  event: EventInput;
};

/** The output of our create `Event` mutation. */
export type CreateEventPayload = {
  __typename?: 'CreateEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Event` that was created by this mutation. */
  event: Maybe<Event>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge: Maybe<EventsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Event` mutation. */
export type CreateEventPayloadEventEdgeArgs = {
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};

/** All input for the create `GalerieDir` mutation. */
export type CreateGalerieDirInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `GalerieDir` to be created by this mutation. */
  galerieDir: GalerieDirInput;
};

/** The output of our create `GalerieDir` mutation. */
export type CreateGalerieDirPayload = {
  __typename?: 'CreateGalerieDirPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GalerieDir` that was created by this mutation. */
  galerieDir: Maybe<GalerieDir>;
  /** An edge for our `GalerieDir`. May be used by Relay 1. */
  galerieDirEdge: Maybe<GalerieDirsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `GalerieDir` mutation. */
export type CreateGalerieDirPayloadGalerieDirEdgeArgs = {
  orderBy?: InputMaybe<Array<GalerieDirsOrderBy>>;
};

/** All input for the create `GalerieFoto` mutation. */
export type CreateGalerieFotoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `GalerieFoto` to be created by this mutation. */
  galerieFoto: GalerieFotoInput;
};

/** The output of our create `GalerieFoto` mutation. */
export type CreateGalerieFotoPayload = {
  __typename?: 'CreateGalerieFotoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
  galerieDirByGfIdRodic: Maybe<GalerieDir>;
  /** The `GalerieFoto` that was created by this mutation. */
  galerieFoto: Maybe<GalerieFoto>;
  /** An edge for our `GalerieFoto`. May be used by Relay 1. */
  galerieFotoEdge: Maybe<GalerieFotosEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `GalerieFoto`. */
  userByGfKdo: Maybe<User>;
};


/** The output of our create `GalerieFoto` mutation. */
export type CreateGalerieFotoPayloadGalerieFotoEdgeArgs = {
  orderBy?: InputMaybe<Array<GalerieFotosOrderBy>>;
};

/** All input for the create `LocationAttachment` mutation. */
export type CreateLocationAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `LocationAttachment` to be created by this mutation. */
  locationAttachment: LocationAttachmentInput;
};

/** The output of our create `LocationAttachment` mutation. */
export type CreateLocationAttachmentPayload = {
  __typename?: 'CreateLocationAttachmentPayload';
  /** Reads a single `Attachment` that is related to this `LocationAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Location` that is related to this `LocationAttachment`. */
  location: Maybe<Location>;
  /** The `LocationAttachment` that was created by this mutation. */
  locationAttachment: Maybe<LocationAttachment>;
  /** An edge for our `LocationAttachment`. May be used by Relay 1. */
  locationAttachmentEdge: Maybe<LocationAttachmentsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `LocationAttachment` mutation. */
export type CreateLocationAttachmentPayloadLocationAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<LocationAttachmentsOrderBy>>;
};

/** All input for the create `Location` mutation. */
export type CreateLocationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Location` to be created by this mutation. */
  location: LocationInput;
};

/** The output of our create `Location` mutation. */
export type CreateLocationPayload = {
  __typename?: 'CreateLocationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Location` that was created by this mutation. */
  location: Maybe<Location>;
  /** An edge for our `Location`. May be used by Relay 1. */
  locationEdge: Maybe<LocationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `Location`. */
  tenantByTenant: Maybe<Tenant>;
};


/** The output of our create `Location` mutation. */
export type CreateLocationPayloadLocationEdgeArgs = {
  orderBy?: InputMaybe<Array<LocationsOrderBy>>;
};

/** All input for the create `Nabidka` mutation. */
export type CreateNabidkaInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Nabidka` to be created by this mutation. */
  nabidka: NabidkaInput;
};

/** All input for the create `NabidkaItem` mutation. */
export type CreateNabidkaItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `NabidkaItem` to be created by this mutation. */
  nabidkaItem: NabidkaItemInput;
};

/** The output of our create `NabidkaItem` mutation. */
export type CreateNabidkaItemPayload = {
  __typename?: 'CreateNabidkaItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Nabidka` that is related to this `NabidkaItem`. */
  nabidkaByNiIdRodic: Maybe<Nabidka>;
  /** The `NabidkaItem` that was created by this mutation. */
  nabidkaItem: Maybe<NabidkaItem>;
  /** An edge for our `NabidkaItem`. May be used by Relay 1. */
  nabidkaItemEdge: Maybe<NabidkaItemsEdge>;
  /** Reads a single `Pary` that is related to this `NabidkaItem`. */
  paryByNiPartner: Maybe<Pary>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `NabidkaItem` mutation. */
export type CreateNabidkaItemPayloadNabidkaItemEdgeArgs = {
  orderBy?: InputMaybe<Array<NabidkaItemsOrderBy>>;
};

/** The output of our create `Nabidka` mutation. */
export type CreateNabidkaPayload = {
  __typename?: 'CreateNabidkaPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Nabidka` that was created by this mutation. */
  nabidka: Maybe<Nabidka>;
  /** An edge for our `Nabidka`. May be used by Relay 1. */
  nabidkaEdge: Maybe<NabidkasEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Nabidka`. */
  userByNTrener: Maybe<User>;
};


/** The output of our create `Nabidka` mutation. */
export type CreateNabidkaPayloadNabidkaEdgeArgs = {
  orderBy?: InputMaybe<Array<NabidkasOrderBy>>;
};

/** All input for the create `Page` mutation. */
export type CreatePageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Page` to be created by this mutation. */
  page: PageInput;
};

/** The output of our create `Page` mutation. */
export type CreatePagePayload = {
  __typename?: 'CreatePagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Page` that was created by this mutation. */
  page: Maybe<Page>;
  /** An edge for our `Page`. May be used by Relay 1. */
  pageEdge: Maybe<PagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Page` mutation. */
export type CreatePagePayloadPageEdgeArgs = {
  orderBy?: InputMaybe<Array<PagesOrderBy>>;
};

/** All input for the create `Parameter` mutation. */
export type CreateParameterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Parameter` to be created by this mutation. */
  parameter: ParameterInput;
};

/** The output of our create `Parameter` mutation. */
export type CreateParameterPayload = {
  __typename?: 'CreateParameterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Parameter` that was created by this mutation. */
  parameter: Maybe<Parameter>;
  /** An edge for our `Parameter`. May be used by Relay 1. */
  parameterEdge: Maybe<ParametersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Parameter` mutation. */
export type CreateParameterPayloadParameterEdgeArgs = {
  orderBy?: InputMaybe<Array<ParametersOrderBy>>;
};

/** All input for the `createParticipation` mutation. */
export type CreateParticipationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  eventId: Scalars['BigInt'];
  myNotes: Scalars['String'];
  yearOfBirth: Scalars['Int'];
};

/** The output of our `createParticipation` mutation. */
export type CreateParticipationPayload = {
  __typename?: 'CreateParticipationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `Pary` mutation. */
export type CreateParyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Pary` to be created by this mutation. */
  pary: ParyInput;
};

/** All input for the create `ParyNavrh` mutation. */
export type CreateParyNavrhInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `ParyNavrh` to be created by this mutation. */
  paryNavrh: ParyNavrhInput;
};

/** The output of our create `ParyNavrh` mutation. */
export type CreateParyNavrhPayload = {
  __typename?: 'CreateParyNavrhPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ParyNavrh` that was created by this mutation. */
  paryNavrh: Maybe<ParyNavrh>;
  /** An edge for our `ParyNavrh`. May be used by Relay 1. */
  paryNavrhEdge: Maybe<ParyNavrhsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnNavrhl: Maybe<User>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnPartnerka: Maybe<User>;
};


/** The output of our create `ParyNavrh` mutation. */
export type CreateParyNavrhPayloadParyNavrhEdgeArgs = {
  orderBy?: InputMaybe<Array<ParyNavrhsOrderBy>>;
};

/** The output of our create `Pary` mutation. */
export type CreateParyPayload = {
  __typename?: 'CreateParyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Pary` that was created by this mutation. */
  pary: Maybe<Pary>;
  /** An edge for our `Pary`. May be used by Relay 1. */
  paryEdge: Maybe<PariesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartnerka: Maybe<User>;
};


/** The output of our create `Pary` mutation. */
export type CreateParyPayloadParyEdgeArgs = {
  orderBy?: InputMaybe<Array<PariesOrderBy>>;
};

/** All input for the create `Permission` mutation. */
export type CreatePermissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Permission` to be created by this mutation. */
  permission: PermissionInput;
};

/** The output of our create `Permission` mutation. */
export type CreatePermissionPayload = {
  __typename?: 'CreatePermissionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Permission` that was created by this mutation. */
  permission: Maybe<Permission>;
  /** An edge for our `Permission`. May be used by Relay 1. */
  permissionEdge: Maybe<PermissionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Permission` mutation. */
export type CreatePermissionPayloadPermissionEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
};

/** All input for the create `Person` mutation. */
export type CreatePersonInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Person` to be created by this mutation. */
  person: PersonInput;
};

/** The output of our create `Person` mutation. */
export type CreatePersonPayload = {
  __typename?: 'CreatePersonPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Person` that was created by this mutation. */
  person: Maybe<Person>;
  /** An edge for our `Person`. May be used by Relay 1. */
  personEdge: Maybe<PeopleEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Person` mutation. */
export type CreatePersonPayloadPersonEdgeArgs = {
  orderBy?: InputMaybe<Array<PeopleOrderBy>>;
};

/** All input for the create `PlatbyCategoryGroup` mutation. */
export type CreatePlatbyCategoryGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `PlatbyCategoryGroup` to be created by this mutation. */
  platbyCategoryGroup: PlatbyCategoryGroupInput;
};

/** The output of our create `PlatbyCategoryGroup` mutation. */
export type CreatePlatbyCategoryGroupPayload = {
  __typename?: 'CreatePlatbyCategoryGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyCategoryGroup`. */
  platbyCategoryByPcgIdCategory: Maybe<PlatbyCategory>;
  /** The `PlatbyCategoryGroup` that was created by this mutation. */
  platbyCategoryGroup: Maybe<PlatbyCategoryGroup>;
  /** An edge for our `PlatbyCategoryGroup`. May be used by Relay 1. */
  platbyCategoryGroupEdge: Maybe<PlatbyCategoryGroupsEdge>;
  /** Reads a single `PlatbyGroup` that is related to this `PlatbyCategoryGroup`. */
  platbyGroupByPcgIdGroup: Maybe<PlatbyGroup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `PlatbyCategoryGroup` mutation. */
export type CreatePlatbyCategoryGroupPayloadPlatbyCategoryGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyCategoryGroupsOrderBy>>;
};

/** All input for the create `PlatbyCategory` mutation. */
export type CreatePlatbyCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `PlatbyCategory` to be created by this mutation. */
  platbyCategory: PlatbyCategoryInput;
};

/** The output of our create `PlatbyCategory` mutation. */
export type CreatePlatbyCategoryPayload = {
  __typename?: 'CreatePlatbyCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlatbyCategory` that was created by this mutation. */
  platbyCategory: Maybe<PlatbyCategory>;
  /** An edge for our `PlatbyCategory`. May be used by Relay 1. */
  platbyCategoryEdge: Maybe<PlatbyCategoriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `PlatbyCategory` mutation. */
export type CreatePlatbyCategoryPayloadPlatbyCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyCategoriesOrderBy>>;
};

/** All input for the create `PlatbyGroup` mutation. */
export type CreatePlatbyGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `PlatbyGroup` to be created by this mutation. */
  platbyGroup: PlatbyGroupInput;
};

/** The output of our create `PlatbyGroup` mutation. */
export type CreatePlatbyGroupPayload = {
  __typename?: 'CreatePlatbyGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlatbyGroup` that was created by this mutation. */
  platbyGroup: Maybe<PlatbyGroup>;
  /** An edge for our `PlatbyGroup`. May be used by Relay 1. */
  platbyGroupEdge: Maybe<PlatbyGroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `PlatbyGroup` mutation. */
export type CreatePlatbyGroupPayloadPlatbyGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyGroupsOrderBy>>;
};

/** All input for the create `PlatbyGroupSkupina` mutation. */
export type CreatePlatbyGroupSkupinaInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `PlatbyGroupSkupina` to be created by this mutation. */
  platbyGroupSkupina: PlatbyGroupSkupinaInput;
};

/** The output of our create `PlatbyGroupSkupina` mutation. */
export type CreatePlatbyGroupSkupinaPayload = {
  __typename?: 'CreatePlatbyGroupSkupinaPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `PlatbyGroup` that is related to this `PlatbyGroupSkupina`. */
  platbyGroupByPgsIdGroup: Maybe<PlatbyGroup>;
  /** The `PlatbyGroupSkupina` that was created by this mutation. */
  platbyGroupSkupina: Maybe<PlatbyGroupSkupina>;
  /** An edge for our `PlatbyGroupSkupina`. May be used by Relay 1. */
  platbyGroupSkupinaEdge: Maybe<PlatbyGroupSkupinasEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `PlatbyGroupSkupina`. */
  skupinyByPgsIdSkupina: Maybe<Skupiny>;
};


/** The output of our create `PlatbyGroupSkupina` mutation. */
export type CreatePlatbyGroupSkupinaPayloadPlatbyGroupSkupinaEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyGroupSkupinasOrderBy>>;
};

/** All input for the create `PlatbyItem` mutation. */
export type CreatePlatbyItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `PlatbyItem` to be created by this mutation. */
  platbyItem: PlatbyItemInput;
};

/** The output of our create `PlatbyItem` mutation. */
export type CreatePlatbyItemPayload = {
  __typename?: 'CreatePlatbyItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
  platbyCategoryByPiIdCategory: Maybe<PlatbyCategory>;
  /** The `PlatbyItem` that was created by this mutation. */
  platbyItem: Maybe<PlatbyItem>;
  /** An edge for our `PlatbyItem`. May be used by Relay 1. */
  platbyItemEdge: Maybe<PlatbyItemsEdge>;
  /** Reads a single `PlatbyRaw` that is related to this `PlatbyItem`. */
  platbyRawByPiIdRaw: Maybe<PlatbyRaw>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `PlatbyItem`. */
  userByPiIdUser: Maybe<User>;
};


/** The output of our create `PlatbyItem` mutation. */
export type CreatePlatbyItemPayloadPlatbyItemEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyItemsOrderBy>>;
};

/** All input for the create `PlatbyRaw` mutation. */
export type CreatePlatbyRawInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `PlatbyRaw` to be created by this mutation. */
  platbyRaw: PlatbyRawInput;
};

/** The output of our create `PlatbyRaw` mutation. */
export type CreatePlatbyRawPayload = {
  __typename?: 'CreatePlatbyRawPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlatbyRaw` that was created by this mutation. */
  platbyRaw: Maybe<PlatbyRaw>;
  /** An edge for our `PlatbyRaw`. May be used by Relay 1. */
  platbyRawEdge: Maybe<PlatbyRawsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `PlatbyRaw` mutation. */
export type CreatePlatbyRawPayloadPlatbyRawEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyRawsOrderBy>>;
};

/** All input for the create `RoomAttachment` mutation. */
export type CreateRoomAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `RoomAttachment` to be created by this mutation. */
  roomAttachment: RoomAttachmentInput;
};

/** The output of our create `RoomAttachment` mutation. */
export type CreateRoomAttachmentPayload = {
  __typename?: 'CreateRoomAttachmentPayload';
  /** Reads a single `Attachment` that is related to this `RoomAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Room` that is related to this `RoomAttachment`. */
  room: Maybe<Room>;
  /** The `RoomAttachment` that was created by this mutation. */
  roomAttachment: Maybe<RoomAttachment>;
  /** An edge for our `RoomAttachment`. May be used by Relay 1. */
  roomAttachmentEdge: Maybe<RoomAttachmentsEdge>;
};


/** The output of our create `RoomAttachment` mutation. */
export type CreateRoomAttachmentPayloadRoomAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<RoomAttachmentsOrderBy>>;
};

/** All input for the create `Room` mutation. */
export type CreateRoomInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Room` to be created by this mutation. */
  room: RoomInput;
};

/** The output of our create `Room` mutation. */
export type CreateRoomPayload = {
  __typename?: 'CreateRoomPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Location` that is related to this `Room`. */
  locationByLocation: Maybe<Location>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Room` that was created by this mutation. */
  room: Maybe<Room>;
  /** An edge for our `Room`. May be used by Relay 1. */
  roomEdge: Maybe<RoomsEdge>;
};


/** The output of our create `Room` mutation. */
export type CreateRoomPayloadRoomEdgeArgs = {
  orderBy?: InputMaybe<Array<RoomsOrderBy>>;
};

/** All input for the create `Rozpi` mutation. */
export type CreateRozpiInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Rozpi` to be created by this mutation. */
  rozpi: RozpiInput;
};

/** The output of our create `Rozpi` mutation. */
export type CreateRozpiPayload = {
  __typename?: 'CreateRozpiPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Rozpi` that was created by this mutation. */
  rozpi: Maybe<Rozpi>;
  /** An edge for our `Rozpi`. May be used by Relay 1. */
  rozpiEdge: Maybe<RozpisEdge>;
  /** Reads a single `User` that is related to this `Rozpi`. */
  userByRTrener: Maybe<User>;
};


/** The output of our create `Rozpi` mutation. */
export type CreateRozpiPayloadRozpiEdgeArgs = {
  orderBy?: InputMaybe<Array<RozpisOrderBy>>;
};

/** All input for the create `RozpisItem` mutation. */
export type CreateRozpisItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `RozpisItem` to be created by this mutation. */
  rozpisItem: RozpisItemInput;
};

/** The output of our create `RozpisItem` mutation. */
export type CreateRozpisItemPayload = {
  __typename?: 'CreateRozpisItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Pary` that is related to this `RozpisItem`. */
  paryByRiPartner: Maybe<Pary>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Rozpi` that is related to this `RozpisItem`. */
  rozpiByRiIdRodic: Maybe<Rozpi>;
  /** The `RozpisItem` that was created by this mutation. */
  rozpisItem: Maybe<RozpisItem>;
  /** An edge for our `RozpisItem`. May be used by Relay 1. */
  rozpisItemEdge: Maybe<RozpisItemsEdge>;
};


/** The output of our create `RozpisItem` mutation. */
export type CreateRozpisItemPayloadRozpisItemEdgeArgs = {
  orderBy?: InputMaybe<Array<RozpisItemsOrderBy>>;
};

/** All input for the create `Session` mutation. */
export type CreateSessionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Session` to be created by this mutation. */
  session: SessionInput;
};

/** The output of our create `Session` mutation. */
export type CreateSessionPayload = {
  __typename?: 'CreateSessionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Session` that was created by this mutation. */
  session: Maybe<Session>;
  /** An edge for our `Session`. May be used by Relay 1. */
  sessionEdge: Maybe<SessionsEdge>;
  /** Reads a single `User` that is related to this `Session`. */
  userBySsUser: Maybe<User>;
};


/** The output of our create `Session` mutation. */
export type CreateSessionPayloadSessionEdgeArgs = {
  orderBy?: InputMaybe<Array<SessionsOrderBy>>;
};

/** All input for the create `Skupiny` mutation. */
export type CreateSkupinyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Skupiny` to be created by this mutation. */
  skupiny: SkupinyInput;
};

/** The output of our create `Skupiny` mutation. */
export type CreateSkupinyPayload = {
  __typename?: 'CreateSkupinyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `CohortGroup` that is related to this `Skupiny`. */
  cohortGroupByCohortGroup: Maybe<CohortGroup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Skupiny` that was created by this mutation. */
  skupiny: Maybe<Skupiny>;
  /** An edge for our `Skupiny`. May be used by Relay 1. */
  skupinyEdge: Maybe<SkupiniesEdge>;
};


/** The output of our create `Skupiny` mutation. */
export type CreateSkupinyPayloadSkupinyEdgeArgs = {
  orderBy?: InputMaybe<Array<SkupiniesOrderBy>>;
};

/** All input for the create `TenantAttachment` mutation. */
export type CreateTenantAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `TenantAttachment` to be created by this mutation. */
  tenantAttachment: TenantAttachmentInput;
};

/** The output of our create `TenantAttachment` mutation. */
export type CreateTenantAttachmentPayload = {
  __typename?: 'CreateTenantAttachmentPayload';
  /** Reads a single `Attachment` that is related to this `TenantAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `TenantAttachment`. */
  tenant: Maybe<Tenant>;
  /** The `TenantAttachment` that was created by this mutation. */
  tenantAttachment: Maybe<TenantAttachment>;
  /** An edge for our `TenantAttachment`. May be used by Relay 1. */
  tenantAttachmentEdge: Maybe<TenantAttachmentsEdge>;
};


/** The output of our create `TenantAttachment` mutation. */
export type CreateTenantAttachmentPayloadTenantAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<TenantAttachmentsOrderBy>>;
};

/** All input for the create `Tenant` mutation. */
export type CreateTenantInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Tenant` to be created by this mutation. */
  tenant: TenantInput;
};

/** The output of our create `Tenant` mutation. */
export type CreateTenantPayload = {
  __typename?: 'CreateTenantPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Tenant` that was created by this mutation. */
  tenant: Maybe<Tenant>;
  /** An edge for our `Tenant`. May be used by Relay 1. */
  tenantEdge: Maybe<TenantsEdge>;
};


/** The output of our create `Tenant` mutation. */
export type CreateTenantPayloadTenantEdgeArgs = {
  orderBy?: InputMaybe<Array<TenantsOrderBy>>;
};

/** All input for the create `TenantPerson` mutation. */
export type CreateTenantPersonInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `TenantPerson` to be created by this mutation. */
  tenantPerson: TenantPersonInput;
};

/** The output of our create `TenantPerson` mutation. */
export type CreateTenantPersonPayload = {
  __typename?: 'CreateTenantPersonPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Person` that is related to this `TenantPerson`. */
  person: Maybe<Person>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `TenantPerson`. */
  tenant: Maybe<Tenant>;
  /** The `TenantPerson` that was created by this mutation. */
  tenantPerson: Maybe<TenantPerson>;
  /** An edge for our `TenantPerson`. May be used by Relay 1. */
  tenantPersonEdge: Maybe<TenantPeopleEdge>;
};


/** The output of our create `TenantPerson` mutation. */
export type CreateTenantPersonPayloadTenantPersonEdgeArgs = {
  orderBy?: InputMaybe<Array<TenantPeopleOrderBy>>;
};

/** All input for the create `Upozorneni` mutation. */
export type CreateUpozorneniInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Upozorneni` to be created by this mutation. */
  upozorneni: UpozorneniInput;
};

/** The output of our create `Upozorneni` mutation. */
export type CreateUpozorneniPayload = {
  __typename?: 'CreateUpozorneniPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Upozorneni` that was created by this mutation. */
  upozorneni: Maybe<Upozorneni>;
  /** An edge for our `Upozorneni`. May be used by Relay 1. */
  upozorneniEdge: Maybe<UpozornenisEdge>;
  /** Reads a single `User` that is related to this `Upozorneni`. */
  userByUpKdo: Maybe<User>;
};


/** The output of our create `Upozorneni` mutation. */
export type CreateUpozorneniPayloadUpozorneniEdgeArgs = {
  orderBy?: InputMaybe<Array<UpozornenisOrderBy>>;
};

/** All input for the create `UpozorneniSkupiny` mutation. */
export type CreateUpozorneniSkupinyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `UpozorneniSkupiny` to be created by this mutation. */
  upozorneniSkupiny: UpozorneniSkupinyInput;
};

/** The output of our create `UpozorneniSkupiny` mutation. */
export type CreateUpozorneniSkupinyPayload = {
  __typename?: 'CreateUpozorneniSkupinyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
  skupinyByUpsIdSkupina: Maybe<Skupiny>;
  /** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
  upozorneniByUpsIdRodic: Maybe<Upozorneni>;
  /** The `UpozorneniSkupiny` that was created by this mutation. */
  upozorneniSkupiny: Maybe<UpozorneniSkupiny>;
  /** An edge for our `UpozorneniSkupiny`. May be used by Relay 1. */
  upozorneniSkupinyEdge: Maybe<UpozorneniSkupiniesEdge>;
};


/** The output of our create `UpozorneniSkupiny` mutation. */
export type CreateUpozorneniSkupinyPayloadUpozorneniSkupinyEdgeArgs = {
  orderBy?: InputMaybe<Array<UpozorneniSkupiniesOrderBy>>;
};

/** All input for the create `User` mutation. */
export type CreateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `User` to be created by this mutation. */
  user: UserInput;
};

/** The output of our create `User` mutation. */
export type CreateUserPayload = {
  __typename?: 'CreateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Permission` that is related to this `User`. */
  permissionByUGroup: Maybe<Permission>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `User`. */
  skupinyByUSkupina: Maybe<Skupiny>;
  /** The `User` that was created by this mutation. */
  user: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge: Maybe<UsersEdge>;
};


/** The output of our create `User` mutation. */
export type CreateUserPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the create `Video` mutation. */
export type CreateVideoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Video` to be created by this mutation. */
  video: VideoInput;
};

/** All input for the create `VideoList` mutation. */
export type CreateVideoListInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `VideoList` to be created by this mutation. */
  videoList: VideoListInput;
};

/** The output of our create `VideoList` mutation. */
export type CreateVideoListPayload = {
  __typename?: 'CreateVideoListPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `VideoList` that was created by this mutation. */
  videoList: Maybe<VideoList>;
  /** An edge for our `VideoList`. May be used by Relay 1. */
  videoListEdge: Maybe<VideoListsEdge>;
};


/** The output of our create `VideoList` mutation. */
export type CreateVideoListPayloadVideoListEdgeArgs = {
  orderBy?: InputMaybe<Array<VideoListsOrderBy>>;
};

/** The output of our create `Video` mutation. */
export type CreateVideoPayload = {
  __typename?: 'CreateVideoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Video` that was created by this mutation. */
  video: Maybe<Video>;
  /** An edge for our `Video`. May be used by Relay 1. */
  videoEdge: Maybe<VideosEdge>;
};


/** The output of our create `Video` mutation. */
export type CreateVideoPayloadVideoEdgeArgs = {
  orderBy?: InputMaybe<Array<VideosOrderBy>>;
};

/** All input for the create `VideoSource` mutation. */
export type CreateVideoSourceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `VideoSource` to be created by this mutation. */
  videoSource: VideoSourceInput;
};

/** The output of our create `VideoSource` mutation. */
export type CreateVideoSourcePayload = {
  __typename?: 'CreateVideoSourcePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `VideoSource` that was created by this mutation. */
  videoSource: Maybe<VideoSource>;
  /** An edge for our `VideoSource`. May be used by Relay 1. */
  videoSourceEdge: Maybe<VideoSourcesEdge>;
};


/** The output of our create `VideoSource` mutation. */
export type CreateVideoSourcePayloadVideoSourceEdgeArgs = {
  orderBy?: InputMaybe<Array<VideoSourcesOrderBy>>;
};

export enum CrmCohort {
  ContactMeLater = 'CONTACT_ME_LATER',
  Dancer = 'DANCER',
  FreeLesson = 'FREE_LESSON',
  Hobbyist = 'HOBBYIST',
  Showdance = 'SHOWDANCE'
}

/** A `BigInt` edge in the connection. */
export type CurrentCoupleIdEdge = {
  __typename?: 'CurrentCoupleIdEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `BigInt` at the end of the edge. */
  node: Maybe<Scalars['BigInt']>;
};

/** A connection to a list of `BigInt` values. */
export type CurrentCoupleIdsConnection = {
  __typename?: 'CurrentCoupleIdsConnection';
  /** A list of edges which contains the `BigInt` and cursor to aid in pagination. */
  edges: Array<CurrentCoupleIdEdge>;
  /** A list of `BigInt` objects. */
  nodes: Array<Maybe<Scalars['BigInt']>>;
  /** The count of *all* `BigInt` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** All input for the `deleteAktualityByNodeId` mutation. */
export type DeleteAktualityByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Aktuality` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteAktuality` mutation. */
export type DeleteAktualityInput = {
  atId: Scalars['BigInt'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** The output of our delete `Aktuality` mutation. */
export type DeleteAktualityPayload = {
  __typename?: 'DeleteAktualityPayload';
  /** The `Aktuality` that was deleted by this mutation. */
  aktuality: Maybe<Aktuality>;
  /** An edge for our `Aktuality`. May be used by Relay 1. */
  aktualityEdge: Maybe<AktualitiesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedAktualityNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
  galerieFotoByAtFotoMain: Maybe<GalerieFoto>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Aktuality`. */
  userByAtKdo: Maybe<User>;
};


/** The output of our delete `Aktuality` mutation. */
export type DeleteAktualityPayloadAktualityEdgeArgs = {
  orderBy?: InputMaybe<Array<AktualitiesOrderBy>>;
};

/** All input for the `deleteAttachmentByNodeId` mutation. */
export type DeleteAttachmentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Attachment` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteAttachment` mutation. */
export type DeleteAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  objectName: Scalars['String'];
};

/** The output of our delete `Attachment` mutation. */
export type DeleteAttachmentPayload = {
  __typename?: 'DeleteAttachmentPayload';
  /** The `Attachment` that was deleted by this mutation. */
  attachment: Maybe<Attachment>;
  /** An edge for our `Attachment`. May be used by Relay 1. */
  attachmentEdge: Maybe<AttachmentsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedAttachmentNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Attachment`. */
  userByUploadedBy: Maybe<User>;
};


/** The output of our delete `Attachment` mutation. */
export type DeleteAttachmentPayloadAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<AttachmentsOrderBy>>;
};

/** All input for the `deleteAttendeeExternalByNodeId` mutation. */
export type DeleteAttendeeExternalByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `AttendeeExternal` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteAttendeeExternal` mutation. */
export type DeleteAttendeeExternalInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `AttendeeExternal` mutation. */
export type DeleteAttendeeExternalPayload = {
  __typename?: 'DeleteAttendeeExternalPayload';
  /** The `AttendeeExternal` that was deleted by this mutation. */
  attendeeExternal: Maybe<AttendeeExternal>;
  /** An edge for our `AttendeeExternal`. May be used by Relay 1. */
  attendeeExternalEdge: Maybe<AttendeeExternalsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedAttendeeExternalNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `Event` that is related to this `AttendeeExternal`. */
  event: Maybe<Event>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `AttendeeExternal`. */
  userByConfirmedBy: Maybe<User>;
  /** Reads a single `User` that is related to this `AttendeeExternal`. */
  userByManagedBy: Maybe<User>;
};


/** The output of our delete `AttendeeExternal` mutation. */
export type DeleteAttendeeExternalPayloadAttendeeExternalEdgeArgs = {
  orderBy?: InputMaybe<Array<AttendeeExternalsOrderBy>>;
};

/** All input for the `deleteAttendeeUserByNodeId` mutation. */
export type DeleteAttendeeUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `AttendeeUser` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteAttendeeUserByUserIdAndEventId` mutation. */
export type DeleteAttendeeUserByUserIdAndEventIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  eventId: Scalars['BigInt'];
  userId: Scalars['BigInt'];
};

/** All input for the `deleteAttendeeUser` mutation. */
export type DeleteAttendeeUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `AttendeeUser` mutation. */
export type DeleteAttendeeUserPayload = {
  __typename?: 'DeleteAttendeeUserPayload';
  /** The `AttendeeUser` that was deleted by this mutation. */
  attendeeUser: Maybe<AttendeeUser>;
  /** An edge for our `AttendeeUser`. May be used by Relay 1. */
  attendeeUserEdge: Maybe<AttendeeUsersEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedAttendeeUserNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `Event` that is related to this `AttendeeUser`. */
  event: Maybe<Event>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `AttendeeUser`. */
  user: Maybe<User>;
};


/** The output of our delete `AttendeeUser` mutation. */
export type DeleteAttendeeUserPayloadAttendeeUserEdgeArgs = {
  orderBy?: InputMaybe<Array<AttendeeUsersOrderBy>>;
};

/** All input for the `deleteCohortGroupByNodeId` mutation. */
export type DeleteCohortGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CohortGroup` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCohortGroup` mutation. */
export type DeleteCohortGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `CohortGroup` mutation. */
export type DeleteCohortGroupPayload = {
  __typename?: 'DeleteCohortGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `CohortGroup` that was deleted by this mutation. */
  cohortGroup: Maybe<CohortGroup>;
  /** An edge for our `CohortGroup`. May be used by Relay 1. */
  cohortGroupEdge: Maybe<CohortGroupsEdge>;
  deletedCohortGroupNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `CohortGroup`. */
  tenantByTenant: Maybe<Tenant>;
};


/** The output of our delete `CohortGroup` mutation. */
export type DeleteCohortGroupPayloadCohortGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<CohortGroupsOrderBy>>;
};

/** All input for the `deleteDokumentyByNodeId` mutation. */
export type DeleteDokumentyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Dokumenty` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteDokumenty` mutation. */
export type DeleteDokumentyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  dId: Scalars['BigInt'];
};

/** The output of our delete `Dokumenty` mutation. */
export type DeleteDokumentyPayload = {
  __typename?: 'DeleteDokumentyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedDokumentyNodeId: Maybe<Scalars['ID']>;
  /** The `Dokumenty` that was deleted by this mutation. */
  dokumenty: Maybe<Dokumenty>;
  /** An edge for our `Dokumenty`. May be used by Relay 1. */
  dokumentyEdge: Maybe<DokumentiesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Dokumenty`. */
  userByDKdo: Maybe<User>;
};


/** The output of our delete `Dokumenty` mutation. */
export type DeleteDokumentyPayloadDokumentyEdgeArgs = {
  orderBy?: InputMaybe<Array<DokumentiesOrderBy>>;
};

/** All input for the `deleteEventByNodeId` mutation. */
export type DeleteEventByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Event` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteEvent` mutation. */
export type DeleteEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Event` mutation. */
export type DeleteEventPayload = {
  __typename?: 'DeleteEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedEventNodeId: Maybe<Scalars['ID']>;
  /** The `Event` that was deleted by this mutation. */
  event: Maybe<Event>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge: Maybe<EventsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Event` mutation. */
export type DeleteEventPayloadEventEdgeArgs = {
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};

/** All input for the `deleteGalerieDirByNodeId` mutation. */
export type DeleteGalerieDirByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GalerieDir` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteGalerieDir` mutation. */
export type DeleteGalerieDirInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  gdId: Scalars['BigInt'];
};

/** The output of our delete `GalerieDir` mutation. */
export type DeleteGalerieDirPayload = {
  __typename?: 'DeleteGalerieDirPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedGalerieDirNodeId: Maybe<Scalars['ID']>;
  /** The `GalerieDir` that was deleted by this mutation. */
  galerieDir: Maybe<GalerieDir>;
  /** An edge for our `GalerieDir`. May be used by Relay 1. */
  galerieDirEdge: Maybe<GalerieDirsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `GalerieDir` mutation. */
export type DeleteGalerieDirPayloadGalerieDirEdgeArgs = {
  orderBy?: InputMaybe<Array<GalerieDirsOrderBy>>;
};

/** All input for the `deleteGalerieFotoByNodeId` mutation. */
export type DeleteGalerieFotoByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GalerieFoto` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteGalerieFoto` mutation. */
export type DeleteGalerieFotoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  gfId: Scalars['BigInt'];
};

/** The output of our delete `GalerieFoto` mutation. */
export type DeleteGalerieFotoPayload = {
  __typename?: 'DeleteGalerieFotoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedGalerieFotoNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
  galerieDirByGfIdRodic: Maybe<GalerieDir>;
  /** The `GalerieFoto` that was deleted by this mutation. */
  galerieFoto: Maybe<GalerieFoto>;
  /** An edge for our `GalerieFoto`. May be used by Relay 1. */
  galerieFotoEdge: Maybe<GalerieFotosEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `GalerieFoto`. */
  userByGfKdo: Maybe<User>;
};


/** The output of our delete `GalerieFoto` mutation. */
export type DeleteGalerieFotoPayloadGalerieFotoEdgeArgs = {
  orderBy?: InputMaybe<Array<GalerieFotosOrderBy>>;
};

/** All input for the `deleteLocationAttachmentByNodeId` mutation. */
export type DeleteLocationAttachmentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LocationAttachment` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteLocationAttachment` mutation. */
export type DeleteLocationAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  locationId: Scalars['BigInt'];
  objectName: Scalars['String'];
};

/** The output of our delete `LocationAttachment` mutation. */
export type DeleteLocationAttachmentPayload = {
  __typename?: 'DeleteLocationAttachmentPayload';
  /** Reads a single `Attachment` that is related to this `LocationAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedLocationAttachmentNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `Location` that is related to this `LocationAttachment`. */
  location: Maybe<Location>;
  /** The `LocationAttachment` that was deleted by this mutation. */
  locationAttachment: Maybe<LocationAttachment>;
  /** An edge for our `LocationAttachment`. May be used by Relay 1. */
  locationAttachmentEdge: Maybe<LocationAttachmentsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `LocationAttachment` mutation. */
export type DeleteLocationAttachmentPayloadLocationAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<LocationAttachmentsOrderBy>>;
};

/** All input for the `deleteLocationByNodeId` mutation. */
export type DeleteLocationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Location` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteLocation` mutation. */
export type DeleteLocationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Location` mutation. */
export type DeleteLocationPayload = {
  __typename?: 'DeleteLocationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedLocationNodeId: Maybe<Scalars['ID']>;
  /** The `Location` that was deleted by this mutation. */
  location: Maybe<Location>;
  /** An edge for our `Location`. May be used by Relay 1. */
  locationEdge: Maybe<LocationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `Location`. */
  tenantByTenant: Maybe<Tenant>;
};


/** The output of our delete `Location` mutation. */
export type DeleteLocationPayloadLocationEdgeArgs = {
  orderBy?: InputMaybe<Array<LocationsOrderBy>>;
};

/** All input for the `deleteNabidkaByNodeId` mutation. */
export type DeleteNabidkaByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Nabidka` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteNabidka` mutation. */
export type DeleteNabidkaInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  nId: Scalars['BigInt'];
};

/** All input for the `deleteNabidkaItemByNiPartnerAndNiIdRodic` mutation. */
export type DeleteNabidkaItemByNiPartnerAndNiIdRodicInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  niIdRodic: Scalars['BigInt'];
  niPartner: Scalars['BigInt'];
};

/** All input for the `deleteNabidkaItemByNodeId` mutation. */
export type DeleteNabidkaItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `NabidkaItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteNabidkaItem` mutation. */
export type DeleteNabidkaItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  niId: Scalars['BigInt'];
};

/** The output of our delete `NabidkaItem` mutation. */
export type DeleteNabidkaItemPayload = {
  __typename?: 'DeleteNabidkaItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedNabidkaItemNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `Nabidka` that is related to this `NabidkaItem`. */
  nabidkaByNiIdRodic: Maybe<Nabidka>;
  /** The `NabidkaItem` that was deleted by this mutation. */
  nabidkaItem: Maybe<NabidkaItem>;
  /** An edge for our `NabidkaItem`. May be used by Relay 1. */
  nabidkaItemEdge: Maybe<NabidkaItemsEdge>;
  /** Reads a single `Pary` that is related to this `NabidkaItem`. */
  paryByNiPartner: Maybe<Pary>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `NabidkaItem` mutation. */
export type DeleteNabidkaItemPayloadNabidkaItemEdgeArgs = {
  orderBy?: InputMaybe<Array<NabidkaItemsOrderBy>>;
};

/** The output of our delete `Nabidka` mutation. */
export type DeleteNabidkaPayload = {
  __typename?: 'DeleteNabidkaPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedNabidkaNodeId: Maybe<Scalars['ID']>;
  /** The `Nabidka` that was deleted by this mutation. */
  nabidka: Maybe<Nabidka>;
  /** An edge for our `Nabidka`. May be used by Relay 1. */
  nabidkaEdge: Maybe<NabidkasEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Nabidka`. */
  userByNTrener: Maybe<User>;
};


/** The output of our delete `Nabidka` mutation. */
export type DeleteNabidkaPayloadNabidkaEdgeArgs = {
  orderBy?: InputMaybe<Array<NabidkasOrderBy>>;
};

/** All input for the `deleteParameterByNodeId` mutation. */
export type DeleteParameterByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Parameter` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteParameter` mutation. */
export type DeleteParameterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  paName: Scalars['String'];
};

/** The output of our delete `Parameter` mutation. */
export type DeleteParameterPayload = {
  __typename?: 'DeleteParameterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedParameterNodeId: Maybe<Scalars['ID']>;
  /** The `Parameter` that was deleted by this mutation. */
  parameter: Maybe<Parameter>;
  /** An edge for our `Parameter`. May be used by Relay 1. */
  parameterEdge: Maybe<ParametersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Parameter` mutation. */
export type DeleteParameterPayloadParameterEdgeArgs = {
  orderBy?: InputMaybe<Array<ParametersOrderBy>>;
};

/** All input for the `deleteParyByNodeId` mutation. */
export type DeleteParyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Pary` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePary` mutation. */
export type DeleteParyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  pId: Scalars['BigInt'];
};

/** All input for the `deleteParyNavrhByNodeId` mutation. */
export type DeleteParyNavrhByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ParyNavrh` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteParyNavrh` mutation. */
export type DeleteParyNavrhInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  pnId: Scalars['BigInt'];
};

/** The output of our delete `ParyNavrh` mutation. */
export type DeleteParyNavrhPayload = {
  __typename?: 'DeleteParyNavrhPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedParyNavrhNodeId: Maybe<Scalars['ID']>;
  /** The `ParyNavrh` that was deleted by this mutation. */
  paryNavrh: Maybe<ParyNavrh>;
  /** An edge for our `ParyNavrh`. May be used by Relay 1. */
  paryNavrhEdge: Maybe<ParyNavrhsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnNavrhl: Maybe<User>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnPartnerka: Maybe<User>;
};


/** The output of our delete `ParyNavrh` mutation. */
export type DeleteParyNavrhPayloadParyNavrhEdgeArgs = {
  orderBy?: InputMaybe<Array<ParyNavrhsOrderBy>>;
};

/** The output of our delete `Pary` mutation. */
export type DeleteParyPayload = {
  __typename?: 'DeleteParyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedParyNodeId: Maybe<Scalars['ID']>;
  /** The `Pary` that was deleted by this mutation. */
  pary: Maybe<Pary>;
  /** An edge for our `Pary`. May be used by Relay 1. */
  paryEdge: Maybe<PariesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartnerka: Maybe<User>;
};


/** The output of our delete `Pary` mutation. */
export type DeleteParyPayloadParyEdgeArgs = {
  orderBy?: InputMaybe<Array<PariesOrderBy>>;
};

/** All input for the `deletePermissionByNodeId` mutation. */
export type DeletePermissionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Permission` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePermission` mutation. */
export type DeletePermissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  peId: Scalars['BigInt'];
};

/** The output of our delete `Permission` mutation. */
export type DeletePermissionPayload = {
  __typename?: 'DeletePermissionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedPermissionNodeId: Maybe<Scalars['ID']>;
  /** The `Permission` that was deleted by this mutation. */
  permission: Maybe<Permission>;
  /** An edge for our `Permission`. May be used by Relay 1. */
  permissionEdge: Maybe<PermissionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Permission` mutation. */
export type DeletePermissionPayloadPermissionEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
};

/** All input for the `deletePersonByNodeId` mutation. */
export type DeletePersonByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Person` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePerson` mutation. */
export type DeletePersonInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Person` mutation. */
export type DeletePersonPayload = {
  __typename?: 'DeletePersonPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedPersonNodeId: Maybe<Scalars['ID']>;
  /** The `Person` that was deleted by this mutation. */
  person: Maybe<Person>;
  /** An edge for our `Person`. May be used by Relay 1. */
  personEdge: Maybe<PeopleEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Person` mutation. */
export type DeletePersonPayloadPersonEdgeArgs = {
  orderBy?: InputMaybe<Array<PeopleOrderBy>>;
};

/** All input for the `deletePlatbyCategoryByNodeId` mutation. */
export type DeletePlatbyCategoryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyCategory` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePlatbyCategoryGroupByNodeId` mutation. */
export type DeletePlatbyCategoryGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyCategoryGroup` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePlatbyCategoryGroup` mutation. */
export type DeletePlatbyCategoryGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  pcgId: Scalars['BigInt'];
};

/** The output of our delete `PlatbyCategoryGroup` mutation. */
export type DeletePlatbyCategoryGroupPayload = {
  __typename?: 'DeletePlatbyCategoryGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedPlatbyCategoryGroupNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyCategoryGroup`. */
  platbyCategoryByPcgIdCategory: Maybe<PlatbyCategory>;
  /** The `PlatbyCategoryGroup` that was deleted by this mutation. */
  platbyCategoryGroup: Maybe<PlatbyCategoryGroup>;
  /** An edge for our `PlatbyCategoryGroup`. May be used by Relay 1. */
  platbyCategoryGroupEdge: Maybe<PlatbyCategoryGroupsEdge>;
  /** Reads a single `PlatbyGroup` that is related to this `PlatbyCategoryGroup`. */
  platbyGroupByPcgIdGroup: Maybe<PlatbyGroup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `PlatbyCategoryGroup` mutation. */
export type DeletePlatbyCategoryGroupPayloadPlatbyCategoryGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyCategoryGroupsOrderBy>>;
};

/** All input for the `deletePlatbyCategory` mutation. */
export type DeletePlatbyCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  pcId: Scalars['BigInt'];
};

/** The output of our delete `PlatbyCategory` mutation. */
export type DeletePlatbyCategoryPayload = {
  __typename?: 'DeletePlatbyCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedPlatbyCategoryNodeId: Maybe<Scalars['ID']>;
  /** The `PlatbyCategory` that was deleted by this mutation. */
  platbyCategory: Maybe<PlatbyCategory>;
  /** An edge for our `PlatbyCategory`. May be used by Relay 1. */
  platbyCategoryEdge: Maybe<PlatbyCategoriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `PlatbyCategory` mutation. */
export type DeletePlatbyCategoryPayloadPlatbyCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyCategoriesOrderBy>>;
};

/** All input for the `deletePlatbyGroupByNodeId` mutation. */
export type DeletePlatbyGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyGroup` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePlatbyGroup` mutation. */
export type DeletePlatbyGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  pgId: Scalars['BigInt'];
};

/** The output of our delete `PlatbyGroup` mutation. */
export type DeletePlatbyGroupPayload = {
  __typename?: 'DeletePlatbyGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedPlatbyGroupNodeId: Maybe<Scalars['ID']>;
  /** The `PlatbyGroup` that was deleted by this mutation. */
  platbyGroup: Maybe<PlatbyGroup>;
  /** An edge for our `PlatbyGroup`. May be used by Relay 1. */
  platbyGroupEdge: Maybe<PlatbyGroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `PlatbyGroup` mutation. */
export type DeletePlatbyGroupPayloadPlatbyGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyGroupsOrderBy>>;
};

/** All input for the `deletePlatbyGroupSkupinaByNodeId` mutation. */
export type DeletePlatbyGroupSkupinaByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyGroupSkupina` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePlatbyGroupSkupina` mutation. */
export type DeletePlatbyGroupSkupinaInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  pgsId: Scalars['BigInt'];
};

/** The output of our delete `PlatbyGroupSkupina` mutation. */
export type DeletePlatbyGroupSkupinaPayload = {
  __typename?: 'DeletePlatbyGroupSkupinaPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedPlatbyGroupSkupinaNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `PlatbyGroup` that is related to this `PlatbyGroupSkupina`. */
  platbyGroupByPgsIdGroup: Maybe<PlatbyGroup>;
  /** The `PlatbyGroupSkupina` that was deleted by this mutation. */
  platbyGroupSkupina: Maybe<PlatbyGroupSkupina>;
  /** An edge for our `PlatbyGroupSkupina`. May be used by Relay 1. */
  platbyGroupSkupinaEdge: Maybe<PlatbyGroupSkupinasEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `PlatbyGroupSkupina`. */
  skupinyByPgsIdSkupina: Maybe<Skupiny>;
};


/** The output of our delete `PlatbyGroupSkupina` mutation. */
export type DeletePlatbyGroupSkupinaPayloadPlatbyGroupSkupinaEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyGroupSkupinasOrderBy>>;
};

/** All input for the `deletePlatbyItemByNodeId` mutation. */
export type DeletePlatbyItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePlatbyItem` mutation. */
export type DeletePlatbyItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  piId: Scalars['BigInt'];
};

/** The output of our delete `PlatbyItem` mutation. */
export type DeletePlatbyItemPayload = {
  __typename?: 'DeletePlatbyItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedPlatbyItemNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
  platbyCategoryByPiIdCategory: Maybe<PlatbyCategory>;
  /** The `PlatbyItem` that was deleted by this mutation. */
  platbyItem: Maybe<PlatbyItem>;
  /** An edge for our `PlatbyItem`. May be used by Relay 1. */
  platbyItemEdge: Maybe<PlatbyItemsEdge>;
  /** Reads a single `PlatbyRaw` that is related to this `PlatbyItem`. */
  platbyRawByPiIdRaw: Maybe<PlatbyRaw>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `PlatbyItem`. */
  userByPiIdUser: Maybe<User>;
};


/** The output of our delete `PlatbyItem` mutation. */
export type DeletePlatbyItemPayloadPlatbyItemEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyItemsOrderBy>>;
};

/** All input for the `deletePlatbyRawByNodeId` mutation. */
export type DeletePlatbyRawByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyRaw` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePlatbyRaw` mutation. */
export type DeletePlatbyRawInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  prId: Scalars['BigInt'];
};

/** The output of our delete `PlatbyRaw` mutation. */
export type DeletePlatbyRawPayload = {
  __typename?: 'DeletePlatbyRawPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedPlatbyRawNodeId: Maybe<Scalars['ID']>;
  /** The `PlatbyRaw` that was deleted by this mutation. */
  platbyRaw: Maybe<PlatbyRaw>;
  /** An edge for our `PlatbyRaw`. May be used by Relay 1. */
  platbyRawEdge: Maybe<PlatbyRawsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `PlatbyRaw` mutation. */
export type DeletePlatbyRawPayloadPlatbyRawEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyRawsOrderBy>>;
};

/** All input for the `deleteRoomAttachmentByNodeId` mutation. */
export type DeleteRoomAttachmentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `RoomAttachment` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteRoomAttachment` mutation. */
export type DeleteRoomAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  objectName: Scalars['String'];
  roomId: Scalars['BigInt'];
};

/** The output of our delete `RoomAttachment` mutation. */
export type DeleteRoomAttachmentPayload = {
  __typename?: 'DeleteRoomAttachmentPayload';
  /** Reads a single `Attachment` that is related to this `RoomAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedRoomAttachmentNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Room` that is related to this `RoomAttachment`. */
  room: Maybe<Room>;
  /** The `RoomAttachment` that was deleted by this mutation. */
  roomAttachment: Maybe<RoomAttachment>;
  /** An edge for our `RoomAttachment`. May be used by Relay 1. */
  roomAttachmentEdge: Maybe<RoomAttachmentsEdge>;
};


/** The output of our delete `RoomAttachment` mutation. */
export type DeleteRoomAttachmentPayloadRoomAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<RoomAttachmentsOrderBy>>;
};

/** All input for the `deleteRoomByNodeId` mutation. */
export type DeleteRoomByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Room` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteRoom` mutation. */
export type DeleteRoomInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Room` mutation. */
export type DeleteRoomPayload = {
  __typename?: 'DeleteRoomPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedRoomNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `Location` that is related to this `Room`. */
  locationByLocation: Maybe<Location>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Room` that was deleted by this mutation. */
  room: Maybe<Room>;
  /** An edge for our `Room`. May be used by Relay 1. */
  roomEdge: Maybe<RoomsEdge>;
};


/** The output of our delete `Room` mutation. */
export type DeleteRoomPayloadRoomEdgeArgs = {
  orderBy?: InputMaybe<Array<RoomsOrderBy>>;
};

/** All input for the `deleteRozpiByNodeId` mutation. */
export type DeleteRozpiByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Rozpi` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteRozpi` mutation. */
export type DeleteRozpiInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  rId: Scalars['BigInt'];
};

/** The output of our delete `Rozpi` mutation. */
export type DeleteRozpiPayload = {
  __typename?: 'DeleteRozpiPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedRozpiNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Rozpi` that was deleted by this mutation. */
  rozpi: Maybe<Rozpi>;
  /** An edge for our `Rozpi`. May be used by Relay 1. */
  rozpiEdge: Maybe<RozpisEdge>;
  /** Reads a single `User` that is related to this `Rozpi`. */
  userByRTrener: Maybe<User>;
};


/** The output of our delete `Rozpi` mutation. */
export type DeleteRozpiPayloadRozpiEdgeArgs = {
  orderBy?: InputMaybe<Array<RozpisOrderBy>>;
};

/** All input for the `deleteRozpisItemByNodeId` mutation. */
export type DeleteRozpisItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `RozpisItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteRozpisItem` mutation. */
export type DeleteRozpisItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  riId: Scalars['BigInt'];
};

/** The output of our delete `RozpisItem` mutation. */
export type DeleteRozpisItemPayload = {
  __typename?: 'DeleteRozpisItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedRozpisItemNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `Pary` that is related to this `RozpisItem`. */
  paryByRiPartner: Maybe<Pary>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Rozpi` that is related to this `RozpisItem`. */
  rozpiByRiIdRodic: Maybe<Rozpi>;
  /** The `RozpisItem` that was deleted by this mutation. */
  rozpisItem: Maybe<RozpisItem>;
  /** An edge for our `RozpisItem`. May be used by Relay 1. */
  rozpisItemEdge: Maybe<RozpisItemsEdge>;
};


/** The output of our delete `RozpisItem` mutation. */
export type DeleteRozpisItemPayloadRozpisItemEdgeArgs = {
  orderBy?: InputMaybe<Array<RozpisItemsOrderBy>>;
};

/** All input for the `deleteSessionByNodeId` mutation. */
export type DeleteSessionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Session` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteSession` mutation. */
export type DeleteSessionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  ssId: Scalars['String'];
};

/** The output of our delete `Session` mutation. */
export type DeleteSessionPayload = {
  __typename?: 'DeleteSessionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedSessionNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Session` that was deleted by this mutation. */
  session: Maybe<Session>;
  /** An edge for our `Session`. May be used by Relay 1. */
  sessionEdge: Maybe<SessionsEdge>;
  /** Reads a single `User` that is related to this `Session`. */
  userBySsUser: Maybe<User>;
};


/** The output of our delete `Session` mutation. */
export type DeleteSessionPayloadSessionEdgeArgs = {
  orderBy?: InputMaybe<Array<SessionsOrderBy>>;
};

/** All input for the `deleteSkupinyByNodeId` mutation. */
export type DeleteSkupinyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Skupiny` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteSkupiny` mutation. */
export type DeleteSkupinyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  sId: Scalars['BigInt'];
};

/** The output of our delete `Skupiny` mutation. */
export type DeleteSkupinyPayload = {
  __typename?: 'DeleteSkupinyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `CohortGroup` that is related to this `Skupiny`. */
  cohortGroupByCohortGroup: Maybe<CohortGroup>;
  deletedSkupinyNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Skupiny` that was deleted by this mutation. */
  skupiny: Maybe<Skupiny>;
  /** An edge for our `Skupiny`. May be used by Relay 1. */
  skupinyEdge: Maybe<SkupiniesEdge>;
};


/** The output of our delete `Skupiny` mutation. */
export type DeleteSkupinyPayloadSkupinyEdgeArgs = {
  orderBy?: InputMaybe<Array<SkupiniesOrderBy>>;
};

/** All input for the `deleteTenantAttachmentByNodeId` mutation. */
export type DeleteTenantAttachmentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TenantAttachment` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTenantAttachment` mutation. */
export type DeleteTenantAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  objectName: Scalars['String'];
  tenantId: Scalars['BigInt'];
};

/** The output of our delete `TenantAttachment` mutation. */
export type DeleteTenantAttachmentPayload = {
  __typename?: 'DeleteTenantAttachmentPayload';
  /** Reads a single `Attachment` that is related to this `TenantAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedTenantAttachmentNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `TenantAttachment`. */
  tenant: Maybe<Tenant>;
  /** The `TenantAttachment` that was deleted by this mutation. */
  tenantAttachment: Maybe<TenantAttachment>;
  /** An edge for our `TenantAttachment`. May be used by Relay 1. */
  tenantAttachmentEdge: Maybe<TenantAttachmentsEdge>;
};


/** The output of our delete `TenantAttachment` mutation. */
export type DeleteTenantAttachmentPayloadTenantAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<TenantAttachmentsOrderBy>>;
};

/** All input for the `deleteTenantByNodeId` mutation. */
export type DeleteTenantByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Tenant` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTenant` mutation. */
export type DeleteTenantInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Tenant` mutation. */
export type DeleteTenantPayload = {
  __typename?: 'DeleteTenantPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedTenantNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Tenant` that was deleted by this mutation. */
  tenant: Maybe<Tenant>;
  /** An edge for our `Tenant`. May be used by Relay 1. */
  tenantEdge: Maybe<TenantsEdge>;
};


/** The output of our delete `Tenant` mutation. */
export type DeleteTenantPayloadTenantEdgeArgs = {
  orderBy?: InputMaybe<Array<TenantsOrderBy>>;
};

/** All input for the `deleteTenantPersonByNodeId` mutation. */
export type DeleteTenantPersonByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TenantPerson` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTenantPerson` mutation. */
export type DeleteTenantPersonInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  personId: Scalars['BigInt'];
  tenantId: Scalars['BigInt'];
};

/** The output of our delete `TenantPerson` mutation. */
export type DeleteTenantPersonPayload = {
  __typename?: 'DeleteTenantPersonPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedTenantPersonNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `Person` that is related to this `TenantPerson`. */
  person: Maybe<Person>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `TenantPerson`. */
  tenant: Maybe<Tenant>;
  /** The `TenantPerson` that was deleted by this mutation. */
  tenantPerson: Maybe<TenantPerson>;
  /** An edge for our `TenantPerson`. May be used by Relay 1. */
  tenantPersonEdge: Maybe<TenantPeopleEdge>;
};


/** The output of our delete `TenantPerson` mutation. */
export type DeleteTenantPersonPayloadTenantPersonEdgeArgs = {
  orderBy?: InputMaybe<Array<TenantPeopleOrderBy>>;
};

/** All input for the `deleteUpozorneniByNodeId` mutation. */
export type DeleteUpozorneniByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Upozorneni` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteUpozorneni` mutation. */
export type DeleteUpozorneniInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  upId: Scalars['BigInt'];
};

/** The output of our delete `Upozorneni` mutation. */
export type DeleteUpozorneniPayload = {
  __typename?: 'DeleteUpozorneniPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedUpozorneniNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Upozorneni` that was deleted by this mutation. */
  upozorneni: Maybe<Upozorneni>;
  /** An edge for our `Upozorneni`. May be used by Relay 1. */
  upozorneniEdge: Maybe<UpozornenisEdge>;
  /** Reads a single `User` that is related to this `Upozorneni`. */
  userByUpKdo: Maybe<User>;
};


/** The output of our delete `Upozorneni` mutation. */
export type DeleteUpozorneniPayloadUpozorneniEdgeArgs = {
  orderBy?: InputMaybe<Array<UpozornenisOrderBy>>;
};

/** All input for the `deleteUpozorneniSkupinyByNodeId` mutation. */
export type DeleteUpozorneniSkupinyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `UpozorneniSkupiny` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteUpozorneniSkupiny` mutation. */
export type DeleteUpozorneniSkupinyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  upsId: Scalars['BigInt'];
};

/** The output of our delete `UpozorneniSkupiny` mutation. */
export type DeleteUpozorneniSkupinyPayload = {
  __typename?: 'DeleteUpozorneniSkupinyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedUpozorneniSkupinyNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
  skupinyByUpsIdSkupina: Maybe<Skupiny>;
  /** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
  upozorneniByUpsIdRodic: Maybe<Upozorneni>;
  /** The `UpozorneniSkupiny` that was deleted by this mutation. */
  upozorneniSkupiny: Maybe<UpozorneniSkupiny>;
  /** An edge for our `UpozorneniSkupiny`. May be used by Relay 1. */
  upozorneniSkupinyEdge: Maybe<UpozorneniSkupiniesEdge>;
};


/** The output of our delete `UpozorneniSkupiny` mutation. */
export type DeleteUpozorneniSkupinyPayloadUpozorneniSkupinyEdgeArgs = {
  orderBy?: InputMaybe<Array<UpozorneniSkupiniesOrderBy>>;
};

/** All input for the `deleteUserByNodeId` mutation. */
export type DeleteUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `User` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteUser` mutation. */
export type DeleteUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  uId: Scalars['BigInt'];
};

/** The output of our delete `User` mutation. */
export type DeleteUserPayload = {
  __typename?: 'DeleteUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedUserNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `Permission` that is related to this `User`. */
  permissionByUGroup: Maybe<Permission>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `User`. */
  skupinyByUSkupina: Maybe<Skupiny>;
  /** The `User` that was deleted by this mutation. */
  user: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge: Maybe<UsersEdge>;
};


/** The output of our delete `User` mutation. */
export type DeleteUserPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the `deleteVideoByNodeId` mutation. */
export type DeleteVideoByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Video` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteVideo` mutation. */
export type DeleteVideoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  vId: Scalars['BigInt'];
};

/** All input for the `deleteVideoListByNodeId` mutation. */
export type DeleteVideoListByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `VideoList` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteVideoList` mutation. */
export type DeleteVideoListInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  vlId: Scalars['BigInt'];
};

/** The output of our delete `VideoList` mutation. */
export type DeleteVideoListPayload = {
  __typename?: 'DeleteVideoListPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedVideoListNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `VideoList` that was deleted by this mutation. */
  videoList: Maybe<VideoList>;
  /** An edge for our `VideoList`. May be used by Relay 1. */
  videoListEdge: Maybe<VideoListsEdge>;
};


/** The output of our delete `VideoList` mutation. */
export type DeleteVideoListPayloadVideoListEdgeArgs = {
  orderBy?: InputMaybe<Array<VideoListsOrderBy>>;
};

/** The output of our delete `Video` mutation. */
export type DeleteVideoPayload = {
  __typename?: 'DeleteVideoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedVideoNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Video` that was deleted by this mutation. */
  video: Maybe<Video>;
  /** An edge for our `Video`. May be used by Relay 1. */
  videoEdge: Maybe<VideosEdge>;
};


/** The output of our delete `Video` mutation. */
export type DeleteVideoPayloadVideoEdgeArgs = {
  orderBy?: InputMaybe<Array<VideosOrderBy>>;
};

/** All input for the `deleteVideoSourceByNodeId` mutation. */
export type DeleteVideoSourceByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `VideoSource` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteVideoSource` mutation. */
export type DeleteVideoSourceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  vsId: Scalars['BigInt'];
};

/** The output of our delete `VideoSource` mutation. */
export type DeleteVideoSourcePayload = {
  __typename?: 'DeleteVideoSourcePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedVideoSourceNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `VideoSource` that was deleted by this mutation. */
  videoSource: Maybe<VideoSource>;
  /** An edge for our `VideoSource`. May be used by Relay 1. */
  videoSourceEdge: Maybe<VideoSourcesEdge>;
};


/** The output of our delete `VideoSource` mutation. */
export type DeleteVideoSourcePayloadVideoSourceEdgeArgs = {
  orderBy?: InputMaybe<Array<VideoSourcesOrderBy>>;
};

/** A connection to a list of `Dokumenty` values. */
export type DokumentiesConnection = {
  __typename?: 'DokumentiesConnection';
  /** A list of edges which contains the `Dokumenty` and cursor to aid in pagination. */
  edges: Array<DokumentiesEdge>;
  /** A list of `Dokumenty` objects. */
  nodes: Array<Dokumenty>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Dokumenty` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Dokumenty` edge in the connection. */
export type DokumentiesEdge = {
  __typename?: 'DokumentiesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Dokumenty` at the end of the edge. */
  node: Dokumenty;
};

/** Methods to use when ordering `Dokumenty`. */
export enum DokumentiesOrderBy {
  DFilenameAsc = 'D_FILENAME_ASC',
  DFilenameDesc = 'D_FILENAME_DESC',
  DIdAsc = 'D_ID_ASC',
  DIdDesc = 'D_ID_DESC',
  DKategorieAsc = 'D_KATEGORIE_ASC',
  DKategorieDesc = 'D_KATEGORIE_DESC',
  DKdoAsc = 'D_KDO_ASC',
  DKdoDesc = 'D_KDO_DESC',
  DNameAsc = 'D_NAME_ASC',
  DNameDesc = 'D_NAME_DESC',
  DPathAsc = 'D_PATH_ASC',
  DPathDesc = 'D_PATH_DESC',
  DTimestampAsc = 'D_TIMESTAMP_ASC',
  DTimestampDesc = 'D_TIMESTAMP_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserByDKdoUBanAsc = 'USER_BY_D_KDO__U_BAN_ASC',
  UserByDKdoUBanDesc = 'USER_BY_D_KDO__U_BAN_DESC',
  UserByDKdoUCityAsc = 'USER_BY_D_KDO__U_CITY_ASC',
  UserByDKdoUCityDesc = 'USER_BY_D_KDO__U_CITY_DESC',
  UserByDKdoUConfirmedAsc = 'USER_BY_D_KDO__U_CONFIRMED_ASC',
  UserByDKdoUConfirmedDesc = 'USER_BY_D_KDO__U_CONFIRMED_DESC',
  UserByDKdoUConscriptionNumberAsc = 'USER_BY_D_KDO__U_CONSCRIPTION_NUMBER_ASC',
  UserByDKdoUConscriptionNumberDesc = 'USER_BY_D_KDO__U_CONSCRIPTION_NUMBER_DESC',
  UserByDKdoUCreatedAtAsc = 'USER_BY_D_KDO__U_CREATED_AT_ASC',
  UserByDKdoUCreatedAtDesc = 'USER_BY_D_KDO__U_CREATED_AT_DESC',
  UserByDKdoUDancerAsc = 'USER_BY_D_KDO__U_DANCER_ASC',
  UserByDKdoUDancerDesc = 'USER_BY_D_KDO__U_DANCER_DESC',
  UserByDKdoUDistrictAsc = 'USER_BY_D_KDO__U_DISTRICT_ASC',
  UserByDKdoUDistrictDesc = 'USER_BY_D_KDO__U_DISTRICT_DESC',
  UserByDKdoUEmailAsc = 'USER_BY_D_KDO__U_EMAIL_ASC',
  UserByDKdoUEmailDesc = 'USER_BY_D_KDO__U_EMAIL_DESC',
  UserByDKdoUGdprSignedAtAsc = 'USER_BY_D_KDO__U_GDPR_SIGNED_AT_ASC',
  UserByDKdoUGdprSignedAtDesc = 'USER_BY_D_KDO__U_GDPR_SIGNED_AT_DESC',
  UserByDKdoUGroupAsc = 'USER_BY_D_KDO__U_GROUP_ASC',
  UserByDKdoUGroupDesc = 'USER_BY_D_KDO__U_GROUP_DESC',
  UserByDKdoUIdAsc = 'USER_BY_D_KDO__U_ID_ASC',
  UserByDKdoUIdDesc = 'USER_BY_D_KDO__U_ID_DESC',
  UserByDKdoUJmenoAsc = 'USER_BY_D_KDO__U_JMENO_ASC',
  UserByDKdoUJmenoDesc = 'USER_BY_D_KDO__U_JMENO_DESC',
  UserByDKdoULevelAsc = 'USER_BY_D_KDO__U_LEVEL_ASC',
  UserByDKdoULevelDesc = 'USER_BY_D_KDO__U_LEVEL_DESC',
  UserByDKdoULockAsc = 'USER_BY_D_KDO__U_LOCK_ASC',
  UserByDKdoULockDesc = 'USER_BY_D_KDO__U_LOCK_DESC',
  UserByDKdoULoginAsc = 'USER_BY_D_KDO__U_LOGIN_ASC',
  UserByDKdoULoginDesc = 'USER_BY_D_KDO__U_LOGIN_DESC',
  UserByDKdoUMemberSinceAsc = 'USER_BY_D_KDO__U_MEMBER_SINCE_ASC',
  UserByDKdoUMemberSinceDesc = 'USER_BY_D_KDO__U_MEMBER_SINCE_DESC',
  UserByDKdoUMemberUntilAsc = 'USER_BY_D_KDO__U_MEMBER_UNTIL_ASC',
  UserByDKdoUMemberUntilDesc = 'USER_BY_D_KDO__U_MEMBER_UNTIL_DESC',
  UserByDKdoUNarozeniAsc = 'USER_BY_D_KDO__U_NAROZENI_ASC',
  UserByDKdoUNarozeniDesc = 'USER_BY_D_KDO__U_NAROZENI_DESC',
  UserByDKdoUNationalityAsc = 'USER_BY_D_KDO__U_NATIONALITY_ASC',
  UserByDKdoUNationalityDesc = 'USER_BY_D_KDO__U_NATIONALITY_DESC',
  UserByDKdoUOrientationNumberAsc = 'USER_BY_D_KDO__U_ORIENTATION_NUMBER_ASC',
  UserByDKdoUOrientationNumberDesc = 'USER_BY_D_KDO__U_ORIENTATION_NUMBER_DESC',
  UserByDKdoUPassAsc = 'USER_BY_D_KDO__U_PASS_ASC',
  UserByDKdoUPassDesc = 'USER_BY_D_KDO__U_PASS_DESC',
  UserByDKdoUPohlaviAsc = 'USER_BY_D_KDO__U_POHLAVI_ASC',
  UserByDKdoUPohlaviDesc = 'USER_BY_D_KDO__U_POHLAVI_DESC',
  UserByDKdoUPostalCodeAsc = 'USER_BY_D_KDO__U_POSTAL_CODE_ASC',
  UserByDKdoUPostalCodeDesc = 'USER_BY_D_KDO__U_POSTAL_CODE_DESC',
  UserByDKdoUPoznamkyAsc = 'USER_BY_D_KDO__U_POZNAMKY_ASC',
  UserByDKdoUPoznamkyDesc = 'USER_BY_D_KDO__U_POZNAMKY_DESC',
  UserByDKdoUPrijmeniAsc = 'USER_BY_D_KDO__U_PRIJMENI_ASC',
  UserByDKdoUPrijmeniDesc = 'USER_BY_D_KDO__U_PRIJMENI_DESC',
  UserByDKdoURodneCisloAsc = 'USER_BY_D_KDO__U_RODNE_CISLO_ASC',
  UserByDKdoURodneCisloDesc = 'USER_BY_D_KDO__U_RODNE_CISLO_DESC',
  UserByDKdoUSkupinaAsc = 'USER_BY_D_KDO__U_SKUPINA_ASC',
  UserByDKdoUSkupinaDesc = 'USER_BY_D_KDO__U_SKUPINA_DESC',
  UserByDKdoUStreetAsc = 'USER_BY_D_KDO__U_STREET_ASC',
  UserByDKdoUStreetDesc = 'USER_BY_D_KDO__U_STREET_DESC',
  UserByDKdoUSystemAsc = 'USER_BY_D_KDO__U_SYSTEM_ASC',
  UserByDKdoUSystemDesc = 'USER_BY_D_KDO__U_SYSTEM_DESC',
  UserByDKdoUTeacherAsc = 'USER_BY_D_KDO__U_TEACHER_ASC',
  UserByDKdoUTeacherDesc = 'USER_BY_D_KDO__U_TEACHER_DESC',
  UserByDKdoUTelefonAsc = 'USER_BY_D_KDO__U_TELEFON_ASC',
  UserByDKdoUTelefonDesc = 'USER_BY_D_KDO__U_TELEFON_DESC',
  UserByDKdoUTimestampAsc = 'USER_BY_D_KDO__U_TIMESTAMP_ASC',
  UserByDKdoUTimestampDesc = 'USER_BY_D_KDO__U_TIMESTAMP_DESC'
}

export type Dokumenty = Node & {
  __typename?: 'Dokumenty';
  dFilename: Scalars['String'];
  dId: Scalars['BigInt'];
  dKategorie: Scalars['Int'];
  dKdo: Scalars['BigInt'];
  dName: Scalars['String'];
  dPath: Scalars['String'];
  dTimestamp: Maybe<Scalars['Datetime']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `User` that is related to this `Dokumenty`. */
  userByDKdo: Maybe<User>;
};

/**
 * A condition to be used against `Dokumenty` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type DokumentyCondition = {
  /** Checks for equality with the object’s `dFilename` field. */
  dFilename?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `dId` field. */
  dId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `dKategorie` field. */
  dKategorie?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `dKdo` field. */
  dKdo?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `dName` field. */
  dName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `dPath` field. */
  dPath?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `dTimestamp` field. */
  dTimestamp?: InputMaybe<Scalars['Datetime']>;
};

/** An input for mutations affecting `Dokumenty` */
export type DokumentyInput = {
  dFilename: Scalars['String'];
  dId?: InputMaybe<Scalars['BigInt']>;
  dKategorie: Scalars['Int'];
  dKdo: Scalars['BigInt'];
  dName: Scalars['String'];
  dPath: Scalars['String'];
  dTimestamp?: InputMaybe<Scalars['Datetime']>;
};

/** Represents an update to a `Dokumenty`. Fields that are set will be updated. */
export type DokumentyPatch = {
  dFilename?: InputMaybe<Scalars['String']>;
  dId?: InputMaybe<Scalars['BigInt']>;
  dKategorie?: InputMaybe<Scalars['Int']>;
  dKdo?: InputMaybe<Scalars['BigInt']>;
  dName?: InputMaybe<Scalars['String']>;
  dPath?: InputMaybe<Scalars['String']>;
  dTimestamp?: InputMaybe<Scalars['Datetime']>;
};

export type Event = Node & {
  __typename?: 'Event';
  /** Reads and enables pagination through a set of `AttendeeExternal`. */
  attendeeExternals: AttendeeExternalsConnection;
  /** Reads and enables pagination through a set of `AttendeeUser`. */
  attendeeUsers: AttendeeUsersConnection;
  capacity: Scalars['BigInt'];
  description: Scalars['String'];
  enableNotes: Scalars['Boolean'];
  filesLegacy: Scalars['String'];
  id: Scalars['BigInt'];
  isLocked: Scalars['Boolean'];
  isPublic: Scalars['Boolean'];
  isVisible: Scalars['Boolean'];
  locationText: Scalars['String'];
  name: Scalars['String'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  remainingSpots: Maybe<Scalars['Int']>;
  since: Scalars['Date'];
  summary: Scalars['JSON'];
  until: Scalars['Date'];
  updatedAt: Maybe<Scalars['Datetime']>;
};


export type EventAttendeeExternalsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AttendeeExternalCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AttendeeExternalsOrderBy>>;
};


export type EventAttendeeUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AttendeeUserCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AttendeeUsersOrderBy>>;
};

/** A condition to be used against `Event` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type EventCondition = {
  /** Checks for equality with the object’s `capacity` field. */
  capacity?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `enableNotes` field. */
  enableNotes?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `filesLegacy` field. */
  filesLegacy?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `isLocked` field. */
  isLocked?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `isPublic` field. */
  isPublic?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `isVisible` field. */
  isVisible?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `locationText` field. */
  locationText?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `since` field. */
  since?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `summary` field. */
  summary?: InputMaybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `until` field. */
  until?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']>;
};

/** An input for mutations affecting `Event` */
export type EventInput = {
  capacity?: InputMaybe<Scalars['BigInt']>;
  description: Scalars['String'];
  enableNotes?: InputMaybe<Scalars['Boolean']>;
  filesLegacy: Scalars['String'];
  id?: InputMaybe<Scalars['BigInt']>;
  isLocked?: InputMaybe<Scalars['Boolean']>;
  isPublic?: InputMaybe<Scalars['Boolean']>;
  isVisible?: InputMaybe<Scalars['Boolean']>;
  locationText: Scalars['String'];
  name: Scalars['String'];
  since: Scalars['Date'];
  summary?: InputMaybe<Scalars['JSON']>;
  until: Scalars['Date'];
  updatedAt?: InputMaybe<Scalars['Datetime']>;
};

/** Represents an update to a `Event`. Fields that are set will be updated. */
export type EventPatch = {
  capacity?: InputMaybe<Scalars['BigInt']>;
  description?: InputMaybe<Scalars['String']>;
  enableNotes?: InputMaybe<Scalars['Boolean']>;
  filesLegacy?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['BigInt']>;
  isLocked?: InputMaybe<Scalars['Boolean']>;
  isPublic?: InputMaybe<Scalars['Boolean']>;
  isVisible?: InputMaybe<Scalars['Boolean']>;
  locationText?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  since?: InputMaybe<Scalars['Date']>;
  summary?: InputMaybe<Scalars['JSON']>;
  until?: InputMaybe<Scalars['Date']>;
  updatedAt?: InputMaybe<Scalars['Datetime']>;
};

/** A connection to a list of `Event` values. */
export type EventsConnection = {
  __typename?: 'EventsConnection';
  /** A list of edges which contains the `Event` and cursor to aid in pagination. */
  edges: Array<EventsEdge>;
  /** A list of `Event` objects. */
  nodes: Array<Event>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Event` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Event` edge in the connection. */
export type EventsEdge = {
  __typename?: 'EventsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Event` at the end of the edge. */
  node: Event;
};

/** Methods to use when ordering `Event`. */
export enum EventsOrderBy {
  AttendeeExternalsByEventIdCountAsc = 'ATTENDEE_EXTERNALS_BY_EVENT_ID__COUNT_ASC',
  AttendeeExternalsByEventIdCountDesc = 'ATTENDEE_EXTERNALS_BY_EVENT_ID__COUNT_DESC',
  AttendeeUsersByEventIdCountAsc = 'ATTENDEE_USERS_BY_EVENT_ID__COUNT_ASC',
  AttendeeUsersByEventIdCountDesc = 'ATTENDEE_USERS_BY_EVENT_ID__COUNT_DESC',
  CapacityAsc = 'CAPACITY_ASC',
  CapacityDesc = 'CAPACITY_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  EnableNotesAsc = 'ENABLE_NOTES_ASC',
  EnableNotesDesc = 'ENABLE_NOTES_DESC',
  FilesLegacyAsc = 'FILES_LEGACY_ASC',
  FilesLegacyDesc = 'FILES_LEGACY_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsLockedAsc = 'IS_LOCKED_ASC',
  IsLockedDesc = 'IS_LOCKED_DESC',
  IsPublicAsc = 'IS_PUBLIC_ASC',
  IsPublicDesc = 'IS_PUBLIC_DESC',
  IsVisibleAsc = 'IS_VISIBLE_ASC',
  IsVisibleDesc = 'IS_VISIBLE_DESC',
  LocationTextAsc = 'LOCATION_TEXT_ASC',
  LocationTextDesc = 'LOCATION_TEXT_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SinceAsc = 'SINCE_ASC',
  SinceDesc = 'SINCE_DESC',
  SummaryAsc = 'SUMMARY_ASC',
  SummaryDesc = 'SUMMARY_DESC',
  UntilAsc = 'UNTIL_ASC',
  UntilDesc = 'UNTIL_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

/** All input for the `fixUnpairedCouples` mutation. */
export type FixUnpairedCouplesInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** The output of our `fixUnpairedCouples` mutation. */
export type FixUnpairedCouplesPayload = {
  __typename?: 'FixUnpairedCouplesPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  paries: Maybe<Array<Pary>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type GalerieDir = Node & {
  __typename?: 'GalerieDir';
  /** Reads and enables pagination through a set of `GalerieFoto`. */
  galerieFotosByGfIdRodic: GalerieFotosConnection;
  gdHidden: Scalars['Boolean'];
  gdId: Scalars['BigInt'];
  gdIdRodic: Scalars['BigInt'];
  gdLevel: Scalars['Int'];
  gdName: Scalars['String'];
  gdPath: Scalars['String'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
};


export type GalerieDirGalerieFotosByGfIdRodicArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<GalerieFotoCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GalerieFotosOrderBy>>;
};

/**
 * A condition to be used against `GalerieDir` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type GalerieDirCondition = {
  /** Checks for equality with the object’s `gdHidden` field. */
  gdHidden?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `gdId` field. */
  gdId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `gdIdRodic` field. */
  gdIdRodic?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `gdLevel` field. */
  gdLevel?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gdName` field. */
  gdName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `gdPath` field. */
  gdPath?: InputMaybe<Scalars['String']>;
};

/** An input for mutations affecting `GalerieDir` */
export type GalerieDirInput = {
  gdHidden?: InputMaybe<Scalars['Boolean']>;
  gdId?: InputMaybe<Scalars['BigInt']>;
  gdIdRodic: Scalars['BigInt'];
  gdLevel?: InputMaybe<Scalars['Int']>;
  gdName: Scalars['String'];
  gdPath: Scalars['String'];
};

/** Represents an update to a `GalerieDir`. Fields that are set will be updated. */
export type GalerieDirPatch = {
  gdHidden?: InputMaybe<Scalars['Boolean']>;
  gdId?: InputMaybe<Scalars['BigInt']>;
  gdIdRodic?: InputMaybe<Scalars['BigInt']>;
  gdLevel?: InputMaybe<Scalars['Int']>;
  gdName?: InputMaybe<Scalars['String']>;
  gdPath?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `GalerieDir` values. */
export type GalerieDirsConnection = {
  __typename?: 'GalerieDirsConnection';
  /** A list of edges which contains the `GalerieDir` and cursor to aid in pagination. */
  edges: Array<GalerieDirsEdge>;
  /** A list of `GalerieDir` objects. */
  nodes: Array<GalerieDir>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `GalerieDir` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `GalerieDir` edge in the connection. */
export type GalerieDirsEdge = {
  __typename?: 'GalerieDirsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `GalerieDir` at the end of the edge. */
  node: GalerieDir;
};

/** Methods to use when ordering `GalerieDir`. */
export enum GalerieDirsOrderBy {
  GalerieFotosByGfIdRodicCountAsc = 'GALERIE_FOTOS_BY_GF_ID_RODIC__COUNT_ASC',
  GalerieFotosByGfIdRodicCountDesc = 'GALERIE_FOTOS_BY_GF_ID_RODIC__COUNT_DESC',
  GdHiddenAsc = 'GD_HIDDEN_ASC',
  GdHiddenDesc = 'GD_HIDDEN_DESC',
  GdIdAsc = 'GD_ID_ASC',
  GdIdDesc = 'GD_ID_DESC',
  GdIdRodicAsc = 'GD_ID_RODIC_ASC',
  GdIdRodicDesc = 'GD_ID_RODIC_DESC',
  GdLevelAsc = 'GD_LEVEL_ASC',
  GdLevelDesc = 'GD_LEVEL_DESC',
  GdNameAsc = 'GD_NAME_ASC',
  GdNameDesc = 'GD_NAME_DESC',
  GdPathAsc = 'GD_PATH_ASC',
  GdPathDesc = 'GD_PATH_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type GalerieFoto = Node & {
  __typename?: 'GalerieFoto';
  /** Reads and enables pagination through a set of `Aktuality`. */
  aktualitiesByAtFotoMain: AktualitiesConnection;
  /** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
  galerieDirByGfIdRodic: Maybe<GalerieDir>;
  gfId: Scalars['BigInt'];
  gfIdRodic: Scalars['BigInt'];
  gfKdo: Scalars['BigInt'];
  gfName: Scalars['String'];
  gfPath: Scalars['String'];
  gfTimestamp: Maybe<Scalars['Datetime']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `User` that is related to this `GalerieFoto`. */
  userByGfKdo: Maybe<User>;
};


export type GalerieFotoAktualitiesByAtFotoMainArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AktualityCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AktualitiesOrderBy>>;
};

/**
 * A condition to be used against `GalerieFoto` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type GalerieFotoCondition = {
  /** Checks for equality with the object’s `gfId` field. */
  gfId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `gfIdRodic` field. */
  gfIdRodic?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `gfKdo` field. */
  gfKdo?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `gfName` field. */
  gfName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `gfPath` field. */
  gfPath?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `gfTimestamp` field. */
  gfTimestamp?: InputMaybe<Scalars['Datetime']>;
};

/** An input for mutations affecting `GalerieFoto` */
export type GalerieFotoInput = {
  gfId?: InputMaybe<Scalars['BigInt']>;
  gfIdRodic: Scalars['BigInt'];
  gfKdo: Scalars['BigInt'];
  gfName: Scalars['String'];
  gfPath: Scalars['String'];
  gfTimestamp?: InputMaybe<Scalars['Datetime']>;
};

/** Represents an update to a `GalerieFoto`. Fields that are set will be updated. */
export type GalerieFotoPatch = {
  gfId?: InputMaybe<Scalars['BigInt']>;
  gfIdRodic?: InputMaybe<Scalars['BigInt']>;
  gfKdo?: InputMaybe<Scalars['BigInt']>;
  gfName?: InputMaybe<Scalars['String']>;
  gfPath?: InputMaybe<Scalars['String']>;
  gfTimestamp?: InputMaybe<Scalars['Datetime']>;
};

/** A connection to a list of `GalerieFoto` values. */
export type GalerieFotosConnection = {
  __typename?: 'GalerieFotosConnection';
  /** A list of edges which contains the `GalerieFoto` and cursor to aid in pagination. */
  edges: Array<GalerieFotosEdge>;
  /** A list of `GalerieFoto` objects. */
  nodes: Array<GalerieFoto>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `GalerieFoto` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `GalerieFoto` edge in the connection. */
export type GalerieFotosEdge = {
  __typename?: 'GalerieFotosEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `GalerieFoto` at the end of the edge. */
  node: GalerieFoto;
};

/** Methods to use when ordering `GalerieFoto`. */
export enum GalerieFotosOrderBy {
  AktualitiesByAtFotoMainCountAsc = 'AKTUALITIES_BY_AT_FOTO_MAIN__COUNT_ASC',
  AktualitiesByAtFotoMainCountDesc = 'AKTUALITIES_BY_AT_FOTO_MAIN__COUNT_DESC',
  GalerieDirByGfIdRodicGdHiddenAsc = 'GALERIE_DIR_BY_GF_ID_RODIC__GD_HIDDEN_ASC',
  GalerieDirByGfIdRodicGdHiddenDesc = 'GALERIE_DIR_BY_GF_ID_RODIC__GD_HIDDEN_DESC',
  GalerieDirByGfIdRodicGdIdAsc = 'GALERIE_DIR_BY_GF_ID_RODIC__GD_ID_ASC',
  GalerieDirByGfIdRodicGdIdDesc = 'GALERIE_DIR_BY_GF_ID_RODIC__GD_ID_DESC',
  GalerieDirByGfIdRodicGdIdRodicAsc = 'GALERIE_DIR_BY_GF_ID_RODIC__GD_ID_RODIC_ASC',
  GalerieDirByGfIdRodicGdIdRodicDesc = 'GALERIE_DIR_BY_GF_ID_RODIC__GD_ID_RODIC_DESC',
  GalerieDirByGfIdRodicGdLevelAsc = 'GALERIE_DIR_BY_GF_ID_RODIC__GD_LEVEL_ASC',
  GalerieDirByGfIdRodicGdLevelDesc = 'GALERIE_DIR_BY_GF_ID_RODIC__GD_LEVEL_DESC',
  GalerieDirByGfIdRodicGdNameAsc = 'GALERIE_DIR_BY_GF_ID_RODIC__GD_NAME_ASC',
  GalerieDirByGfIdRodicGdNameDesc = 'GALERIE_DIR_BY_GF_ID_RODIC__GD_NAME_DESC',
  GalerieDirByGfIdRodicGdPathAsc = 'GALERIE_DIR_BY_GF_ID_RODIC__GD_PATH_ASC',
  GalerieDirByGfIdRodicGdPathDesc = 'GALERIE_DIR_BY_GF_ID_RODIC__GD_PATH_DESC',
  GfIdAsc = 'GF_ID_ASC',
  GfIdDesc = 'GF_ID_DESC',
  GfIdRodicAsc = 'GF_ID_RODIC_ASC',
  GfIdRodicDesc = 'GF_ID_RODIC_DESC',
  GfKdoAsc = 'GF_KDO_ASC',
  GfKdoDesc = 'GF_KDO_DESC',
  GfNameAsc = 'GF_NAME_ASC',
  GfNameDesc = 'GF_NAME_DESC',
  GfPathAsc = 'GF_PATH_ASC',
  GfPathDesc = 'GF_PATH_DESC',
  GfTimestampAsc = 'GF_TIMESTAMP_ASC',
  GfTimestampDesc = 'GF_TIMESTAMP_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserByGfKdoUBanAsc = 'USER_BY_GF_KDO__U_BAN_ASC',
  UserByGfKdoUBanDesc = 'USER_BY_GF_KDO__U_BAN_DESC',
  UserByGfKdoUCityAsc = 'USER_BY_GF_KDO__U_CITY_ASC',
  UserByGfKdoUCityDesc = 'USER_BY_GF_KDO__U_CITY_DESC',
  UserByGfKdoUConfirmedAsc = 'USER_BY_GF_KDO__U_CONFIRMED_ASC',
  UserByGfKdoUConfirmedDesc = 'USER_BY_GF_KDO__U_CONFIRMED_DESC',
  UserByGfKdoUConscriptionNumberAsc = 'USER_BY_GF_KDO__U_CONSCRIPTION_NUMBER_ASC',
  UserByGfKdoUConscriptionNumberDesc = 'USER_BY_GF_KDO__U_CONSCRIPTION_NUMBER_DESC',
  UserByGfKdoUCreatedAtAsc = 'USER_BY_GF_KDO__U_CREATED_AT_ASC',
  UserByGfKdoUCreatedAtDesc = 'USER_BY_GF_KDO__U_CREATED_AT_DESC',
  UserByGfKdoUDancerAsc = 'USER_BY_GF_KDO__U_DANCER_ASC',
  UserByGfKdoUDancerDesc = 'USER_BY_GF_KDO__U_DANCER_DESC',
  UserByGfKdoUDistrictAsc = 'USER_BY_GF_KDO__U_DISTRICT_ASC',
  UserByGfKdoUDistrictDesc = 'USER_BY_GF_KDO__U_DISTRICT_DESC',
  UserByGfKdoUEmailAsc = 'USER_BY_GF_KDO__U_EMAIL_ASC',
  UserByGfKdoUEmailDesc = 'USER_BY_GF_KDO__U_EMAIL_DESC',
  UserByGfKdoUGdprSignedAtAsc = 'USER_BY_GF_KDO__U_GDPR_SIGNED_AT_ASC',
  UserByGfKdoUGdprSignedAtDesc = 'USER_BY_GF_KDO__U_GDPR_SIGNED_AT_DESC',
  UserByGfKdoUGroupAsc = 'USER_BY_GF_KDO__U_GROUP_ASC',
  UserByGfKdoUGroupDesc = 'USER_BY_GF_KDO__U_GROUP_DESC',
  UserByGfKdoUIdAsc = 'USER_BY_GF_KDO__U_ID_ASC',
  UserByGfKdoUIdDesc = 'USER_BY_GF_KDO__U_ID_DESC',
  UserByGfKdoUJmenoAsc = 'USER_BY_GF_KDO__U_JMENO_ASC',
  UserByGfKdoUJmenoDesc = 'USER_BY_GF_KDO__U_JMENO_DESC',
  UserByGfKdoULevelAsc = 'USER_BY_GF_KDO__U_LEVEL_ASC',
  UserByGfKdoULevelDesc = 'USER_BY_GF_KDO__U_LEVEL_DESC',
  UserByGfKdoULockAsc = 'USER_BY_GF_KDO__U_LOCK_ASC',
  UserByGfKdoULockDesc = 'USER_BY_GF_KDO__U_LOCK_DESC',
  UserByGfKdoULoginAsc = 'USER_BY_GF_KDO__U_LOGIN_ASC',
  UserByGfKdoULoginDesc = 'USER_BY_GF_KDO__U_LOGIN_DESC',
  UserByGfKdoUMemberSinceAsc = 'USER_BY_GF_KDO__U_MEMBER_SINCE_ASC',
  UserByGfKdoUMemberSinceDesc = 'USER_BY_GF_KDO__U_MEMBER_SINCE_DESC',
  UserByGfKdoUMemberUntilAsc = 'USER_BY_GF_KDO__U_MEMBER_UNTIL_ASC',
  UserByGfKdoUMemberUntilDesc = 'USER_BY_GF_KDO__U_MEMBER_UNTIL_DESC',
  UserByGfKdoUNarozeniAsc = 'USER_BY_GF_KDO__U_NAROZENI_ASC',
  UserByGfKdoUNarozeniDesc = 'USER_BY_GF_KDO__U_NAROZENI_DESC',
  UserByGfKdoUNationalityAsc = 'USER_BY_GF_KDO__U_NATIONALITY_ASC',
  UserByGfKdoUNationalityDesc = 'USER_BY_GF_KDO__U_NATIONALITY_DESC',
  UserByGfKdoUOrientationNumberAsc = 'USER_BY_GF_KDO__U_ORIENTATION_NUMBER_ASC',
  UserByGfKdoUOrientationNumberDesc = 'USER_BY_GF_KDO__U_ORIENTATION_NUMBER_DESC',
  UserByGfKdoUPassAsc = 'USER_BY_GF_KDO__U_PASS_ASC',
  UserByGfKdoUPassDesc = 'USER_BY_GF_KDO__U_PASS_DESC',
  UserByGfKdoUPohlaviAsc = 'USER_BY_GF_KDO__U_POHLAVI_ASC',
  UserByGfKdoUPohlaviDesc = 'USER_BY_GF_KDO__U_POHLAVI_DESC',
  UserByGfKdoUPostalCodeAsc = 'USER_BY_GF_KDO__U_POSTAL_CODE_ASC',
  UserByGfKdoUPostalCodeDesc = 'USER_BY_GF_KDO__U_POSTAL_CODE_DESC',
  UserByGfKdoUPoznamkyAsc = 'USER_BY_GF_KDO__U_POZNAMKY_ASC',
  UserByGfKdoUPoznamkyDesc = 'USER_BY_GF_KDO__U_POZNAMKY_DESC',
  UserByGfKdoUPrijmeniAsc = 'USER_BY_GF_KDO__U_PRIJMENI_ASC',
  UserByGfKdoUPrijmeniDesc = 'USER_BY_GF_KDO__U_PRIJMENI_DESC',
  UserByGfKdoURodneCisloAsc = 'USER_BY_GF_KDO__U_RODNE_CISLO_ASC',
  UserByGfKdoURodneCisloDesc = 'USER_BY_GF_KDO__U_RODNE_CISLO_DESC',
  UserByGfKdoUSkupinaAsc = 'USER_BY_GF_KDO__U_SKUPINA_ASC',
  UserByGfKdoUSkupinaDesc = 'USER_BY_GF_KDO__U_SKUPINA_DESC',
  UserByGfKdoUStreetAsc = 'USER_BY_GF_KDO__U_STREET_ASC',
  UserByGfKdoUStreetDesc = 'USER_BY_GF_KDO__U_STREET_DESC',
  UserByGfKdoUSystemAsc = 'USER_BY_GF_KDO__U_SYSTEM_ASC',
  UserByGfKdoUSystemDesc = 'USER_BY_GF_KDO__U_SYSTEM_DESC',
  UserByGfKdoUTeacherAsc = 'USER_BY_GF_KDO__U_TEACHER_ASC',
  UserByGfKdoUTeacherDesc = 'USER_BY_GF_KDO__U_TEACHER_DESC',
  UserByGfKdoUTelefonAsc = 'USER_BY_GF_KDO__U_TELEFON_ASC',
  UserByGfKdoUTelefonDesc = 'USER_BY_GF_KDO__U_TELEFON_DESC',
  UserByGfKdoUTimestampAsc = 'USER_BY_GF_KDO__U_TIMESTAMP_ASC',
  UserByGfKdoUTimestampDesc = 'USER_BY_GF_KDO__U_TIMESTAMP_DESC'
}

export enum GenderType {
  Men = 'MEN',
  Unspecified = 'UNSPECIFIED',
  Woman = 'WOMAN'
}

export type Location = Node & {
  __typename?: 'Location';
  description: Scalars['JSON'];
  id: Scalars['BigInt'];
  /** Reads and enables pagination through a set of `LocationAttachment`. */
  locationAttachments: LocationAttachmentsConnection;
  name: Scalars['String'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads and enables pagination through a set of `Room`. */
  roomsByLocation: RoomsConnection;
  tenant: Maybe<Scalars['BigInt']>;
  /** Reads a single `Tenant` that is related to this `Location`. */
  tenantByTenant: Maybe<Tenant>;
};


export type LocationLocationAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<LocationAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LocationAttachmentsOrderBy>>;
};


export type LocationRoomsByLocationArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<RoomCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RoomsOrderBy>>;
};

export type LocationAttachment = Node & {
  __typename?: 'LocationAttachment';
  /** Reads a single `Attachment` that is related to this `LocationAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /** Reads a single `Location` that is related to this `LocationAttachment`. */
  location: Maybe<Location>;
  locationId: Scalars['BigInt'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  objectName: Scalars['String'];
};

/**
 * A condition to be used against `LocationAttachment` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type LocationAttachmentCondition = {
  /** Checks for equality with the object’s `locationId` field. */
  locationId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `objectName` field. */
  objectName?: InputMaybe<Scalars['String']>;
};

/** An input for mutations affecting `LocationAttachment` */
export type LocationAttachmentInput = {
  locationId: Scalars['BigInt'];
  objectName: Scalars['String'];
};

/** Represents an update to a `LocationAttachment`. Fields that are set will be updated. */
export type LocationAttachmentPatch = {
  locationId?: InputMaybe<Scalars['BigInt']>;
  objectName?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `LocationAttachment` values. */
export type LocationAttachmentsConnection = {
  __typename?: 'LocationAttachmentsConnection';
  /** A list of edges which contains the `LocationAttachment` and cursor to aid in pagination. */
  edges: Array<LocationAttachmentsEdge>;
  /** A list of `LocationAttachment` objects. */
  nodes: Array<LocationAttachment>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `LocationAttachment` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `LocationAttachment` edge in the connection. */
export type LocationAttachmentsEdge = {
  __typename?: 'LocationAttachmentsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `LocationAttachment` at the end of the edge. */
  node: LocationAttachment;
};

/** Methods to use when ordering `LocationAttachment`. */
export enum LocationAttachmentsOrderBy {
  AttachmentByObjectNameObjectNameAsc = 'ATTACHMENT_BY_OBJECT_NAME__OBJECT_NAME_ASC',
  AttachmentByObjectNameObjectNameDesc = 'ATTACHMENT_BY_OBJECT_NAME__OBJECT_NAME_DESC',
  AttachmentByObjectNamePreviewObjectNameAsc = 'ATTACHMENT_BY_OBJECT_NAME__PREVIEW_OBJECT_NAME_ASC',
  AttachmentByObjectNamePreviewObjectNameDesc = 'ATTACHMENT_BY_OBJECT_NAME__PREVIEW_OBJECT_NAME_DESC',
  AttachmentByObjectNameUploadedAtAsc = 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_AT_ASC',
  AttachmentByObjectNameUploadedAtDesc = 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_AT_DESC',
  AttachmentByObjectNameUploadedByAsc = 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_BY_ASC',
  AttachmentByObjectNameUploadedByDesc = 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_BY_DESC',
  LocationByLocationIdDescriptionAsc = 'LOCATION_BY_LOCATION_ID__DESCRIPTION_ASC',
  LocationByLocationIdDescriptionDesc = 'LOCATION_BY_LOCATION_ID__DESCRIPTION_DESC',
  LocationByLocationIdIdAsc = 'LOCATION_BY_LOCATION_ID__ID_ASC',
  LocationByLocationIdIdDesc = 'LOCATION_BY_LOCATION_ID__ID_DESC',
  LocationByLocationIdNameAsc = 'LOCATION_BY_LOCATION_ID__NAME_ASC',
  LocationByLocationIdNameDesc = 'LOCATION_BY_LOCATION_ID__NAME_DESC',
  LocationByLocationIdTenantAsc = 'LOCATION_BY_LOCATION_ID__TENANT_ASC',
  LocationByLocationIdTenantDesc = 'LOCATION_BY_LOCATION_ID__TENANT_DESC',
  LocationIdAsc = 'LOCATION_ID_ASC',
  LocationIdDesc = 'LOCATION_ID_DESC',
  Natural = 'NATURAL',
  ObjectNameAsc = 'OBJECT_NAME_ASC',
  ObjectNameDesc = 'OBJECT_NAME_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `Location` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type LocationCondition = {
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `tenant` field. */
  tenant?: InputMaybe<Scalars['BigInt']>;
};

/** An input for mutations affecting `Location` */
export type LocationInput = {
  description: Scalars['JSON'];
  id?: InputMaybe<Scalars['BigInt']>;
  name: Scalars['String'];
  tenant?: InputMaybe<Scalars['BigInt']>;
};

/** Represents an update to a `Location`. Fields that are set will be updated. */
export type LocationPatch = {
  description?: InputMaybe<Scalars['JSON']>;
  id?: InputMaybe<Scalars['BigInt']>;
  name?: InputMaybe<Scalars['String']>;
  tenant?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `Location` values. */
export type LocationsConnection = {
  __typename?: 'LocationsConnection';
  /** A list of edges which contains the `Location` and cursor to aid in pagination. */
  edges: Array<LocationsEdge>;
  /** A list of `Location` objects. */
  nodes: Array<Location>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Location` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Location` edge in the connection. */
export type LocationsEdge = {
  __typename?: 'LocationsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Location` at the end of the edge. */
  node: Location;
};

/** Methods to use when ordering `Location`. */
export enum LocationsOrderBy {
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LocationAttachmentsByLocationIdCountAsc = 'LOCATION_ATTACHMENTS_BY_LOCATION_ID__COUNT_ASC',
  LocationAttachmentsByLocationIdCountDesc = 'LOCATION_ATTACHMENTS_BY_LOCATION_ID__COUNT_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RoomsByLocationCountAsc = 'ROOMS_BY_LOCATION__COUNT_ASC',
  RoomsByLocationCountDesc = 'ROOMS_BY_LOCATION__COUNT_DESC',
  TenantAsc = 'TENANT_ASC',
  TenantByTenantIdAsc = 'TENANT_BY_TENANT__ID_ASC',
  TenantByTenantIdDesc = 'TENANT_BY_TENANT__ID_DESC',
  TenantByTenantMemberInfoAsc = 'TENANT_BY_TENANT__MEMBER_INFO_ASC',
  TenantByTenantMemberInfoDesc = 'TENANT_BY_TENANT__MEMBER_INFO_DESC',
  TenantByTenantNameAsc = 'TENANT_BY_TENANT__NAME_ASC',
  TenantByTenantNameDesc = 'TENANT_BY_TENANT__NAME_DESC',
  TenantDesc = 'TENANT_DESC'
}

/** All input for the `login` mutation. */
export type LoginInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  login: Scalars['String'];
  passwd: Scalars['String'];
};

/** The output of our `login` mutation. */
export type LoginPayload = {
  __typename?: 'LoginPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  result: Maybe<LoginRecord>;
};

/** The return type of our `login` mutation. */
export type LoginRecord = {
  __typename?: 'LoginRecord';
  couple: Maybe<Pary>;
  sess: Maybe<Session>;
  usr: Maybe<User>;
};

/** All input for the `logout` mutation. */
export type LogoutInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** The output of our `logout` mutation. */
export type LogoutPayload = {
  __typename?: 'LogoutPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type Member = {
  __typename?: 'Member';
  newestPayment: Maybe<Scalars['Date']>;
  oldestPayment: Maybe<Scalars['Date']>;
  paymentValid: Maybe<Scalars['Boolean']>;
  sColorRgb: Maybe<Scalars['String']>;
  sColorText: Maybe<Scalars['String']>;
  sDescription: Maybe<Scalars['String']>;
  sId: Maybe<Scalars['BigInt']>;
  sLocation: Maybe<Scalars['String']>;
  sName: Maybe<Scalars['String']>;
  sVisible: Maybe<Scalars['Boolean']>;
  uBan: Maybe<Scalars['Boolean']>;
  uCity: Maybe<Scalars['String']>;
  uConfirmed: Maybe<Scalars['Boolean']>;
  uConscriptionNumber: Maybe<Scalars['String']>;
  uCreatedAt: Maybe<Scalars['Datetime']>;
  uDancer: Maybe<Scalars['Boolean']>;
  uDistrict: Maybe<Scalars['String']>;
  uEmail: Maybe<Scalars['String']>;
  uGdprSignedAt: Maybe<Scalars['Datetime']>;
  uGroup: Maybe<Scalars['BigInt']>;
  uId: Maybe<Scalars['BigInt']>;
  uJmeno: Maybe<Scalars['String']>;
  uLevel: Maybe<Scalars['Int']>;
  uLock: Maybe<Scalars['Boolean']>;
  uLogin: Maybe<Scalars['String']>;
  uMemberSince: Maybe<Scalars['Datetime']>;
  uMemberUntil: Maybe<Scalars['Datetime']>;
  uNarozeni: Maybe<Scalars['Date']>;
  uNationality: Maybe<Scalars['String']>;
  uOrientationNumber: Maybe<Scalars['String']>;
  uPass: Maybe<Scalars['String']>;
  uPohlavi: Maybe<Scalars['String']>;
  uPostalCode: Maybe<Scalars['String']>;
  uPoznamky: Maybe<Scalars['String']>;
  uPrijmeni: Maybe<Scalars['String']>;
  uRodneCislo: Maybe<Scalars['String']>;
  uSkupina: Maybe<Scalars['BigInt']>;
  uStreet: Maybe<Scalars['String']>;
  uSystem: Maybe<Scalars['Boolean']>;
  uTeacher: Maybe<Scalars['Boolean']>;
  uTelefon: Maybe<Scalars['String']>;
  uTimestamp: Maybe<Scalars['Datetime']>;
};

/** A condition to be used against `Member` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type MemberCondition = {
  /** Checks for equality with the object’s `newestPayment` field. */
  newestPayment?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `oldestPayment` field. */
  oldestPayment?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `paymentValid` field. */
  paymentValid?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `sColorRgb` field. */
  sColorRgb?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sColorText` field. */
  sColorText?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sDescription` field. */
  sDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sId` field. */
  sId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `sLocation` field. */
  sLocation?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sName` field. */
  sName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sVisible` field. */
  sVisible?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uBan` field. */
  uBan?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uCity` field. */
  uCity?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uConfirmed` field. */
  uConfirmed?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uConscriptionNumber` field. */
  uConscriptionNumber?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uCreatedAt` field. */
  uCreatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `uDancer` field. */
  uDancer?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uDistrict` field. */
  uDistrict?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uEmail` field. */
  uEmail?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uGdprSignedAt` field. */
  uGdprSignedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `uGroup` field. */
  uGroup?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `uId` field. */
  uId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `uJmeno` field. */
  uJmeno?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uLevel` field. */
  uLevel?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uLock` field. */
  uLock?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uLogin` field. */
  uLogin?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uMemberSince` field. */
  uMemberSince?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `uMemberUntil` field. */
  uMemberUntil?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `uNarozeni` field. */
  uNarozeni?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `uNationality` field. */
  uNationality?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uOrientationNumber` field. */
  uOrientationNumber?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uPass` field. */
  uPass?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uPohlavi` field. */
  uPohlavi?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uPostalCode` field. */
  uPostalCode?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uPoznamky` field. */
  uPoznamky?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uPrijmeni` field. */
  uPrijmeni?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uRodneCislo` field. */
  uRodneCislo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uSkupina` field. */
  uSkupina?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `uStreet` field. */
  uStreet?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uSystem` field. */
  uSystem?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uTeacher` field. */
  uTeacher?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uTelefon` field. */
  uTelefon?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uTimestamp` field. */
  uTimestamp?: InputMaybe<Scalars['Datetime']>;
};

/** A connection to a list of `Member` values. */
export type MembersConnection = {
  __typename?: 'MembersConnection';
  /** A list of edges which contains the `Member` and cursor to aid in pagination. */
  edges: Array<MembersEdge>;
  /** A list of `Member` objects. */
  nodes: Array<Member>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Member` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Member` edge in the connection. */
export type MembersEdge = {
  __typename?: 'MembersEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Member` at the end of the edge. */
  node: Member;
};

/** Methods to use when ordering `Member`. */
export enum MembersOrderBy {
  Natural = 'NATURAL',
  NewestPaymentAsc = 'NEWEST_PAYMENT_ASC',
  NewestPaymentDesc = 'NEWEST_PAYMENT_DESC',
  OldestPaymentAsc = 'OLDEST_PAYMENT_ASC',
  OldestPaymentDesc = 'OLDEST_PAYMENT_DESC',
  PaymentValidAsc = 'PAYMENT_VALID_ASC',
  PaymentValidDesc = 'PAYMENT_VALID_DESC',
  SColorRgbAsc = 'S_COLOR_RGB_ASC',
  SColorRgbDesc = 'S_COLOR_RGB_DESC',
  SColorTextAsc = 'S_COLOR_TEXT_ASC',
  SColorTextDesc = 'S_COLOR_TEXT_DESC',
  SDescriptionAsc = 'S_DESCRIPTION_ASC',
  SDescriptionDesc = 'S_DESCRIPTION_DESC',
  SIdAsc = 'S_ID_ASC',
  SIdDesc = 'S_ID_DESC',
  SLocationAsc = 'S_LOCATION_ASC',
  SLocationDesc = 'S_LOCATION_DESC',
  SNameAsc = 'S_NAME_ASC',
  SNameDesc = 'S_NAME_DESC',
  SVisibleAsc = 'S_VISIBLE_ASC',
  SVisibleDesc = 'S_VISIBLE_DESC',
  UBanAsc = 'U_BAN_ASC',
  UBanDesc = 'U_BAN_DESC',
  UCityAsc = 'U_CITY_ASC',
  UCityDesc = 'U_CITY_DESC',
  UConfirmedAsc = 'U_CONFIRMED_ASC',
  UConfirmedDesc = 'U_CONFIRMED_DESC',
  UConscriptionNumberAsc = 'U_CONSCRIPTION_NUMBER_ASC',
  UConscriptionNumberDesc = 'U_CONSCRIPTION_NUMBER_DESC',
  UCreatedAtAsc = 'U_CREATED_AT_ASC',
  UCreatedAtDesc = 'U_CREATED_AT_DESC',
  UDancerAsc = 'U_DANCER_ASC',
  UDancerDesc = 'U_DANCER_DESC',
  UDistrictAsc = 'U_DISTRICT_ASC',
  UDistrictDesc = 'U_DISTRICT_DESC',
  UEmailAsc = 'U_EMAIL_ASC',
  UEmailDesc = 'U_EMAIL_DESC',
  UGdprSignedAtAsc = 'U_GDPR_SIGNED_AT_ASC',
  UGdprSignedAtDesc = 'U_GDPR_SIGNED_AT_DESC',
  UGroupAsc = 'U_GROUP_ASC',
  UGroupDesc = 'U_GROUP_DESC',
  UIdAsc = 'U_ID_ASC',
  UIdDesc = 'U_ID_DESC',
  UJmenoAsc = 'U_JMENO_ASC',
  UJmenoDesc = 'U_JMENO_DESC',
  ULevelAsc = 'U_LEVEL_ASC',
  ULevelDesc = 'U_LEVEL_DESC',
  ULockAsc = 'U_LOCK_ASC',
  ULockDesc = 'U_LOCK_DESC',
  ULoginAsc = 'U_LOGIN_ASC',
  ULoginDesc = 'U_LOGIN_DESC',
  UMemberSinceAsc = 'U_MEMBER_SINCE_ASC',
  UMemberSinceDesc = 'U_MEMBER_SINCE_DESC',
  UMemberUntilAsc = 'U_MEMBER_UNTIL_ASC',
  UMemberUntilDesc = 'U_MEMBER_UNTIL_DESC',
  UNarozeniAsc = 'U_NAROZENI_ASC',
  UNarozeniDesc = 'U_NAROZENI_DESC',
  UNationalityAsc = 'U_NATIONALITY_ASC',
  UNationalityDesc = 'U_NATIONALITY_DESC',
  UOrientationNumberAsc = 'U_ORIENTATION_NUMBER_ASC',
  UOrientationNumberDesc = 'U_ORIENTATION_NUMBER_DESC',
  UPassAsc = 'U_PASS_ASC',
  UPassDesc = 'U_PASS_DESC',
  UPohlaviAsc = 'U_POHLAVI_ASC',
  UPohlaviDesc = 'U_POHLAVI_DESC',
  UPostalCodeAsc = 'U_POSTAL_CODE_ASC',
  UPostalCodeDesc = 'U_POSTAL_CODE_DESC',
  UPoznamkyAsc = 'U_POZNAMKY_ASC',
  UPoznamkyDesc = 'U_POZNAMKY_DESC',
  UPrijmeniAsc = 'U_PRIJMENI_ASC',
  UPrijmeniDesc = 'U_PRIJMENI_DESC',
  URodneCisloAsc = 'U_RODNE_CISLO_ASC',
  URodneCisloDesc = 'U_RODNE_CISLO_DESC',
  USkupinaAsc = 'U_SKUPINA_ASC',
  USkupinaDesc = 'U_SKUPINA_DESC',
  UStreetAsc = 'U_STREET_ASC',
  UStreetDesc = 'U_STREET_DESC',
  USystemAsc = 'U_SYSTEM_ASC',
  USystemDesc = 'U_SYSTEM_DESC',
  UTeacherAsc = 'U_TEACHER_ASC',
  UTeacherDesc = 'U_TEACHER_DESC',
  UTelefonAsc = 'U_TELEFON_ASC',
  UTelefonDesc = 'U_TELEFON_DESC',
  UTimestampAsc = 'U_TIMESTAMP_ASC',
  UTimestampDesc = 'U_TIMESTAMP_DESC'
}

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  __typename?: 'Mutation';
  bookLesson: Maybe<BookLessonPayload>;
  cancelLesson: Maybe<CancelLessonPayload>;
  cancelParticipation: Maybe<CancelParticipationPayload>;
  changePassword: Maybe<ChangePasswordPayload>;
  confirmUser: Maybe<ConfirmUserPayload>;
  /** Creates a single `Akce`. */
  createAkce: Maybe<CreateAkcePayload>;
  /** Creates a single `AkceItem`. */
  createAkceItem: Maybe<CreateAkceItemPayload>;
  /** Creates a single `Aktuality`. */
  createAktuality: Maybe<CreateAktualityPayload>;
  /** Creates a single `Attachment`. */
  createAttachment: Maybe<CreateAttachmentPayload>;
  /** Creates a single `AttendeeExternal`. */
  createAttendeeExternal: Maybe<CreateAttendeeExternalPayload>;
  /** Creates a single `AttendeeUser`. */
  createAttendeeUser: Maybe<CreateAttendeeUserPayload>;
  /** Creates a single `CohortGroup`. */
  createCohortGroup: Maybe<CreateCohortGroupPayload>;
  createCouple: Maybe<CreateCouplePayload>;
  /** Creates a single `Dokumenty`. */
  createDokumenty: Maybe<CreateDokumentyPayload>;
  /** Creates a single `Event`. */
  createEvent: Maybe<CreateEventPayload>;
  /** Creates a single `GalerieDir`. */
  createGalerieDir: Maybe<CreateGalerieDirPayload>;
  /** Creates a single `GalerieFoto`. */
  createGalerieFoto: Maybe<CreateGalerieFotoPayload>;
  /** Creates a single `Location`. */
  createLocation: Maybe<CreateLocationPayload>;
  /** Creates a single `LocationAttachment`. */
  createLocationAttachment: Maybe<CreateLocationAttachmentPayload>;
  /** Creates a single `Nabidka`. */
  createNabidka: Maybe<CreateNabidkaPayload>;
  /** Creates a single `NabidkaItem`. */
  createNabidkaItem: Maybe<CreateNabidkaItemPayload>;
  /** Creates a single `Page`. */
  createPage: Maybe<CreatePagePayload>;
  /** Creates a single `Parameter`. */
  createParameter: Maybe<CreateParameterPayload>;
  createParticipation: Maybe<CreateParticipationPayload>;
  /** Creates a single `Pary`. */
  createPary: Maybe<CreateParyPayload>;
  /** Creates a single `ParyNavrh`. */
  createParyNavrh: Maybe<CreateParyNavrhPayload>;
  /** Creates a single `Permission`. */
  createPermission: Maybe<CreatePermissionPayload>;
  /** Creates a single `Person`. */
  createPerson: Maybe<CreatePersonPayload>;
  /** Creates a single `PlatbyCategory`. */
  createPlatbyCategory: Maybe<CreatePlatbyCategoryPayload>;
  /** Creates a single `PlatbyCategoryGroup`. */
  createPlatbyCategoryGroup: Maybe<CreatePlatbyCategoryGroupPayload>;
  /** Creates a single `PlatbyGroup`. */
  createPlatbyGroup: Maybe<CreatePlatbyGroupPayload>;
  /** Creates a single `PlatbyGroupSkupina`. */
  createPlatbyGroupSkupina: Maybe<CreatePlatbyGroupSkupinaPayload>;
  /** Creates a single `PlatbyItem`. */
  createPlatbyItem: Maybe<CreatePlatbyItemPayload>;
  /** Creates a single `PlatbyRaw`. */
  createPlatbyRaw: Maybe<CreatePlatbyRawPayload>;
  /** Creates a single `Room`. */
  createRoom: Maybe<CreateRoomPayload>;
  /** Creates a single `RoomAttachment`. */
  createRoomAttachment: Maybe<CreateRoomAttachmentPayload>;
  /** Creates a single `Rozpi`. */
  createRozpi: Maybe<CreateRozpiPayload>;
  /** Creates a single `RozpisItem`. */
  createRozpisItem: Maybe<CreateRozpisItemPayload>;
  /** Creates a single `Session`. */
  createSession: Maybe<CreateSessionPayload>;
  /** Creates a single `Skupiny`. */
  createSkupiny: Maybe<CreateSkupinyPayload>;
  /** Creates a single `Tenant`. */
  createTenant: Maybe<CreateTenantPayload>;
  /** Creates a single `TenantAttachment`. */
  createTenantAttachment: Maybe<CreateTenantAttachmentPayload>;
  /** Creates a single `TenantPerson`. */
  createTenantPerson: Maybe<CreateTenantPersonPayload>;
  /** Creates a single `Upozorneni`. */
  createUpozorneni: Maybe<CreateUpozorneniPayload>;
  /** Creates a single `UpozorneniSkupiny`. */
  createUpozorneniSkupiny: Maybe<CreateUpozorneniSkupinyPayload>;
  /** Creates a single `User`. */
  createUser: Maybe<CreateUserPayload>;
  /** Creates a single `Video`. */
  createVideo: Maybe<CreateVideoPayload>;
  /** Creates a single `VideoList`. */
  createVideoList: Maybe<CreateVideoListPayload>;
  /** Creates a single `VideoSource`. */
  createVideoSource: Maybe<CreateVideoSourcePayload>;
  /** Deletes a single `Aktuality` using a unique key. */
  deleteAktuality: Maybe<DeleteAktualityPayload>;
  /** Deletes a single `Aktuality` using its globally unique id. */
  deleteAktualityByNodeId: Maybe<DeleteAktualityPayload>;
  /** Deletes a single `Attachment` using a unique key. */
  deleteAttachment: Maybe<DeleteAttachmentPayload>;
  /** Deletes a single `Attachment` using its globally unique id. */
  deleteAttachmentByNodeId: Maybe<DeleteAttachmentPayload>;
  /** Deletes a single `AttendeeExternal` using a unique key. */
  deleteAttendeeExternal: Maybe<DeleteAttendeeExternalPayload>;
  /** Deletes a single `AttendeeExternal` using its globally unique id. */
  deleteAttendeeExternalByNodeId: Maybe<DeleteAttendeeExternalPayload>;
  /** Deletes a single `AttendeeUser` using a unique key. */
  deleteAttendeeUser: Maybe<DeleteAttendeeUserPayload>;
  /** Deletes a single `AttendeeUser` using its globally unique id. */
  deleteAttendeeUserByNodeId: Maybe<DeleteAttendeeUserPayload>;
  /** Deletes a single `AttendeeUser` using a unique key. */
  deleteAttendeeUserByUserIdAndEventId: Maybe<DeleteAttendeeUserPayload>;
  /** Deletes a single `CohortGroup` using a unique key. */
  deleteCohortGroup: Maybe<DeleteCohortGroupPayload>;
  /** Deletes a single `CohortGroup` using its globally unique id. */
  deleteCohortGroupByNodeId: Maybe<DeleteCohortGroupPayload>;
  /** Deletes a single `Dokumenty` using a unique key. */
  deleteDokumenty: Maybe<DeleteDokumentyPayload>;
  /** Deletes a single `Dokumenty` using its globally unique id. */
  deleteDokumentyByNodeId: Maybe<DeleteDokumentyPayload>;
  /** Deletes a single `Event` using a unique key. */
  deleteEvent: Maybe<DeleteEventPayload>;
  /** Deletes a single `Event` using its globally unique id. */
  deleteEventByNodeId: Maybe<DeleteEventPayload>;
  /** Deletes a single `GalerieDir` using a unique key. */
  deleteGalerieDir: Maybe<DeleteGalerieDirPayload>;
  /** Deletes a single `GalerieDir` using its globally unique id. */
  deleteGalerieDirByNodeId: Maybe<DeleteGalerieDirPayload>;
  /** Deletes a single `GalerieFoto` using a unique key. */
  deleteGalerieFoto: Maybe<DeleteGalerieFotoPayload>;
  /** Deletes a single `GalerieFoto` using its globally unique id. */
  deleteGalerieFotoByNodeId: Maybe<DeleteGalerieFotoPayload>;
  /** Deletes a single `Location` using a unique key. */
  deleteLocation: Maybe<DeleteLocationPayload>;
  /** Deletes a single `LocationAttachment` using a unique key. */
  deleteLocationAttachment: Maybe<DeleteLocationAttachmentPayload>;
  /** Deletes a single `LocationAttachment` using its globally unique id. */
  deleteLocationAttachmentByNodeId: Maybe<DeleteLocationAttachmentPayload>;
  /** Deletes a single `Location` using its globally unique id. */
  deleteLocationByNodeId: Maybe<DeleteLocationPayload>;
  /** Deletes a single `Nabidka` using a unique key. */
  deleteNabidka: Maybe<DeleteNabidkaPayload>;
  /** Deletes a single `Nabidka` using its globally unique id. */
  deleteNabidkaByNodeId: Maybe<DeleteNabidkaPayload>;
  /** Deletes a single `NabidkaItem` using a unique key. */
  deleteNabidkaItem: Maybe<DeleteNabidkaItemPayload>;
  /** Deletes a single `NabidkaItem` using a unique key. */
  deleteNabidkaItemByNiPartnerAndNiIdRodic: Maybe<DeleteNabidkaItemPayload>;
  /** Deletes a single `NabidkaItem` using its globally unique id. */
  deleteNabidkaItemByNodeId: Maybe<DeleteNabidkaItemPayload>;
  /** Deletes a single `Parameter` using a unique key. */
  deleteParameter: Maybe<DeleteParameterPayload>;
  /** Deletes a single `Parameter` using its globally unique id. */
  deleteParameterByNodeId: Maybe<DeleteParameterPayload>;
  /** Deletes a single `Pary` using a unique key. */
  deletePary: Maybe<DeleteParyPayload>;
  /** Deletes a single `Pary` using its globally unique id. */
  deleteParyByNodeId: Maybe<DeleteParyPayload>;
  /** Deletes a single `ParyNavrh` using a unique key. */
  deleteParyNavrh: Maybe<DeleteParyNavrhPayload>;
  /** Deletes a single `ParyNavrh` using its globally unique id. */
  deleteParyNavrhByNodeId: Maybe<DeleteParyNavrhPayload>;
  /** Deletes a single `Permission` using a unique key. */
  deletePermission: Maybe<DeletePermissionPayload>;
  /** Deletes a single `Permission` using its globally unique id. */
  deletePermissionByNodeId: Maybe<DeletePermissionPayload>;
  /** Deletes a single `Person` using a unique key. */
  deletePerson: Maybe<DeletePersonPayload>;
  /** Deletes a single `Person` using its globally unique id. */
  deletePersonByNodeId: Maybe<DeletePersonPayload>;
  /** Deletes a single `PlatbyCategory` using a unique key. */
  deletePlatbyCategory: Maybe<DeletePlatbyCategoryPayload>;
  /** Deletes a single `PlatbyCategory` using its globally unique id. */
  deletePlatbyCategoryByNodeId: Maybe<DeletePlatbyCategoryPayload>;
  /** Deletes a single `PlatbyCategoryGroup` using a unique key. */
  deletePlatbyCategoryGroup: Maybe<DeletePlatbyCategoryGroupPayload>;
  /** Deletes a single `PlatbyCategoryGroup` using its globally unique id. */
  deletePlatbyCategoryGroupByNodeId: Maybe<DeletePlatbyCategoryGroupPayload>;
  /** Deletes a single `PlatbyGroup` using a unique key. */
  deletePlatbyGroup: Maybe<DeletePlatbyGroupPayload>;
  /** Deletes a single `PlatbyGroup` using its globally unique id. */
  deletePlatbyGroupByNodeId: Maybe<DeletePlatbyGroupPayload>;
  /** Deletes a single `PlatbyGroupSkupina` using a unique key. */
  deletePlatbyGroupSkupina: Maybe<DeletePlatbyGroupSkupinaPayload>;
  /** Deletes a single `PlatbyGroupSkupina` using its globally unique id. */
  deletePlatbyGroupSkupinaByNodeId: Maybe<DeletePlatbyGroupSkupinaPayload>;
  /** Deletes a single `PlatbyItem` using a unique key. */
  deletePlatbyItem: Maybe<DeletePlatbyItemPayload>;
  /** Deletes a single `PlatbyItem` using its globally unique id. */
  deletePlatbyItemByNodeId: Maybe<DeletePlatbyItemPayload>;
  /** Deletes a single `PlatbyRaw` using a unique key. */
  deletePlatbyRaw: Maybe<DeletePlatbyRawPayload>;
  /** Deletes a single `PlatbyRaw` using its globally unique id. */
  deletePlatbyRawByNodeId: Maybe<DeletePlatbyRawPayload>;
  /** Deletes a single `Room` using a unique key. */
  deleteRoom: Maybe<DeleteRoomPayload>;
  /** Deletes a single `RoomAttachment` using a unique key. */
  deleteRoomAttachment: Maybe<DeleteRoomAttachmentPayload>;
  /** Deletes a single `RoomAttachment` using its globally unique id. */
  deleteRoomAttachmentByNodeId: Maybe<DeleteRoomAttachmentPayload>;
  /** Deletes a single `Room` using its globally unique id. */
  deleteRoomByNodeId: Maybe<DeleteRoomPayload>;
  /** Deletes a single `Rozpi` using a unique key. */
  deleteRozpi: Maybe<DeleteRozpiPayload>;
  /** Deletes a single `Rozpi` using its globally unique id. */
  deleteRozpiByNodeId: Maybe<DeleteRozpiPayload>;
  /** Deletes a single `RozpisItem` using a unique key. */
  deleteRozpisItem: Maybe<DeleteRozpisItemPayload>;
  /** Deletes a single `RozpisItem` using its globally unique id. */
  deleteRozpisItemByNodeId: Maybe<DeleteRozpisItemPayload>;
  /** Deletes a single `Session` using a unique key. */
  deleteSession: Maybe<DeleteSessionPayload>;
  /** Deletes a single `Session` using its globally unique id. */
  deleteSessionByNodeId: Maybe<DeleteSessionPayload>;
  /** Deletes a single `Skupiny` using a unique key. */
  deleteSkupiny: Maybe<DeleteSkupinyPayload>;
  /** Deletes a single `Skupiny` using its globally unique id. */
  deleteSkupinyByNodeId: Maybe<DeleteSkupinyPayload>;
  /** Deletes a single `Tenant` using a unique key. */
  deleteTenant: Maybe<DeleteTenantPayload>;
  /** Deletes a single `TenantAttachment` using a unique key. */
  deleteTenantAttachment: Maybe<DeleteTenantAttachmentPayload>;
  /** Deletes a single `TenantAttachment` using its globally unique id. */
  deleteTenantAttachmentByNodeId: Maybe<DeleteTenantAttachmentPayload>;
  /** Deletes a single `Tenant` using its globally unique id. */
  deleteTenantByNodeId: Maybe<DeleteTenantPayload>;
  /** Deletes a single `TenantPerson` using a unique key. */
  deleteTenantPerson: Maybe<DeleteTenantPersonPayload>;
  /** Deletes a single `TenantPerson` using its globally unique id. */
  deleteTenantPersonByNodeId: Maybe<DeleteTenantPersonPayload>;
  /** Deletes a single `Upozorneni` using a unique key. */
  deleteUpozorneni: Maybe<DeleteUpozorneniPayload>;
  /** Deletes a single `Upozorneni` using its globally unique id. */
  deleteUpozorneniByNodeId: Maybe<DeleteUpozorneniPayload>;
  /** Deletes a single `UpozorneniSkupiny` using a unique key. */
  deleteUpozorneniSkupiny: Maybe<DeleteUpozorneniSkupinyPayload>;
  /** Deletes a single `UpozorneniSkupiny` using its globally unique id. */
  deleteUpozorneniSkupinyByNodeId: Maybe<DeleteUpozorneniSkupinyPayload>;
  /** Deletes a single `User` using a unique key. */
  deleteUser: Maybe<DeleteUserPayload>;
  /** Deletes a single `User` using its globally unique id. */
  deleteUserByNodeId: Maybe<DeleteUserPayload>;
  /** Deletes a single `Video` using a unique key. */
  deleteVideo: Maybe<DeleteVideoPayload>;
  /** Deletes a single `Video` using its globally unique id. */
  deleteVideoByNodeId: Maybe<DeleteVideoPayload>;
  /** Deletes a single `VideoList` using a unique key. */
  deleteVideoList: Maybe<DeleteVideoListPayload>;
  /** Deletes a single `VideoList` using its globally unique id. */
  deleteVideoListByNodeId: Maybe<DeleteVideoListPayload>;
  /** Deletes a single `VideoSource` using a unique key. */
  deleteVideoSource: Maybe<DeleteVideoSourcePayload>;
  /** Deletes a single `VideoSource` using its globally unique id. */
  deleteVideoSourceByNodeId: Maybe<DeleteVideoSourcePayload>;
  downloadFile: Scalars['String'];
  fixUnpairedCouples: Maybe<FixUnpairedCouplesPayload>;
  login: Maybe<LoginPayload>;
  logout: Maybe<LogoutPayload>;
  prospectFormDancer: Maybe<ProspectFormDancerPayload>;
  reservationSetDesiredLessons: Maybe<ReservationSetDesiredLessonsPayload>;
  resetPassword: Maybe<ResetPasswordPayload>;
  /** Updates a single `Aktuality` using a unique key and a patch. */
  updateAktuality: Maybe<UpdateAktualityPayload>;
  /** Updates a single `Aktuality` using its globally unique id and a patch. */
  updateAktualityByNodeId: Maybe<UpdateAktualityPayload>;
  /** Updates a single `Attachment` using a unique key and a patch. */
  updateAttachment: Maybe<UpdateAttachmentPayload>;
  /** Updates a single `Attachment` using its globally unique id and a patch. */
  updateAttachmentByNodeId: Maybe<UpdateAttachmentPayload>;
  /** Updates a single `AttendeeExternal` using a unique key and a patch. */
  updateAttendeeExternal: Maybe<UpdateAttendeeExternalPayload>;
  /** Updates a single `AttendeeExternal` using its globally unique id and a patch. */
  updateAttendeeExternalByNodeId: Maybe<UpdateAttendeeExternalPayload>;
  /** Updates a single `AttendeeUser` using a unique key and a patch. */
  updateAttendeeUser: Maybe<UpdateAttendeeUserPayload>;
  /** Updates a single `AttendeeUser` using its globally unique id and a patch. */
  updateAttendeeUserByNodeId: Maybe<UpdateAttendeeUserPayload>;
  /** Updates a single `AttendeeUser` using a unique key and a patch. */
  updateAttendeeUserByUserIdAndEventId: Maybe<UpdateAttendeeUserPayload>;
  /** Updates a single `CohortGroup` using a unique key and a patch. */
  updateCohortGroup: Maybe<UpdateCohortGroupPayload>;
  /** Updates a single `CohortGroup` using its globally unique id and a patch. */
  updateCohortGroupByNodeId: Maybe<UpdateCohortGroupPayload>;
  /** Updates a single `Dokumenty` using a unique key and a patch. */
  updateDokumenty: Maybe<UpdateDokumentyPayload>;
  /** Updates a single `Dokumenty` using its globally unique id and a patch. */
  updateDokumentyByNodeId: Maybe<UpdateDokumentyPayload>;
  /** Updates a single `Event` using a unique key and a patch. */
  updateEvent: Maybe<UpdateEventPayload>;
  /** Updates a single `Event` using its globally unique id and a patch. */
  updateEventByNodeId: Maybe<UpdateEventPayload>;
  /** Updates a single `GalerieDir` using a unique key and a patch. */
  updateGalerieDir: Maybe<UpdateGalerieDirPayload>;
  /** Updates a single `GalerieDir` using its globally unique id and a patch. */
  updateGalerieDirByNodeId: Maybe<UpdateGalerieDirPayload>;
  /** Updates a single `GalerieFoto` using a unique key and a patch. */
  updateGalerieFoto: Maybe<UpdateGalerieFotoPayload>;
  /** Updates a single `GalerieFoto` using its globally unique id and a patch. */
  updateGalerieFotoByNodeId: Maybe<UpdateGalerieFotoPayload>;
  /** Updates a single `Location` using a unique key and a patch. */
  updateLocation: Maybe<UpdateLocationPayload>;
  /** Updates a single `LocationAttachment` using a unique key and a patch. */
  updateLocationAttachment: Maybe<UpdateLocationAttachmentPayload>;
  /** Updates a single `LocationAttachment` using its globally unique id and a patch. */
  updateLocationAttachmentByNodeId: Maybe<UpdateLocationAttachmentPayload>;
  /** Updates a single `Location` using its globally unique id and a patch. */
  updateLocationByNodeId: Maybe<UpdateLocationPayload>;
  /** Updates a single `Nabidka` using a unique key and a patch. */
  updateNabidka: Maybe<UpdateNabidkaPayload>;
  /** Updates a single `Nabidka` using its globally unique id and a patch. */
  updateNabidkaByNodeId: Maybe<UpdateNabidkaPayload>;
  /** Updates a single `NabidkaItem` using a unique key and a patch. */
  updateNabidkaItem: Maybe<UpdateNabidkaItemPayload>;
  /** Updates a single `NabidkaItem` using a unique key and a patch. */
  updateNabidkaItemByNiPartnerAndNiIdRodic: Maybe<UpdateNabidkaItemPayload>;
  /** Updates a single `NabidkaItem` using its globally unique id and a patch. */
  updateNabidkaItemByNodeId: Maybe<UpdateNabidkaItemPayload>;
  /** Updates a single `Page` using a unique key and a patch. */
  updatePage: Maybe<UpdatePagePayload>;
  /** Updates a single `Page` using its globally unique id and a patch. */
  updatePageByNodeId: Maybe<UpdatePagePayload>;
  /** Updates a single `Page` using a unique key and a patch. */
  updatePageByUrl: Maybe<UpdatePagePayload>;
  /** Updates a single `Parameter` using a unique key and a patch. */
  updateParameter: Maybe<UpdateParameterPayload>;
  /** Updates a single `Parameter` using its globally unique id and a patch. */
  updateParameterByNodeId: Maybe<UpdateParameterPayload>;
  /** Updates a single `Pary` using a unique key and a patch. */
  updatePary: Maybe<UpdateParyPayload>;
  /** Updates a single `Pary` using its globally unique id and a patch. */
  updateParyByNodeId: Maybe<UpdateParyPayload>;
  /** Updates a single `ParyNavrh` using a unique key and a patch. */
  updateParyNavrh: Maybe<UpdateParyNavrhPayload>;
  /** Updates a single `ParyNavrh` using its globally unique id and a patch. */
  updateParyNavrhByNodeId: Maybe<UpdateParyNavrhPayload>;
  /** Updates a single `Permission` using a unique key and a patch. */
  updatePermission: Maybe<UpdatePermissionPayload>;
  /** Updates a single `Permission` using its globally unique id and a patch. */
  updatePermissionByNodeId: Maybe<UpdatePermissionPayload>;
  /** Updates a single `Person` using a unique key and a patch. */
  updatePerson: Maybe<UpdatePersonPayload>;
  /** Updates a single `Person` using its globally unique id and a patch. */
  updatePersonByNodeId: Maybe<UpdatePersonPayload>;
  /** Updates a single `PlatbyCategory` using a unique key and a patch. */
  updatePlatbyCategory: Maybe<UpdatePlatbyCategoryPayload>;
  /** Updates a single `PlatbyCategory` using its globally unique id and a patch. */
  updatePlatbyCategoryByNodeId: Maybe<UpdatePlatbyCategoryPayload>;
  /** Updates a single `PlatbyCategoryGroup` using a unique key and a patch. */
  updatePlatbyCategoryGroup: Maybe<UpdatePlatbyCategoryGroupPayload>;
  /** Updates a single `PlatbyCategoryGroup` using its globally unique id and a patch. */
  updatePlatbyCategoryGroupByNodeId: Maybe<UpdatePlatbyCategoryGroupPayload>;
  /** Updates a single `PlatbyGroup` using a unique key and a patch. */
  updatePlatbyGroup: Maybe<UpdatePlatbyGroupPayload>;
  /** Updates a single `PlatbyGroup` using its globally unique id and a patch. */
  updatePlatbyGroupByNodeId: Maybe<UpdatePlatbyGroupPayload>;
  /** Updates a single `PlatbyGroupSkupina` using a unique key and a patch. */
  updatePlatbyGroupSkupina: Maybe<UpdatePlatbyGroupSkupinaPayload>;
  /** Updates a single `PlatbyGroupSkupina` using its globally unique id and a patch. */
  updatePlatbyGroupSkupinaByNodeId: Maybe<UpdatePlatbyGroupSkupinaPayload>;
  /** Updates a single `PlatbyItem` using a unique key and a patch. */
  updatePlatbyItem: Maybe<UpdatePlatbyItemPayload>;
  /** Updates a single `PlatbyItem` using its globally unique id and a patch. */
  updatePlatbyItemByNodeId: Maybe<UpdatePlatbyItemPayload>;
  /** Updates a single `PlatbyRaw` using a unique key and a patch. */
  updatePlatbyRaw: Maybe<UpdatePlatbyRawPayload>;
  /** Updates a single `PlatbyRaw` using its globally unique id and a patch. */
  updatePlatbyRawByNodeId: Maybe<UpdatePlatbyRawPayload>;
  /** Updates a single `Room` using a unique key and a patch. */
  updateRoom: Maybe<UpdateRoomPayload>;
  /** Updates a single `RoomAttachment` using a unique key and a patch. */
  updateRoomAttachment: Maybe<UpdateRoomAttachmentPayload>;
  /** Updates a single `RoomAttachment` using its globally unique id and a patch. */
  updateRoomAttachmentByNodeId: Maybe<UpdateRoomAttachmentPayload>;
  /** Updates a single `Room` using its globally unique id and a patch. */
  updateRoomByNodeId: Maybe<UpdateRoomPayload>;
  /** Updates a single `Rozpi` using a unique key and a patch. */
  updateRozpi: Maybe<UpdateRozpiPayload>;
  /** Updates a single `Rozpi` using its globally unique id and a patch. */
  updateRozpiByNodeId: Maybe<UpdateRozpiPayload>;
  /** Updates a single `RozpisItem` using a unique key and a patch. */
  updateRozpisItem: Maybe<UpdateRozpisItemPayload>;
  /** Updates a single `RozpisItem` using its globally unique id and a patch. */
  updateRozpisItemByNodeId: Maybe<UpdateRozpisItemPayload>;
  /** Updates a single `Session` using a unique key and a patch. */
  updateSession: Maybe<UpdateSessionPayload>;
  /** Updates a single `Session` using its globally unique id and a patch. */
  updateSessionByNodeId: Maybe<UpdateSessionPayload>;
  /** Updates a single `Skupiny` using a unique key and a patch. */
  updateSkupiny: Maybe<UpdateSkupinyPayload>;
  /** Updates a single `Skupiny` using its globally unique id and a patch. */
  updateSkupinyByNodeId: Maybe<UpdateSkupinyPayload>;
  /** Updates a single `Tenant` using a unique key and a patch. */
  updateTenant: Maybe<UpdateTenantPayload>;
  /** Updates a single `TenantAttachment` using a unique key and a patch. */
  updateTenantAttachment: Maybe<UpdateTenantAttachmentPayload>;
  /** Updates a single `TenantAttachment` using its globally unique id and a patch. */
  updateTenantAttachmentByNodeId: Maybe<UpdateTenantAttachmentPayload>;
  /** Updates a single `Tenant` using its globally unique id and a patch. */
  updateTenantByNodeId: Maybe<UpdateTenantPayload>;
  /** Updates a single `TenantPerson` using a unique key and a patch. */
  updateTenantPerson: Maybe<UpdateTenantPersonPayload>;
  /** Updates a single `TenantPerson` using its globally unique id and a patch. */
  updateTenantPersonByNodeId: Maybe<UpdateTenantPersonPayload>;
  /** Updates a single `Upozorneni` using a unique key and a patch. */
  updateUpozorneni: Maybe<UpdateUpozorneniPayload>;
  /** Updates a single `Upozorneni` using its globally unique id and a patch. */
  updateUpozorneniByNodeId: Maybe<UpdateUpozorneniPayload>;
  /** Updates a single `UpozorneniSkupiny` using a unique key and a patch. */
  updateUpozorneniSkupiny: Maybe<UpdateUpozorneniSkupinyPayload>;
  /** Updates a single `UpozorneniSkupiny` using its globally unique id and a patch. */
  updateUpozorneniSkupinyByNodeId: Maybe<UpdateUpozorneniSkupinyPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUser: Maybe<UpdateUserPayload>;
  /** Updates a single `User` using its globally unique id and a patch. */
  updateUserByNodeId: Maybe<UpdateUserPayload>;
  /** Updates a single `Video` using a unique key and a patch. */
  updateVideo: Maybe<UpdateVideoPayload>;
  /** Updates a single `Video` using its globally unique id and a patch. */
  updateVideoByNodeId: Maybe<UpdateVideoPayload>;
  /** Updates a single `VideoList` using a unique key and a patch. */
  updateVideoList: Maybe<UpdateVideoListPayload>;
  /** Updates a single `VideoList` using its globally unique id and a patch. */
  updateVideoListByNodeId: Maybe<UpdateVideoListPayload>;
  /** Updates a single `VideoSource` using a unique key and a patch. */
  updateVideoSource: Maybe<UpdateVideoSourcePayload>;
  /** Updates a single `VideoSource` using its globally unique id and a patch. */
  updateVideoSourceByNodeId: Maybe<UpdateVideoSourcePayload>;
  uploadFile: UploadFilePayload;
  verifyFunction: Maybe<VerifyFunctionPayload>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBookLessonArgs = {
  input: BookLessonInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCancelLessonArgs = {
  input: CancelLessonInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCancelParticipationArgs = {
  input: CancelParticipationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationChangePasswordArgs = {
  input: ChangePasswordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationConfirmUserArgs = {
  input: ConfirmUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAkceArgs = {
  input: CreateAkceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAkceItemArgs = {
  input: CreateAkceItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAktualityArgs = {
  input: CreateAktualityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAttachmentArgs = {
  input: CreateAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAttendeeExternalArgs = {
  input: CreateAttendeeExternalInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAttendeeUserArgs = {
  input: CreateAttendeeUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCohortGroupArgs = {
  input: CreateCohortGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCoupleArgs = {
  input: CreateCoupleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDokumentyArgs = {
  input: CreateDokumentyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEventArgs = {
  input: CreateEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGalerieDirArgs = {
  input: CreateGalerieDirInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGalerieFotoArgs = {
  input: CreateGalerieFotoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLocationArgs = {
  input: CreateLocationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLocationAttachmentArgs = {
  input: CreateLocationAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateNabidkaArgs = {
  input: CreateNabidkaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateNabidkaItemArgs = {
  input: CreateNabidkaItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePageArgs = {
  input: CreatePageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateParameterArgs = {
  input: CreateParameterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateParticipationArgs = {
  input: CreateParticipationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateParyArgs = {
  input: CreateParyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateParyNavrhArgs = {
  input: CreateParyNavrhInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePermissionArgs = {
  input: CreatePermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePersonArgs = {
  input: CreatePersonInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlatbyCategoryArgs = {
  input: CreatePlatbyCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlatbyCategoryGroupArgs = {
  input: CreatePlatbyCategoryGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlatbyGroupArgs = {
  input: CreatePlatbyGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlatbyGroupSkupinaArgs = {
  input: CreatePlatbyGroupSkupinaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlatbyItemArgs = {
  input: CreatePlatbyItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlatbyRawArgs = {
  input: CreatePlatbyRawInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRoomArgs = {
  input: CreateRoomInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRoomAttachmentArgs = {
  input: CreateRoomAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRozpiArgs = {
  input: CreateRozpiInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRozpisItemArgs = {
  input: CreateRozpisItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSessionArgs = {
  input: CreateSessionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSkupinyArgs = {
  input: CreateSkupinyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTenantArgs = {
  input: CreateTenantInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTenantAttachmentArgs = {
  input: CreateTenantAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTenantPersonArgs = {
  input: CreateTenantPersonInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUpozorneniArgs = {
  input: CreateUpozorneniInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUpozorneniSkupinyArgs = {
  input: CreateUpozorneniSkupinyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserArgs = {
  input: CreateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVideoArgs = {
  input: CreateVideoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVideoListArgs = {
  input: CreateVideoListInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVideoSourceArgs = {
  input: CreateVideoSourceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAktualityArgs = {
  input: DeleteAktualityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAktualityByNodeIdArgs = {
  input: DeleteAktualityByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAttachmentArgs = {
  input: DeleteAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAttachmentByNodeIdArgs = {
  input: DeleteAttachmentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAttendeeExternalArgs = {
  input: DeleteAttendeeExternalInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAttendeeExternalByNodeIdArgs = {
  input: DeleteAttendeeExternalByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAttendeeUserArgs = {
  input: DeleteAttendeeUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAttendeeUserByNodeIdArgs = {
  input: DeleteAttendeeUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAttendeeUserByUserIdAndEventIdArgs = {
  input: DeleteAttendeeUserByUserIdAndEventIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCohortGroupArgs = {
  input: DeleteCohortGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCohortGroupByNodeIdArgs = {
  input: DeleteCohortGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDokumentyArgs = {
  input: DeleteDokumentyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDokumentyByNodeIdArgs = {
  input: DeleteDokumentyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEventArgs = {
  input: DeleteEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEventByNodeIdArgs = {
  input: DeleteEventByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGalerieDirArgs = {
  input: DeleteGalerieDirInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGalerieDirByNodeIdArgs = {
  input: DeleteGalerieDirByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGalerieFotoArgs = {
  input: DeleteGalerieFotoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGalerieFotoByNodeIdArgs = {
  input: DeleteGalerieFotoByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLocationArgs = {
  input: DeleteLocationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLocationAttachmentArgs = {
  input: DeleteLocationAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLocationAttachmentByNodeIdArgs = {
  input: DeleteLocationAttachmentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLocationByNodeIdArgs = {
  input: DeleteLocationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNabidkaArgs = {
  input: DeleteNabidkaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNabidkaByNodeIdArgs = {
  input: DeleteNabidkaByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNabidkaItemArgs = {
  input: DeleteNabidkaItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNabidkaItemByNiPartnerAndNiIdRodicArgs = {
  input: DeleteNabidkaItemByNiPartnerAndNiIdRodicInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNabidkaItemByNodeIdArgs = {
  input: DeleteNabidkaItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteParameterArgs = {
  input: DeleteParameterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteParameterByNodeIdArgs = {
  input: DeleteParameterByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteParyArgs = {
  input: DeleteParyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteParyByNodeIdArgs = {
  input: DeleteParyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteParyNavrhArgs = {
  input: DeleteParyNavrhInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteParyNavrhByNodeIdArgs = {
  input: DeleteParyNavrhByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePermissionArgs = {
  input: DeletePermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePermissionByNodeIdArgs = {
  input: DeletePermissionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePersonArgs = {
  input: DeletePersonInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePersonByNodeIdArgs = {
  input: DeletePersonByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyCategoryArgs = {
  input: DeletePlatbyCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyCategoryByNodeIdArgs = {
  input: DeletePlatbyCategoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyCategoryGroupArgs = {
  input: DeletePlatbyCategoryGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyCategoryGroupByNodeIdArgs = {
  input: DeletePlatbyCategoryGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyGroupArgs = {
  input: DeletePlatbyGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyGroupByNodeIdArgs = {
  input: DeletePlatbyGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyGroupSkupinaArgs = {
  input: DeletePlatbyGroupSkupinaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyGroupSkupinaByNodeIdArgs = {
  input: DeletePlatbyGroupSkupinaByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyItemArgs = {
  input: DeletePlatbyItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyItemByNodeIdArgs = {
  input: DeletePlatbyItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyRawArgs = {
  input: DeletePlatbyRawInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyRawByNodeIdArgs = {
  input: DeletePlatbyRawByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoomArgs = {
  input: DeleteRoomInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoomAttachmentArgs = {
  input: DeleteRoomAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoomAttachmentByNodeIdArgs = {
  input: DeleteRoomAttachmentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoomByNodeIdArgs = {
  input: DeleteRoomByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRozpiArgs = {
  input: DeleteRozpiInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRozpiByNodeIdArgs = {
  input: DeleteRozpiByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRozpisItemArgs = {
  input: DeleteRozpisItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRozpisItemByNodeIdArgs = {
  input: DeleteRozpisItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSessionArgs = {
  input: DeleteSessionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSessionByNodeIdArgs = {
  input: DeleteSessionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSkupinyArgs = {
  input: DeleteSkupinyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSkupinyByNodeIdArgs = {
  input: DeleteSkupinyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTenantArgs = {
  input: DeleteTenantInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTenantAttachmentArgs = {
  input: DeleteTenantAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTenantAttachmentByNodeIdArgs = {
  input: DeleteTenantAttachmentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTenantByNodeIdArgs = {
  input: DeleteTenantByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTenantPersonArgs = {
  input: DeleteTenantPersonInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTenantPersonByNodeIdArgs = {
  input: DeleteTenantPersonByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUpozorneniArgs = {
  input: DeleteUpozorneniInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUpozorneniByNodeIdArgs = {
  input: DeleteUpozorneniByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUpozorneniSkupinyArgs = {
  input: DeleteUpozorneniSkupinyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUpozorneniSkupinyByNodeIdArgs = {
  input: DeleteUpozorneniSkupinyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserArgs = {
  input: DeleteUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserByNodeIdArgs = {
  input: DeleteUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVideoArgs = {
  input: DeleteVideoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVideoByNodeIdArgs = {
  input: DeleteVideoByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVideoListArgs = {
  input: DeleteVideoListInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVideoListByNodeIdArgs = {
  input: DeleteVideoListByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVideoSourceArgs = {
  input: DeleteVideoSourceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVideoSourceByNodeIdArgs = {
  input: DeleteVideoSourceByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDownloadFileArgs = {
  id: Scalars['Int'];
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationFixUnpairedCouplesArgs = {
  input: FixUnpairedCouplesInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationLoginArgs = {
  input: LoginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationLogoutArgs = {
  input: LogoutInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationProspectFormDancerArgs = {
  input: ProspectFormDancerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationReservationSetDesiredLessonsArgs = {
  input: ReservationSetDesiredLessonsInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationResetPasswordArgs = {
  input: ResetPasswordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAktualityArgs = {
  input: UpdateAktualityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAktualityByNodeIdArgs = {
  input: UpdateAktualityByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAttachmentArgs = {
  input: UpdateAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAttachmentByNodeIdArgs = {
  input: UpdateAttachmentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAttendeeExternalArgs = {
  input: UpdateAttendeeExternalInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAttendeeExternalByNodeIdArgs = {
  input: UpdateAttendeeExternalByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAttendeeUserArgs = {
  input: UpdateAttendeeUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAttendeeUserByNodeIdArgs = {
  input: UpdateAttendeeUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAttendeeUserByUserIdAndEventIdArgs = {
  input: UpdateAttendeeUserByUserIdAndEventIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCohortGroupArgs = {
  input: UpdateCohortGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCohortGroupByNodeIdArgs = {
  input: UpdateCohortGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDokumentyArgs = {
  input: UpdateDokumentyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDokumentyByNodeIdArgs = {
  input: UpdateDokumentyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEventArgs = {
  input: UpdateEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEventByNodeIdArgs = {
  input: UpdateEventByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGalerieDirArgs = {
  input: UpdateGalerieDirInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGalerieDirByNodeIdArgs = {
  input: UpdateGalerieDirByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGalerieFotoArgs = {
  input: UpdateGalerieFotoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGalerieFotoByNodeIdArgs = {
  input: UpdateGalerieFotoByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLocationArgs = {
  input: UpdateLocationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLocationAttachmentArgs = {
  input: UpdateLocationAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLocationAttachmentByNodeIdArgs = {
  input: UpdateLocationAttachmentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLocationByNodeIdArgs = {
  input: UpdateLocationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNabidkaArgs = {
  input: UpdateNabidkaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNabidkaByNodeIdArgs = {
  input: UpdateNabidkaByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNabidkaItemArgs = {
  input: UpdateNabidkaItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNabidkaItemByNiPartnerAndNiIdRodicArgs = {
  input: UpdateNabidkaItemByNiPartnerAndNiIdRodicInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNabidkaItemByNodeIdArgs = {
  input: UpdateNabidkaItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePageArgs = {
  input: UpdatePageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePageByNodeIdArgs = {
  input: UpdatePageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePageByUrlArgs = {
  input: UpdatePageByUrlInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateParameterArgs = {
  input: UpdateParameterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateParameterByNodeIdArgs = {
  input: UpdateParameterByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateParyArgs = {
  input: UpdateParyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateParyByNodeIdArgs = {
  input: UpdateParyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateParyNavrhArgs = {
  input: UpdateParyNavrhInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateParyNavrhByNodeIdArgs = {
  input: UpdateParyNavrhByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePermissionArgs = {
  input: UpdatePermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePermissionByNodeIdArgs = {
  input: UpdatePermissionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePersonArgs = {
  input: UpdatePersonInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePersonByNodeIdArgs = {
  input: UpdatePersonByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyCategoryArgs = {
  input: UpdatePlatbyCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyCategoryByNodeIdArgs = {
  input: UpdatePlatbyCategoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyCategoryGroupArgs = {
  input: UpdatePlatbyCategoryGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyCategoryGroupByNodeIdArgs = {
  input: UpdatePlatbyCategoryGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyGroupArgs = {
  input: UpdatePlatbyGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyGroupByNodeIdArgs = {
  input: UpdatePlatbyGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyGroupSkupinaArgs = {
  input: UpdatePlatbyGroupSkupinaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyGroupSkupinaByNodeIdArgs = {
  input: UpdatePlatbyGroupSkupinaByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyItemArgs = {
  input: UpdatePlatbyItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyItemByNodeIdArgs = {
  input: UpdatePlatbyItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyRawArgs = {
  input: UpdatePlatbyRawInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyRawByNodeIdArgs = {
  input: UpdatePlatbyRawByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoomArgs = {
  input: UpdateRoomInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoomAttachmentArgs = {
  input: UpdateRoomAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoomAttachmentByNodeIdArgs = {
  input: UpdateRoomAttachmentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoomByNodeIdArgs = {
  input: UpdateRoomByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRozpiArgs = {
  input: UpdateRozpiInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRozpiByNodeIdArgs = {
  input: UpdateRozpiByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRozpisItemArgs = {
  input: UpdateRozpisItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRozpisItemByNodeIdArgs = {
  input: UpdateRozpisItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSessionArgs = {
  input: UpdateSessionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSessionByNodeIdArgs = {
  input: UpdateSessionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSkupinyArgs = {
  input: UpdateSkupinyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSkupinyByNodeIdArgs = {
  input: UpdateSkupinyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTenantArgs = {
  input: UpdateTenantInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTenantAttachmentArgs = {
  input: UpdateTenantAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTenantAttachmentByNodeIdArgs = {
  input: UpdateTenantAttachmentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTenantByNodeIdArgs = {
  input: UpdateTenantByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTenantPersonArgs = {
  input: UpdateTenantPersonInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTenantPersonByNodeIdArgs = {
  input: UpdateTenantPersonByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUpozorneniArgs = {
  input: UpdateUpozorneniInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUpozorneniByNodeIdArgs = {
  input: UpdateUpozorneniByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUpozorneniSkupinyArgs = {
  input: UpdateUpozorneniSkupinyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUpozorneniSkupinyByNodeIdArgs = {
  input: UpdateUpozorneniSkupinyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserArgs = {
  input: UpdateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByNodeIdArgs = {
  input: UpdateUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVideoArgs = {
  input: UpdateVideoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVideoByNodeIdArgs = {
  input: UpdateVideoByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVideoListArgs = {
  input: UpdateVideoListInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVideoListByNodeIdArgs = {
  input: UpdateVideoListByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVideoSourceArgs = {
  input: UpdateVideoSourceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVideoSourceByNodeIdArgs = {
  input: UpdateVideoSourceByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUploadFileArgs = {
  fileName: Scalars['String'];
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationVerifyFunctionArgs = {
  input: VerifyFunctionInput;
};

export type Nabidka = Node & {
  __typename?: 'Nabidka';
  freeLessons: Maybe<Scalars['Int']>;
  myLessons: Maybe<Scalars['Int']>;
  /** Reads and enables pagination through a set of `NabidkaItem`. */
  nabidkaItemsByNiIdRodic: NabidkaItemsConnection;
  nDo: Scalars['Date'];
  nId: Scalars['BigInt'];
  nLock: Scalars['Boolean'];
  nMaxPocetHod: Scalars['Int'];
  nOd: Scalars['Date'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  nPocetHod: Scalars['Int'];
  nTimestamp: Maybe<Scalars['Datetime']>;
  nTrener: Scalars['BigInt'];
  nVisible: Scalars['Boolean'];
  /** Reads a single `User` that is related to this `Nabidka`. */
  userByNTrener: Maybe<User>;
};


export type NabidkaNabidkaItemsByNiIdRodicArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<NabidkaItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<NabidkaItemsOrderBy>>;
};

/** A condition to be used against `Nabidka` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type NabidkaCondition = {
  /** Checks for equality with the object’s `nDo` field. */
  nDo?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `nId` field. */
  nId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `nLock` field. */
  nLock?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `nMaxPocetHod` field. */
  nMaxPocetHod?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `nOd` field. */
  nOd?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `nPocetHod` field. */
  nPocetHod?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `nTimestamp` field. */
  nTimestamp?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `nTrener` field. */
  nTrener?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `nVisible` field. */
  nVisible?: InputMaybe<Scalars['Boolean']>;
};

/** An input for mutations affecting `Nabidka` */
export type NabidkaInput = {
  nDo: Scalars['Date'];
  nId?: InputMaybe<Scalars['BigInt']>;
  nLock?: InputMaybe<Scalars['Boolean']>;
  nMaxPocetHod?: InputMaybe<Scalars['Int']>;
  nOd: Scalars['Date'];
  nPocetHod?: InputMaybe<Scalars['Int']>;
  nTimestamp?: InputMaybe<Scalars['Datetime']>;
  nTrener: Scalars['BigInt'];
  nVisible?: InputMaybe<Scalars['Boolean']>;
};

export type NabidkaItem = Node & {
  __typename?: 'NabidkaItem';
  /** Reads a single `Nabidka` that is related to this `NabidkaItem`. */
  nabidkaByNiIdRodic: Maybe<Nabidka>;
  niId: Scalars['BigInt'];
  niIdRodic: Scalars['BigInt'];
  niLock: Scalars['Boolean'];
  niPartner: Scalars['BigInt'];
  niPocetHod: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `Pary` that is related to this `NabidkaItem`. */
  paryByNiPartner: Maybe<Pary>;
};

/**
 * A condition to be used against `NabidkaItem` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type NabidkaItemCondition = {
  /** Checks for equality with the object’s `niId` field. */
  niId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `niIdRodic` field. */
  niIdRodic?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `niLock` field. */
  niLock?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `niPartner` field. */
  niPartner?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `niPocetHod` field. */
  niPocetHod?: InputMaybe<Scalars['Int']>;
};

/** An input for mutations affecting `NabidkaItem` */
export type NabidkaItemInput = {
  niId?: InputMaybe<Scalars['BigInt']>;
  niIdRodic: Scalars['BigInt'];
  niLock?: InputMaybe<Scalars['Boolean']>;
  niPartner: Scalars['BigInt'];
  niPocetHod?: InputMaybe<Scalars['Int']>;
};

/** Represents an update to a `NabidkaItem`. Fields that are set will be updated. */
export type NabidkaItemPatch = {
  niId?: InputMaybe<Scalars['BigInt']>;
  niIdRodic?: InputMaybe<Scalars['BigInt']>;
  niLock?: InputMaybe<Scalars['Boolean']>;
  niPartner?: InputMaybe<Scalars['BigInt']>;
  niPocetHod?: InputMaybe<Scalars['Int']>;
};

/** A connection to a list of `NabidkaItem` values. */
export type NabidkaItemsConnection = {
  __typename?: 'NabidkaItemsConnection';
  /** A list of edges which contains the `NabidkaItem` and cursor to aid in pagination. */
  edges: Array<NabidkaItemsEdge>;
  /** A list of `NabidkaItem` objects. */
  nodes: Array<NabidkaItem>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `NabidkaItem` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `NabidkaItem` edge in the connection. */
export type NabidkaItemsEdge = {
  __typename?: 'NabidkaItemsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `NabidkaItem` at the end of the edge. */
  node: NabidkaItem;
};

/** Methods to use when ordering `NabidkaItem`. */
export enum NabidkaItemsOrderBy {
  NabidkaByNiIdRodicNDoAsc = 'NABIDKA_BY_NI_ID_RODIC__N_DO_ASC',
  NabidkaByNiIdRodicNDoDesc = 'NABIDKA_BY_NI_ID_RODIC__N_DO_DESC',
  NabidkaByNiIdRodicNIdAsc = 'NABIDKA_BY_NI_ID_RODIC__N_ID_ASC',
  NabidkaByNiIdRodicNIdDesc = 'NABIDKA_BY_NI_ID_RODIC__N_ID_DESC',
  NabidkaByNiIdRodicNLockAsc = 'NABIDKA_BY_NI_ID_RODIC__N_LOCK_ASC',
  NabidkaByNiIdRodicNLockDesc = 'NABIDKA_BY_NI_ID_RODIC__N_LOCK_DESC',
  NabidkaByNiIdRodicNMaxPocetHodAsc = 'NABIDKA_BY_NI_ID_RODIC__N_MAX_POCET_HOD_ASC',
  NabidkaByNiIdRodicNMaxPocetHodDesc = 'NABIDKA_BY_NI_ID_RODIC__N_MAX_POCET_HOD_DESC',
  NabidkaByNiIdRodicNOdAsc = 'NABIDKA_BY_NI_ID_RODIC__N_OD_ASC',
  NabidkaByNiIdRodicNOdDesc = 'NABIDKA_BY_NI_ID_RODIC__N_OD_DESC',
  NabidkaByNiIdRodicNPocetHodAsc = 'NABIDKA_BY_NI_ID_RODIC__N_POCET_HOD_ASC',
  NabidkaByNiIdRodicNPocetHodDesc = 'NABIDKA_BY_NI_ID_RODIC__N_POCET_HOD_DESC',
  NabidkaByNiIdRodicNTimestampAsc = 'NABIDKA_BY_NI_ID_RODIC__N_TIMESTAMP_ASC',
  NabidkaByNiIdRodicNTimestampDesc = 'NABIDKA_BY_NI_ID_RODIC__N_TIMESTAMP_DESC',
  NabidkaByNiIdRodicNTrenerAsc = 'NABIDKA_BY_NI_ID_RODIC__N_TRENER_ASC',
  NabidkaByNiIdRodicNTrenerDesc = 'NABIDKA_BY_NI_ID_RODIC__N_TRENER_DESC',
  NabidkaByNiIdRodicNVisibleAsc = 'NABIDKA_BY_NI_ID_RODIC__N_VISIBLE_ASC',
  NabidkaByNiIdRodicNVisibleDesc = 'NABIDKA_BY_NI_ID_RODIC__N_VISIBLE_DESC',
  Natural = 'NATURAL',
  NiIdAsc = 'NI_ID_ASC',
  NiIdDesc = 'NI_ID_DESC',
  NiIdRodicAsc = 'NI_ID_RODIC_ASC',
  NiIdRodicDesc = 'NI_ID_RODIC_DESC',
  NiLockAsc = 'NI_LOCK_ASC',
  NiLockDesc = 'NI_LOCK_DESC',
  NiPartnerAsc = 'NI_PARTNER_ASC',
  NiPartnerDesc = 'NI_PARTNER_DESC',
  NiPocetHodAsc = 'NI_POCET_HOD_ASC',
  NiPocetHodDesc = 'NI_POCET_HOD_DESC',
  ParyByNiPartnerPArchivAsc = 'PARY_BY_NI_PARTNER__P_ARCHIV_ASC',
  ParyByNiPartnerPArchivDesc = 'PARY_BY_NI_PARTNER__P_ARCHIV_DESC',
  ParyByNiPartnerPHodnoceniAsc = 'PARY_BY_NI_PARTNER__P_HODNOCENI_ASC',
  ParyByNiPartnerPHodnoceniDesc = 'PARY_BY_NI_PARTNER__P_HODNOCENI_DESC',
  ParyByNiPartnerPIdAsc = 'PARY_BY_NI_PARTNER__P_ID_ASC',
  ParyByNiPartnerPIdDesc = 'PARY_BY_NI_PARTNER__P_ID_DESC',
  ParyByNiPartnerPIdPartnerAsc = 'PARY_BY_NI_PARTNER__P_ID_PARTNER_ASC',
  ParyByNiPartnerPIdPartnerDesc = 'PARY_BY_NI_PARTNER__P_ID_PARTNER_DESC',
  ParyByNiPartnerPIdPartnerkaAsc = 'PARY_BY_NI_PARTNER__P_ID_PARTNERKA_ASC',
  ParyByNiPartnerPIdPartnerkaDesc = 'PARY_BY_NI_PARTNER__P_ID_PARTNERKA_DESC',
  ParyByNiPartnerPLatBodyAsc = 'PARY_BY_NI_PARTNER__P_LAT_BODY_ASC',
  ParyByNiPartnerPLatBodyDesc = 'PARY_BY_NI_PARTNER__P_LAT_BODY_DESC',
  ParyByNiPartnerPLatFinaleAsc = 'PARY_BY_NI_PARTNER__P_LAT_FINALE_ASC',
  ParyByNiPartnerPLatFinaleDesc = 'PARY_BY_NI_PARTNER__P_LAT_FINALE_DESC',
  ParyByNiPartnerPLatTridaAsc = 'PARY_BY_NI_PARTNER__P_LAT_TRIDA_ASC',
  ParyByNiPartnerPLatTridaDesc = 'PARY_BY_NI_PARTNER__P_LAT_TRIDA_DESC',
  ParyByNiPartnerPSttBodyAsc = 'PARY_BY_NI_PARTNER__P_STT_BODY_ASC',
  ParyByNiPartnerPSttBodyDesc = 'PARY_BY_NI_PARTNER__P_STT_BODY_DESC',
  ParyByNiPartnerPSttFinaleAsc = 'PARY_BY_NI_PARTNER__P_STT_FINALE_ASC',
  ParyByNiPartnerPSttFinaleDesc = 'PARY_BY_NI_PARTNER__P_STT_FINALE_DESC',
  ParyByNiPartnerPSttTridaAsc = 'PARY_BY_NI_PARTNER__P_STT_TRIDA_ASC',
  ParyByNiPartnerPSttTridaDesc = 'PARY_BY_NI_PARTNER__P_STT_TRIDA_DESC',
  ParyByNiPartnerPTimestampAddAsc = 'PARY_BY_NI_PARTNER__P_TIMESTAMP_ADD_ASC',
  ParyByNiPartnerPTimestampAddDesc = 'PARY_BY_NI_PARTNER__P_TIMESTAMP_ADD_DESC',
  ParyByNiPartnerPTimestampArchiveAsc = 'PARY_BY_NI_PARTNER__P_TIMESTAMP_ARCHIVE_ASC',
  ParyByNiPartnerPTimestampArchiveDesc = 'PARY_BY_NI_PARTNER__P_TIMESTAMP_ARCHIVE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Represents an update to a `Nabidka`. Fields that are set will be updated. */
export type NabidkaPatch = {
  nDo?: InputMaybe<Scalars['Date']>;
  nId?: InputMaybe<Scalars['BigInt']>;
  nLock?: InputMaybe<Scalars['Boolean']>;
  nMaxPocetHod?: InputMaybe<Scalars['Int']>;
  nOd?: InputMaybe<Scalars['Date']>;
  nPocetHod?: InputMaybe<Scalars['Int']>;
  nTimestamp?: InputMaybe<Scalars['Datetime']>;
  nTrener?: InputMaybe<Scalars['BigInt']>;
  nVisible?: InputMaybe<Scalars['Boolean']>;
};

/** A connection to a list of `Nabidka` values. */
export type NabidkasConnection = {
  __typename?: 'NabidkasConnection';
  /** A list of edges which contains the `Nabidka` and cursor to aid in pagination. */
  edges: Array<NabidkasEdge>;
  /** A list of `Nabidka` objects. */
  nodes: Array<Nabidka>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Nabidka` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Nabidka` edge in the connection. */
export type NabidkasEdge = {
  __typename?: 'NabidkasEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Nabidka` at the end of the edge. */
  node: Nabidka;
};

/** Methods to use when ordering `Nabidka`. */
export enum NabidkasOrderBy {
  NDoAsc = 'N_DO_ASC',
  NDoDesc = 'N_DO_DESC',
  NIdAsc = 'N_ID_ASC',
  NIdDesc = 'N_ID_DESC',
  NLockAsc = 'N_LOCK_ASC',
  NLockDesc = 'N_LOCK_DESC',
  NMaxPocetHodAsc = 'N_MAX_POCET_HOD_ASC',
  NMaxPocetHodDesc = 'N_MAX_POCET_HOD_DESC',
  NOdAsc = 'N_OD_ASC',
  NOdDesc = 'N_OD_DESC',
  NPocetHodAsc = 'N_POCET_HOD_ASC',
  NPocetHodDesc = 'N_POCET_HOD_DESC',
  NTimestampAsc = 'N_TIMESTAMP_ASC',
  NTimestampDesc = 'N_TIMESTAMP_DESC',
  NTrenerAsc = 'N_TRENER_ASC',
  NTrenerDesc = 'N_TRENER_DESC',
  NVisibleAsc = 'N_VISIBLE_ASC',
  NVisibleDesc = 'N_VISIBLE_DESC',
  NabidkaItemsByNiIdRodicCountAsc = 'NABIDKA_ITEMS_BY_NI_ID_RODIC__COUNT_ASC',
  NabidkaItemsByNiIdRodicCountDesc = 'NABIDKA_ITEMS_BY_NI_ID_RODIC__COUNT_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserByNTrenerUBanAsc = 'USER_BY_N_TRENER__U_BAN_ASC',
  UserByNTrenerUBanDesc = 'USER_BY_N_TRENER__U_BAN_DESC',
  UserByNTrenerUCityAsc = 'USER_BY_N_TRENER__U_CITY_ASC',
  UserByNTrenerUCityDesc = 'USER_BY_N_TRENER__U_CITY_DESC',
  UserByNTrenerUConfirmedAsc = 'USER_BY_N_TRENER__U_CONFIRMED_ASC',
  UserByNTrenerUConfirmedDesc = 'USER_BY_N_TRENER__U_CONFIRMED_DESC',
  UserByNTrenerUConscriptionNumberAsc = 'USER_BY_N_TRENER__U_CONSCRIPTION_NUMBER_ASC',
  UserByNTrenerUConscriptionNumberDesc = 'USER_BY_N_TRENER__U_CONSCRIPTION_NUMBER_DESC',
  UserByNTrenerUCreatedAtAsc = 'USER_BY_N_TRENER__U_CREATED_AT_ASC',
  UserByNTrenerUCreatedAtDesc = 'USER_BY_N_TRENER__U_CREATED_AT_DESC',
  UserByNTrenerUDancerAsc = 'USER_BY_N_TRENER__U_DANCER_ASC',
  UserByNTrenerUDancerDesc = 'USER_BY_N_TRENER__U_DANCER_DESC',
  UserByNTrenerUDistrictAsc = 'USER_BY_N_TRENER__U_DISTRICT_ASC',
  UserByNTrenerUDistrictDesc = 'USER_BY_N_TRENER__U_DISTRICT_DESC',
  UserByNTrenerUEmailAsc = 'USER_BY_N_TRENER__U_EMAIL_ASC',
  UserByNTrenerUEmailDesc = 'USER_BY_N_TRENER__U_EMAIL_DESC',
  UserByNTrenerUGdprSignedAtAsc = 'USER_BY_N_TRENER__U_GDPR_SIGNED_AT_ASC',
  UserByNTrenerUGdprSignedAtDesc = 'USER_BY_N_TRENER__U_GDPR_SIGNED_AT_DESC',
  UserByNTrenerUGroupAsc = 'USER_BY_N_TRENER__U_GROUP_ASC',
  UserByNTrenerUGroupDesc = 'USER_BY_N_TRENER__U_GROUP_DESC',
  UserByNTrenerUIdAsc = 'USER_BY_N_TRENER__U_ID_ASC',
  UserByNTrenerUIdDesc = 'USER_BY_N_TRENER__U_ID_DESC',
  UserByNTrenerUJmenoAsc = 'USER_BY_N_TRENER__U_JMENO_ASC',
  UserByNTrenerUJmenoDesc = 'USER_BY_N_TRENER__U_JMENO_DESC',
  UserByNTrenerULevelAsc = 'USER_BY_N_TRENER__U_LEVEL_ASC',
  UserByNTrenerULevelDesc = 'USER_BY_N_TRENER__U_LEVEL_DESC',
  UserByNTrenerULockAsc = 'USER_BY_N_TRENER__U_LOCK_ASC',
  UserByNTrenerULockDesc = 'USER_BY_N_TRENER__U_LOCK_DESC',
  UserByNTrenerULoginAsc = 'USER_BY_N_TRENER__U_LOGIN_ASC',
  UserByNTrenerULoginDesc = 'USER_BY_N_TRENER__U_LOGIN_DESC',
  UserByNTrenerUMemberSinceAsc = 'USER_BY_N_TRENER__U_MEMBER_SINCE_ASC',
  UserByNTrenerUMemberSinceDesc = 'USER_BY_N_TRENER__U_MEMBER_SINCE_DESC',
  UserByNTrenerUMemberUntilAsc = 'USER_BY_N_TRENER__U_MEMBER_UNTIL_ASC',
  UserByNTrenerUMemberUntilDesc = 'USER_BY_N_TRENER__U_MEMBER_UNTIL_DESC',
  UserByNTrenerUNarozeniAsc = 'USER_BY_N_TRENER__U_NAROZENI_ASC',
  UserByNTrenerUNarozeniDesc = 'USER_BY_N_TRENER__U_NAROZENI_DESC',
  UserByNTrenerUNationalityAsc = 'USER_BY_N_TRENER__U_NATIONALITY_ASC',
  UserByNTrenerUNationalityDesc = 'USER_BY_N_TRENER__U_NATIONALITY_DESC',
  UserByNTrenerUOrientationNumberAsc = 'USER_BY_N_TRENER__U_ORIENTATION_NUMBER_ASC',
  UserByNTrenerUOrientationNumberDesc = 'USER_BY_N_TRENER__U_ORIENTATION_NUMBER_DESC',
  UserByNTrenerUPassAsc = 'USER_BY_N_TRENER__U_PASS_ASC',
  UserByNTrenerUPassDesc = 'USER_BY_N_TRENER__U_PASS_DESC',
  UserByNTrenerUPohlaviAsc = 'USER_BY_N_TRENER__U_POHLAVI_ASC',
  UserByNTrenerUPohlaviDesc = 'USER_BY_N_TRENER__U_POHLAVI_DESC',
  UserByNTrenerUPostalCodeAsc = 'USER_BY_N_TRENER__U_POSTAL_CODE_ASC',
  UserByNTrenerUPostalCodeDesc = 'USER_BY_N_TRENER__U_POSTAL_CODE_DESC',
  UserByNTrenerUPoznamkyAsc = 'USER_BY_N_TRENER__U_POZNAMKY_ASC',
  UserByNTrenerUPoznamkyDesc = 'USER_BY_N_TRENER__U_POZNAMKY_DESC',
  UserByNTrenerUPrijmeniAsc = 'USER_BY_N_TRENER__U_PRIJMENI_ASC',
  UserByNTrenerUPrijmeniDesc = 'USER_BY_N_TRENER__U_PRIJMENI_DESC',
  UserByNTrenerURodneCisloAsc = 'USER_BY_N_TRENER__U_RODNE_CISLO_ASC',
  UserByNTrenerURodneCisloDesc = 'USER_BY_N_TRENER__U_RODNE_CISLO_DESC',
  UserByNTrenerUSkupinaAsc = 'USER_BY_N_TRENER__U_SKUPINA_ASC',
  UserByNTrenerUSkupinaDesc = 'USER_BY_N_TRENER__U_SKUPINA_DESC',
  UserByNTrenerUStreetAsc = 'USER_BY_N_TRENER__U_STREET_ASC',
  UserByNTrenerUStreetDesc = 'USER_BY_N_TRENER__U_STREET_DESC',
  UserByNTrenerUSystemAsc = 'USER_BY_N_TRENER__U_SYSTEM_ASC',
  UserByNTrenerUSystemDesc = 'USER_BY_N_TRENER__U_SYSTEM_DESC',
  UserByNTrenerUTeacherAsc = 'USER_BY_N_TRENER__U_TEACHER_ASC',
  UserByNTrenerUTeacherDesc = 'USER_BY_N_TRENER__U_TEACHER_DESC',
  UserByNTrenerUTelefonAsc = 'USER_BY_N_TRENER__U_TELEFON_ASC',
  UserByNTrenerUTelefonDesc = 'USER_BY_N_TRENER__U_TELEFON_DESC',
  UserByNTrenerUTimestampAsc = 'USER_BY_N_TRENER__U_TIMESTAMP_ASC',
  UserByNTrenerUTimestampDesc = 'USER_BY_N_TRENER__U_TIMESTAMP_DESC'
}

/** An object with a globally unique `ID`. */
export type Node = {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
};

export type Page = Node & {
  __typename?: 'Page';
  content: Scalars['JSON'];
  createdAt: Scalars['Datetime'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  title: Scalars['String'];
  updatedAt: Scalars['Datetime'];
  url: Scalars['String'];
};

/** A condition to be used against `Page` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PageCondition = {
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `url` field. */
  url?: InputMaybe<Scalars['String']>;
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor: Maybe<Scalars['Cursor']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor: Maybe<Scalars['Cursor']>;
};

/** An input for mutations affecting `Page` */
export type PageInput = {
  content: Scalars['JSON'];
  createdAt?: InputMaybe<Scalars['Datetime']>;
  id?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['Datetime']>;
  url: Scalars['String'];
};

/** Represents an update to a `Page`. Fields that are set will be updated. */
export type PagePatch = {
  content?: InputMaybe<Scalars['JSON']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  id?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['Datetime']>;
  url?: InputMaybe<Scalars['String']>;
};

export type PageRevision = Node & {
  __typename?: 'PageRevision';
  content: Scalars['JSON'];
  createdAt: Scalars['Datetime'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  revNumber: Scalars['Int'];
  revOperation: Scalars['String'];
  revTimestamp: Maybe<Scalars['Datetime']>;
  title: Scalars['String'];
  updatedAt: Scalars['Datetime'];
  url: Scalars['String'];
};

/**
 * A condition to be used against `PageRevision` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PageRevisionCondition = {
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `revNumber` field. */
  revNumber?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `revOperation` field. */
  revOperation?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `revTimestamp` field. */
  revTimestamp?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `url` field. */
  url?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `PageRevision` values. */
export type PageRevisionsConnection = {
  __typename?: 'PageRevisionsConnection';
  /** A list of edges which contains the `PageRevision` and cursor to aid in pagination. */
  edges: Array<PageRevisionsEdge>;
  /** A list of `PageRevision` objects. */
  nodes: Array<PageRevision>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PageRevision` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PageRevision` edge in the connection. */
export type PageRevisionsEdge = {
  __typename?: 'PageRevisionsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `PageRevision` at the end of the edge. */
  node: PageRevision;
};

/** Methods to use when ordering `PageRevision`. */
export enum PageRevisionsOrderBy {
  ContentAsc = 'CONTENT_ASC',
  ContentDesc = 'CONTENT_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RevNumberAsc = 'REV_NUMBER_ASC',
  RevNumberDesc = 'REV_NUMBER_DESC',
  RevOperationAsc = 'REV_OPERATION_ASC',
  RevOperationDesc = 'REV_OPERATION_DESC',
  RevTimestampAsc = 'REV_TIMESTAMP_ASC',
  RevTimestampDesc = 'REV_TIMESTAMP_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UrlAsc = 'URL_ASC',
  UrlDesc = 'URL_DESC'
}

/** A connection to a list of `Page` values. */
export type PagesConnection = {
  __typename?: 'PagesConnection';
  /** A list of edges which contains the `Page` and cursor to aid in pagination. */
  edges: Array<PagesEdge>;
  /** A list of `Page` objects. */
  nodes: Array<Page>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Page` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Page` edge in the connection. */
export type PagesEdge = {
  __typename?: 'PagesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Page` at the end of the edge. */
  node: Page;
};

/** Methods to use when ordering `Page`. */
export enum PagesOrderBy {
  ContentAsc = 'CONTENT_ASC',
  ContentDesc = 'CONTENT_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UrlAsc = 'URL_ASC',
  UrlDesc = 'URL_DESC'
}

export type Parameter = Node & {
  __typename?: 'Parameter';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  paName: Scalars['String'];
  paValue: Scalars['String'];
};

/**
 * A condition to be used against `Parameter` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ParameterCondition = {
  /** Checks for equality with the object’s `paName` field. */
  paName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `paValue` field. */
  paValue?: InputMaybe<Scalars['String']>;
};

/** An input for mutations affecting `Parameter` */
export type ParameterInput = {
  paName: Scalars['String'];
  paValue: Scalars['String'];
};

/** Represents an update to a `Parameter`. Fields that are set will be updated. */
export type ParameterPatch = {
  paName?: InputMaybe<Scalars['String']>;
  paValue?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Parameter` values. */
export type ParametersConnection = {
  __typename?: 'ParametersConnection';
  /** A list of edges which contains the `Parameter` and cursor to aid in pagination. */
  edges: Array<ParametersEdge>;
  /** A list of `Parameter` objects. */
  nodes: Array<Parameter>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Parameter` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Parameter` edge in the connection. */
export type ParametersEdge = {
  __typename?: 'ParametersEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Parameter` at the end of the edge. */
  node: Parameter;
};

/** Methods to use when ordering `Parameter`. */
export enum ParametersOrderBy {
  Natural = 'NATURAL',
  PaNameAsc = 'PA_NAME_ASC',
  PaNameDesc = 'PA_NAME_DESC',
  PaValueAsc = 'PA_VALUE_ASC',
  PaValueDesc = 'PA_VALUE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `Pary` values. */
export type PariesConnection = {
  __typename?: 'PariesConnection';
  /** A list of edges which contains the `Pary` and cursor to aid in pagination. */
  edges: Array<PariesEdge>;
  /** A list of `Pary` objects. */
  nodes: Array<Pary>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Pary` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Pary` edge in the connection. */
export type PariesEdge = {
  __typename?: 'PariesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Pary` at the end of the edge. */
  node: Pary;
};

/** Methods to use when ordering `Pary`. */
export enum PariesOrderBy {
  NabidkaItemsByNiPartnerCountAsc = 'NABIDKA_ITEMS_BY_NI_PARTNER__COUNT_ASC',
  NabidkaItemsByNiPartnerCountDesc = 'NABIDKA_ITEMS_BY_NI_PARTNER__COUNT_DESC',
  Natural = 'NATURAL',
  PArchivAsc = 'P_ARCHIV_ASC',
  PArchivDesc = 'P_ARCHIV_DESC',
  PHodnoceniAsc = 'P_HODNOCENI_ASC',
  PHodnoceniDesc = 'P_HODNOCENI_DESC',
  PIdAsc = 'P_ID_ASC',
  PIdDesc = 'P_ID_DESC',
  PIdPartnerAsc = 'P_ID_PARTNER_ASC',
  PIdPartnerDesc = 'P_ID_PARTNER_DESC',
  PIdPartnerkaAsc = 'P_ID_PARTNERKA_ASC',
  PIdPartnerkaDesc = 'P_ID_PARTNERKA_DESC',
  PLatBodyAsc = 'P_LAT_BODY_ASC',
  PLatBodyDesc = 'P_LAT_BODY_DESC',
  PLatFinaleAsc = 'P_LAT_FINALE_ASC',
  PLatFinaleDesc = 'P_LAT_FINALE_DESC',
  PLatTridaAsc = 'P_LAT_TRIDA_ASC',
  PLatTridaDesc = 'P_LAT_TRIDA_DESC',
  PSttBodyAsc = 'P_STT_BODY_ASC',
  PSttBodyDesc = 'P_STT_BODY_DESC',
  PSttFinaleAsc = 'P_STT_FINALE_ASC',
  PSttFinaleDesc = 'P_STT_FINALE_DESC',
  PSttTridaAsc = 'P_STT_TRIDA_ASC',
  PSttTridaDesc = 'P_STT_TRIDA_DESC',
  PTimestampAddAsc = 'P_TIMESTAMP_ADD_ASC',
  PTimestampAddDesc = 'P_TIMESTAMP_ADD_DESC',
  PTimestampArchiveAsc = 'P_TIMESTAMP_ARCHIVE_ASC',
  PTimestampArchiveDesc = 'P_TIMESTAMP_ARCHIVE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RozpisItemsByRiPartnerCountAsc = 'ROZPIS_ITEMS_BY_RI_PARTNER__COUNT_ASC',
  RozpisItemsByRiPartnerCountDesc = 'ROZPIS_ITEMS_BY_RI_PARTNER__COUNT_DESC',
  UserByPIdPartnerUBanAsc = 'USER_BY_P_ID_PARTNER__U_BAN_ASC',
  UserByPIdPartnerUBanDesc = 'USER_BY_P_ID_PARTNER__U_BAN_DESC',
  UserByPIdPartnerUCityAsc = 'USER_BY_P_ID_PARTNER__U_CITY_ASC',
  UserByPIdPartnerUCityDesc = 'USER_BY_P_ID_PARTNER__U_CITY_DESC',
  UserByPIdPartnerUConfirmedAsc = 'USER_BY_P_ID_PARTNER__U_CONFIRMED_ASC',
  UserByPIdPartnerUConfirmedDesc = 'USER_BY_P_ID_PARTNER__U_CONFIRMED_DESC',
  UserByPIdPartnerUConscriptionNumberAsc = 'USER_BY_P_ID_PARTNER__U_CONSCRIPTION_NUMBER_ASC',
  UserByPIdPartnerUConscriptionNumberDesc = 'USER_BY_P_ID_PARTNER__U_CONSCRIPTION_NUMBER_DESC',
  UserByPIdPartnerUCreatedAtAsc = 'USER_BY_P_ID_PARTNER__U_CREATED_AT_ASC',
  UserByPIdPartnerUCreatedAtDesc = 'USER_BY_P_ID_PARTNER__U_CREATED_AT_DESC',
  UserByPIdPartnerUDancerAsc = 'USER_BY_P_ID_PARTNER__U_DANCER_ASC',
  UserByPIdPartnerUDancerDesc = 'USER_BY_P_ID_PARTNER__U_DANCER_DESC',
  UserByPIdPartnerUDistrictAsc = 'USER_BY_P_ID_PARTNER__U_DISTRICT_ASC',
  UserByPIdPartnerUDistrictDesc = 'USER_BY_P_ID_PARTNER__U_DISTRICT_DESC',
  UserByPIdPartnerUEmailAsc = 'USER_BY_P_ID_PARTNER__U_EMAIL_ASC',
  UserByPIdPartnerUEmailDesc = 'USER_BY_P_ID_PARTNER__U_EMAIL_DESC',
  UserByPIdPartnerUGdprSignedAtAsc = 'USER_BY_P_ID_PARTNER__U_GDPR_SIGNED_AT_ASC',
  UserByPIdPartnerUGdprSignedAtDesc = 'USER_BY_P_ID_PARTNER__U_GDPR_SIGNED_AT_DESC',
  UserByPIdPartnerUGroupAsc = 'USER_BY_P_ID_PARTNER__U_GROUP_ASC',
  UserByPIdPartnerUGroupDesc = 'USER_BY_P_ID_PARTNER__U_GROUP_DESC',
  UserByPIdPartnerUIdAsc = 'USER_BY_P_ID_PARTNER__U_ID_ASC',
  UserByPIdPartnerUIdDesc = 'USER_BY_P_ID_PARTNER__U_ID_DESC',
  UserByPIdPartnerUJmenoAsc = 'USER_BY_P_ID_PARTNER__U_JMENO_ASC',
  UserByPIdPartnerUJmenoDesc = 'USER_BY_P_ID_PARTNER__U_JMENO_DESC',
  UserByPIdPartnerULevelAsc = 'USER_BY_P_ID_PARTNER__U_LEVEL_ASC',
  UserByPIdPartnerULevelDesc = 'USER_BY_P_ID_PARTNER__U_LEVEL_DESC',
  UserByPIdPartnerULockAsc = 'USER_BY_P_ID_PARTNER__U_LOCK_ASC',
  UserByPIdPartnerULockDesc = 'USER_BY_P_ID_PARTNER__U_LOCK_DESC',
  UserByPIdPartnerULoginAsc = 'USER_BY_P_ID_PARTNER__U_LOGIN_ASC',
  UserByPIdPartnerULoginDesc = 'USER_BY_P_ID_PARTNER__U_LOGIN_DESC',
  UserByPIdPartnerUMemberSinceAsc = 'USER_BY_P_ID_PARTNER__U_MEMBER_SINCE_ASC',
  UserByPIdPartnerUMemberSinceDesc = 'USER_BY_P_ID_PARTNER__U_MEMBER_SINCE_DESC',
  UserByPIdPartnerUMemberUntilAsc = 'USER_BY_P_ID_PARTNER__U_MEMBER_UNTIL_ASC',
  UserByPIdPartnerUMemberUntilDesc = 'USER_BY_P_ID_PARTNER__U_MEMBER_UNTIL_DESC',
  UserByPIdPartnerUNarozeniAsc = 'USER_BY_P_ID_PARTNER__U_NAROZENI_ASC',
  UserByPIdPartnerUNarozeniDesc = 'USER_BY_P_ID_PARTNER__U_NAROZENI_DESC',
  UserByPIdPartnerUNationalityAsc = 'USER_BY_P_ID_PARTNER__U_NATIONALITY_ASC',
  UserByPIdPartnerUNationalityDesc = 'USER_BY_P_ID_PARTNER__U_NATIONALITY_DESC',
  UserByPIdPartnerUOrientationNumberAsc = 'USER_BY_P_ID_PARTNER__U_ORIENTATION_NUMBER_ASC',
  UserByPIdPartnerUOrientationNumberDesc = 'USER_BY_P_ID_PARTNER__U_ORIENTATION_NUMBER_DESC',
  UserByPIdPartnerUPassAsc = 'USER_BY_P_ID_PARTNER__U_PASS_ASC',
  UserByPIdPartnerUPassDesc = 'USER_BY_P_ID_PARTNER__U_PASS_DESC',
  UserByPIdPartnerUPohlaviAsc = 'USER_BY_P_ID_PARTNER__U_POHLAVI_ASC',
  UserByPIdPartnerUPohlaviDesc = 'USER_BY_P_ID_PARTNER__U_POHLAVI_DESC',
  UserByPIdPartnerUPostalCodeAsc = 'USER_BY_P_ID_PARTNER__U_POSTAL_CODE_ASC',
  UserByPIdPartnerUPostalCodeDesc = 'USER_BY_P_ID_PARTNER__U_POSTAL_CODE_DESC',
  UserByPIdPartnerUPoznamkyAsc = 'USER_BY_P_ID_PARTNER__U_POZNAMKY_ASC',
  UserByPIdPartnerUPoznamkyDesc = 'USER_BY_P_ID_PARTNER__U_POZNAMKY_DESC',
  UserByPIdPartnerUPrijmeniAsc = 'USER_BY_P_ID_PARTNER__U_PRIJMENI_ASC',
  UserByPIdPartnerUPrijmeniDesc = 'USER_BY_P_ID_PARTNER__U_PRIJMENI_DESC',
  UserByPIdPartnerURodneCisloAsc = 'USER_BY_P_ID_PARTNER__U_RODNE_CISLO_ASC',
  UserByPIdPartnerURodneCisloDesc = 'USER_BY_P_ID_PARTNER__U_RODNE_CISLO_DESC',
  UserByPIdPartnerUSkupinaAsc = 'USER_BY_P_ID_PARTNER__U_SKUPINA_ASC',
  UserByPIdPartnerUSkupinaDesc = 'USER_BY_P_ID_PARTNER__U_SKUPINA_DESC',
  UserByPIdPartnerUStreetAsc = 'USER_BY_P_ID_PARTNER__U_STREET_ASC',
  UserByPIdPartnerUStreetDesc = 'USER_BY_P_ID_PARTNER__U_STREET_DESC',
  UserByPIdPartnerUSystemAsc = 'USER_BY_P_ID_PARTNER__U_SYSTEM_ASC',
  UserByPIdPartnerUSystemDesc = 'USER_BY_P_ID_PARTNER__U_SYSTEM_DESC',
  UserByPIdPartnerUTeacherAsc = 'USER_BY_P_ID_PARTNER__U_TEACHER_ASC',
  UserByPIdPartnerUTeacherDesc = 'USER_BY_P_ID_PARTNER__U_TEACHER_DESC',
  UserByPIdPartnerUTelefonAsc = 'USER_BY_P_ID_PARTNER__U_TELEFON_ASC',
  UserByPIdPartnerUTelefonDesc = 'USER_BY_P_ID_PARTNER__U_TELEFON_DESC',
  UserByPIdPartnerUTimestampAsc = 'USER_BY_P_ID_PARTNER__U_TIMESTAMP_ASC',
  UserByPIdPartnerUTimestampDesc = 'USER_BY_P_ID_PARTNER__U_TIMESTAMP_DESC',
  UserByPIdPartnerkaUBanAsc = 'USER_BY_P_ID_PARTNERKA__U_BAN_ASC',
  UserByPIdPartnerkaUBanDesc = 'USER_BY_P_ID_PARTNERKA__U_BAN_DESC',
  UserByPIdPartnerkaUCityAsc = 'USER_BY_P_ID_PARTNERKA__U_CITY_ASC',
  UserByPIdPartnerkaUCityDesc = 'USER_BY_P_ID_PARTNERKA__U_CITY_DESC',
  UserByPIdPartnerkaUConfirmedAsc = 'USER_BY_P_ID_PARTNERKA__U_CONFIRMED_ASC',
  UserByPIdPartnerkaUConfirmedDesc = 'USER_BY_P_ID_PARTNERKA__U_CONFIRMED_DESC',
  UserByPIdPartnerkaUConscriptionNumberAsc = 'USER_BY_P_ID_PARTNERKA__U_CONSCRIPTION_NUMBER_ASC',
  UserByPIdPartnerkaUConscriptionNumberDesc = 'USER_BY_P_ID_PARTNERKA__U_CONSCRIPTION_NUMBER_DESC',
  UserByPIdPartnerkaUCreatedAtAsc = 'USER_BY_P_ID_PARTNERKA__U_CREATED_AT_ASC',
  UserByPIdPartnerkaUCreatedAtDesc = 'USER_BY_P_ID_PARTNERKA__U_CREATED_AT_DESC',
  UserByPIdPartnerkaUDancerAsc = 'USER_BY_P_ID_PARTNERKA__U_DANCER_ASC',
  UserByPIdPartnerkaUDancerDesc = 'USER_BY_P_ID_PARTNERKA__U_DANCER_DESC',
  UserByPIdPartnerkaUDistrictAsc = 'USER_BY_P_ID_PARTNERKA__U_DISTRICT_ASC',
  UserByPIdPartnerkaUDistrictDesc = 'USER_BY_P_ID_PARTNERKA__U_DISTRICT_DESC',
  UserByPIdPartnerkaUEmailAsc = 'USER_BY_P_ID_PARTNERKA__U_EMAIL_ASC',
  UserByPIdPartnerkaUEmailDesc = 'USER_BY_P_ID_PARTNERKA__U_EMAIL_DESC',
  UserByPIdPartnerkaUGdprSignedAtAsc = 'USER_BY_P_ID_PARTNERKA__U_GDPR_SIGNED_AT_ASC',
  UserByPIdPartnerkaUGdprSignedAtDesc = 'USER_BY_P_ID_PARTNERKA__U_GDPR_SIGNED_AT_DESC',
  UserByPIdPartnerkaUGroupAsc = 'USER_BY_P_ID_PARTNERKA__U_GROUP_ASC',
  UserByPIdPartnerkaUGroupDesc = 'USER_BY_P_ID_PARTNERKA__U_GROUP_DESC',
  UserByPIdPartnerkaUIdAsc = 'USER_BY_P_ID_PARTNERKA__U_ID_ASC',
  UserByPIdPartnerkaUIdDesc = 'USER_BY_P_ID_PARTNERKA__U_ID_DESC',
  UserByPIdPartnerkaUJmenoAsc = 'USER_BY_P_ID_PARTNERKA__U_JMENO_ASC',
  UserByPIdPartnerkaUJmenoDesc = 'USER_BY_P_ID_PARTNERKA__U_JMENO_DESC',
  UserByPIdPartnerkaULevelAsc = 'USER_BY_P_ID_PARTNERKA__U_LEVEL_ASC',
  UserByPIdPartnerkaULevelDesc = 'USER_BY_P_ID_PARTNERKA__U_LEVEL_DESC',
  UserByPIdPartnerkaULockAsc = 'USER_BY_P_ID_PARTNERKA__U_LOCK_ASC',
  UserByPIdPartnerkaULockDesc = 'USER_BY_P_ID_PARTNERKA__U_LOCK_DESC',
  UserByPIdPartnerkaULoginAsc = 'USER_BY_P_ID_PARTNERKA__U_LOGIN_ASC',
  UserByPIdPartnerkaULoginDesc = 'USER_BY_P_ID_PARTNERKA__U_LOGIN_DESC',
  UserByPIdPartnerkaUMemberSinceAsc = 'USER_BY_P_ID_PARTNERKA__U_MEMBER_SINCE_ASC',
  UserByPIdPartnerkaUMemberSinceDesc = 'USER_BY_P_ID_PARTNERKA__U_MEMBER_SINCE_DESC',
  UserByPIdPartnerkaUMemberUntilAsc = 'USER_BY_P_ID_PARTNERKA__U_MEMBER_UNTIL_ASC',
  UserByPIdPartnerkaUMemberUntilDesc = 'USER_BY_P_ID_PARTNERKA__U_MEMBER_UNTIL_DESC',
  UserByPIdPartnerkaUNarozeniAsc = 'USER_BY_P_ID_PARTNERKA__U_NAROZENI_ASC',
  UserByPIdPartnerkaUNarozeniDesc = 'USER_BY_P_ID_PARTNERKA__U_NAROZENI_DESC',
  UserByPIdPartnerkaUNationalityAsc = 'USER_BY_P_ID_PARTNERKA__U_NATIONALITY_ASC',
  UserByPIdPartnerkaUNationalityDesc = 'USER_BY_P_ID_PARTNERKA__U_NATIONALITY_DESC',
  UserByPIdPartnerkaUOrientationNumberAsc = 'USER_BY_P_ID_PARTNERKA__U_ORIENTATION_NUMBER_ASC',
  UserByPIdPartnerkaUOrientationNumberDesc = 'USER_BY_P_ID_PARTNERKA__U_ORIENTATION_NUMBER_DESC',
  UserByPIdPartnerkaUPassAsc = 'USER_BY_P_ID_PARTNERKA__U_PASS_ASC',
  UserByPIdPartnerkaUPassDesc = 'USER_BY_P_ID_PARTNERKA__U_PASS_DESC',
  UserByPIdPartnerkaUPohlaviAsc = 'USER_BY_P_ID_PARTNERKA__U_POHLAVI_ASC',
  UserByPIdPartnerkaUPohlaviDesc = 'USER_BY_P_ID_PARTNERKA__U_POHLAVI_DESC',
  UserByPIdPartnerkaUPostalCodeAsc = 'USER_BY_P_ID_PARTNERKA__U_POSTAL_CODE_ASC',
  UserByPIdPartnerkaUPostalCodeDesc = 'USER_BY_P_ID_PARTNERKA__U_POSTAL_CODE_DESC',
  UserByPIdPartnerkaUPoznamkyAsc = 'USER_BY_P_ID_PARTNERKA__U_POZNAMKY_ASC',
  UserByPIdPartnerkaUPoznamkyDesc = 'USER_BY_P_ID_PARTNERKA__U_POZNAMKY_DESC',
  UserByPIdPartnerkaUPrijmeniAsc = 'USER_BY_P_ID_PARTNERKA__U_PRIJMENI_ASC',
  UserByPIdPartnerkaUPrijmeniDesc = 'USER_BY_P_ID_PARTNERKA__U_PRIJMENI_DESC',
  UserByPIdPartnerkaURodneCisloAsc = 'USER_BY_P_ID_PARTNERKA__U_RODNE_CISLO_ASC',
  UserByPIdPartnerkaURodneCisloDesc = 'USER_BY_P_ID_PARTNERKA__U_RODNE_CISLO_DESC',
  UserByPIdPartnerkaUSkupinaAsc = 'USER_BY_P_ID_PARTNERKA__U_SKUPINA_ASC',
  UserByPIdPartnerkaUSkupinaDesc = 'USER_BY_P_ID_PARTNERKA__U_SKUPINA_DESC',
  UserByPIdPartnerkaUStreetAsc = 'USER_BY_P_ID_PARTNERKA__U_STREET_ASC',
  UserByPIdPartnerkaUStreetDesc = 'USER_BY_P_ID_PARTNERKA__U_STREET_DESC',
  UserByPIdPartnerkaUSystemAsc = 'USER_BY_P_ID_PARTNERKA__U_SYSTEM_ASC',
  UserByPIdPartnerkaUSystemDesc = 'USER_BY_P_ID_PARTNERKA__U_SYSTEM_DESC',
  UserByPIdPartnerkaUTeacherAsc = 'USER_BY_P_ID_PARTNERKA__U_TEACHER_ASC',
  UserByPIdPartnerkaUTeacherDesc = 'USER_BY_P_ID_PARTNERKA__U_TEACHER_DESC',
  UserByPIdPartnerkaUTelefonAsc = 'USER_BY_P_ID_PARTNERKA__U_TELEFON_ASC',
  UserByPIdPartnerkaUTelefonDesc = 'USER_BY_P_ID_PARTNERKA__U_TELEFON_DESC',
  UserByPIdPartnerkaUTimestampAsc = 'USER_BY_P_ID_PARTNERKA__U_TIMESTAMP_ASC',
  UserByPIdPartnerkaUTimestampDesc = 'USER_BY_P_ID_PARTNERKA__U_TIMESTAMP_DESC'
}

export type Pary = Node & {
  __typename?: 'Pary';
  /** Reads and enables pagination through a set of `NabidkaItem`. */
  nabidkaItemsByNiPartner: NabidkaItemsConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  pArchiv: Scalars['Boolean'];
  pHodnoceni: Scalars['Int'];
  pId: Scalars['BigInt'];
  pIdPartner: Scalars['BigInt'];
  pIdPartnerka: Maybe<Scalars['BigInt']>;
  pLatBody: Scalars['Int'];
  pLatFinale: Scalars['Boolean'];
  pLatTrida: ParyPLatTrida;
  pSttBody: Scalars['Int'];
  pSttFinale: Scalars['Boolean'];
  pSttTrida: ParyPSttTrida;
  pTimestampAdd: Scalars['Datetime'];
  pTimestampArchive: Maybe<Scalars['Datetime']>;
  /** Reads and enables pagination through a set of `RozpisItem`. */
  rozpisItemsByRiPartner: RozpisItemsConnection;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartnerka: Maybe<User>;
};


export type ParyNabidkaItemsByNiPartnerArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<NabidkaItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<NabidkaItemsOrderBy>>;
};


export type ParyRozpisItemsByRiPartnerArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<RozpisItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RozpisItemsOrderBy>>;
};

/** A condition to be used against `Pary` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ParyCondition = {
  /** Checks for equality with the object’s `pArchiv` field. */
  pArchiv?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `pHodnoceni` field. */
  pHodnoceni?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `pId` field. */
  pId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pIdPartner` field. */
  pIdPartner?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pIdPartnerka` field. */
  pIdPartnerka?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pLatBody` field. */
  pLatBody?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `pLatFinale` field. */
  pLatFinale?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `pLatTrida` field. */
  pLatTrida?: InputMaybe<ParyPLatTrida>;
  /** Checks for equality with the object’s `pSttBody` field. */
  pSttBody?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `pSttFinale` field. */
  pSttFinale?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `pSttTrida` field. */
  pSttTrida?: InputMaybe<ParyPSttTrida>;
  /** Checks for equality with the object’s `pTimestampAdd` field. */
  pTimestampAdd?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `pTimestampArchive` field. */
  pTimestampArchive?: InputMaybe<Scalars['Datetime']>;
};

/** An input for mutations affecting `Pary` */
export type ParyInput = {
  pArchiv?: InputMaybe<Scalars['Boolean']>;
  pHodnoceni?: InputMaybe<Scalars['Int']>;
  pId?: InputMaybe<Scalars['BigInt']>;
  pIdPartner: Scalars['BigInt'];
  pIdPartnerka?: InputMaybe<Scalars['BigInt']>;
  pLatBody?: InputMaybe<Scalars['Int']>;
  pLatFinale?: InputMaybe<Scalars['Boolean']>;
  pLatTrida?: InputMaybe<ParyPLatTrida>;
  pSttBody?: InputMaybe<Scalars['Int']>;
  pSttFinale?: InputMaybe<Scalars['Boolean']>;
  pSttTrida?: InputMaybe<ParyPSttTrida>;
  pTimestampAdd?: InputMaybe<Scalars['Datetime']>;
  pTimestampArchive?: InputMaybe<Scalars['Datetime']>;
};

export type ParyNavrh = Node & {
  __typename?: 'ParyNavrh';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  pnId: Scalars['BigInt'];
  pnNavrhl: Scalars['BigInt'];
  pnPartner: Scalars['BigInt'];
  pnPartnerka: Scalars['BigInt'];
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnNavrhl: Maybe<User>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnPartnerka: Maybe<User>;
};

/**
 * A condition to be used against `ParyNavrh` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ParyNavrhCondition = {
  /** Checks for equality with the object’s `pnId` field. */
  pnId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pnNavrhl` field. */
  pnNavrhl?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pnPartner` field. */
  pnPartner?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pnPartnerka` field. */
  pnPartnerka?: InputMaybe<Scalars['BigInt']>;
};

/** An input for mutations affecting `ParyNavrh` */
export type ParyNavrhInput = {
  pnId?: InputMaybe<Scalars['BigInt']>;
  pnNavrhl: Scalars['BigInt'];
  pnPartner: Scalars['BigInt'];
  pnPartnerka: Scalars['BigInt'];
};

/** Represents an update to a `ParyNavrh`. Fields that are set will be updated. */
export type ParyNavrhPatch = {
  pnId?: InputMaybe<Scalars['BigInt']>;
  pnNavrhl?: InputMaybe<Scalars['BigInt']>;
  pnPartner?: InputMaybe<Scalars['BigInt']>;
  pnPartnerka?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `ParyNavrh` values. */
export type ParyNavrhsConnection = {
  __typename?: 'ParyNavrhsConnection';
  /** A list of edges which contains the `ParyNavrh` and cursor to aid in pagination. */
  edges: Array<ParyNavrhsEdge>;
  /** A list of `ParyNavrh` objects. */
  nodes: Array<ParyNavrh>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ParyNavrh` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ParyNavrh` edge in the connection. */
export type ParyNavrhsEdge = {
  __typename?: 'ParyNavrhsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `ParyNavrh` at the end of the edge. */
  node: ParyNavrh;
};

/** Methods to use when ordering `ParyNavrh`. */
export enum ParyNavrhsOrderBy {
  Natural = 'NATURAL',
  PnIdAsc = 'PN_ID_ASC',
  PnIdDesc = 'PN_ID_DESC',
  PnNavrhlAsc = 'PN_NAVRHL_ASC',
  PnNavrhlDesc = 'PN_NAVRHL_DESC',
  PnPartnerAsc = 'PN_PARTNER_ASC',
  PnPartnerDesc = 'PN_PARTNER_DESC',
  PnPartnerkaAsc = 'PN_PARTNERKA_ASC',
  PnPartnerkaDesc = 'PN_PARTNERKA_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserByPnNavrhlUBanAsc = 'USER_BY_PN_NAVRHL__U_BAN_ASC',
  UserByPnNavrhlUBanDesc = 'USER_BY_PN_NAVRHL__U_BAN_DESC',
  UserByPnNavrhlUCityAsc = 'USER_BY_PN_NAVRHL__U_CITY_ASC',
  UserByPnNavrhlUCityDesc = 'USER_BY_PN_NAVRHL__U_CITY_DESC',
  UserByPnNavrhlUConfirmedAsc = 'USER_BY_PN_NAVRHL__U_CONFIRMED_ASC',
  UserByPnNavrhlUConfirmedDesc = 'USER_BY_PN_NAVRHL__U_CONFIRMED_DESC',
  UserByPnNavrhlUConscriptionNumberAsc = 'USER_BY_PN_NAVRHL__U_CONSCRIPTION_NUMBER_ASC',
  UserByPnNavrhlUConscriptionNumberDesc = 'USER_BY_PN_NAVRHL__U_CONSCRIPTION_NUMBER_DESC',
  UserByPnNavrhlUCreatedAtAsc = 'USER_BY_PN_NAVRHL__U_CREATED_AT_ASC',
  UserByPnNavrhlUCreatedAtDesc = 'USER_BY_PN_NAVRHL__U_CREATED_AT_DESC',
  UserByPnNavrhlUDancerAsc = 'USER_BY_PN_NAVRHL__U_DANCER_ASC',
  UserByPnNavrhlUDancerDesc = 'USER_BY_PN_NAVRHL__U_DANCER_DESC',
  UserByPnNavrhlUDistrictAsc = 'USER_BY_PN_NAVRHL__U_DISTRICT_ASC',
  UserByPnNavrhlUDistrictDesc = 'USER_BY_PN_NAVRHL__U_DISTRICT_DESC',
  UserByPnNavrhlUEmailAsc = 'USER_BY_PN_NAVRHL__U_EMAIL_ASC',
  UserByPnNavrhlUEmailDesc = 'USER_BY_PN_NAVRHL__U_EMAIL_DESC',
  UserByPnNavrhlUGdprSignedAtAsc = 'USER_BY_PN_NAVRHL__U_GDPR_SIGNED_AT_ASC',
  UserByPnNavrhlUGdprSignedAtDesc = 'USER_BY_PN_NAVRHL__U_GDPR_SIGNED_AT_DESC',
  UserByPnNavrhlUGroupAsc = 'USER_BY_PN_NAVRHL__U_GROUP_ASC',
  UserByPnNavrhlUGroupDesc = 'USER_BY_PN_NAVRHL__U_GROUP_DESC',
  UserByPnNavrhlUIdAsc = 'USER_BY_PN_NAVRHL__U_ID_ASC',
  UserByPnNavrhlUIdDesc = 'USER_BY_PN_NAVRHL__U_ID_DESC',
  UserByPnNavrhlUJmenoAsc = 'USER_BY_PN_NAVRHL__U_JMENO_ASC',
  UserByPnNavrhlUJmenoDesc = 'USER_BY_PN_NAVRHL__U_JMENO_DESC',
  UserByPnNavrhlULevelAsc = 'USER_BY_PN_NAVRHL__U_LEVEL_ASC',
  UserByPnNavrhlULevelDesc = 'USER_BY_PN_NAVRHL__U_LEVEL_DESC',
  UserByPnNavrhlULockAsc = 'USER_BY_PN_NAVRHL__U_LOCK_ASC',
  UserByPnNavrhlULockDesc = 'USER_BY_PN_NAVRHL__U_LOCK_DESC',
  UserByPnNavrhlULoginAsc = 'USER_BY_PN_NAVRHL__U_LOGIN_ASC',
  UserByPnNavrhlULoginDesc = 'USER_BY_PN_NAVRHL__U_LOGIN_DESC',
  UserByPnNavrhlUMemberSinceAsc = 'USER_BY_PN_NAVRHL__U_MEMBER_SINCE_ASC',
  UserByPnNavrhlUMemberSinceDesc = 'USER_BY_PN_NAVRHL__U_MEMBER_SINCE_DESC',
  UserByPnNavrhlUMemberUntilAsc = 'USER_BY_PN_NAVRHL__U_MEMBER_UNTIL_ASC',
  UserByPnNavrhlUMemberUntilDesc = 'USER_BY_PN_NAVRHL__U_MEMBER_UNTIL_DESC',
  UserByPnNavrhlUNarozeniAsc = 'USER_BY_PN_NAVRHL__U_NAROZENI_ASC',
  UserByPnNavrhlUNarozeniDesc = 'USER_BY_PN_NAVRHL__U_NAROZENI_DESC',
  UserByPnNavrhlUNationalityAsc = 'USER_BY_PN_NAVRHL__U_NATIONALITY_ASC',
  UserByPnNavrhlUNationalityDesc = 'USER_BY_PN_NAVRHL__U_NATIONALITY_DESC',
  UserByPnNavrhlUOrientationNumberAsc = 'USER_BY_PN_NAVRHL__U_ORIENTATION_NUMBER_ASC',
  UserByPnNavrhlUOrientationNumberDesc = 'USER_BY_PN_NAVRHL__U_ORIENTATION_NUMBER_DESC',
  UserByPnNavrhlUPassAsc = 'USER_BY_PN_NAVRHL__U_PASS_ASC',
  UserByPnNavrhlUPassDesc = 'USER_BY_PN_NAVRHL__U_PASS_DESC',
  UserByPnNavrhlUPohlaviAsc = 'USER_BY_PN_NAVRHL__U_POHLAVI_ASC',
  UserByPnNavrhlUPohlaviDesc = 'USER_BY_PN_NAVRHL__U_POHLAVI_DESC',
  UserByPnNavrhlUPostalCodeAsc = 'USER_BY_PN_NAVRHL__U_POSTAL_CODE_ASC',
  UserByPnNavrhlUPostalCodeDesc = 'USER_BY_PN_NAVRHL__U_POSTAL_CODE_DESC',
  UserByPnNavrhlUPoznamkyAsc = 'USER_BY_PN_NAVRHL__U_POZNAMKY_ASC',
  UserByPnNavrhlUPoznamkyDesc = 'USER_BY_PN_NAVRHL__U_POZNAMKY_DESC',
  UserByPnNavrhlUPrijmeniAsc = 'USER_BY_PN_NAVRHL__U_PRIJMENI_ASC',
  UserByPnNavrhlUPrijmeniDesc = 'USER_BY_PN_NAVRHL__U_PRIJMENI_DESC',
  UserByPnNavrhlURodneCisloAsc = 'USER_BY_PN_NAVRHL__U_RODNE_CISLO_ASC',
  UserByPnNavrhlURodneCisloDesc = 'USER_BY_PN_NAVRHL__U_RODNE_CISLO_DESC',
  UserByPnNavrhlUSkupinaAsc = 'USER_BY_PN_NAVRHL__U_SKUPINA_ASC',
  UserByPnNavrhlUSkupinaDesc = 'USER_BY_PN_NAVRHL__U_SKUPINA_DESC',
  UserByPnNavrhlUStreetAsc = 'USER_BY_PN_NAVRHL__U_STREET_ASC',
  UserByPnNavrhlUStreetDesc = 'USER_BY_PN_NAVRHL__U_STREET_DESC',
  UserByPnNavrhlUSystemAsc = 'USER_BY_PN_NAVRHL__U_SYSTEM_ASC',
  UserByPnNavrhlUSystemDesc = 'USER_BY_PN_NAVRHL__U_SYSTEM_DESC',
  UserByPnNavrhlUTeacherAsc = 'USER_BY_PN_NAVRHL__U_TEACHER_ASC',
  UserByPnNavrhlUTeacherDesc = 'USER_BY_PN_NAVRHL__U_TEACHER_DESC',
  UserByPnNavrhlUTelefonAsc = 'USER_BY_PN_NAVRHL__U_TELEFON_ASC',
  UserByPnNavrhlUTelefonDesc = 'USER_BY_PN_NAVRHL__U_TELEFON_DESC',
  UserByPnNavrhlUTimestampAsc = 'USER_BY_PN_NAVRHL__U_TIMESTAMP_ASC',
  UserByPnNavrhlUTimestampDesc = 'USER_BY_PN_NAVRHL__U_TIMESTAMP_DESC',
  UserByPnPartnerUBanAsc = 'USER_BY_PN_PARTNER__U_BAN_ASC',
  UserByPnPartnerUBanDesc = 'USER_BY_PN_PARTNER__U_BAN_DESC',
  UserByPnPartnerUCityAsc = 'USER_BY_PN_PARTNER__U_CITY_ASC',
  UserByPnPartnerUCityDesc = 'USER_BY_PN_PARTNER__U_CITY_DESC',
  UserByPnPartnerUConfirmedAsc = 'USER_BY_PN_PARTNER__U_CONFIRMED_ASC',
  UserByPnPartnerUConfirmedDesc = 'USER_BY_PN_PARTNER__U_CONFIRMED_DESC',
  UserByPnPartnerUConscriptionNumberAsc = 'USER_BY_PN_PARTNER__U_CONSCRIPTION_NUMBER_ASC',
  UserByPnPartnerUConscriptionNumberDesc = 'USER_BY_PN_PARTNER__U_CONSCRIPTION_NUMBER_DESC',
  UserByPnPartnerUCreatedAtAsc = 'USER_BY_PN_PARTNER__U_CREATED_AT_ASC',
  UserByPnPartnerUCreatedAtDesc = 'USER_BY_PN_PARTNER__U_CREATED_AT_DESC',
  UserByPnPartnerUDancerAsc = 'USER_BY_PN_PARTNER__U_DANCER_ASC',
  UserByPnPartnerUDancerDesc = 'USER_BY_PN_PARTNER__U_DANCER_DESC',
  UserByPnPartnerUDistrictAsc = 'USER_BY_PN_PARTNER__U_DISTRICT_ASC',
  UserByPnPartnerUDistrictDesc = 'USER_BY_PN_PARTNER__U_DISTRICT_DESC',
  UserByPnPartnerUEmailAsc = 'USER_BY_PN_PARTNER__U_EMAIL_ASC',
  UserByPnPartnerUEmailDesc = 'USER_BY_PN_PARTNER__U_EMAIL_DESC',
  UserByPnPartnerUGdprSignedAtAsc = 'USER_BY_PN_PARTNER__U_GDPR_SIGNED_AT_ASC',
  UserByPnPartnerUGdprSignedAtDesc = 'USER_BY_PN_PARTNER__U_GDPR_SIGNED_AT_DESC',
  UserByPnPartnerUGroupAsc = 'USER_BY_PN_PARTNER__U_GROUP_ASC',
  UserByPnPartnerUGroupDesc = 'USER_BY_PN_PARTNER__U_GROUP_DESC',
  UserByPnPartnerUIdAsc = 'USER_BY_PN_PARTNER__U_ID_ASC',
  UserByPnPartnerUIdDesc = 'USER_BY_PN_PARTNER__U_ID_DESC',
  UserByPnPartnerUJmenoAsc = 'USER_BY_PN_PARTNER__U_JMENO_ASC',
  UserByPnPartnerUJmenoDesc = 'USER_BY_PN_PARTNER__U_JMENO_DESC',
  UserByPnPartnerULevelAsc = 'USER_BY_PN_PARTNER__U_LEVEL_ASC',
  UserByPnPartnerULevelDesc = 'USER_BY_PN_PARTNER__U_LEVEL_DESC',
  UserByPnPartnerULockAsc = 'USER_BY_PN_PARTNER__U_LOCK_ASC',
  UserByPnPartnerULockDesc = 'USER_BY_PN_PARTNER__U_LOCK_DESC',
  UserByPnPartnerULoginAsc = 'USER_BY_PN_PARTNER__U_LOGIN_ASC',
  UserByPnPartnerULoginDesc = 'USER_BY_PN_PARTNER__U_LOGIN_DESC',
  UserByPnPartnerUMemberSinceAsc = 'USER_BY_PN_PARTNER__U_MEMBER_SINCE_ASC',
  UserByPnPartnerUMemberSinceDesc = 'USER_BY_PN_PARTNER__U_MEMBER_SINCE_DESC',
  UserByPnPartnerUMemberUntilAsc = 'USER_BY_PN_PARTNER__U_MEMBER_UNTIL_ASC',
  UserByPnPartnerUMemberUntilDesc = 'USER_BY_PN_PARTNER__U_MEMBER_UNTIL_DESC',
  UserByPnPartnerUNarozeniAsc = 'USER_BY_PN_PARTNER__U_NAROZENI_ASC',
  UserByPnPartnerUNarozeniDesc = 'USER_BY_PN_PARTNER__U_NAROZENI_DESC',
  UserByPnPartnerUNationalityAsc = 'USER_BY_PN_PARTNER__U_NATIONALITY_ASC',
  UserByPnPartnerUNationalityDesc = 'USER_BY_PN_PARTNER__U_NATIONALITY_DESC',
  UserByPnPartnerUOrientationNumberAsc = 'USER_BY_PN_PARTNER__U_ORIENTATION_NUMBER_ASC',
  UserByPnPartnerUOrientationNumberDesc = 'USER_BY_PN_PARTNER__U_ORIENTATION_NUMBER_DESC',
  UserByPnPartnerUPassAsc = 'USER_BY_PN_PARTNER__U_PASS_ASC',
  UserByPnPartnerUPassDesc = 'USER_BY_PN_PARTNER__U_PASS_DESC',
  UserByPnPartnerUPohlaviAsc = 'USER_BY_PN_PARTNER__U_POHLAVI_ASC',
  UserByPnPartnerUPohlaviDesc = 'USER_BY_PN_PARTNER__U_POHLAVI_DESC',
  UserByPnPartnerUPostalCodeAsc = 'USER_BY_PN_PARTNER__U_POSTAL_CODE_ASC',
  UserByPnPartnerUPostalCodeDesc = 'USER_BY_PN_PARTNER__U_POSTAL_CODE_DESC',
  UserByPnPartnerUPoznamkyAsc = 'USER_BY_PN_PARTNER__U_POZNAMKY_ASC',
  UserByPnPartnerUPoznamkyDesc = 'USER_BY_PN_PARTNER__U_POZNAMKY_DESC',
  UserByPnPartnerUPrijmeniAsc = 'USER_BY_PN_PARTNER__U_PRIJMENI_ASC',
  UserByPnPartnerUPrijmeniDesc = 'USER_BY_PN_PARTNER__U_PRIJMENI_DESC',
  UserByPnPartnerURodneCisloAsc = 'USER_BY_PN_PARTNER__U_RODNE_CISLO_ASC',
  UserByPnPartnerURodneCisloDesc = 'USER_BY_PN_PARTNER__U_RODNE_CISLO_DESC',
  UserByPnPartnerUSkupinaAsc = 'USER_BY_PN_PARTNER__U_SKUPINA_ASC',
  UserByPnPartnerUSkupinaDesc = 'USER_BY_PN_PARTNER__U_SKUPINA_DESC',
  UserByPnPartnerUStreetAsc = 'USER_BY_PN_PARTNER__U_STREET_ASC',
  UserByPnPartnerUStreetDesc = 'USER_BY_PN_PARTNER__U_STREET_DESC',
  UserByPnPartnerUSystemAsc = 'USER_BY_PN_PARTNER__U_SYSTEM_ASC',
  UserByPnPartnerUSystemDesc = 'USER_BY_PN_PARTNER__U_SYSTEM_DESC',
  UserByPnPartnerUTeacherAsc = 'USER_BY_PN_PARTNER__U_TEACHER_ASC',
  UserByPnPartnerUTeacherDesc = 'USER_BY_PN_PARTNER__U_TEACHER_DESC',
  UserByPnPartnerUTelefonAsc = 'USER_BY_PN_PARTNER__U_TELEFON_ASC',
  UserByPnPartnerUTelefonDesc = 'USER_BY_PN_PARTNER__U_TELEFON_DESC',
  UserByPnPartnerUTimestampAsc = 'USER_BY_PN_PARTNER__U_TIMESTAMP_ASC',
  UserByPnPartnerUTimestampDesc = 'USER_BY_PN_PARTNER__U_TIMESTAMP_DESC',
  UserByPnPartnerkaUBanAsc = 'USER_BY_PN_PARTNERKA__U_BAN_ASC',
  UserByPnPartnerkaUBanDesc = 'USER_BY_PN_PARTNERKA__U_BAN_DESC',
  UserByPnPartnerkaUCityAsc = 'USER_BY_PN_PARTNERKA__U_CITY_ASC',
  UserByPnPartnerkaUCityDesc = 'USER_BY_PN_PARTNERKA__U_CITY_DESC',
  UserByPnPartnerkaUConfirmedAsc = 'USER_BY_PN_PARTNERKA__U_CONFIRMED_ASC',
  UserByPnPartnerkaUConfirmedDesc = 'USER_BY_PN_PARTNERKA__U_CONFIRMED_DESC',
  UserByPnPartnerkaUConscriptionNumberAsc = 'USER_BY_PN_PARTNERKA__U_CONSCRIPTION_NUMBER_ASC',
  UserByPnPartnerkaUConscriptionNumberDesc = 'USER_BY_PN_PARTNERKA__U_CONSCRIPTION_NUMBER_DESC',
  UserByPnPartnerkaUCreatedAtAsc = 'USER_BY_PN_PARTNERKA__U_CREATED_AT_ASC',
  UserByPnPartnerkaUCreatedAtDesc = 'USER_BY_PN_PARTNERKA__U_CREATED_AT_DESC',
  UserByPnPartnerkaUDancerAsc = 'USER_BY_PN_PARTNERKA__U_DANCER_ASC',
  UserByPnPartnerkaUDancerDesc = 'USER_BY_PN_PARTNERKA__U_DANCER_DESC',
  UserByPnPartnerkaUDistrictAsc = 'USER_BY_PN_PARTNERKA__U_DISTRICT_ASC',
  UserByPnPartnerkaUDistrictDesc = 'USER_BY_PN_PARTNERKA__U_DISTRICT_DESC',
  UserByPnPartnerkaUEmailAsc = 'USER_BY_PN_PARTNERKA__U_EMAIL_ASC',
  UserByPnPartnerkaUEmailDesc = 'USER_BY_PN_PARTNERKA__U_EMAIL_DESC',
  UserByPnPartnerkaUGdprSignedAtAsc = 'USER_BY_PN_PARTNERKA__U_GDPR_SIGNED_AT_ASC',
  UserByPnPartnerkaUGdprSignedAtDesc = 'USER_BY_PN_PARTNERKA__U_GDPR_SIGNED_AT_DESC',
  UserByPnPartnerkaUGroupAsc = 'USER_BY_PN_PARTNERKA__U_GROUP_ASC',
  UserByPnPartnerkaUGroupDesc = 'USER_BY_PN_PARTNERKA__U_GROUP_DESC',
  UserByPnPartnerkaUIdAsc = 'USER_BY_PN_PARTNERKA__U_ID_ASC',
  UserByPnPartnerkaUIdDesc = 'USER_BY_PN_PARTNERKA__U_ID_DESC',
  UserByPnPartnerkaUJmenoAsc = 'USER_BY_PN_PARTNERKA__U_JMENO_ASC',
  UserByPnPartnerkaUJmenoDesc = 'USER_BY_PN_PARTNERKA__U_JMENO_DESC',
  UserByPnPartnerkaULevelAsc = 'USER_BY_PN_PARTNERKA__U_LEVEL_ASC',
  UserByPnPartnerkaULevelDesc = 'USER_BY_PN_PARTNERKA__U_LEVEL_DESC',
  UserByPnPartnerkaULockAsc = 'USER_BY_PN_PARTNERKA__U_LOCK_ASC',
  UserByPnPartnerkaULockDesc = 'USER_BY_PN_PARTNERKA__U_LOCK_DESC',
  UserByPnPartnerkaULoginAsc = 'USER_BY_PN_PARTNERKA__U_LOGIN_ASC',
  UserByPnPartnerkaULoginDesc = 'USER_BY_PN_PARTNERKA__U_LOGIN_DESC',
  UserByPnPartnerkaUMemberSinceAsc = 'USER_BY_PN_PARTNERKA__U_MEMBER_SINCE_ASC',
  UserByPnPartnerkaUMemberSinceDesc = 'USER_BY_PN_PARTNERKA__U_MEMBER_SINCE_DESC',
  UserByPnPartnerkaUMemberUntilAsc = 'USER_BY_PN_PARTNERKA__U_MEMBER_UNTIL_ASC',
  UserByPnPartnerkaUMemberUntilDesc = 'USER_BY_PN_PARTNERKA__U_MEMBER_UNTIL_DESC',
  UserByPnPartnerkaUNarozeniAsc = 'USER_BY_PN_PARTNERKA__U_NAROZENI_ASC',
  UserByPnPartnerkaUNarozeniDesc = 'USER_BY_PN_PARTNERKA__U_NAROZENI_DESC',
  UserByPnPartnerkaUNationalityAsc = 'USER_BY_PN_PARTNERKA__U_NATIONALITY_ASC',
  UserByPnPartnerkaUNationalityDesc = 'USER_BY_PN_PARTNERKA__U_NATIONALITY_DESC',
  UserByPnPartnerkaUOrientationNumberAsc = 'USER_BY_PN_PARTNERKA__U_ORIENTATION_NUMBER_ASC',
  UserByPnPartnerkaUOrientationNumberDesc = 'USER_BY_PN_PARTNERKA__U_ORIENTATION_NUMBER_DESC',
  UserByPnPartnerkaUPassAsc = 'USER_BY_PN_PARTNERKA__U_PASS_ASC',
  UserByPnPartnerkaUPassDesc = 'USER_BY_PN_PARTNERKA__U_PASS_DESC',
  UserByPnPartnerkaUPohlaviAsc = 'USER_BY_PN_PARTNERKA__U_POHLAVI_ASC',
  UserByPnPartnerkaUPohlaviDesc = 'USER_BY_PN_PARTNERKA__U_POHLAVI_DESC',
  UserByPnPartnerkaUPostalCodeAsc = 'USER_BY_PN_PARTNERKA__U_POSTAL_CODE_ASC',
  UserByPnPartnerkaUPostalCodeDesc = 'USER_BY_PN_PARTNERKA__U_POSTAL_CODE_DESC',
  UserByPnPartnerkaUPoznamkyAsc = 'USER_BY_PN_PARTNERKA__U_POZNAMKY_ASC',
  UserByPnPartnerkaUPoznamkyDesc = 'USER_BY_PN_PARTNERKA__U_POZNAMKY_DESC',
  UserByPnPartnerkaUPrijmeniAsc = 'USER_BY_PN_PARTNERKA__U_PRIJMENI_ASC',
  UserByPnPartnerkaUPrijmeniDesc = 'USER_BY_PN_PARTNERKA__U_PRIJMENI_DESC',
  UserByPnPartnerkaURodneCisloAsc = 'USER_BY_PN_PARTNERKA__U_RODNE_CISLO_ASC',
  UserByPnPartnerkaURodneCisloDesc = 'USER_BY_PN_PARTNERKA__U_RODNE_CISLO_DESC',
  UserByPnPartnerkaUSkupinaAsc = 'USER_BY_PN_PARTNERKA__U_SKUPINA_ASC',
  UserByPnPartnerkaUSkupinaDesc = 'USER_BY_PN_PARTNERKA__U_SKUPINA_DESC',
  UserByPnPartnerkaUStreetAsc = 'USER_BY_PN_PARTNERKA__U_STREET_ASC',
  UserByPnPartnerkaUStreetDesc = 'USER_BY_PN_PARTNERKA__U_STREET_DESC',
  UserByPnPartnerkaUSystemAsc = 'USER_BY_PN_PARTNERKA__U_SYSTEM_ASC',
  UserByPnPartnerkaUSystemDesc = 'USER_BY_PN_PARTNERKA__U_SYSTEM_DESC',
  UserByPnPartnerkaUTeacherAsc = 'USER_BY_PN_PARTNERKA__U_TEACHER_ASC',
  UserByPnPartnerkaUTeacherDesc = 'USER_BY_PN_PARTNERKA__U_TEACHER_DESC',
  UserByPnPartnerkaUTelefonAsc = 'USER_BY_PN_PARTNERKA__U_TELEFON_ASC',
  UserByPnPartnerkaUTelefonDesc = 'USER_BY_PN_PARTNERKA__U_TELEFON_DESC',
  UserByPnPartnerkaUTimestampAsc = 'USER_BY_PN_PARTNERKA__U_TIMESTAMP_ASC',
  UserByPnPartnerkaUTimestampDesc = 'USER_BY_PN_PARTNERKA__U_TIMESTAMP_DESC'
}

/** Represents an update to a `Pary`. Fields that are set will be updated. */
export type ParyPatch = {
  pArchiv?: InputMaybe<Scalars['Boolean']>;
  pHodnoceni?: InputMaybe<Scalars['Int']>;
  pId?: InputMaybe<Scalars['BigInt']>;
  pIdPartner?: InputMaybe<Scalars['BigInt']>;
  pIdPartnerka?: InputMaybe<Scalars['BigInt']>;
  pLatBody?: InputMaybe<Scalars['Int']>;
  pLatFinale?: InputMaybe<Scalars['Boolean']>;
  pLatTrida?: InputMaybe<ParyPLatTrida>;
  pSttBody?: InputMaybe<Scalars['Int']>;
  pSttFinale?: InputMaybe<Scalars['Boolean']>;
  pSttTrida?: InputMaybe<ParyPSttTrida>;
  pTimestampAdd?: InputMaybe<Scalars['Datetime']>;
  pTimestampArchive?: InputMaybe<Scalars['Datetime']>;
};

export enum ParyPLatTrida {
  A = 'A',
  B = 'B',
  C = 'C',
  D = 'D',
  H = 'H',
  M = 'M',
  Z = 'Z'
}

export enum ParyPSttTrida {
  A = 'A',
  B = 'B',
  C = 'C',
  D = 'D',
  H = 'H',
  M = 'M',
  Z = 'Z'
}

/** A connection to a list of `Person` values. */
export type PeopleConnection = {
  __typename?: 'PeopleConnection';
  /** A list of edges which contains the `Person` and cursor to aid in pagination. */
  edges: Array<PeopleEdge>;
  /** A list of `Person` objects. */
  nodes: Array<Person>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Person` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Person` edge in the connection. */
export type PeopleEdge = {
  __typename?: 'PeopleEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Person` at the end of the edge. */
  node: Person;
};

/** Methods to use when ordering `Person`. */
export enum PeopleOrderBy {
  FirstNameAsc = 'FIRST_NAME_ASC',
  FirstNameDesc = 'FIRST_NAME_DESC',
  GenderAsc = 'GENDER_ASC',
  GenderDesc = 'GENDER_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LastNameAsc = 'LAST_NAME_ASC',
  LastNameDesc = 'LAST_NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TenantPeopleByPersonIdCountAsc = 'TENANT_PEOPLE_BY_PERSON_ID__COUNT_ASC',
  TenantPeopleByPersonIdCountDesc = 'TENANT_PEOPLE_BY_PERSON_ID__COUNT_DESC'
}

export type Permission = Node & {
  __typename?: 'Permission';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  peAkce: Scalars['Int'];
  peAktuality: Scalars['Int'];
  peAnkety: Scalars['Int'];
  peDescription: Scalars['String'];
  peDokumenty: Scalars['Int'];
  peGalerie: Scalars['Int'];
  peId: Scalars['BigInt'];
  peInzerce: Scalars['Int'];
  peKonzole: Scalars['Int'];
  peMain: Scalars['Int'];
  peNabidka: Scalars['Int'];
  peName: Scalars['String'];
  peNastenka: Scalars['Int'];
  peNovinky: Scalars['Int'];
  pePary: Scalars['Int'];
  pePermissions: Scalars['Int'];
  pePlatby: Scalars['Int'];
  peRozpis: Scalars['Int'];
  peSkupiny: Scalars['Int'];
  peUsers: Scalars['Int'];
  /** Reads and enables pagination through a set of `User`. */
  usersByUGroup: UsersConnection;
};


export type PermissionUsersByUGroupArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<UserCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/**
 * A condition to be used against `Permission` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PermissionCondition = {
  /** Checks for equality with the object’s `peAkce` field. */
  peAkce?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peAktuality` field. */
  peAktuality?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peAnkety` field. */
  peAnkety?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peDescription` field. */
  peDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `peDokumenty` field. */
  peDokumenty?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peGalerie` field. */
  peGalerie?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peId` field. */
  peId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `peInzerce` field. */
  peInzerce?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peKonzole` field. */
  peKonzole?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peMain` field. */
  peMain?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peNabidka` field. */
  peNabidka?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peName` field. */
  peName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `peNastenka` field. */
  peNastenka?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peNovinky` field. */
  peNovinky?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `pePary` field. */
  pePary?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `pePermissions` field. */
  pePermissions?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `pePlatby` field. */
  pePlatby?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peRozpis` field. */
  peRozpis?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peSkupiny` field. */
  peSkupiny?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peUsers` field. */
  peUsers?: InputMaybe<Scalars['Int']>;
};

/** An input for mutations affecting `Permission` */
export type PermissionInput = {
  peAkce: Scalars['Int'];
  peAktuality: Scalars['Int'];
  peAnkety: Scalars['Int'];
  peDescription: Scalars['String'];
  peDokumenty: Scalars['Int'];
  peGalerie: Scalars['Int'];
  peId?: InputMaybe<Scalars['BigInt']>;
  peInzerce: Scalars['Int'];
  peKonzole: Scalars['Int'];
  peMain: Scalars['Int'];
  peNabidka: Scalars['Int'];
  peName: Scalars['String'];
  peNastenka: Scalars['Int'];
  peNovinky: Scalars['Int'];
  pePary: Scalars['Int'];
  pePermissions: Scalars['Int'];
  pePlatby: Scalars['Int'];
  peRozpis: Scalars['Int'];
  peSkupiny: Scalars['Int'];
  peUsers: Scalars['Int'];
};

/** Represents an update to a `Permission`. Fields that are set will be updated. */
export type PermissionPatch = {
  peAkce?: InputMaybe<Scalars['Int']>;
  peAktuality?: InputMaybe<Scalars['Int']>;
  peAnkety?: InputMaybe<Scalars['Int']>;
  peDescription?: InputMaybe<Scalars['String']>;
  peDokumenty?: InputMaybe<Scalars['Int']>;
  peGalerie?: InputMaybe<Scalars['Int']>;
  peId?: InputMaybe<Scalars['BigInt']>;
  peInzerce?: InputMaybe<Scalars['Int']>;
  peKonzole?: InputMaybe<Scalars['Int']>;
  peMain?: InputMaybe<Scalars['Int']>;
  peNabidka?: InputMaybe<Scalars['Int']>;
  peName?: InputMaybe<Scalars['String']>;
  peNastenka?: InputMaybe<Scalars['Int']>;
  peNovinky?: InputMaybe<Scalars['Int']>;
  pePary?: InputMaybe<Scalars['Int']>;
  pePermissions?: InputMaybe<Scalars['Int']>;
  pePlatby?: InputMaybe<Scalars['Int']>;
  peRozpis?: InputMaybe<Scalars['Int']>;
  peSkupiny?: InputMaybe<Scalars['Int']>;
  peUsers?: InputMaybe<Scalars['Int']>;
};

/** A connection to a list of `Permission` values. */
export type PermissionsConnection = {
  __typename?: 'PermissionsConnection';
  /** A list of edges which contains the `Permission` and cursor to aid in pagination. */
  edges: Array<PermissionsEdge>;
  /** A list of `Permission` objects. */
  nodes: Array<Permission>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Permission` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Permission` edge in the connection. */
export type PermissionsEdge = {
  __typename?: 'PermissionsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Permission` at the end of the edge. */
  node: Permission;
};

/** Methods to use when ordering `Permission`. */
export enum PermissionsOrderBy {
  Natural = 'NATURAL',
  PeAkceAsc = 'PE_AKCE_ASC',
  PeAkceDesc = 'PE_AKCE_DESC',
  PeAktualityAsc = 'PE_AKTUALITY_ASC',
  PeAktualityDesc = 'PE_AKTUALITY_DESC',
  PeAnketyAsc = 'PE_ANKETY_ASC',
  PeAnketyDesc = 'PE_ANKETY_DESC',
  PeDescriptionAsc = 'PE_DESCRIPTION_ASC',
  PeDescriptionDesc = 'PE_DESCRIPTION_DESC',
  PeDokumentyAsc = 'PE_DOKUMENTY_ASC',
  PeDokumentyDesc = 'PE_DOKUMENTY_DESC',
  PeGalerieAsc = 'PE_GALERIE_ASC',
  PeGalerieDesc = 'PE_GALERIE_DESC',
  PeIdAsc = 'PE_ID_ASC',
  PeIdDesc = 'PE_ID_DESC',
  PeInzerceAsc = 'PE_INZERCE_ASC',
  PeInzerceDesc = 'PE_INZERCE_DESC',
  PeKonzoleAsc = 'PE_KONZOLE_ASC',
  PeKonzoleDesc = 'PE_KONZOLE_DESC',
  PeMainAsc = 'PE_MAIN_ASC',
  PeMainDesc = 'PE_MAIN_DESC',
  PeNabidkaAsc = 'PE_NABIDKA_ASC',
  PeNabidkaDesc = 'PE_NABIDKA_DESC',
  PeNameAsc = 'PE_NAME_ASC',
  PeNameDesc = 'PE_NAME_DESC',
  PeNastenkaAsc = 'PE_NASTENKA_ASC',
  PeNastenkaDesc = 'PE_NASTENKA_DESC',
  PeNovinkyAsc = 'PE_NOVINKY_ASC',
  PeNovinkyDesc = 'PE_NOVINKY_DESC',
  PeParyAsc = 'PE_PARY_ASC',
  PeParyDesc = 'PE_PARY_DESC',
  PePermissionsAsc = 'PE_PERMISSIONS_ASC',
  PePermissionsDesc = 'PE_PERMISSIONS_DESC',
  PePlatbyAsc = 'PE_PLATBY_ASC',
  PePlatbyDesc = 'PE_PLATBY_DESC',
  PeRozpisAsc = 'PE_ROZPIS_ASC',
  PeRozpisDesc = 'PE_ROZPIS_DESC',
  PeSkupinyAsc = 'PE_SKUPINY_ASC',
  PeSkupinyDesc = 'PE_SKUPINY_DESC',
  PeUsersAsc = 'PE_USERS_ASC',
  PeUsersDesc = 'PE_USERS_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UsersByUGroupCountAsc = 'USERS_BY_U_GROUP__COUNT_ASC',
  UsersByUGroupCountDesc = 'USERS_BY_U_GROUP__COUNT_DESC'
}

export type Person = Node & {
  __typename?: 'Person';
  firstName: Scalars['String'];
  gender: GenderType;
  id: Scalars['BigInt'];
  lastName: Scalars['String'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads and enables pagination through a set of `TenantPerson`. */
  tenantPeople: TenantPeopleConnection;
};


export type PersonTenantPeopleArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<TenantPersonCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TenantPeopleOrderBy>>;
};

/** A condition to be used against `Person` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PersonCondition = {
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `gender` field. */
  gender?: InputMaybe<GenderType>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: InputMaybe<Scalars['String']>;
};

/** An input for mutations affecting `Person` */
export type PersonInput = {
  firstName: Scalars['String'];
  gender: GenderType;
  id?: InputMaybe<Scalars['BigInt']>;
  lastName: Scalars['String'];
};

/** Represents an update to a `Person`. Fields that are set will be updated. */
export type PersonPatch = {
  firstName?: InputMaybe<Scalars['String']>;
  gender?: InputMaybe<GenderType>;
  id?: InputMaybe<Scalars['BigInt']>;
  lastName?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `PlatbyCategory` values. */
export type PlatbyCategoriesConnection = {
  __typename?: 'PlatbyCategoriesConnection';
  /** A list of edges which contains the `PlatbyCategory` and cursor to aid in pagination. */
  edges: Array<PlatbyCategoriesEdge>;
  /** A list of `PlatbyCategory` objects. */
  nodes: Array<PlatbyCategory>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PlatbyCategory` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PlatbyCategory` edge in the connection. */
export type PlatbyCategoriesEdge = {
  __typename?: 'PlatbyCategoriesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `PlatbyCategory` at the end of the edge. */
  node: PlatbyCategory;
};

/** Methods to use when ordering `PlatbyCategory`. */
export enum PlatbyCategoriesOrderBy {
  Natural = 'NATURAL',
  PcAmountAsc = 'PC_AMOUNT_ASC',
  PcAmountDesc = 'PC_AMOUNT_DESC',
  PcArchiveAsc = 'PC_ARCHIVE_ASC',
  PcArchiveDesc = 'PC_ARCHIVE_DESC',
  PcDateDueAsc = 'PC_DATE_DUE_ASC',
  PcDateDueDesc = 'PC_DATE_DUE_DESC',
  PcIdAsc = 'PC_ID_ASC',
  PcIdDesc = 'PC_ID_DESC',
  PcNameAsc = 'PC_NAME_ASC',
  PcNameDesc = 'PC_NAME_DESC',
  PcSymbolAsc = 'PC_SYMBOL_ASC',
  PcSymbolDesc = 'PC_SYMBOL_DESC',
  PcUseBaseAsc = 'PC_USE_BASE_ASC',
  PcUseBaseDesc = 'PC_USE_BASE_DESC',
  PcUsePrefixAsc = 'PC_USE_PREFIX_ASC',
  PcUsePrefixDesc = 'PC_USE_PREFIX_DESC',
  PcValidFromAsc = 'PC_VALID_FROM_ASC',
  PcValidFromDesc = 'PC_VALID_FROM_DESC',
  PcValidToAsc = 'PC_VALID_TO_ASC',
  PcValidToDesc = 'PC_VALID_TO_DESC',
  PcVisibleAsc = 'PC_VISIBLE_ASC',
  PcVisibleDesc = 'PC_VISIBLE_DESC',
  PlatbyCategoryGroupsByPcgIdCategoryCountAsc = 'PLATBY_CATEGORY_GROUPS_BY_PCG_ID_CATEGORY__COUNT_ASC',
  PlatbyCategoryGroupsByPcgIdCategoryCountDesc = 'PLATBY_CATEGORY_GROUPS_BY_PCG_ID_CATEGORY__COUNT_DESC',
  PlatbyItemsByPiIdCategoryCountAsc = 'PLATBY_ITEMS_BY_PI_ID_CATEGORY__COUNT_ASC',
  PlatbyItemsByPiIdCategoryCountDesc = 'PLATBY_ITEMS_BY_PI_ID_CATEGORY__COUNT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type PlatbyCategory = Node & {
  __typename?: 'PlatbyCategory';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  pcAmount: Scalars['BigFloat'];
  pcArchive: Scalars['Boolean'];
  pcDateDue: Scalars['Date'];
  pcId: Scalars['BigInt'];
  pcName: Scalars['String'];
  pcSymbol: Scalars['BigInt'];
  pcUseBase: Scalars['Boolean'];
  pcUsePrefix: Scalars['Boolean'];
  pcValidFrom: Scalars['Date'];
  pcValidTo: Scalars['Date'];
  pcVisible: Scalars['Boolean'];
  /** Reads and enables pagination through a set of `PlatbyCategoryGroup`. */
  platbyCategoryGroupsByPcgIdCategory: PlatbyCategoryGroupsConnection;
  /** Reads and enables pagination through a set of `PlatbyItem`. */
  platbyItemsByPiIdCategory: PlatbyItemsConnection;
};


export type PlatbyCategoryPlatbyCategoryGroupsByPcgIdCategoryArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyCategoryGroupCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyCategoryGroupsOrderBy>>;
};


export type PlatbyCategoryPlatbyItemsByPiIdCategoryArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyItemsOrderBy>>;
};

/**
 * A condition to be used against `PlatbyCategory` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PlatbyCategoryCondition = {
  /** Checks for equality with the object’s `pcAmount` field. */
  pcAmount?: InputMaybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `pcArchive` field. */
  pcArchive?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `pcDateDue` field. */
  pcDateDue?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `pcId` field. */
  pcId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pcName` field. */
  pcName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `pcSymbol` field. */
  pcSymbol?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pcUseBase` field. */
  pcUseBase?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `pcUsePrefix` field. */
  pcUsePrefix?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `pcValidFrom` field. */
  pcValidFrom?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `pcValidTo` field. */
  pcValidTo?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `pcVisible` field. */
  pcVisible?: InputMaybe<Scalars['Boolean']>;
};

export type PlatbyCategoryGroup = Node & {
  __typename?: 'PlatbyCategoryGroup';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  pcgId: Scalars['BigInt'];
  pcgIdCategory: Scalars['BigInt'];
  pcgIdGroup: Scalars['BigInt'];
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyCategoryGroup`. */
  platbyCategoryByPcgIdCategory: Maybe<PlatbyCategory>;
  /** Reads a single `PlatbyGroup` that is related to this `PlatbyCategoryGroup`. */
  platbyGroupByPcgIdGroup: Maybe<PlatbyGroup>;
};

/**
 * A condition to be used against `PlatbyCategoryGroup` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type PlatbyCategoryGroupCondition = {
  /** Checks for equality with the object’s `pcgId` field. */
  pcgId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pcgIdCategory` field. */
  pcgIdCategory?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pcgIdGroup` field. */
  pcgIdGroup?: InputMaybe<Scalars['BigInt']>;
};

/** An input for mutations affecting `PlatbyCategoryGroup` */
export type PlatbyCategoryGroupInput = {
  pcgId?: InputMaybe<Scalars['BigInt']>;
  pcgIdCategory: Scalars['BigInt'];
  pcgIdGroup: Scalars['BigInt'];
};

/** Represents an update to a `PlatbyCategoryGroup`. Fields that are set will be updated. */
export type PlatbyCategoryGroupPatch = {
  pcgId?: InputMaybe<Scalars['BigInt']>;
  pcgIdCategory?: InputMaybe<Scalars['BigInt']>;
  pcgIdGroup?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `PlatbyCategoryGroup` values. */
export type PlatbyCategoryGroupsConnection = {
  __typename?: 'PlatbyCategoryGroupsConnection';
  /** A list of edges which contains the `PlatbyCategoryGroup` and cursor to aid in pagination. */
  edges: Array<PlatbyCategoryGroupsEdge>;
  /** A list of `PlatbyCategoryGroup` objects. */
  nodes: Array<PlatbyCategoryGroup>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PlatbyCategoryGroup` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PlatbyCategoryGroup` edge in the connection. */
export type PlatbyCategoryGroupsEdge = {
  __typename?: 'PlatbyCategoryGroupsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `PlatbyCategoryGroup` at the end of the edge. */
  node: PlatbyCategoryGroup;
};

/** Methods to use when ordering `PlatbyCategoryGroup`. */
export enum PlatbyCategoryGroupsOrderBy {
  Natural = 'NATURAL',
  PcgIdAsc = 'PCG_ID_ASC',
  PcgIdCategoryAsc = 'PCG_ID_CATEGORY_ASC',
  PcgIdCategoryDesc = 'PCG_ID_CATEGORY_DESC',
  PcgIdDesc = 'PCG_ID_DESC',
  PcgIdGroupAsc = 'PCG_ID_GROUP_ASC',
  PcgIdGroupDesc = 'PCG_ID_GROUP_DESC',
  PlatbyCategoryByPcgIdCategoryPcAmountAsc = 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_AMOUNT_ASC',
  PlatbyCategoryByPcgIdCategoryPcAmountDesc = 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_AMOUNT_DESC',
  PlatbyCategoryByPcgIdCategoryPcArchiveAsc = 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_ARCHIVE_ASC',
  PlatbyCategoryByPcgIdCategoryPcArchiveDesc = 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_ARCHIVE_DESC',
  PlatbyCategoryByPcgIdCategoryPcDateDueAsc = 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_DATE_DUE_ASC',
  PlatbyCategoryByPcgIdCategoryPcDateDueDesc = 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_DATE_DUE_DESC',
  PlatbyCategoryByPcgIdCategoryPcIdAsc = 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_ID_ASC',
  PlatbyCategoryByPcgIdCategoryPcIdDesc = 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_ID_DESC',
  PlatbyCategoryByPcgIdCategoryPcNameAsc = 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_NAME_ASC',
  PlatbyCategoryByPcgIdCategoryPcNameDesc = 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_NAME_DESC',
  PlatbyCategoryByPcgIdCategoryPcSymbolAsc = 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_SYMBOL_ASC',
  PlatbyCategoryByPcgIdCategoryPcSymbolDesc = 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_SYMBOL_DESC',
  PlatbyCategoryByPcgIdCategoryPcUseBaseAsc = 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_USE_BASE_ASC',
  PlatbyCategoryByPcgIdCategoryPcUseBaseDesc = 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_USE_BASE_DESC',
  PlatbyCategoryByPcgIdCategoryPcUsePrefixAsc = 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_USE_PREFIX_ASC',
  PlatbyCategoryByPcgIdCategoryPcUsePrefixDesc = 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_USE_PREFIX_DESC',
  PlatbyCategoryByPcgIdCategoryPcValidFromAsc = 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_VALID_FROM_ASC',
  PlatbyCategoryByPcgIdCategoryPcValidFromDesc = 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_VALID_FROM_DESC',
  PlatbyCategoryByPcgIdCategoryPcValidToAsc = 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_VALID_TO_ASC',
  PlatbyCategoryByPcgIdCategoryPcValidToDesc = 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_VALID_TO_DESC',
  PlatbyCategoryByPcgIdCategoryPcVisibleAsc = 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_VISIBLE_ASC',
  PlatbyCategoryByPcgIdCategoryPcVisibleDesc = 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_VISIBLE_DESC',
  PlatbyGroupByPcgIdGroupPgBaseAsc = 'PLATBY_GROUP_BY_PCG_ID_GROUP__PG_BASE_ASC',
  PlatbyGroupByPcgIdGroupPgBaseDesc = 'PLATBY_GROUP_BY_PCG_ID_GROUP__PG_BASE_DESC',
  PlatbyGroupByPcgIdGroupPgDescriptionAsc = 'PLATBY_GROUP_BY_PCG_ID_GROUP__PG_DESCRIPTION_ASC',
  PlatbyGroupByPcgIdGroupPgDescriptionDesc = 'PLATBY_GROUP_BY_PCG_ID_GROUP__PG_DESCRIPTION_DESC',
  PlatbyGroupByPcgIdGroupPgIdAsc = 'PLATBY_GROUP_BY_PCG_ID_GROUP__PG_ID_ASC',
  PlatbyGroupByPcgIdGroupPgIdDesc = 'PLATBY_GROUP_BY_PCG_ID_GROUP__PG_ID_DESC',
  PlatbyGroupByPcgIdGroupPgNameAsc = 'PLATBY_GROUP_BY_PCG_ID_GROUP__PG_NAME_ASC',
  PlatbyGroupByPcgIdGroupPgNameDesc = 'PLATBY_GROUP_BY_PCG_ID_GROUP__PG_NAME_DESC',
  PlatbyGroupByPcgIdGroupPgTypeAsc = 'PLATBY_GROUP_BY_PCG_ID_GROUP__PG_TYPE_ASC',
  PlatbyGroupByPcgIdGroupPgTypeDesc = 'PLATBY_GROUP_BY_PCG_ID_GROUP__PG_TYPE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** An input for mutations affecting `PlatbyCategory` */
export type PlatbyCategoryInput = {
  pcAmount: Scalars['BigFloat'];
  pcArchive?: InputMaybe<Scalars['Boolean']>;
  pcDateDue: Scalars['Date'];
  pcId?: InputMaybe<Scalars['BigInt']>;
  pcName: Scalars['String'];
  pcSymbol: Scalars['BigInt'];
  pcUseBase?: InputMaybe<Scalars['Boolean']>;
  pcUsePrefix?: InputMaybe<Scalars['Boolean']>;
  pcValidFrom: Scalars['Date'];
  pcValidTo: Scalars['Date'];
  pcVisible?: InputMaybe<Scalars['Boolean']>;
};

/** Represents an update to a `PlatbyCategory`. Fields that are set will be updated. */
export type PlatbyCategoryPatch = {
  pcAmount?: InputMaybe<Scalars['BigFloat']>;
  pcArchive?: InputMaybe<Scalars['Boolean']>;
  pcDateDue?: InputMaybe<Scalars['Date']>;
  pcId?: InputMaybe<Scalars['BigInt']>;
  pcName?: InputMaybe<Scalars['String']>;
  pcSymbol?: InputMaybe<Scalars['BigInt']>;
  pcUseBase?: InputMaybe<Scalars['Boolean']>;
  pcUsePrefix?: InputMaybe<Scalars['Boolean']>;
  pcValidFrom?: InputMaybe<Scalars['Date']>;
  pcValidTo?: InputMaybe<Scalars['Date']>;
  pcVisible?: InputMaybe<Scalars['Boolean']>;
};

export type PlatbyGroup = Node & {
  __typename?: 'PlatbyGroup';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  pgBase: Scalars['BigInt'];
  pgDescription: Scalars['String'];
  pgId: Scalars['BigInt'];
  pgName: Scalars['String'];
  pgType: Scalars['BigFloat'];
  /** Reads and enables pagination through a set of `PlatbyCategoryGroup`. */
  platbyCategoryGroupsByPcgIdGroup: PlatbyCategoryGroupsConnection;
  /** Reads and enables pagination through a set of `PlatbyGroupSkupina`. */
  platbyGroupSkupinasByPgsIdGroup: PlatbyGroupSkupinasConnection;
};


export type PlatbyGroupPlatbyCategoryGroupsByPcgIdGroupArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyCategoryGroupCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyCategoryGroupsOrderBy>>;
};


export type PlatbyGroupPlatbyGroupSkupinasByPgsIdGroupArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyGroupSkupinaCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyGroupSkupinasOrderBy>>;
};

/**
 * A condition to be used against `PlatbyGroup` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PlatbyGroupCondition = {
  /** Checks for equality with the object’s `pgBase` field. */
  pgBase?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pgDescription` field. */
  pgDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `pgId` field. */
  pgId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pgName` field. */
  pgName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `pgType` field. */
  pgType?: InputMaybe<Scalars['BigFloat']>;
};

/** An input for mutations affecting `PlatbyGroup` */
export type PlatbyGroupInput = {
  pgBase?: InputMaybe<Scalars['BigInt']>;
  pgDescription: Scalars['String'];
  pgId?: InputMaybe<Scalars['BigInt']>;
  pgName: Scalars['String'];
  pgType?: InputMaybe<Scalars['BigFloat']>;
};

/** Represents an update to a `PlatbyGroup`. Fields that are set will be updated. */
export type PlatbyGroupPatch = {
  pgBase?: InputMaybe<Scalars['BigInt']>;
  pgDescription?: InputMaybe<Scalars['String']>;
  pgId?: InputMaybe<Scalars['BigInt']>;
  pgName?: InputMaybe<Scalars['String']>;
  pgType?: InputMaybe<Scalars['BigFloat']>;
};

/** A connection to a list of `PlatbyGroup` values. */
export type PlatbyGroupsConnection = {
  __typename?: 'PlatbyGroupsConnection';
  /** A list of edges which contains the `PlatbyGroup` and cursor to aid in pagination. */
  edges: Array<PlatbyGroupsEdge>;
  /** A list of `PlatbyGroup` objects. */
  nodes: Array<PlatbyGroup>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PlatbyGroup` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PlatbyGroup` edge in the connection. */
export type PlatbyGroupsEdge = {
  __typename?: 'PlatbyGroupsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `PlatbyGroup` at the end of the edge. */
  node: PlatbyGroup;
};

export type PlatbyGroupSkupina = Node & {
  __typename?: 'PlatbyGroupSkupina';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  pgsId: Scalars['BigInt'];
  pgsIdGroup: Scalars['BigInt'];
  pgsIdSkupina: Scalars['BigInt'];
  /** Reads a single `PlatbyGroup` that is related to this `PlatbyGroupSkupina`. */
  platbyGroupByPgsIdGroup: Maybe<PlatbyGroup>;
  /** Reads a single `Skupiny` that is related to this `PlatbyGroupSkupina`. */
  skupinyByPgsIdSkupina: Maybe<Skupiny>;
};

/**
 * A condition to be used against `PlatbyGroupSkupina` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PlatbyGroupSkupinaCondition = {
  /** Checks for equality with the object’s `pgsId` field. */
  pgsId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pgsIdGroup` field. */
  pgsIdGroup?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pgsIdSkupina` field. */
  pgsIdSkupina?: InputMaybe<Scalars['BigInt']>;
};

/** An input for mutations affecting `PlatbyGroupSkupina` */
export type PlatbyGroupSkupinaInput = {
  pgsId?: InputMaybe<Scalars['BigInt']>;
  pgsIdGroup: Scalars['BigInt'];
  pgsIdSkupina: Scalars['BigInt'];
};

/** Represents an update to a `PlatbyGroupSkupina`. Fields that are set will be updated. */
export type PlatbyGroupSkupinaPatch = {
  pgsId?: InputMaybe<Scalars['BigInt']>;
  pgsIdGroup?: InputMaybe<Scalars['BigInt']>;
  pgsIdSkupina?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `PlatbyGroupSkupina` values. */
export type PlatbyGroupSkupinasConnection = {
  __typename?: 'PlatbyGroupSkupinasConnection';
  /** A list of edges which contains the `PlatbyGroupSkupina` and cursor to aid in pagination. */
  edges: Array<PlatbyGroupSkupinasEdge>;
  /** A list of `PlatbyGroupSkupina` objects. */
  nodes: Array<PlatbyGroupSkupina>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PlatbyGroupSkupina` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PlatbyGroupSkupina` edge in the connection. */
export type PlatbyGroupSkupinasEdge = {
  __typename?: 'PlatbyGroupSkupinasEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `PlatbyGroupSkupina` at the end of the edge. */
  node: PlatbyGroupSkupina;
};

/** Methods to use when ordering `PlatbyGroupSkupina`. */
export enum PlatbyGroupSkupinasOrderBy {
  Natural = 'NATURAL',
  PgsIdAsc = 'PGS_ID_ASC',
  PgsIdDesc = 'PGS_ID_DESC',
  PgsIdGroupAsc = 'PGS_ID_GROUP_ASC',
  PgsIdGroupDesc = 'PGS_ID_GROUP_DESC',
  PgsIdSkupinaAsc = 'PGS_ID_SKUPINA_ASC',
  PgsIdSkupinaDesc = 'PGS_ID_SKUPINA_DESC',
  PlatbyGroupByPgsIdGroupPgBaseAsc = 'PLATBY_GROUP_BY_PGS_ID_GROUP__PG_BASE_ASC',
  PlatbyGroupByPgsIdGroupPgBaseDesc = 'PLATBY_GROUP_BY_PGS_ID_GROUP__PG_BASE_DESC',
  PlatbyGroupByPgsIdGroupPgDescriptionAsc = 'PLATBY_GROUP_BY_PGS_ID_GROUP__PG_DESCRIPTION_ASC',
  PlatbyGroupByPgsIdGroupPgDescriptionDesc = 'PLATBY_GROUP_BY_PGS_ID_GROUP__PG_DESCRIPTION_DESC',
  PlatbyGroupByPgsIdGroupPgIdAsc = 'PLATBY_GROUP_BY_PGS_ID_GROUP__PG_ID_ASC',
  PlatbyGroupByPgsIdGroupPgIdDesc = 'PLATBY_GROUP_BY_PGS_ID_GROUP__PG_ID_DESC',
  PlatbyGroupByPgsIdGroupPgNameAsc = 'PLATBY_GROUP_BY_PGS_ID_GROUP__PG_NAME_ASC',
  PlatbyGroupByPgsIdGroupPgNameDesc = 'PLATBY_GROUP_BY_PGS_ID_GROUP__PG_NAME_DESC',
  PlatbyGroupByPgsIdGroupPgTypeAsc = 'PLATBY_GROUP_BY_PGS_ID_GROUP__PG_TYPE_ASC',
  PlatbyGroupByPgsIdGroupPgTypeDesc = 'PLATBY_GROUP_BY_PGS_ID_GROUP__PG_TYPE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SkupinyByPgsIdSkupinaCohortGroupAsc = 'SKUPINY_BY_PGS_ID_SKUPINA__COHORT_GROUP_ASC',
  SkupinyByPgsIdSkupinaCohortGroupDesc = 'SKUPINY_BY_PGS_ID_SKUPINA__COHORT_GROUP_DESC',
  SkupinyByPgsIdSkupinaInternalInfoAsc = 'SKUPINY_BY_PGS_ID_SKUPINA__INTERNAL_INFO_ASC',
  SkupinyByPgsIdSkupinaInternalInfoDesc = 'SKUPINY_BY_PGS_ID_SKUPINA__INTERNAL_INFO_DESC',
  SkupinyByPgsIdSkupinaOrderingAsc = 'SKUPINY_BY_PGS_ID_SKUPINA__ORDERING_ASC',
  SkupinyByPgsIdSkupinaOrderingDesc = 'SKUPINY_BY_PGS_ID_SKUPINA__ORDERING_DESC',
  SkupinyByPgsIdSkupinaSColorRgbAsc = 'SKUPINY_BY_PGS_ID_SKUPINA__S_COLOR_RGB_ASC',
  SkupinyByPgsIdSkupinaSColorRgbDesc = 'SKUPINY_BY_PGS_ID_SKUPINA__S_COLOR_RGB_DESC',
  SkupinyByPgsIdSkupinaSColorTextAsc = 'SKUPINY_BY_PGS_ID_SKUPINA__S_COLOR_TEXT_ASC',
  SkupinyByPgsIdSkupinaSColorTextDesc = 'SKUPINY_BY_PGS_ID_SKUPINA__S_COLOR_TEXT_DESC',
  SkupinyByPgsIdSkupinaSDescriptionAsc = 'SKUPINY_BY_PGS_ID_SKUPINA__S_DESCRIPTION_ASC',
  SkupinyByPgsIdSkupinaSDescriptionDesc = 'SKUPINY_BY_PGS_ID_SKUPINA__S_DESCRIPTION_DESC',
  SkupinyByPgsIdSkupinaSIdAsc = 'SKUPINY_BY_PGS_ID_SKUPINA__S_ID_ASC',
  SkupinyByPgsIdSkupinaSIdDesc = 'SKUPINY_BY_PGS_ID_SKUPINA__S_ID_DESC',
  SkupinyByPgsIdSkupinaSLocationAsc = 'SKUPINY_BY_PGS_ID_SKUPINA__S_LOCATION_ASC',
  SkupinyByPgsIdSkupinaSLocationDesc = 'SKUPINY_BY_PGS_ID_SKUPINA__S_LOCATION_DESC',
  SkupinyByPgsIdSkupinaSNameAsc = 'SKUPINY_BY_PGS_ID_SKUPINA__S_NAME_ASC',
  SkupinyByPgsIdSkupinaSNameDesc = 'SKUPINY_BY_PGS_ID_SKUPINA__S_NAME_DESC',
  SkupinyByPgsIdSkupinaSVisibleAsc = 'SKUPINY_BY_PGS_ID_SKUPINA__S_VISIBLE_ASC',
  SkupinyByPgsIdSkupinaSVisibleDesc = 'SKUPINY_BY_PGS_ID_SKUPINA__S_VISIBLE_DESC'
}

/** Methods to use when ordering `PlatbyGroup`. */
export enum PlatbyGroupsOrderBy {
  Natural = 'NATURAL',
  PgBaseAsc = 'PG_BASE_ASC',
  PgBaseDesc = 'PG_BASE_DESC',
  PgDescriptionAsc = 'PG_DESCRIPTION_ASC',
  PgDescriptionDesc = 'PG_DESCRIPTION_DESC',
  PgIdAsc = 'PG_ID_ASC',
  PgIdDesc = 'PG_ID_DESC',
  PgNameAsc = 'PG_NAME_ASC',
  PgNameDesc = 'PG_NAME_DESC',
  PgTypeAsc = 'PG_TYPE_ASC',
  PgTypeDesc = 'PG_TYPE_DESC',
  PlatbyCategoryGroupsByPcgIdGroupCountAsc = 'PLATBY_CATEGORY_GROUPS_BY_PCG_ID_GROUP__COUNT_ASC',
  PlatbyCategoryGroupsByPcgIdGroupCountDesc = 'PLATBY_CATEGORY_GROUPS_BY_PCG_ID_GROUP__COUNT_DESC',
  PlatbyGroupSkupinasByPgsIdGroupCountAsc = 'PLATBY_GROUP_SKUPINAS_BY_PGS_ID_GROUP__COUNT_ASC',
  PlatbyGroupSkupinasByPgsIdGroupCountDesc = 'PLATBY_GROUP_SKUPINAS_BY_PGS_ID_GROUP__COUNT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type PlatbyItem = Node & {
  __typename?: 'PlatbyItem';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  piAmount: Scalars['BigFloat'];
  piDate: Scalars['Date'];
  piId: Scalars['BigInt'];
  piIdCategory: Scalars['BigInt'];
  piIdRaw: Maybe<Scalars['BigInt']>;
  piIdUser: Maybe<Scalars['BigInt']>;
  piPrefix: Scalars['Int'];
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
  platbyCategoryByPiIdCategory: Maybe<PlatbyCategory>;
  /** Reads a single `PlatbyRaw` that is related to this `PlatbyItem`. */
  platbyRawByPiIdRaw: Maybe<PlatbyRaw>;
  /** Reads a single `User` that is related to this `PlatbyItem`. */
  userByPiIdUser: Maybe<User>;
};

/**
 * A condition to be used against `PlatbyItem` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PlatbyItemCondition = {
  /** Checks for equality with the object’s `piAmount` field. */
  piAmount?: InputMaybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `piDate` field. */
  piDate?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `piId` field. */
  piId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `piIdCategory` field. */
  piIdCategory?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `piIdRaw` field. */
  piIdRaw?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `piIdUser` field. */
  piIdUser?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `piPrefix` field. */
  piPrefix?: InputMaybe<Scalars['Int']>;
};

/** An input for mutations affecting `PlatbyItem` */
export type PlatbyItemInput = {
  piAmount: Scalars['BigFloat'];
  piDate: Scalars['Date'];
  piId?: InputMaybe<Scalars['BigInt']>;
  piIdCategory: Scalars['BigInt'];
  piIdRaw?: InputMaybe<Scalars['BigInt']>;
  piIdUser?: InputMaybe<Scalars['BigInt']>;
  piPrefix?: InputMaybe<Scalars['Int']>;
};

/** Represents an update to a `PlatbyItem`. Fields that are set will be updated. */
export type PlatbyItemPatch = {
  piAmount?: InputMaybe<Scalars['BigFloat']>;
  piDate?: InputMaybe<Scalars['Date']>;
  piId?: InputMaybe<Scalars['BigInt']>;
  piIdCategory?: InputMaybe<Scalars['BigInt']>;
  piIdRaw?: InputMaybe<Scalars['BigInt']>;
  piIdUser?: InputMaybe<Scalars['BigInt']>;
  piPrefix?: InputMaybe<Scalars['Int']>;
};

/** A connection to a list of `PlatbyItem` values. */
export type PlatbyItemsConnection = {
  __typename?: 'PlatbyItemsConnection';
  /** A list of edges which contains the `PlatbyItem` and cursor to aid in pagination. */
  edges: Array<PlatbyItemsEdge>;
  /** A list of `PlatbyItem` objects. */
  nodes: Array<PlatbyItem>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PlatbyItem` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PlatbyItem` edge in the connection. */
export type PlatbyItemsEdge = {
  __typename?: 'PlatbyItemsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `PlatbyItem` at the end of the edge. */
  node: PlatbyItem;
};

/** Methods to use when ordering `PlatbyItem`. */
export enum PlatbyItemsOrderBy {
  Natural = 'NATURAL',
  PiAmountAsc = 'PI_AMOUNT_ASC',
  PiAmountDesc = 'PI_AMOUNT_DESC',
  PiDateAsc = 'PI_DATE_ASC',
  PiDateDesc = 'PI_DATE_DESC',
  PiIdAsc = 'PI_ID_ASC',
  PiIdCategoryAsc = 'PI_ID_CATEGORY_ASC',
  PiIdCategoryDesc = 'PI_ID_CATEGORY_DESC',
  PiIdDesc = 'PI_ID_DESC',
  PiIdRawAsc = 'PI_ID_RAW_ASC',
  PiIdRawDesc = 'PI_ID_RAW_DESC',
  PiIdUserAsc = 'PI_ID_USER_ASC',
  PiIdUserDesc = 'PI_ID_USER_DESC',
  PiPrefixAsc = 'PI_PREFIX_ASC',
  PiPrefixDesc = 'PI_PREFIX_DESC',
  PlatbyCategoryByPiIdCategoryPcAmountAsc = 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_AMOUNT_ASC',
  PlatbyCategoryByPiIdCategoryPcAmountDesc = 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_AMOUNT_DESC',
  PlatbyCategoryByPiIdCategoryPcArchiveAsc = 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_ARCHIVE_ASC',
  PlatbyCategoryByPiIdCategoryPcArchiveDesc = 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_ARCHIVE_DESC',
  PlatbyCategoryByPiIdCategoryPcDateDueAsc = 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_DATE_DUE_ASC',
  PlatbyCategoryByPiIdCategoryPcDateDueDesc = 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_DATE_DUE_DESC',
  PlatbyCategoryByPiIdCategoryPcIdAsc = 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_ID_ASC',
  PlatbyCategoryByPiIdCategoryPcIdDesc = 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_ID_DESC',
  PlatbyCategoryByPiIdCategoryPcNameAsc = 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_NAME_ASC',
  PlatbyCategoryByPiIdCategoryPcNameDesc = 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_NAME_DESC',
  PlatbyCategoryByPiIdCategoryPcSymbolAsc = 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_SYMBOL_ASC',
  PlatbyCategoryByPiIdCategoryPcSymbolDesc = 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_SYMBOL_DESC',
  PlatbyCategoryByPiIdCategoryPcUseBaseAsc = 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_USE_BASE_ASC',
  PlatbyCategoryByPiIdCategoryPcUseBaseDesc = 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_USE_BASE_DESC',
  PlatbyCategoryByPiIdCategoryPcUsePrefixAsc = 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_USE_PREFIX_ASC',
  PlatbyCategoryByPiIdCategoryPcUsePrefixDesc = 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_USE_PREFIX_DESC',
  PlatbyCategoryByPiIdCategoryPcValidFromAsc = 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_VALID_FROM_ASC',
  PlatbyCategoryByPiIdCategoryPcValidFromDesc = 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_VALID_FROM_DESC',
  PlatbyCategoryByPiIdCategoryPcValidToAsc = 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_VALID_TO_ASC',
  PlatbyCategoryByPiIdCategoryPcValidToDesc = 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_VALID_TO_DESC',
  PlatbyCategoryByPiIdCategoryPcVisibleAsc = 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_VISIBLE_ASC',
  PlatbyCategoryByPiIdCategoryPcVisibleDesc = 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_VISIBLE_DESC',
  PlatbyRawByPiIdRawPrDiscardedAsc = 'PLATBY_RAW_BY_PI_ID_RAW__PR_DISCARDED_ASC',
  PlatbyRawByPiIdRawPrDiscardedDesc = 'PLATBY_RAW_BY_PI_ID_RAW__PR_DISCARDED_DESC',
  PlatbyRawByPiIdRawPrHashAsc = 'PLATBY_RAW_BY_PI_ID_RAW__PR_HASH_ASC',
  PlatbyRawByPiIdRawPrHashDesc = 'PLATBY_RAW_BY_PI_ID_RAW__PR_HASH_DESC',
  PlatbyRawByPiIdRawPrIdAsc = 'PLATBY_RAW_BY_PI_ID_RAW__PR_ID_ASC',
  PlatbyRawByPiIdRawPrIdDesc = 'PLATBY_RAW_BY_PI_ID_RAW__PR_ID_DESC',
  PlatbyRawByPiIdRawPrRawAsc = 'PLATBY_RAW_BY_PI_ID_RAW__PR_RAW_ASC',
  PlatbyRawByPiIdRawPrRawDesc = 'PLATBY_RAW_BY_PI_ID_RAW__PR_RAW_DESC',
  PlatbyRawByPiIdRawPrSortedAsc = 'PLATBY_RAW_BY_PI_ID_RAW__PR_SORTED_ASC',
  PlatbyRawByPiIdRawPrSortedDesc = 'PLATBY_RAW_BY_PI_ID_RAW__PR_SORTED_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserByPiIdUserUBanAsc = 'USER_BY_PI_ID_USER__U_BAN_ASC',
  UserByPiIdUserUBanDesc = 'USER_BY_PI_ID_USER__U_BAN_DESC',
  UserByPiIdUserUCityAsc = 'USER_BY_PI_ID_USER__U_CITY_ASC',
  UserByPiIdUserUCityDesc = 'USER_BY_PI_ID_USER__U_CITY_DESC',
  UserByPiIdUserUConfirmedAsc = 'USER_BY_PI_ID_USER__U_CONFIRMED_ASC',
  UserByPiIdUserUConfirmedDesc = 'USER_BY_PI_ID_USER__U_CONFIRMED_DESC',
  UserByPiIdUserUConscriptionNumberAsc = 'USER_BY_PI_ID_USER__U_CONSCRIPTION_NUMBER_ASC',
  UserByPiIdUserUConscriptionNumberDesc = 'USER_BY_PI_ID_USER__U_CONSCRIPTION_NUMBER_DESC',
  UserByPiIdUserUCreatedAtAsc = 'USER_BY_PI_ID_USER__U_CREATED_AT_ASC',
  UserByPiIdUserUCreatedAtDesc = 'USER_BY_PI_ID_USER__U_CREATED_AT_DESC',
  UserByPiIdUserUDancerAsc = 'USER_BY_PI_ID_USER__U_DANCER_ASC',
  UserByPiIdUserUDancerDesc = 'USER_BY_PI_ID_USER__U_DANCER_DESC',
  UserByPiIdUserUDistrictAsc = 'USER_BY_PI_ID_USER__U_DISTRICT_ASC',
  UserByPiIdUserUDistrictDesc = 'USER_BY_PI_ID_USER__U_DISTRICT_DESC',
  UserByPiIdUserUEmailAsc = 'USER_BY_PI_ID_USER__U_EMAIL_ASC',
  UserByPiIdUserUEmailDesc = 'USER_BY_PI_ID_USER__U_EMAIL_DESC',
  UserByPiIdUserUGdprSignedAtAsc = 'USER_BY_PI_ID_USER__U_GDPR_SIGNED_AT_ASC',
  UserByPiIdUserUGdprSignedAtDesc = 'USER_BY_PI_ID_USER__U_GDPR_SIGNED_AT_DESC',
  UserByPiIdUserUGroupAsc = 'USER_BY_PI_ID_USER__U_GROUP_ASC',
  UserByPiIdUserUGroupDesc = 'USER_BY_PI_ID_USER__U_GROUP_DESC',
  UserByPiIdUserUIdAsc = 'USER_BY_PI_ID_USER__U_ID_ASC',
  UserByPiIdUserUIdDesc = 'USER_BY_PI_ID_USER__U_ID_DESC',
  UserByPiIdUserUJmenoAsc = 'USER_BY_PI_ID_USER__U_JMENO_ASC',
  UserByPiIdUserUJmenoDesc = 'USER_BY_PI_ID_USER__U_JMENO_DESC',
  UserByPiIdUserULevelAsc = 'USER_BY_PI_ID_USER__U_LEVEL_ASC',
  UserByPiIdUserULevelDesc = 'USER_BY_PI_ID_USER__U_LEVEL_DESC',
  UserByPiIdUserULockAsc = 'USER_BY_PI_ID_USER__U_LOCK_ASC',
  UserByPiIdUserULockDesc = 'USER_BY_PI_ID_USER__U_LOCK_DESC',
  UserByPiIdUserULoginAsc = 'USER_BY_PI_ID_USER__U_LOGIN_ASC',
  UserByPiIdUserULoginDesc = 'USER_BY_PI_ID_USER__U_LOGIN_DESC',
  UserByPiIdUserUMemberSinceAsc = 'USER_BY_PI_ID_USER__U_MEMBER_SINCE_ASC',
  UserByPiIdUserUMemberSinceDesc = 'USER_BY_PI_ID_USER__U_MEMBER_SINCE_DESC',
  UserByPiIdUserUMemberUntilAsc = 'USER_BY_PI_ID_USER__U_MEMBER_UNTIL_ASC',
  UserByPiIdUserUMemberUntilDesc = 'USER_BY_PI_ID_USER__U_MEMBER_UNTIL_DESC',
  UserByPiIdUserUNarozeniAsc = 'USER_BY_PI_ID_USER__U_NAROZENI_ASC',
  UserByPiIdUserUNarozeniDesc = 'USER_BY_PI_ID_USER__U_NAROZENI_DESC',
  UserByPiIdUserUNationalityAsc = 'USER_BY_PI_ID_USER__U_NATIONALITY_ASC',
  UserByPiIdUserUNationalityDesc = 'USER_BY_PI_ID_USER__U_NATIONALITY_DESC',
  UserByPiIdUserUOrientationNumberAsc = 'USER_BY_PI_ID_USER__U_ORIENTATION_NUMBER_ASC',
  UserByPiIdUserUOrientationNumberDesc = 'USER_BY_PI_ID_USER__U_ORIENTATION_NUMBER_DESC',
  UserByPiIdUserUPassAsc = 'USER_BY_PI_ID_USER__U_PASS_ASC',
  UserByPiIdUserUPassDesc = 'USER_BY_PI_ID_USER__U_PASS_DESC',
  UserByPiIdUserUPohlaviAsc = 'USER_BY_PI_ID_USER__U_POHLAVI_ASC',
  UserByPiIdUserUPohlaviDesc = 'USER_BY_PI_ID_USER__U_POHLAVI_DESC',
  UserByPiIdUserUPostalCodeAsc = 'USER_BY_PI_ID_USER__U_POSTAL_CODE_ASC',
  UserByPiIdUserUPostalCodeDesc = 'USER_BY_PI_ID_USER__U_POSTAL_CODE_DESC',
  UserByPiIdUserUPoznamkyAsc = 'USER_BY_PI_ID_USER__U_POZNAMKY_ASC',
  UserByPiIdUserUPoznamkyDesc = 'USER_BY_PI_ID_USER__U_POZNAMKY_DESC',
  UserByPiIdUserUPrijmeniAsc = 'USER_BY_PI_ID_USER__U_PRIJMENI_ASC',
  UserByPiIdUserUPrijmeniDesc = 'USER_BY_PI_ID_USER__U_PRIJMENI_DESC',
  UserByPiIdUserURodneCisloAsc = 'USER_BY_PI_ID_USER__U_RODNE_CISLO_ASC',
  UserByPiIdUserURodneCisloDesc = 'USER_BY_PI_ID_USER__U_RODNE_CISLO_DESC',
  UserByPiIdUserUSkupinaAsc = 'USER_BY_PI_ID_USER__U_SKUPINA_ASC',
  UserByPiIdUserUSkupinaDesc = 'USER_BY_PI_ID_USER__U_SKUPINA_DESC',
  UserByPiIdUserUStreetAsc = 'USER_BY_PI_ID_USER__U_STREET_ASC',
  UserByPiIdUserUStreetDesc = 'USER_BY_PI_ID_USER__U_STREET_DESC',
  UserByPiIdUserUSystemAsc = 'USER_BY_PI_ID_USER__U_SYSTEM_ASC',
  UserByPiIdUserUSystemDesc = 'USER_BY_PI_ID_USER__U_SYSTEM_DESC',
  UserByPiIdUserUTeacherAsc = 'USER_BY_PI_ID_USER__U_TEACHER_ASC',
  UserByPiIdUserUTeacherDesc = 'USER_BY_PI_ID_USER__U_TEACHER_DESC',
  UserByPiIdUserUTelefonAsc = 'USER_BY_PI_ID_USER__U_TELEFON_ASC',
  UserByPiIdUserUTelefonDesc = 'USER_BY_PI_ID_USER__U_TELEFON_DESC',
  UserByPiIdUserUTimestampAsc = 'USER_BY_PI_ID_USER__U_TIMESTAMP_ASC',
  UserByPiIdUserUTimestampDesc = 'USER_BY_PI_ID_USER__U_TIMESTAMP_DESC'
}

export type PlatbyRaw = Node & {
  __typename?: 'PlatbyRaw';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads and enables pagination through a set of `PlatbyItem`. */
  platbyItemsByPiIdRaw: PlatbyItemsConnection;
  prDiscarded: Scalars['Boolean'];
  prHash: Scalars['String'];
  prId: Scalars['BigInt'];
  prRaw: Scalars['String'];
  prSorted: Scalars['Boolean'];
};


export type PlatbyRawPlatbyItemsByPiIdRawArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyItemsOrderBy>>;
};

/**
 * A condition to be used against `PlatbyRaw` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PlatbyRawCondition = {
  /** Checks for equality with the object’s `prDiscarded` field. */
  prDiscarded?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `prHash` field. */
  prHash?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `prId` field. */
  prId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `prRaw` field. */
  prRaw?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `prSorted` field. */
  prSorted?: InputMaybe<Scalars['Boolean']>;
};

/** An input for mutations affecting `PlatbyRaw` */
export type PlatbyRawInput = {
  prDiscarded?: InputMaybe<Scalars['Boolean']>;
  prHash: Scalars['String'];
  prId?: InputMaybe<Scalars['BigInt']>;
  prRaw: Scalars['String'];
  prSorted?: InputMaybe<Scalars['Boolean']>;
};

/** Represents an update to a `PlatbyRaw`. Fields that are set will be updated. */
export type PlatbyRawPatch = {
  prDiscarded?: InputMaybe<Scalars['Boolean']>;
  prHash?: InputMaybe<Scalars['String']>;
  prId?: InputMaybe<Scalars['BigInt']>;
  prRaw?: InputMaybe<Scalars['String']>;
  prSorted?: InputMaybe<Scalars['Boolean']>;
};

/** A connection to a list of `PlatbyRaw` values. */
export type PlatbyRawsConnection = {
  __typename?: 'PlatbyRawsConnection';
  /** A list of edges which contains the `PlatbyRaw` and cursor to aid in pagination. */
  edges: Array<PlatbyRawsEdge>;
  /** A list of `PlatbyRaw` objects. */
  nodes: Array<PlatbyRaw>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PlatbyRaw` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PlatbyRaw` edge in the connection. */
export type PlatbyRawsEdge = {
  __typename?: 'PlatbyRawsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `PlatbyRaw` at the end of the edge. */
  node: PlatbyRaw;
};

/** Methods to use when ordering `PlatbyRaw`. */
export enum PlatbyRawsOrderBy {
  Natural = 'NATURAL',
  PlatbyItemsByPiIdRawCountAsc = 'PLATBY_ITEMS_BY_PI_ID_RAW__COUNT_ASC',
  PlatbyItemsByPiIdRawCountDesc = 'PLATBY_ITEMS_BY_PI_ID_RAW__COUNT_DESC',
  PrDiscardedAsc = 'PR_DISCARDED_ASC',
  PrDiscardedDesc = 'PR_DISCARDED_DESC',
  PrHashAsc = 'PR_HASH_ASC',
  PrHashDesc = 'PR_HASH_DESC',
  PrIdAsc = 'PR_ID_ASC',
  PrIdDesc = 'PR_ID_DESC',
  PrRawAsc = 'PR_RAW_ASC',
  PrRawDesc = 'PR_RAW_DESC',
  PrSortedAsc = 'PR_SORTED_ASC',
  PrSortedDesc = 'PR_SORTED_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type ProspectDatum = {
  __typename?: 'ProspectDatum';
  email: Maybe<Scalars['String']>;
  name: Maybe<Scalars['String']>;
  phone: Maybe<Scalars['String']>;
  surname: Maybe<Scalars['String']>;
  yearofbirth: Maybe<Scalars['String']>;
};

/** An input for mutations affecting `ProspectDatum` */
export type ProspectDatumInput = {
  email?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  phone?: InputMaybe<Scalars['String']>;
  surname?: InputMaybe<Scalars['String']>;
  yearofbirth?: InputMaybe<Scalars['String']>;
};

/** All input for the `prospectFormDancer` mutation. */
export type ProspectFormDancerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  cohort: CrmCohort;
  note: Scalars['String'];
  origin: Scalars['String'];
  prospectData: ProspectDatumInput;
};

/** The output of our `prospectFormDancer` mutation. */
export type ProspectFormDancerPayload = {
  __typename?: 'ProspectFormDancerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** The root query type which gives access points into the data universe. */
export type Query = Node & {
  __typename?: 'Query';
  /** Reads and enables pagination through a set of `Pary`. */
  activeCouples: Maybe<PariesConnection>;
  activeProspects: Maybe<ActiveProspectsConnection>;
  /** Reads and enables pagination through a set of `AkceItem`. */
  akceItems: Maybe<AkceItemsConnection>;
  /** Reads and enables pagination through a set of `Akce`. */
  akces: Maybe<AkcesConnection>;
  /** Reads and enables pagination through a set of `Aktuality`. */
  aktualities: Maybe<AktualitiesConnection>;
  aktuality: Maybe<Aktuality>;
  /** Reads a single `Aktuality` using its globally unique `ID`. */
  aktualityByNodeId: Maybe<Aktuality>;
  attachment: Maybe<Attachment>;
  /** Reads a single `Attachment` using its globally unique `ID`. */
  attachmentByNodeId: Maybe<Attachment>;
  /** Reads and enables pagination through a set of `Attachment`. */
  attachments: Maybe<AttachmentsConnection>;
  attendeeExternal: Maybe<AttendeeExternal>;
  /** Reads a single `AttendeeExternal` using its globally unique `ID`. */
  attendeeExternalByNodeId: Maybe<AttendeeExternal>;
  /** Reads and enables pagination through a set of `AttendeeExternal`. */
  attendeeExternals: Maybe<AttendeeExternalsConnection>;
  attendeeUser: Maybe<AttendeeUser>;
  /** Reads a single `AttendeeUser` using its globally unique `ID`. */
  attendeeUserByNodeId: Maybe<AttendeeUser>;
  attendeeUserByUserIdAndEventId: Maybe<AttendeeUser>;
  /** Reads and enables pagination through a set of `AttendeeUser`. */
  attendeeUsers: Maybe<AttendeeUsersConnection>;
  cohortGroup: Maybe<CohortGroup>;
  /** Reads a single `CohortGroup` using its globally unique `ID`. */
  cohortGroupByNodeId: Maybe<CohortGroup>;
  /** Reads and enables pagination through a set of `CohortGroup`. */
  cohortGroups: Maybe<CohortGroupsConnection>;
  currentCoupleIds: Maybe<CurrentCoupleIdsConnection>;
  /** Reads and enables pagination through a set of `Permission`. */
  currentPermissions: Maybe<PermissionsConnection>;
  currentSessionId: Maybe<Scalars['String']>;
  currentTenantId: Maybe<Scalars['BigInt']>;
  currentUserId: Maybe<Scalars['BigInt']>;
  /** Reads and enables pagination through a set of `Dokumenty`. */
  dokumenties: Maybe<DokumentiesConnection>;
  dokumenty: Maybe<Dokumenty>;
  /** Reads a single `Dokumenty` using its globally unique `ID`. */
  dokumentyByNodeId: Maybe<Dokumenty>;
  event: Maybe<Event>;
  /** Reads a single `Event` using its globally unique `ID`. */
  eventByNodeId: Maybe<Event>;
  /** Reads and enables pagination through a set of `Event`. */
  events: Maybe<EventsConnection>;
  galerieDir: Maybe<GalerieDir>;
  /** Reads a single `GalerieDir` using its globally unique `ID`. */
  galerieDirByNodeId: Maybe<GalerieDir>;
  /** Reads and enables pagination through a set of `GalerieDir`. */
  galerieDirs: Maybe<GalerieDirsConnection>;
  galerieFoto: Maybe<GalerieFoto>;
  /** Reads a single `GalerieFoto` using its globally unique `ID`. */
  galerieFotoByNodeId: Maybe<GalerieFoto>;
  /** Reads and enables pagination through a set of `GalerieFoto`. */
  galerieFotos: Maybe<GalerieFotosConnection>;
  getCurrentCouple: Maybe<Pary>;
  getCurrentTenant: Maybe<Tenant>;
  getCurrentUser: Maybe<User>;
  location: Maybe<Location>;
  locationAttachment: Maybe<LocationAttachment>;
  /** Reads a single `LocationAttachment` using its globally unique `ID`. */
  locationAttachmentByNodeId: Maybe<LocationAttachment>;
  /** Reads and enables pagination through a set of `LocationAttachment`. */
  locationAttachments: Maybe<LocationAttachmentsConnection>;
  /** Reads a single `Location` using its globally unique `ID`. */
  locationByNodeId: Maybe<Location>;
  /** Reads and enables pagination through a set of `Location`. */
  locations: Maybe<LocationsConnection>;
  /** Reads and enables pagination through a set of `Member`. */
  members: Maybe<MembersConnection>;
  /** Reads and enables pagination through a set of `Upozorneni`. */
  myAnnouncements: Maybe<UpozornenisConnection>;
  /** Reads and enables pagination through a set of `RozpisItem`. */
  myLessons: Maybe<RozpisItemsConnection>;
  nabidka: Maybe<Nabidka>;
  /** Reads a single `Nabidka` using its globally unique `ID`. */
  nabidkaByNodeId: Maybe<Nabidka>;
  nabidkaItem: Maybe<NabidkaItem>;
  nabidkaItemByNiPartnerAndNiIdRodic: Maybe<NabidkaItem>;
  /** Reads a single `NabidkaItem` using its globally unique `ID`. */
  nabidkaItemByNodeId: Maybe<NabidkaItem>;
  /** Reads and enables pagination through a set of `NabidkaItem`. */
  nabidkaItems: Maybe<NabidkaItemsConnection>;
  /** Reads and enables pagination through a set of `Nabidka`. */
  nabidkas: Maybe<NabidkasConnection>;
  /** Fetches an object given its globally unique `ID`. */
  node: Maybe<Node>;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID'];
  page: Maybe<Page>;
  /** Reads a single `Page` using its globally unique `ID`. */
  pageByNodeId: Maybe<Page>;
  pageByUrl: Maybe<Page>;
  pageRevision: Maybe<PageRevision>;
  /** Reads a single `PageRevision` using its globally unique `ID`. */
  pageRevisionByNodeId: Maybe<PageRevision>;
  /** Reads and enables pagination through a set of `PageRevision`. */
  pageRevisions: Maybe<PageRevisionsConnection>;
  /** Reads and enables pagination through a set of `Page`. */
  pages: Maybe<PagesConnection>;
  parameter: Maybe<Parameter>;
  /** Reads a single `Parameter` using its globally unique `ID`. */
  parameterByNodeId: Maybe<Parameter>;
  /** Reads and enables pagination through a set of `Parameter`. */
  parameters: Maybe<ParametersConnection>;
  /** Reads and enables pagination through a set of `Pary`. */
  paries: Maybe<PariesConnection>;
  pary: Maybe<Pary>;
  /** Reads a single `Pary` using its globally unique `ID`. */
  paryByNodeId: Maybe<Pary>;
  paryNavrh: Maybe<ParyNavrh>;
  /** Reads a single `ParyNavrh` using its globally unique `ID`. */
  paryNavrhByNodeId: Maybe<ParyNavrh>;
  /** Reads and enables pagination through a set of `ParyNavrh`. */
  paryNavrhs: Maybe<ParyNavrhsConnection>;
  /** Reads and enables pagination through a set of `Person`. */
  people: Maybe<PeopleConnection>;
  permission: Maybe<Permission>;
  /** Reads a single `Permission` using its globally unique `ID`. */
  permissionByNodeId: Maybe<Permission>;
  /** Reads and enables pagination through a set of `Permission`. */
  permissions: Maybe<PermissionsConnection>;
  person: Maybe<Person>;
  /** Reads a single `Person` using its globally unique `ID`. */
  personByNodeId: Maybe<Person>;
  /** Reads and enables pagination through a set of `PlatbyCategory`. */
  platbyCategories: Maybe<PlatbyCategoriesConnection>;
  platbyCategory: Maybe<PlatbyCategory>;
  /** Reads a single `PlatbyCategory` using its globally unique `ID`. */
  platbyCategoryByNodeId: Maybe<PlatbyCategory>;
  platbyCategoryGroup: Maybe<PlatbyCategoryGroup>;
  /** Reads a single `PlatbyCategoryGroup` using its globally unique `ID`. */
  platbyCategoryGroupByNodeId: Maybe<PlatbyCategoryGroup>;
  /** Reads and enables pagination through a set of `PlatbyCategoryGroup`. */
  platbyCategoryGroups: Maybe<PlatbyCategoryGroupsConnection>;
  platbyGroup: Maybe<PlatbyGroup>;
  /** Reads a single `PlatbyGroup` using its globally unique `ID`. */
  platbyGroupByNodeId: Maybe<PlatbyGroup>;
  /** Reads and enables pagination through a set of `PlatbyGroup`. */
  platbyGroups: Maybe<PlatbyGroupsConnection>;
  platbyGroupSkupina: Maybe<PlatbyGroupSkupina>;
  /** Reads a single `PlatbyGroupSkupina` using its globally unique `ID`. */
  platbyGroupSkupinaByNodeId: Maybe<PlatbyGroupSkupina>;
  /** Reads and enables pagination through a set of `PlatbyGroupSkupina`. */
  platbyGroupSkupinas: Maybe<PlatbyGroupSkupinasConnection>;
  platbyItem: Maybe<PlatbyItem>;
  /** Reads a single `PlatbyItem` using its globally unique `ID`. */
  platbyItemByNodeId: Maybe<PlatbyItem>;
  /** Reads and enables pagination through a set of `PlatbyItem`. */
  platbyItems: Maybe<PlatbyItemsConnection>;
  platbyRaw: Maybe<PlatbyRaw>;
  /** Reads a single `PlatbyRaw` using its globally unique `ID`. */
  platbyRawByNodeId: Maybe<PlatbyRaw>;
  /** Reads and enables pagination through a set of `PlatbyRaw`. */
  platbyRaws: Maybe<PlatbyRawsConnection>;
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
  /** Reads and enables pagination through a set of `Nabidka`. */
  reservationsForRange: Maybe<NabidkasConnection>;
  room: Maybe<Room>;
  roomAttachment: Maybe<RoomAttachment>;
  /** Reads a single `RoomAttachment` using its globally unique `ID`. */
  roomAttachmentByNodeId: Maybe<RoomAttachment>;
  /** Reads and enables pagination through a set of `RoomAttachment`. */
  roomAttachments: Maybe<RoomAttachmentsConnection>;
  /** Reads a single `Room` using its globally unique `ID`. */
  roomByNodeId: Maybe<Room>;
  /** Reads and enables pagination through a set of `Room`. */
  rooms: Maybe<RoomsConnection>;
  rozpi: Maybe<Rozpi>;
  /** Reads a single `Rozpi` using its globally unique `ID`. */
  rozpiByNodeId: Maybe<Rozpi>;
  /** Reads and enables pagination through a set of `Rozpi`. */
  rozpis: Maybe<RozpisConnection>;
  rozpisItem: Maybe<RozpisItem>;
  /** Reads a single `RozpisItem` using its globally unique `ID`. */
  rozpisItemByNodeId: Maybe<RozpisItem>;
  /** Reads and enables pagination through a set of `RozpisItem`. */
  rozpisItems: Maybe<RozpisItemsConnection>;
  /** Reads and enables pagination through a set of `Rozpi`. */
  schedulesForRange: Maybe<RozpisConnection>;
  session: Maybe<Session>;
  /** Reads a single `Session` using its globally unique `ID`. */
  sessionByNodeId: Maybe<Session>;
  /** Reads and enables pagination through a set of `Session`. */
  sessions: Maybe<SessionsConnection>;
  /** Reads and enables pagination through a set of `Skupiny`. */
  skupinies: Maybe<SkupiniesConnection>;
  skupiny: Maybe<Skupiny>;
  /** Reads a single `Skupiny` using its globally unique `ID`. */
  skupinyByNodeId: Maybe<Skupiny>;
  tenant: Maybe<Tenant>;
  tenantAttachment: Maybe<TenantAttachment>;
  /** Reads a single `TenantAttachment` using its globally unique `ID`. */
  tenantAttachmentByNodeId: Maybe<TenantAttachment>;
  /** Reads and enables pagination through a set of `TenantAttachment`. */
  tenantAttachments: Maybe<TenantAttachmentsConnection>;
  /** Reads a single `Tenant` using its globally unique `ID`. */
  tenantByNodeId: Maybe<Tenant>;
  /** Reads and enables pagination through a set of `TenantPerson`. */
  tenantPeople: Maybe<TenantPeopleConnection>;
  tenantPerson: Maybe<TenantPerson>;
  /** Reads a single `TenantPerson` using its globally unique `ID`. */
  tenantPersonByNodeId: Maybe<TenantPerson>;
  /** Reads and enables pagination through a set of `Tenant`. */
  tenants: Maybe<TenantsConnection>;
  /** Reads and enables pagination through a set of `Video`. */
  titleVideos: Maybe<VideosConnection>;
  /** Reads and enables pagination through a set of `User`. */
  trainers: Maybe<UsersConnection>;
  upozorneni: Maybe<Upozorneni>;
  /** Reads a single `Upozorneni` using its globally unique `ID`. */
  upozorneniByNodeId: Maybe<Upozorneni>;
  /** Reads and enables pagination through a set of `Upozorneni`. */
  upozornenis: Maybe<UpozornenisConnection>;
  /** Reads and enables pagination through a set of `UpozorneniSkupiny`. */
  upozorneniSkupinies: Maybe<UpozorneniSkupiniesConnection>;
  upozorneniSkupiny: Maybe<UpozorneniSkupiny>;
  /** Reads a single `UpozorneniSkupiny` using its globally unique `ID`. */
  upozorneniSkupinyByNodeId: Maybe<UpozorneniSkupiny>;
  user: Maybe<User>;
  /** Reads a single `User` using its globally unique `ID`. */
  userByNodeId: Maybe<User>;
  /** Reads and enables pagination through a set of `User`. */
  users: Maybe<UsersConnection>;
  video: Maybe<Video>;
  /** Reads a single `Video` using its globally unique `ID`. */
  videoByNodeId: Maybe<Video>;
  videoList: Maybe<VideoList>;
  /** Reads a single `VideoList` using its globally unique `ID`. */
  videoListByNodeId: Maybe<VideoList>;
  /** Reads and enables pagination through a set of `VideoList`. */
  videoLists: Maybe<VideoListsConnection>;
  /** Reads and enables pagination through a set of `Video`. */
  videos: Maybe<VideosConnection>;
  videoSource: Maybe<VideoSource>;
  /** Reads a single `VideoSource` using its globally unique `ID`. */
  videoSourceByNodeId: Maybe<VideoSource>;
  /** Reads and enables pagination through a set of `VideoSource`. */
  videoSources: Maybe<VideoSourcesConnection>;
};


/** The root query type which gives access points into the data universe. */
export type QueryActiveCouplesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryActiveProspectsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAkceItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AkceItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AkceItemsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAkcesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AkceCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AkcesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAktualitiesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AktualityCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AktualitiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAktualityArgs = {
  atId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAktualityByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAttachmentArgs = {
  objectName: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAttachmentByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AttachmentCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AttachmentsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAttendeeExternalArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAttendeeExternalByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAttendeeExternalsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AttendeeExternalCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AttendeeExternalsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAttendeeUserArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAttendeeUserByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAttendeeUserByUserIdAndEventIdArgs = {
  eventId: Scalars['BigInt'];
  userId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAttendeeUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AttendeeUserCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AttendeeUsersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCohortGroupArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCohortGroupByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCohortGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<CohortGroupCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CohortGroupsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCurrentCoupleIdsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCurrentPermissionsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDokumentiesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<DokumentyCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<DokumentiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDokumentyArgs = {
  dId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDokumentyByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<EventCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGalerieDirArgs = {
  gdId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGalerieDirByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGalerieDirsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<GalerieDirCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GalerieDirsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGalerieFotoArgs = {
  gfId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGalerieFotoByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGalerieFotosArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<GalerieFotoCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GalerieFotosOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLocationArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLocationAttachmentArgs = {
  locationId: Scalars['BigInt'];
  objectName: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLocationAttachmentByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLocationAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<LocationAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LocationAttachmentsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLocationByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLocationsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<LocationCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LocationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMembersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<MemberCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<MembersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMyAnnouncementsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMyLessonsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  endDate?: InputMaybe<Scalars['Date']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  startDate?: InputMaybe<Scalars['Date']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNabidkaArgs = {
  nId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNabidkaByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNabidkaItemArgs = {
  niId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNabidkaItemByNiPartnerAndNiIdRodicArgs = {
  niIdRodic: Scalars['BigInt'];
  niPartner: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNabidkaItemByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNabidkaItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<NabidkaItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<NabidkaItemsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNabidkasArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<NabidkaCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<NabidkasOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNodeArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPageArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPageByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPageByUrlArgs = {
  url: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPageRevisionArgs = {
  id: Scalars['Int'];
  revNumber: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPageRevisionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPageRevisionsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PageRevisionCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PageRevisionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPagesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PageCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PagesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryParameterArgs = {
  paName: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryParameterByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryParametersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<ParameterCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ParametersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPariesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<ParyCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PariesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryParyArgs = {
  pId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryParyByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryParyNavrhArgs = {
  pnId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryParyNavrhByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryParyNavrhsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<ParyNavrhCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ParyNavrhsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPeopleArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PersonCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PeopleOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionArgs = {
  peId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PermissionCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPersonArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPersonByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyCategoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyCategoryCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyCategoriesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyCategoryArgs = {
  pcId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyCategoryByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyCategoryGroupArgs = {
  pcgId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyCategoryGroupByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyCategoryGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyCategoryGroupCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyCategoryGroupsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyGroupArgs = {
  pgId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyGroupByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyGroupCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyGroupsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyGroupSkupinaArgs = {
  pgsId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyGroupSkupinaByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyGroupSkupinasArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyGroupSkupinaCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyGroupSkupinasOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyItemArgs = {
  piId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyItemByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyItemsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyRawArgs = {
  prId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyRawByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyRawsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyRawCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyRawsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReservationsForRangeArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  endDate?: InputMaybe<Scalars['Date']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  startDate?: InputMaybe<Scalars['Date']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomAttachmentArgs = {
  objectName: Scalars['String'];
  roomId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomAttachmentByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<RoomAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RoomAttachmentsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<RoomCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RoomsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRozpiArgs = {
  rId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRozpiByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRozpisArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<RozpiCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RozpisOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRozpisItemArgs = {
  riId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRozpisItemByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRozpisItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<RozpisItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RozpisItemsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySchedulesForRangeArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  endDate?: InputMaybe<Scalars['Date']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  startDate?: InputMaybe<Scalars['Date']>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySessionArgs = {
  ssId: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySessionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySessionsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<SessionCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SessionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySkupiniesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<SkupinyCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SkupiniesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySkupinyArgs = {
  sId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySkupinyByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantAttachmentArgs = {
  objectName: Scalars['String'];
  tenantId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantAttachmentByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<TenantAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TenantAttachmentsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantPeopleArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<TenantPersonCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TenantPeopleOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantPersonArgs = {
  personId: Scalars['BigInt'];
  tenantId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantPersonByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<TenantCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TenantsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTitleVideosArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTrainersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUpozorneniArgs = {
  upId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUpozorneniByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUpozornenisArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<UpozorneniCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UpozornenisOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUpozorneniSkupiniesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<UpozorneniSkupinyCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UpozorneniSkupiniesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUpozorneniSkupinyArgs = {
  upsId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUpozorneniSkupinyByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserArgs = {
  uId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<UserCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVideoArgs = {
  vId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVideoByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVideoListArgs = {
  vlId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVideoListByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVideoListsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<VideoListCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VideoListsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVideosArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<VideoCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VideosOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVideoSourceArgs = {
  vsId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVideoSourceByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVideoSourcesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<VideoSourceCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VideoSourcesOrderBy>>;
};

/** All input for the `reservationSetDesiredLessons` mutation. */
export type ReservationSetDesiredLessonsInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  lessonCount: Scalars['Int'];
  reservationId: Scalars['BigInt'];
};

/** The output of our `reservationSetDesiredLessons` mutation. */
export type ReservationSetDesiredLessonsPayload = {
  __typename?: 'ReservationSetDesiredLessonsPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** An edge for our `Nabidka`. May be used by Relay 1. */
  nabidkaEdge: Maybe<NabidkasEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  reservation: Maybe<Nabidka>;
  /** Reads a single `User` that is related to this `Nabidka`. */
  userByNTrener: Maybe<User>;
};


/** The output of our `reservationSetDesiredLessons` mutation. */
export type ReservationSetDesiredLessonsPayloadNabidkaEdgeArgs = {
  orderBy?: InputMaybe<Array<NabidkasOrderBy>>;
};

/** All input for the `resetPassword` mutation. */
export type ResetPasswordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  email: Scalars['String'];
  login: Scalars['String'];
};

/** The output of our `resetPassword` mutation. */
export type ResetPasswordPayload = {
  __typename?: 'ResetPasswordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type Room = Node & {
  __typename?: 'Room';
  description: Scalars['JSON'];
  id: Scalars['BigInt'];
  location: Maybe<Scalars['BigInt']>;
  /** Reads a single `Location` that is related to this `Room`. */
  locationByLocation: Maybe<Location>;
  name: Scalars['String'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads and enables pagination through a set of `RoomAttachment`. */
  roomAttachments: RoomAttachmentsConnection;
};


export type RoomRoomAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<RoomAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RoomAttachmentsOrderBy>>;
};

export type RoomAttachment = Node & {
  __typename?: 'RoomAttachment';
  /** Reads a single `Attachment` that is related to this `RoomAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  objectName: Scalars['String'];
  /** Reads a single `Room` that is related to this `RoomAttachment`. */
  room: Maybe<Room>;
  roomId: Scalars['BigInt'];
};

/**
 * A condition to be used against `RoomAttachment` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type RoomAttachmentCondition = {
  /** Checks for equality with the object’s `objectName` field. */
  objectName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `roomId` field. */
  roomId?: InputMaybe<Scalars['BigInt']>;
};

/** An input for mutations affecting `RoomAttachment` */
export type RoomAttachmentInput = {
  objectName: Scalars['String'];
  roomId: Scalars['BigInt'];
};

/** Represents an update to a `RoomAttachment`. Fields that are set will be updated. */
export type RoomAttachmentPatch = {
  objectName?: InputMaybe<Scalars['String']>;
  roomId?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `RoomAttachment` values. */
export type RoomAttachmentsConnection = {
  __typename?: 'RoomAttachmentsConnection';
  /** A list of edges which contains the `RoomAttachment` and cursor to aid in pagination. */
  edges: Array<RoomAttachmentsEdge>;
  /** A list of `RoomAttachment` objects. */
  nodes: Array<RoomAttachment>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `RoomAttachment` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `RoomAttachment` edge in the connection. */
export type RoomAttachmentsEdge = {
  __typename?: 'RoomAttachmentsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `RoomAttachment` at the end of the edge. */
  node: RoomAttachment;
};

/** Methods to use when ordering `RoomAttachment`. */
export enum RoomAttachmentsOrderBy {
  AttachmentByObjectNameObjectNameAsc = 'ATTACHMENT_BY_OBJECT_NAME__OBJECT_NAME_ASC',
  AttachmentByObjectNameObjectNameDesc = 'ATTACHMENT_BY_OBJECT_NAME__OBJECT_NAME_DESC',
  AttachmentByObjectNamePreviewObjectNameAsc = 'ATTACHMENT_BY_OBJECT_NAME__PREVIEW_OBJECT_NAME_ASC',
  AttachmentByObjectNamePreviewObjectNameDesc = 'ATTACHMENT_BY_OBJECT_NAME__PREVIEW_OBJECT_NAME_DESC',
  AttachmentByObjectNameUploadedAtAsc = 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_AT_ASC',
  AttachmentByObjectNameUploadedAtDesc = 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_AT_DESC',
  AttachmentByObjectNameUploadedByAsc = 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_BY_ASC',
  AttachmentByObjectNameUploadedByDesc = 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_BY_DESC',
  Natural = 'NATURAL',
  ObjectNameAsc = 'OBJECT_NAME_ASC',
  ObjectNameDesc = 'OBJECT_NAME_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RoomByRoomIdDescriptionAsc = 'ROOM_BY_ROOM_ID__DESCRIPTION_ASC',
  RoomByRoomIdDescriptionDesc = 'ROOM_BY_ROOM_ID__DESCRIPTION_DESC',
  RoomByRoomIdIdAsc = 'ROOM_BY_ROOM_ID__ID_ASC',
  RoomByRoomIdIdDesc = 'ROOM_BY_ROOM_ID__ID_DESC',
  RoomByRoomIdLocationAsc = 'ROOM_BY_ROOM_ID__LOCATION_ASC',
  RoomByRoomIdLocationDesc = 'ROOM_BY_ROOM_ID__LOCATION_DESC',
  RoomByRoomIdNameAsc = 'ROOM_BY_ROOM_ID__NAME_ASC',
  RoomByRoomIdNameDesc = 'ROOM_BY_ROOM_ID__NAME_DESC',
  RoomIdAsc = 'ROOM_ID_ASC',
  RoomIdDesc = 'ROOM_ID_DESC'
}

/** A condition to be used against `Room` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type RoomCondition = {
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `location` field. */
  location?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
};

/** An input for mutations affecting `Room` */
export type RoomInput = {
  description: Scalars['JSON'];
  id?: InputMaybe<Scalars['BigInt']>;
  location?: InputMaybe<Scalars['BigInt']>;
  name: Scalars['String'];
};

/** Represents an update to a `Room`. Fields that are set will be updated. */
export type RoomPatch = {
  description?: InputMaybe<Scalars['JSON']>;
  id?: InputMaybe<Scalars['BigInt']>;
  location?: InputMaybe<Scalars['BigInt']>;
  name?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Room` values. */
export type RoomsConnection = {
  __typename?: 'RoomsConnection';
  /** A list of edges which contains the `Room` and cursor to aid in pagination. */
  edges: Array<RoomsEdge>;
  /** A list of `Room` objects. */
  nodes: Array<Room>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Room` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Room` edge in the connection. */
export type RoomsEdge = {
  __typename?: 'RoomsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Room` at the end of the edge. */
  node: Room;
};

/** Methods to use when ordering `Room`. */
export enum RoomsOrderBy {
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LocationAsc = 'LOCATION_ASC',
  LocationByLocationDescriptionAsc = 'LOCATION_BY_LOCATION__DESCRIPTION_ASC',
  LocationByLocationDescriptionDesc = 'LOCATION_BY_LOCATION__DESCRIPTION_DESC',
  LocationByLocationIdAsc = 'LOCATION_BY_LOCATION__ID_ASC',
  LocationByLocationIdDesc = 'LOCATION_BY_LOCATION__ID_DESC',
  LocationByLocationNameAsc = 'LOCATION_BY_LOCATION__NAME_ASC',
  LocationByLocationNameDesc = 'LOCATION_BY_LOCATION__NAME_DESC',
  LocationByLocationTenantAsc = 'LOCATION_BY_LOCATION__TENANT_ASC',
  LocationByLocationTenantDesc = 'LOCATION_BY_LOCATION__TENANT_DESC',
  LocationDesc = 'LOCATION_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RoomAttachmentsByRoomIdCountAsc = 'ROOM_ATTACHMENTS_BY_ROOM_ID__COUNT_ASC',
  RoomAttachmentsByRoomIdCountDesc = 'ROOM_ATTACHMENTS_BY_ROOM_ID__COUNT_DESC'
}

export type Rozpi = Node & {
  __typename?: 'Rozpi';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  rDatum: Scalars['Date'];
  rId: Scalars['BigInt'];
  rKde: Scalars['String'];
  rLock: Scalars['Boolean'];
  /** Reads and enables pagination through a set of `RozpisItem`. */
  rozpisItemsByRiIdRodic: RozpisItemsConnection;
  rTimestamp: Maybe<Scalars['Datetime']>;
  rTrener: Scalars['BigInt'];
  rVisible: Scalars['Boolean'];
  /** Reads a single `User` that is related to this `Rozpi`. */
  userByRTrener: Maybe<User>;
};


export type RozpiRozpisItemsByRiIdRodicArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<RozpisItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RozpisItemsOrderBy>>;
};

/** A condition to be used against `Rozpi` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type RozpiCondition = {
  /** Checks for equality with the object’s `rDatum` field. */
  rDatum?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `rId` field. */
  rId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `rKde` field. */
  rKde?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `rLock` field. */
  rLock?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `rTimestamp` field. */
  rTimestamp?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `rTrener` field. */
  rTrener?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `rVisible` field. */
  rVisible?: InputMaybe<Scalars['Boolean']>;
};

/** An input for mutations affecting `Rozpi` */
export type RozpiInput = {
  rDatum: Scalars['Date'];
  rId?: InputMaybe<Scalars['BigInt']>;
  rKde: Scalars['String'];
  rLock?: InputMaybe<Scalars['Boolean']>;
  rTimestamp?: InputMaybe<Scalars['Datetime']>;
  rTrener: Scalars['BigInt'];
  rVisible?: InputMaybe<Scalars['Boolean']>;
};

/** Represents an update to a `Rozpi`. Fields that are set will be updated. */
export type RozpiPatch = {
  rDatum?: InputMaybe<Scalars['Date']>;
  rId?: InputMaybe<Scalars['BigInt']>;
  rKde?: InputMaybe<Scalars['String']>;
  rLock?: InputMaybe<Scalars['Boolean']>;
  rTimestamp?: InputMaybe<Scalars['Datetime']>;
  rTrener?: InputMaybe<Scalars['BigInt']>;
  rVisible?: InputMaybe<Scalars['Boolean']>;
};

/** A connection to a list of `Rozpi` values. */
export type RozpisConnection = {
  __typename?: 'RozpisConnection';
  /** A list of edges which contains the `Rozpi` and cursor to aid in pagination. */
  edges: Array<RozpisEdge>;
  /** A list of `Rozpi` objects. */
  nodes: Array<Rozpi>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Rozpi` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Rozpi` edge in the connection. */
export type RozpisEdge = {
  __typename?: 'RozpisEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Rozpi` at the end of the edge. */
  node: Rozpi;
};

export type RozpisItem = Node & {
  __typename?: 'RozpisItem';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `Pary` that is related to this `RozpisItem`. */
  paryByRiPartner: Maybe<Pary>;
  riDo: Scalars['Time'];
  riId: Scalars['BigInt'];
  riIdRodic: Scalars['BigInt'];
  riLock: Scalars['Boolean'];
  riOd: Scalars['Time'];
  riPartner: Maybe<Scalars['BigInt']>;
  /** Reads a single `Rozpi` that is related to this `RozpisItem`. */
  rozpiByRiIdRodic: Maybe<Rozpi>;
};

/**
 * A condition to be used against `RozpisItem` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type RozpisItemCondition = {
  /** Checks for equality with the object’s `riDo` field. */
  riDo?: InputMaybe<Scalars['Time']>;
  /** Checks for equality with the object’s `riId` field. */
  riId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `riIdRodic` field. */
  riIdRodic?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `riLock` field. */
  riLock?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `riOd` field. */
  riOd?: InputMaybe<Scalars['Time']>;
  /** Checks for equality with the object’s `riPartner` field. */
  riPartner?: InputMaybe<Scalars['BigInt']>;
};

/** An input for mutations affecting `RozpisItem` */
export type RozpisItemInput = {
  riDo: Scalars['Time'];
  riId?: InputMaybe<Scalars['BigInt']>;
  riIdRodic: Scalars['BigInt'];
  riLock?: InputMaybe<Scalars['Boolean']>;
  riOd: Scalars['Time'];
  riPartner?: InputMaybe<Scalars['BigInt']>;
};

/** Represents an update to a `RozpisItem`. Fields that are set will be updated. */
export type RozpisItemPatch = {
  riDo?: InputMaybe<Scalars['Time']>;
  riId?: InputMaybe<Scalars['BigInt']>;
  riIdRodic?: InputMaybe<Scalars['BigInt']>;
  riLock?: InputMaybe<Scalars['Boolean']>;
  riOd?: InputMaybe<Scalars['Time']>;
  riPartner?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `RozpisItem` values. */
export type RozpisItemsConnection = {
  __typename?: 'RozpisItemsConnection';
  /** A list of edges which contains the `RozpisItem` and cursor to aid in pagination. */
  edges: Array<RozpisItemsEdge>;
  /** A list of `RozpisItem` objects. */
  nodes: Array<RozpisItem>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `RozpisItem` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `RozpisItem` edge in the connection. */
export type RozpisItemsEdge = {
  __typename?: 'RozpisItemsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `RozpisItem` at the end of the edge. */
  node: RozpisItem;
};

/** Methods to use when ordering `RozpisItem`. */
export enum RozpisItemsOrderBy {
  Natural = 'NATURAL',
  ParyByRiPartnerPArchivAsc = 'PARY_BY_RI_PARTNER__P_ARCHIV_ASC',
  ParyByRiPartnerPArchivDesc = 'PARY_BY_RI_PARTNER__P_ARCHIV_DESC',
  ParyByRiPartnerPHodnoceniAsc = 'PARY_BY_RI_PARTNER__P_HODNOCENI_ASC',
  ParyByRiPartnerPHodnoceniDesc = 'PARY_BY_RI_PARTNER__P_HODNOCENI_DESC',
  ParyByRiPartnerPIdAsc = 'PARY_BY_RI_PARTNER__P_ID_ASC',
  ParyByRiPartnerPIdDesc = 'PARY_BY_RI_PARTNER__P_ID_DESC',
  ParyByRiPartnerPIdPartnerAsc = 'PARY_BY_RI_PARTNER__P_ID_PARTNER_ASC',
  ParyByRiPartnerPIdPartnerDesc = 'PARY_BY_RI_PARTNER__P_ID_PARTNER_DESC',
  ParyByRiPartnerPIdPartnerkaAsc = 'PARY_BY_RI_PARTNER__P_ID_PARTNERKA_ASC',
  ParyByRiPartnerPIdPartnerkaDesc = 'PARY_BY_RI_PARTNER__P_ID_PARTNERKA_DESC',
  ParyByRiPartnerPLatBodyAsc = 'PARY_BY_RI_PARTNER__P_LAT_BODY_ASC',
  ParyByRiPartnerPLatBodyDesc = 'PARY_BY_RI_PARTNER__P_LAT_BODY_DESC',
  ParyByRiPartnerPLatFinaleAsc = 'PARY_BY_RI_PARTNER__P_LAT_FINALE_ASC',
  ParyByRiPartnerPLatFinaleDesc = 'PARY_BY_RI_PARTNER__P_LAT_FINALE_DESC',
  ParyByRiPartnerPLatTridaAsc = 'PARY_BY_RI_PARTNER__P_LAT_TRIDA_ASC',
  ParyByRiPartnerPLatTridaDesc = 'PARY_BY_RI_PARTNER__P_LAT_TRIDA_DESC',
  ParyByRiPartnerPSttBodyAsc = 'PARY_BY_RI_PARTNER__P_STT_BODY_ASC',
  ParyByRiPartnerPSttBodyDesc = 'PARY_BY_RI_PARTNER__P_STT_BODY_DESC',
  ParyByRiPartnerPSttFinaleAsc = 'PARY_BY_RI_PARTNER__P_STT_FINALE_ASC',
  ParyByRiPartnerPSttFinaleDesc = 'PARY_BY_RI_PARTNER__P_STT_FINALE_DESC',
  ParyByRiPartnerPSttTridaAsc = 'PARY_BY_RI_PARTNER__P_STT_TRIDA_ASC',
  ParyByRiPartnerPSttTridaDesc = 'PARY_BY_RI_PARTNER__P_STT_TRIDA_DESC',
  ParyByRiPartnerPTimestampAddAsc = 'PARY_BY_RI_PARTNER__P_TIMESTAMP_ADD_ASC',
  ParyByRiPartnerPTimestampAddDesc = 'PARY_BY_RI_PARTNER__P_TIMESTAMP_ADD_DESC',
  ParyByRiPartnerPTimestampArchiveAsc = 'PARY_BY_RI_PARTNER__P_TIMESTAMP_ARCHIVE_ASC',
  ParyByRiPartnerPTimestampArchiveDesc = 'PARY_BY_RI_PARTNER__P_TIMESTAMP_ARCHIVE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RiDoAsc = 'RI_DO_ASC',
  RiDoDesc = 'RI_DO_DESC',
  RiIdAsc = 'RI_ID_ASC',
  RiIdDesc = 'RI_ID_DESC',
  RiIdRodicAsc = 'RI_ID_RODIC_ASC',
  RiIdRodicDesc = 'RI_ID_RODIC_DESC',
  RiLockAsc = 'RI_LOCK_ASC',
  RiLockDesc = 'RI_LOCK_DESC',
  RiOdAsc = 'RI_OD_ASC',
  RiOdDesc = 'RI_OD_DESC',
  RiPartnerAsc = 'RI_PARTNER_ASC',
  RiPartnerDesc = 'RI_PARTNER_DESC',
  RozpiByRiIdRodicRDatumAsc = 'ROZPI_BY_RI_ID_RODIC__R_DATUM_ASC',
  RozpiByRiIdRodicRDatumDesc = 'ROZPI_BY_RI_ID_RODIC__R_DATUM_DESC',
  RozpiByRiIdRodicRIdAsc = 'ROZPI_BY_RI_ID_RODIC__R_ID_ASC',
  RozpiByRiIdRodicRIdDesc = 'ROZPI_BY_RI_ID_RODIC__R_ID_DESC',
  RozpiByRiIdRodicRKdeAsc = 'ROZPI_BY_RI_ID_RODIC__R_KDE_ASC',
  RozpiByRiIdRodicRKdeDesc = 'ROZPI_BY_RI_ID_RODIC__R_KDE_DESC',
  RozpiByRiIdRodicRLockAsc = 'ROZPI_BY_RI_ID_RODIC__R_LOCK_ASC',
  RozpiByRiIdRodicRLockDesc = 'ROZPI_BY_RI_ID_RODIC__R_LOCK_DESC',
  RozpiByRiIdRodicRTimestampAsc = 'ROZPI_BY_RI_ID_RODIC__R_TIMESTAMP_ASC',
  RozpiByRiIdRodicRTimestampDesc = 'ROZPI_BY_RI_ID_RODIC__R_TIMESTAMP_DESC',
  RozpiByRiIdRodicRTrenerAsc = 'ROZPI_BY_RI_ID_RODIC__R_TRENER_ASC',
  RozpiByRiIdRodicRTrenerDesc = 'ROZPI_BY_RI_ID_RODIC__R_TRENER_DESC',
  RozpiByRiIdRodicRVisibleAsc = 'ROZPI_BY_RI_ID_RODIC__R_VISIBLE_ASC',
  RozpiByRiIdRodicRVisibleDesc = 'ROZPI_BY_RI_ID_RODIC__R_VISIBLE_DESC'
}

/** Methods to use when ordering `Rozpi`. */
export enum RozpisOrderBy {
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RDatumAsc = 'R_DATUM_ASC',
  RDatumDesc = 'R_DATUM_DESC',
  RIdAsc = 'R_ID_ASC',
  RIdDesc = 'R_ID_DESC',
  RKdeAsc = 'R_KDE_ASC',
  RKdeDesc = 'R_KDE_DESC',
  RLockAsc = 'R_LOCK_ASC',
  RLockDesc = 'R_LOCK_DESC',
  RTimestampAsc = 'R_TIMESTAMP_ASC',
  RTimestampDesc = 'R_TIMESTAMP_DESC',
  RTrenerAsc = 'R_TRENER_ASC',
  RTrenerDesc = 'R_TRENER_DESC',
  RVisibleAsc = 'R_VISIBLE_ASC',
  RVisibleDesc = 'R_VISIBLE_DESC',
  RozpisItemsByRiIdRodicCountAsc = 'ROZPIS_ITEMS_BY_RI_ID_RODIC__COUNT_ASC',
  RozpisItemsByRiIdRodicCountDesc = 'ROZPIS_ITEMS_BY_RI_ID_RODIC__COUNT_DESC',
  UserByRTrenerUBanAsc = 'USER_BY_R_TRENER__U_BAN_ASC',
  UserByRTrenerUBanDesc = 'USER_BY_R_TRENER__U_BAN_DESC',
  UserByRTrenerUCityAsc = 'USER_BY_R_TRENER__U_CITY_ASC',
  UserByRTrenerUCityDesc = 'USER_BY_R_TRENER__U_CITY_DESC',
  UserByRTrenerUConfirmedAsc = 'USER_BY_R_TRENER__U_CONFIRMED_ASC',
  UserByRTrenerUConfirmedDesc = 'USER_BY_R_TRENER__U_CONFIRMED_DESC',
  UserByRTrenerUConscriptionNumberAsc = 'USER_BY_R_TRENER__U_CONSCRIPTION_NUMBER_ASC',
  UserByRTrenerUConscriptionNumberDesc = 'USER_BY_R_TRENER__U_CONSCRIPTION_NUMBER_DESC',
  UserByRTrenerUCreatedAtAsc = 'USER_BY_R_TRENER__U_CREATED_AT_ASC',
  UserByRTrenerUCreatedAtDesc = 'USER_BY_R_TRENER__U_CREATED_AT_DESC',
  UserByRTrenerUDancerAsc = 'USER_BY_R_TRENER__U_DANCER_ASC',
  UserByRTrenerUDancerDesc = 'USER_BY_R_TRENER__U_DANCER_DESC',
  UserByRTrenerUDistrictAsc = 'USER_BY_R_TRENER__U_DISTRICT_ASC',
  UserByRTrenerUDistrictDesc = 'USER_BY_R_TRENER__U_DISTRICT_DESC',
  UserByRTrenerUEmailAsc = 'USER_BY_R_TRENER__U_EMAIL_ASC',
  UserByRTrenerUEmailDesc = 'USER_BY_R_TRENER__U_EMAIL_DESC',
  UserByRTrenerUGdprSignedAtAsc = 'USER_BY_R_TRENER__U_GDPR_SIGNED_AT_ASC',
  UserByRTrenerUGdprSignedAtDesc = 'USER_BY_R_TRENER__U_GDPR_SIGNED_AT_DESC',
  UserByRTrenerUGroupAsc = 'USER_BY_R_TRENER__U_GROUP_ASC',
  UserByRTrenerUGroupDesc = 'USER_BY_R_TRENER__U_GROUP_DESC',
  UserByRTrenerUIdAsc = 'USER_BY_R_TRENER__U_ID_ASC',
  UserByRTrenerUIdDesc = 'USER_BY_R_TRENER__U_ID_DESC',
  UserByRTrenerUJmenoAsc = 'USER_BY_R_TRENER__U_JMENO_ASC',
  UserByRTrenerUJmenoDesc = 'USER_BY_R_TRENER__U_JMENO_DESC',
  UserByRTrenerULevelAsc = 'USER_BY_R_TRENER__U_LEVEL_ASC',
  UserByRTrenerULevelDesc = 'USER_BY_R_TRENER__U_LEVEL_DESC',
  UserByRTrenerULockAsc = 'USER_BY_R_TRENER__U_LOCK_ASC',
  UserByRTrenerULockDesc = 'USER_BY_R_TRENER__U_LOCK_DESC',
  UserByRTrenerULoginAsc = 'USER_BY_R_TRENER__U_LOGIN_ASC',
  UserByRTrenerULoginDesc = 'USER_BY_R_TRENER__U_LOGIN_DESC',
  UserByRTrenerUMemberSinceAsc = 'USER_BY_R_TRENER__U_MEMBER_SINCE_ASC',
  UserByRTrenerUMemberSinceDesc = 'USER_BY_R_TRENER__U_MEMBER_SINCE_DESC',
  UserByRTrenerUMemberUntilAsc = 'USER_BY_R_TRENER__U_MEMBER_UNTIL_ASC',
  UserByRTrenerUMemberUntilDesc = 'USER_BY_R_TRENER__U_MEMBER_UNTIL_DESC',
  UserByRTrenerUNarozeniAsc = 'USER_BY_R_TRENER__U_NAROZENI_ASC',
  UserByRTrenerUNarozeniDesc = 'USER_BY_R_TRENER__U_NAROZENI_DESC',
  UserByRTrenerUNationalityAsc = 'USER_BY_R_TRENER__U_NATIONALITY_ASC',
  UserByRTrenerUNationalityDesc = 'USER_BY_R_TRENER__U_NATIONALITY_DESC',
  UserByRTrenerUOrientationNumberAsc = 'USER_BY_R_TRENER__U_ORIENTATION_NUMBER_ASC',
  UserByRTrenerUOrientationNumberDesc = 'USER_BY_R_TRENER__U_ORIENTATION_NUMBER_DESC',
  UserByRTrenerUPassAsc = 'USER_BY_R_TRENER__U_PASS_ASC',
  UserByRTrenerUPassDesc = 'USER_BY_R_TRENER__U_PASS_DESC',
  UserByRTrenerUPohlaviAsc = 'USER_BY_R_TRENER__U_POHLAVI_ASC',
  UserByRTrenerUPohlaviDesc = 'USER_BY_R_TRENER__U_POHLAVI_DESC',
  UserByRTrenerUPostalCodeAsc = 'USER_BY_R_TRENER__U_POSTAL_CODE_ASC',
  UserByRTrenerUPostalCodeDesc = 'USER_BY_R_TRENER__U_POSTAL_CODE_DESC',
  UserByRTrenerUPoznamkyAsc = 'USER_BY_R_TRENER__U_POZNAMKY_ASC',
  UserByRTrenerUPoznamkyDesc = 'USER_BY_R_TRENER__U_POZNAMKY_DESC',
  UserByRTrenerUPrijmeniAsc = 'USER_BY_R_TRENER__U_PRIJMENI_ASC',
  UserByRTrenerUPrijmeniDesc = 'USER_BY_R_TRENER__U_PRIJMENI_DESC',
  UserByRTrenerURodneCisloAsc = 'USER_BY_R_TRENER__U_RODNE_CISLO_ASC',
  UserByRTrenerURodneCisloDesc = 'USER_BY_R_TRENER__U_RODNE_CISLO_DESC',
  UserByRTrenerUSkupinaAsc = 'USER_BY_R_TRENER__U_SKUPINA_ASC',
  UserByRTrenerUSkupinaDesc = 'USER_BY_R_TRENER__U_SKUPINA_DESC',
  UserByRTrenerUStreetAsc = 'USER_BY_R_TRENER__U_STREET_ASC',
  UserByRTrenerUStreetDesc = 'USER_BY_R_TRENER__U_STREET_DESC',
  UserByRTrenerUSystemAsc = 'USER_BY_R_TRENER__U_SYSTEM_ASC',
  UserByRTrenerUSystemDesc = 'USER_BY_R_TRENER__U_SYSTEM_DESC',
  UserByRTrenerUTeacherAsc = 'USER_BY_R_TRENER__U_TEACHER_ASC',
  UserByRTrenerUTeacherDesc = 'USER_BY_R_TRENER__U_TEACHER_DESC',
  UserByRTrenerUTelefonAsc = 'USER_BY_R_TRENER__U_TELEFON_ASC',
  UserByRTrenerUTelefonDesc = 'USER_BY_R_TRENER__U_TELEFON_DESC',
  UserByRTrenerUTimestampAsc = 'USER_BY_R_TRENER__U_TIMESTAMP_ASC',
  UserByRTrenerUTimestampDesc = 'USER_BY_R_TRENER__U_TIMESTAMP_DESC'
}

export type Session = Node & {
  __typename?: 'Session';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  ssId: Scalars['String'];
  ssLifetime: Scalars['BigInt'];
  ssUpdatedAt: Scalars['Datetime'];
  ssUser: Maybe<Scalars['BigInt']>;
  /** Reads a single `User` that is related to this `Session`. */
  userBySsUser: Maybe<User>;
};

/** A condition to be used against `Session` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type SessionCondition = {
  /** Checks for equality with the object’s `ssId` field. */
  ssId?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `ssLifetime` field. */
  ssLifetime?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `ssUpdatedAt` field. */
  ssUpdatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `ssUser` field. */
  ssUser?: InputMaybe<Scalars['BigInt']>;
};

/** An input for mutations affecting `Session` */
export type SessionInput = {
  ssId: Scalars['String'];
  ssLifetime: Scalars['BigInt'];
  ssUpdatedAt?: InputMaybe<Scalars['Datetime']>;
  ssUser?: InputMaybe<Scalars['BigInt']>;
};

/** Represents an update to a `Session`. Fields that are set will be updated. */
export type SessionPatch = {
  ssId?: InputMaybe<Scalars['String']>;
  ssLifetime?: InputMaybe<Scalars['BigInt']>;
  ssUpdatedAt?: InputMaybe<Scalars['Datetime']>;
  ssUser?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `Session` values. */
export type SessionsConnection = {
  __typename?: 'SessionsConnection';
  /** A list of edges which contains the `Session` and cursor to aid in pagination. */
  edges: Array<SessionsEdge>;
  /** A list of `Session` objects. */
  nodes: Array<Session>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Session` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Session` edge in the connection. */
export type SessionsEdge = {
  __typename?: 'SessionsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Session` at the end of the edge. */
  node: Session;
};

/** Methods to use when ordering `Session`. */
export enum SessionsOrderBy {
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SsIdAsc = 'SS_ID_ASC',
  SsIdDesc = 'SS_ID_DESC',
  SsLifetimeAsc = 'SS_LIFETIME_ASC',
  SsLifetimeDesc = 'SS_LIFETIME_DESC',
  SsUpdatedAtAsc = 'SS_UPDATED_AT_ASC',
  SsUpdatedAtDesc = 'SS_UPDATED_AT_DESC',
  SsUserAsc = 'SS_USER_ASC',
  SsUserDesc = 'SS_USER_DESC',
  UserBySsUserUBanAsc = 'USER_BY_SS_USER__U_BAN_ASC',
  UserBySsUserUBanDesc = 'USER_BY_SS_USER__U_BAN_DESC',
  UserBySsUserUCityAsc = 'USER_BY_SS_USER__U_CITY_ASC',
  UserBySsUserUCityDesc = 'USER_BY_SS_USER__U_CITY_DESC',
  UserBySsUserUConfirmedAsc = 'USER_BY_SS_USER__U_CONFIRMED_ASC',
  UserBySsUserUConfirmedDesc = 'USER_BY_SS_USER__U_CONFIRMED_DESC',
  UserBySsUserUConscriptionNumberAsc = 'USER_BY_SS_USER__U_CONSCRIPTION_NUMBER_ASC',
  UserBySsUserUConscriptionNumberDesc = 'USER_BY_SS_USER__U_CONSCRIPTION_NUMBER_DESC',
  UserBySsUserUCreatedAtAsc = 'USER_BY_SS_USER__U_CREATED_AT_ASC',
  UserBySsUserUCreatedAtDesc = 'USER_BY_SS_USER__U_CREATED_AT_DESC',
  UserBySsUserUDancerAsc = 'USER_BY_SS_USER__U_DANCER_ASC',
  UserBySsUserUDancerDesc = 'USER_BY_SS_USER__U_DANCER_DESC',
  UserBySsUserUDistrictAsc = 'USER_BY_SS_USER__U_DISTRICT_ASC',
  UserBySsUserUDistrictDesc = 'USER_BY_SS_USER__U_DISTRICT_DESC',
  UserBySsUserUEmailAsc = 'USER_BY_SS_USER__U_EMAIL_ASC',
  UserBySsUserUEmailDesc = 'USER_BY_SS_USER__U_EMAIL_DESC',
  UserBySsUserUGdprSignedAtAsc = 'USER_BY_SS_USER__U_GDPR_SIGNED_AT_ASC',
  UserBySsUserUGdprSignedAtDesc = 'USER_BY_SS_USER__U_GDPR_SIGNED_AT_DESC',
  UserBySsUserUGroupAsc = 'USER_BY_SS_USER__U_GROUP_ASC',
  UserBySsUserUGroupDesc = 'USER_BY_SS_USER__U_GROUP_DESC',
  UserBySsUserUIdAsc = 'USER_BY_SS_USER__U_ID_ASC',
  UserBySsUserUIdDesc = 'USER_BY_SS_USER__U_ID_DESC',
  UserBySsUserUJmenoAsc = 'USER_BY_SS_USER__U_JMENO_ASC',
  UserBySsUserUJmenoDesc = 'USER_BY_SS_USER__U_JMENO_DESC',
  UserBySsUserULevelAsc = 'USER_BY_SS_USER__U_LEVEL_ASC',
  UserBySsUserULevelDesc = 'USER_BY_SS_USER__U_LEVEL_DESC',
  UserBySsUserULockAsc = 'USER_BY_SS_USER__U_LOCK_ASC',
  UserBySsUserULockDesc = 'USER_BY_SS_USER__U_LOCK_DESC',
  UserBySsUserULoginAsc = 'USER_BY_SS_USER__U_LOGIN_ASC',
  UserBySsUserULoginDesc = 'USER_BY_SS_USER__U_LOGIN_DESC',
  UserBySsUserUMemberSinceAsc = 'USER_BY_SS_USER__U_MEMBER_SINCE_ASC',
  UserBySsUserUMemberSinceDesc = 'USER_BY_SS_USER__U_MEMBER_SINCE_DESC',
  UserBySsUserUMemberUntilAsc = 'USER_BY_SS_USER__U_MEMBER_UNTIL_ASC',
  UserBySsUserUMemberUntilDesc = 'USER_BY_SS_USER__U_MEMBER_UNTIL_DESC',
  UserBySsUserUNarozeniAsc = 'USER_BY_SS_USER__U_NAROZENI_ASC',
  UserBySsUserUNarozeniDesc = 'USER_BY_SS_USER__U_NAROZENI_DESC',
  UserBySsUserUNationalityAsc = 'USER_BY_SS_USER__U_NATIONALITY_ASC',
  UserBySsUserUNationalityDesc = 'USER_BY_SS_USER__U_NATIONALITY_DESC',
  UserBySsUserUOrientationNumberAsc = 'USER_BY_SS_USER__U_ORIENTATION_NUMBER_ASC',
  UserBySsUserUOrientationNumberDesc = 'USER_BY_SS_USER__U_ORIENTATION_NUMBER_DESC',
  UserBySsUserUPassAsc = 'USER_BY_SS_USER__U_PASS_ASC',
  UserBySsUserUPassDesc = 'USER_BY_SS_USER__U_PASS_DESC',
  UserBySsUserUPohlaviAsc = 'USER_BY_SS_USER__U_POHLAVI_ASC',
  UserBySsUserUPohlaviDesc = 'USER_BY_SS_USER__U_POHLAVI_DESC',
  UserBySsUserUPostalCodeAsc = 'USER_BY_SS_USER__U_POSTAL_CODE_ASC',
  UserBySsUserUPostalCodeDesc = 'USER_BY_SS_USER__U_POSTAL_CODE_DESC',
  UserBySsUserUPoznamkyAsc = 'USER_BY_SS_USER__U_POZNAMKY_ASC',
  UserBySsUserUPoznamkyDesc = 'USER_BY_SS_USER__U_POZNAMKY_DESC',
  UserBySsUserUPrijmeniAsc = 'USER_BY_SS_USER__U_PRIJMENI_ASC',
  UserBySsUserUPrijmeniDesc = 'USER_BY_SS_USER__U_PRIJMENI_DESC',
  UserBySsUserURodneCisloAsc = 'USER_BY_SS_USER__U_RODNE_CISLO_ASC',
  UserBySsUserURodneCisloDesc = 'USER_BY_SS_USER__U_RODNE_CISLO_DESC',
  UserBySsUserUSkupinaAsc = 'USER_BY_SS_USER__U_SKUPINA_ASC',
  UserBySsUserUSkupinaDesc = 'USER_BY_SS_USER__U_SKUPINA_DESC',
  UserBySsUserUStreetAsc = 'USER_BY_SS_USER__U_STREET_ASC',
  UserBySsUserUStreetDesc = 'USER_BY_SS_USER__U_STREET_DESC',
  UserBySsUserUSystemAsc = 'USER_BY_SS_USER__U_SYSTEM_ASC',
  UserBySsUserUSystemDesc = 'USER_BY_SS_USER__U_SYSTEM_DESC',
  UserBySsUserUTeacherAsc = 'USER_BY_SS_USER__U_TEACHER_ASC',
  UserBySsUserUTeacherDesc = 'USER_BY_SS_USER__U_TEACHER_DESC',
  UserBySsUserUTelefonAsc = 'USER_BY_SS_USER__U_TELEFON_ASC',
  UserBySsUserUTelefonDesc = 'USER_BY_SS_USER__U_TELEFON_DESC',
  UserBySsUserUTimestampAsc = 'USER_BY_SS_USER__U_TIMESTAMP_ASC',
  UserBySsUserUTimestampDesc = 'USER_BY_SS_USER__U_TIMESTAMP_DESC'
}

/** A connection to a list of `Skupiny` values. */
export type SkupiniesConnection = {
  __typename?: 'SkupiniesConnection';
  /** A list of edges which contains the `Skupiny` and cursor to aid in pagination. */
  edges: Array<SkupiniesEdge>;
  /** A list of `Skupiny` objects. */
  nodes: Array<Skupiny>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Skupiny` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Skupiny` edge in the connection. */
export type SkupiniesEdge = {
  __typename?: 'SkupiniesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Skupiny` at the end of the edge. */
  node: Skupiny;
};

/** Methods to use when ordering `Skupiny`. */
export enum SkupiniesOrderBy {
  CohortGroupAsc = 'COHORT_GROUP_ASC',
  CohortGroupByCohortGroupDescriptionAsc = 'COHORT_GROUP_BY_COHORT_GROUP__DESCRIPTION_ASC',
  CohortGroupByCohortGroupDescriptionDesc = 'COHORT_GROUP_BY_COHORT_GROUP__DESCRIPTION_DESC',
  CohortGroupByCohortGroupIdAsc = 'COHORT_GROUP_BY_COHORT_GROUP__ID_ASC',
  CohortGroupByCohortGroupIdDesc = 'COHORT_GROUP_BY_COHORT_GROUP__ID_DESC',
  CohortGroupByCohortGroupIsPublicAsc = 'COHORT_GROUP_BY_COHORT_GROUP__IS_PUBLIC_ASC',
  CohortGroupByCohortGroupIsPublicDesc = 'COHORT_GROUP_BY_COHORT_GROUP__IS_PUBLIC_DESC',
  CohortGroupByCohortGroupNameAsc = 'COHORT_GROUP_BY_COHORT_GROUP__NAME_ASC',
  CohortGroupByCohortGroupNameDesc = 'COHORT_GROUP_BY_COHORT_GROUP__NAME_DESC',
  CohortGroupByCohortGroupOrderingAsc = 'COHORT_GROUP_BY_COHORT_GROUP__ORDERING_ASC',
  CohortGroupByCohortGroupOrderingDesc = 'COHORT_GROUP_BY_COHORT_GROUP__ORDERING_DESC',
  CohortGroupByCohortGroupTenantAsc = 'COHORT_GROUP_BY_COHORT_GROUP__TENANT_ASC',
  CohortGroupByCohortGroupTenantDesc = 'COHORT_GROUP_BY_COHORT_GROUP__TENANT_DESC',
  CohortGroupDesc = 'COHORT_GROUP_DESC',
  InternalInfoAsc = 'INTERNAL_INFO_ASC',
  InternalInfoDesc = 'INTERNAL_INFO_DESC',
  Natural = 'NATURAL',
  OrderingAsc = 'ORDERING_ASC',
  OrderingDesc = 'ORDERING_DESC',
  PlatbyGroupSkupinasByPgsIdSkupinaCountAsc = 'PLATBY_GROUP_SKUPINAS_BY_PGS_ID_SKUPINA__COUNT_ASC',
  PlatbyGroupSkupinasByPgsIdSkupinaCountDesc = 'PLATBY_GROUP_SKUPINAS_BY_PGS_ID_SKUPINA__COUNT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SColorRgbAsc = 'S_COLOR_RGB_ASC',
  SColorRgbDesc = 'S_COLOR_RGB_DESC',
  SColorTextAsc = 'S_COLOR_TEXT_ASC',
  SColorTextDesc = 'S_COLOR_TEXT_DESC',
  SDescriptionAsc = 'S_DESCRIPTION_ASC',
  SDescriptionDesc = 'S_DESCRIPTION_DESC',
  SIdAsc = 'S_ID_ASC',
  SIdDesc = 'S_ID_DESC',
  SLocationAsc = 'S_LOCATION_ASC',
  SLocationDesc = 'S_LOCATION_DESC',
  SNameAsc = 'S_NAME_ASC',
  SNameDesc = 'S_NAME_DESC',
  SVisibleAsc = 'S_VISIBLE_ASC',
  SVisibleDesc = 'S_VISIBLE_DESC',
  UpozorneniSkupiniesByUpsIdSkupinaCountAsc = 'UPOZORNENI_SKUPINIES_BY_UPS_ID_SKUPINA__COUNT_ASC',
  UpozorneniSkupiniesByUpsIdSkupinaCountDesc = 'UPOZORNENI_SKUPINIES_BY_UPS_ID_SKUPINA__COUNT_DESC',
  UsersByUSkupinaCountAsc = 'USERS_BY_U_SKUPINA__COUNT_ASC',
  UsersByUSkupinaCountDesc = 'USERS_BY_U_SKUPINA__COUNT_DESC'
}

export type Skupiny = Node & {
  __typename?: 'Skupiny';
  cohortGroup: Maybe<Scalars['BigInt']>;
  /** Reads a single `CohortGroup` that is related to this `Skupiny`. */
  cohortGroupByCohortGroup: Maybe<CohortGroup>;
  internalInfo: Scalars['JSON'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  ordering: Scalars['Int'];
  /** Reads and enables pagination through a set of `PlatbyGroupSkupina`. */
  platbyGroupSkupinasByPgsIdSkupina: PlatbyGroupSkupinasConnection;
  sColorRgb: Scalars['String'];
  sColorText: Scalars['String'];
  sDescription: Scalars['String'];
  sId: Scalars['BigInt'];
  sLocation: Scalars['String'];
  sName: Scalars['String'];
  sVisible: Scalars['Boolean'];
  /** Reads and enables pagination through a set of `UpozorneniSkupiny`. */
  upozorneniSkupiniesByUpsIdSkupina: UpozorneniSkupiniesConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByUSkupina: UsersConnection;
};


export type SkupinyPlatbyGroupSkupinasByPgsIdSkupinaArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyGroupSkupinaCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyGroupSkupinasOrderBy>>;
};


export type SkupinyUpozorneniSkupiniesByUpsIdSkupinaArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<UpozorneniSkupinyCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UpozorneniSkupiniesOrderBy>>;
};


export type SkupinyUsersByUSkupinaArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<UserCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** A condition to be used against `Skupiny` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type SkupinyCondition = {
  /** Checks for equality with the object’s `cohortGroup` field. */
  cohortGroup?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `internalInfo` field. */
  internalInfo?: InputMaybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `ordering` field. */
  ordering?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sColorRgb` field. */
  sColorRgb?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sColorText` field. */
  sColorText?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sDescription` field. */
  sDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sId` field. */
  sId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `sLocation` field. */
  sLocation?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sName` field. */
  sName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sVisible` field. */
  sVisible?: InputMaybe<Scalars['Boolean']>;
};

/** An input for mutations affecting `Skupiny` */
export type SkupinyInput = {
  cohortGroup?: InputMaybe<Scalars['BigInt']>;
  internalInfo?: InputMaybe<Scalars['JSON']>;
  ordering?: InputMaybe<Scalars['Int']>;
  sColorRgb: Scalars['String'];
  sColorText?: InputMaybe<Scalars['String']>;
  sDescription: Scalars['String'];
  sId?: InputMaybe<Scalars['BigInt']>;
  sLocation?: InputMaybe<Scalars['String']>;
  sName: Scalars['String'];
  sVisible?: InputMaybe<Scalars['Boolean']>;
};

/** Represents an update to a `Skupiny`. Fields that are set will be updated. */
export type SkupinyPatch = {
  cohortGroup?: InputMaybe<Scalars['BigInt']>;
  internalInfo?: InputMaybe<Scalars['JSON']>;
  ordering?: InputMaybe<Scalars['Int']>;
  sColorRgb?: InputMaybe<Scalars['String']>;
  sColorText?: InputMaybe<Scalars['String']>;
  sDescription?: InputMaybe<Scalars['String']>;
  sId?: InputMaybe<Scalars['BigInt']>;
  sLocation?: InputMaybe<Scalars['String']>;
  sName?: InputMaybe<Scalars['String']>;
  sVisible?: InputMaybe<Scalars['Boolean']>;
};

export type Tenant = Node & {
  __typename?: 'Tenant';
  /** Reads and enables pagination through a set of `CohortGroup`. */
  cohortGroupsByTenant: CohortGroupsConnection;
  id: Scalars['BigInt'];
  /** Reads and enables pagination through a set of `Location`. */
  locationsByTenant: LocationsConnection;
  memberInfo: Scalars['JSON'];
  name: Scalars['String'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads and enables pagination through a set of `TenantAttachment`. */
  tenantAttachments: TenantAttachmentsConnection;
  /** Reads and enables pagination through a set of `TenantPerson`. */
  tenantPeople: TenantPeopleConnection;
};


export type TenantCohortGroupsByTenantArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<CohortGroupCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CohortGroupsOrderBy>>;
};


export type TenantLocationsByTenantArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<LocationCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LocationsOrderBy>>;
};


export type TenantTenantAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<TenantAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TenantAttachmentsOrderBy>>;
};


export type TenantTenantPeopleArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<TenantPersonCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TenantPeopleOrderBy>>;
};

export type TenantAttachment = Node & {
  __typename?: 'TenantAttachment';
  /** Reads a single `Attachment` that is related to this `TenantAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  objectName: Scalars['String'];
  /** Reads a single `Tenant` that is related to this `TenantAttachment`. */
  tenant: Maybe<Tenant>;
  tenantId: Scalars['BigInt'];
  type: Maybe<TenantAttachmentType>;
};

/**
 * A condition to be used against `TenantAttachment` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TenantAttachmentCondition = {
  /** Checks for equality with the object’s `objectName` field. */
  objectName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `tenantId` field. */
  tenantId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<TenantAttachmentType>;
};

/** An input for mutations affecting `TenantAttachment` */
export type TenantAttachmentInput = {
  objectName: Scalars['String'];
  tenantId: Scalars['BigInt'];
  type?: InputMaybe<TenantAttachmentType>;
};

/** Represents an update to a `TenantAttachment`. Fields that are set will be updated. */
export type TenantAttachmentPatch = {
  objectName?: InputMaybe<Scalars['String']>;
  tenantId?: InputMaybe<Scalars['BigInt']>;
  type?: InputMaybe<TenantAttachmentType>;
};

/** A connection to a list of `TenantAttachment` values. */
export type TenantAttachmentsConnection = {
  __typename?: 'TenantAttachmentsConnection';
  /** A list of edges which contains the `TenantAttachment` and cursor to aid in pagination. */
  edges: Array<TenantAttachmentsEdge>;
  /** A list of `TenantAttachment` objects. */
  nodes: Array<TenantAttachment>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TenantAttachment` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `TenantAttachment` edge in the connection. */
export type TenantAttachmentsEdge = {
  __typename?: 'TenantAttachmentsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `TenantAttachment` at the end of the edge. */
  node: TenantAttachment;
};

/** Methods to use when ordering `TenantAttachment`. */
export enum TenantAttachmentsOrderBy {
  AttachmentByObjectNameObjectNameAsc = 'ATTACHMENT_BY_OBJECT_NAME__OBJECT_NAME_ASC',
  AttachmentByObjectNameObjectNameDesc = 'ATTACHMENT_BY_OBJECT_NAME__OBJECT_NAME_DESC',
  AttachmentByObjectNamePreviewObjectNameAsc = 'ATTACHMENT_BY_OBJECT_NAME__PREVIEW_OBJECT_NAME_ASC',
  AttachmentByObjectNamePreviewObjectNameDesc = 'ATTACHMENT_BY_OBJECT_NAME__PREVIEW_OBJECT_NAME_DESC',
  AttachmentByObjectNameUploadedAtAsc = 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_AT_ASC',
  AttachmentByObjectNameUploadedAtDesc = 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_AT_DESC',
  AttachmentByObjectNameUploadedByAsc = 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_BY_ASC',
  AttachmentByObjectNameUploadedByDesc = 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_BY_DESC',
  Natural = 'NATURAL',
  ObjectNameAsc = 'OBJECT_NAME_ASC',
  ObjectNameDesc = 'OBJECT_NAME_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TenantByTenantIdIdAsc = 'TENANT_BY_TENANT_ID__ID_ASC',
  TenantByTenantIdIdDesc = 'TENANT_BY_TENANT_ID__ID_DESC',
  TenantByTenantIdMemberInfoAsc = 'TENANT_BY_TENANT_ID__MEMBER_INFO_ASC',
  TenantByTenantIdMemberInfoDesc = 'TENANT_BY_TENANT_ID__MEMBER_INFO_DESC',
  TenantByTenantIdNameAsc = 'TENANT_BY_TENANT_ID__NAME_ASC',
  TenantByTenantIdNameDesc = 'TENANT_BY_TENANT_ID__NAME_DESC',
  TenantIdAsc = 'TENANT_ID_ASC',
  TenantIdDesc = 'TENANT_ID_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC'
}

export enum TenantAttachmentType {
  Logo = 'LOGO',
  Map = 'MAP',
  Photo = 'PHOTO'
}

/** A condition to be used against `Tenant` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TenantCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `memberInfo` field. */
  memberInfo?: InputMaybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
};

/** An input for mutations affecting `Tenant` */
export type TenantInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  memberInfo: Scalars['JSON'];
  name: Scalars['String'];
};

/** Represents an update to a `Tenant`. Fields that are set will be updated. */
export type TenantPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  memberInfo?: InputMaybe<Scalars['JSON']>;
  name?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `TenantPerson` values. */
export type TenantPeopleConnection = {
  __typename?: 'TenantPeopleConnection';
  /** A list of edges which contains the `TenantPerson` and cursor to aid in pagination. */
  edges: Array<TenantPeopleEdge>;
  /** A list of `TenantPerson` objects. */
  nodes: Array<TenantPerson>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TenantPerson` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `TenantPerson` edge in the connection. */
export type TenantPeopleEdge = {
  __typename?: 'TenantPeopleEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `TenantPerson` at the end of the edge. */
  node: TenantPerson;
};

/** Methods to use when ordering `TenantPerson`. */
export enum TenantPeopleOrderBy {
  Natural = 'NATURAL',
  PersonByPersonIdFirstNameAsc = 'PERSON_BY_PERSON_ID__FIRST_NAME_ASC',
  PersonByPersonIdFirstNameDesc = 'PERSON_BY_PERSON_ID__FIRST_NAME_DESC',
  PersonByPersonIdGenderAsc = 'PERSON_BY_PERSON_ID__GENDER_ASC',
  PersonByPersonIdGenderDesc = 'PERSON_BY_PERSON_ID__GENDER_DESC',
  PersonByPersonIdIdAsc = 'PERSON_BY_PERSON_ID__ID_ASC',
  PersonByPersonIdIdDesc = 'PERSON_BY_PERSON_ID__ID_DESC',
  PersonByPersonIdLastNameAsc = 'PERSON_BY_PERSON_ID__LAST_NAME_ASC',
  PersonByPersonIdLastNameDesc = 'PERSON_BY_PERSON_ID__LAST_NAME_DESC',
  PersonIdAsc = 'PERSON_ID_ASC',
  PersonIdDesc = 'PERSON_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TenantByTenantIdIdAsc = 'TENANT_BY_TENANT_ID__ID_ASC',
  TenantByTenantIdIdDesc = 'TENANT_BY_TENANT_ID__ID_DESC',
  TenantByTenantIdMemberInfoAsc = 'TENANT_BY_TENANT_ID__MEMBER_INFO_ASC',
  TenantByTenantIdMemberInfoDesc = 'TENANT_BY_TENANT_ID__MEMBER_INFO_DESC',
  TenantByTenantIdNameAsc = 'TENANT_BY_TENANT_ID__NAME_ASC',
  TenantByTenantIdNameDesc = 'TENANT_BY_TENANT_ID__NAME_DESC',
  TenantIdAsc = 'TENANT_ID_ASC',
  TenantIdDesc = 'TENANT_ID_DESC'
}

export type TenantPerson = Node & {
  __typename?: 'TenantPerson';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `Person` that is related to this `TenantPerson`. */
  person: Maybe<Person>;
  personId: Scalars['BigInt'];
  /** Reads a single `Tenant` that is related to this `TenantPerson`. */
  tenant: Maybe<Tenant>;
  tenantId: Scalars['BigInt'];
};

/**
 * A condition to be used against `TenantPerson` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TenantPersonCondition = {
  /** Checks for equality with the object’s `personId` field. */
  personId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `tenantId` field. */
  tenantId?: InputMaybe<Scalars['BigInt']>;
};

/** An input for mutations affecting `TenantPerson` */
export type TenantPersonInput = {
  personId: Scalars['BigInt'];
  tenantId: Scalars['BigInt'];
};

/** Represents an update to a `TenantPerson`. Fields that are set will be updated. */
export type TenantPersonPatch = {
  personId?: InputMaybe<Scalars['BigInt']>;
  tenantId?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `Tenant` values. */
export type TenantsConnection = {
  __typename?: 'TenantsConnection';
  /** A list of edges which contains the `Tenant` and cursor to aid in pagination. */
  edges: Array<TenantsEdge>;
  /** A list of `Tenant` objects. */
  nodes: Array<Tenant>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Tenant` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Tenant` edge in the connection. */
export type TenantsEdge = {
  __typename?: 'TenantsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Tenant` at the end of the edge. */
  node: Tenant;
};

/** Methods to use when ordering `Tenant`. */
export enum TenantsOrderBy {
  CohortGroupsByTenantCountAsc = 'COHORT_GROUPS_BY_TENANT__COUNT_ASC',
  CohortGroupsByTenantCountDesc = 'COHORT_GROUPS_BY_TENANT__COUNT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LocationsByTenantCountAsc = 'LOCATIONS_BY_TENANT__COUNT_ASC',
  LocationsByTenantCountDesc = 'LOCATIONS_BY_TENANT__COUNT_DESC',
  MemberInfoAsc = 'MEMBER_INFO_ASC',
  MemberInfoDesc = 'MEMBER_INFO_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TenantAttachmentsByTenantIdCountAsc = 'TENANT_ATTACHMENTS_BY_TENANT_ID__COUNT_ASC',
  TenantAttachmentsByTenantIdCountDesc = 'TENANT_ATTACHMENTS_BY_TENANT_ID__COUNT_DESC',
  TenantPeopleByTenantIdCountAsc = 'TENANT_PEOPLE_BY_TENANT_ID__COUNT_ASC',
  TenantPeopleByTenantIdCountDesc = 'TENANT_PEOPLE_BY_TENANT_ID__COUNT_DESC'
}

/** All input for the `updateAktualityByNodeId` mutation. */
export type UpdateAktualityByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Aktuality` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Aktuality` being updated. */
  patch: AktualityPatch;
};

/** All input for the `updateAktuality` mutation. */
export type UpdateAktualityInput = {
  atId: Scalars['BigInt'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Aktuality` being updated. */
  patch: AktualityPatch;
};

/** The output of our update `Aktuality` mutation. */
export type UpdateAktualityPayload = {
  __typename?: 'UpdateAktualityPayload';
  /** The `Aktuality` that was updated by this mutation. */
  aktuality: Maybe<Aktuality>;
  /** An edge for our `Aktuality`. May be used by Relay 1. */
  aktualityEdge: Maybe<AktualitiesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
  galerieFotoByAtFotoMain: Maybe<GalerieFoto>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Aktuality`. */
  userByAtKdo: Maybe<User>;
};


/** The output of our update `Aktuality` mutation. */
export type UpdateAktualityPayloadAktualityEdgeArgs = {
  orderBy?: InputMaybe<Array<AktualitiesOrderBy>>;
};

/** All input for the `updateAttachmentByNodeId` mutation. */
export type UpdateAttachmentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Attachment` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Attachment` being updated. */
  patch: AttachmentPatch;
};

/** All input for the `updateAttachment` mutation. */
export type UpdateAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  objectName: Scalars['String'];
  /** An object where the defined keys will be set on the `Attachment` being updated. */
  patch: AttachmentPatch;
};

/** The output of our update `Attachment` mutation. */
export type UpdateAttachmentPayload = {
  __typename?: 'UpdateAttachmentPayload';
  /** The `Attachment` that was updated by this mutation. */
  attachment: Maybe<Attachment>;
  /** An edge for our `Attachment`. May be used by Relay 1. */
  attachmentEdge: Maybe<AttachmentsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Attachment`. */
  userByUploadedBy: Maybe<User>;
};


/** The output of our update `Attachment` mutation. */
export type UpdateAttachmentPayloadAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<AttachmentsOrderBy>>;
};

/** All input for the `updateAttendeeExternalByNodeId` mutation. */
export type UpdateAttendeeExternalByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `AttendeeExternal` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `AttendeeExternal` being updated. */
  patch: AttendeeExternalPatch;
};

/** All input for the `updateAttendeeExternal` mutation. */
export type UpdateAttendeeExternalInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `AttendeeExternal` being updated. */
  patch: AttendeeExternalPatch;
};

/** The output of our update `AttendeeExternal` mutation. */
export type UpdateAttendeeExternalPayload = {
  __typename?: 'UpdateAttendeeExternalPayload';
  /** The `AttendeeExternal` that was updated by this mutation. */
  attendeeExternal: Maybe<AttendeeExternal>;
  /** An edge for our `AttendeeExternal`. May be used by Relay 1. */
  attendeeExternalEdge: Maybe<AttendeeExternalsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Event` that is related to this `AttendeeExternal`. */
  event: Maybe<Event>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `AttendeeExternal`. */
  userByConfirmedBy: Maybe<User>;
  /** Reads a single `User` that is related to this `AttendeeExternal`. */
  userByManagedBy: Maybe<User>;
};


/** The output of our update `AttendeeExternal` mutation. */
export type UpdateAttendeeExternalPayloadAttendeeExternalEdgeArgs = {
  orderBy?: InputMaybe<Array<AttendeeExternalsOrderBy>>;
};

/** All input for the `updateAttendeeUserByNodeId` mutation. */
export type UpdateAttendeeUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `AttendeeUser` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `AttendeeUser` being updated. */
  patch: AttendeeUserPatch;
};

/** All input for the `updateAttendeeUserByUserIdAndEventId` mutation. */
export type UpdateAttendeeUserByUserIdAndEventIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  eventId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `AttendeeUser` being updated. */
  patch: AttendeeUserPatch;
  userId: Scalars['BigInt'];
};

/** All input for the `updateAttendeeUser` mutation. */
export type UpdateAttendeeUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `AttendeeUser` being updated. */
  patch: AttendeeUserPatch;
};

/** The output of our update `AttendeeUser` mutation. */
export type UpdateAttendeeUserPayload = {
  __typename?: 'UpdateAttendeeUserPayload';
  /** The `AttendeeUser` that was updated by this mutation. */
  attendeeUser: Maybe<AttendeeUser>;
  /** An edge for our `AttendeeUser`. May be used by Relay 1. */
  attendeeUserEdge: Maybe<AttendeeUsersEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Event` that is related to this `AttendeeUser`. */
  event: Maybe<Event>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `AttendeeUser`. */
  user: Maybe<User>;
};


/** The output of our update `AttendeeUser` mutation. */
export type UpdateAttendeeUserPayloadAttendeeUserEdgeArgs = {
  orderBy?: InputMaybe<Array<AttendeeUsersOrderBy>>;
};

/** All input for the `updateCohortGroupByNodeId` mutation. */
export type UpdateCohortGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CohortGroup` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CohortGroup` being updated. */
  patch: CohortGroupPatch;
};

/** All input for the `updateCohortGroup` mutation. */
export type UpdateCohortGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `CohortGroup` being updated. */
  patch: CohortGroupPatch;
};

/** The output of our update `CohortGroup` mutation. */
export type UpdateCohortGroupPayload = {
  __typename?: 'UpdateCohortGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `CohortGroup` that was updated by this mutation. */
  cohortGroup: Maybe<CohortGroup>;
  /** An edge for our `CohortGroup`. May be used by Relay 1. */
  cohortGroupEdge: Maybe<CohortGroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `CohortGroup`. */
  tenantByTenant: Maybe<Tenant>;
};


/** The output of our update `CohortGroup` mutation. */
export type UpdateCohortGroupPayloadCohortGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<CohortGroupsOrderBy>>;
};

/** All input for the `updateDokumentyByNodeId` mutation. */
export type UpdateDokumentyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Dokumenty` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Dokumenty` being updated. */
  patch: DokumentyPatch;
};

/** All input for the `updateDokumenty` mutation. */
export type UpdateDokumentyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  dId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `Dokumenty` being updated. */
  patch: DokumentyPatch;
};

/** The output of our update `Dokumenty` mutation. */
export type UpdateDokumentyPayload = {
  __typename?: 'UpdateDokumentyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Dokumenty` that was updated by this mutation. */
  dokumenty: Maybe<Dokumenty>;
  /** An edge for our `Dokumenty`. May be used by Relay 1. */
  dokumentyEdge: Maybe<DokumentiesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Dokumenty`. */
  userByDKdo: Maybe<User>;
};


/** The output of our update `Dokumenty` mutation. */
export type UpdateDokumentyPayloadDokumentyEdgeArgs = {
  orderBy?: InputMaybe<Array<DokumentiesOrderBy>>;
};

/** All input for the `updateEventByNodeId` mutation. */
export type UpdateEventByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Event` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Event` being updated. */
  patch: EventPatch;
};

/** All input for the `updateEvent` mutation. */
export type UpdateEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `Event` being updated. */
  patch: EventPatch;
};

/** The output of our update `Event` mutation. */
export type UpdateEventPayload = {
  __typename?: 'UpdateEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Event` that was updated by this mutation. */
  event: Maybe<Event>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge: Maybe<EventsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Event` mutation. */
export type UpdateEventPayloadEventEdgeArgs = {
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};

/** All input for the `updateGalerieDirByNodeId` mutation. */
export type UpdateGalerieDirByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GalerieDir` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `GalerieDir` being updated. */
  patch: GalerieDirPatch;
};

/** All input for the `updateGalerieDir` mutation. */
export type UpdateGalerieDirInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  gdId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `GalerieDir` being updated. */
  patch: GalerieDirPatch;
};

/** The output of our update `GalerieDir` mutation. */
export type UpdateGalerieDirPayload = {
  __typename?: 'UpdateGalerieDirPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GalerieDir` that was updated by this mutation. */
  galerieDir: Maybe<GalerieDir>;
  /** An edge for our `GalerieDir`. May be used by Relay 1. */
  galerieDirEdge: Maybe<GalerieDirsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `GalerieDir` mutation. */
export type UpdateGalerieDirPayloadGalerieDirEdgeArgs = {
  orderBy?: InputMaybe<Array<GalerieDirsOrderBy>>;
};

/** All input for the `updateGalerieFotoByNodeId` mutation. */
export type UpdateGalerieFotoByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GalerieFoto` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `GalerieFoto` being updated. */
  patch: GalerieFotoPatch;
};

/** All input for the `updateGalerieFoto` mutation. */
export type UpdateGalerieFotoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  gfId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `GalerieFoto` being updated. */
  patch: GalerieFotoPatch;
};

/** The output of our update `GalerieFoto` mutation. */
export type UpdateGalerieFotoPayload = {
  __typename?: 'UpdateGalerieFotoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
  galerieDirByGfIdRodic: Maybe<GalerieDir>;
  /** The `GalerieFoto` that was updated by this mutation. */
  galerieFoto: Maybe<GalerieFoto>;
  /** An edge for our `GalerieFoto`. May be used by Relay 1. */
  galerieFotoEdge: Maybe<GalerieFotosEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `GalerieFoto`. */
  userByGfKdo: Maybe<User>;
};


/** The output of our update `GalerieFoto` mutation. */
export type UpdateGalerieFotoPayloadGalerieFotoEdgeArgs = {
  orderBy?: InputMaybe<Array<GalerieFotosOrderBy>>;
};

/** All input for the `updateLocationAttachmentByNodeId` mutation. */
export type UpdateLocationAttachmentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LocationAttachment` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `LocationAttachment` being updated. */
  patch: LocationAttachmentPatch;
};

/** All input for the `updateLocationAttachment` mutation. */
export type UpdateLocationAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  locationId: Scalars['BigInt'];
  objectName: Scalars['String'];
  /** An object where the defined keys will be set on the `LocationAttachment` being updated. */
  patch: LocationAttachmentPatch;
};

/** The output of our update `LocationAttachment` mutation. */
export type UpdateLocationAttachmentPayload = {
  __typename?: 'UpdateLocationAttachmentPayload';
  /** Reads a single `Attachment` that is related to this `LocationAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Location` that is related to this `LocationAttachment`. */
  location: Maybe<Location>;
  /** The `LocationAttachment` that was updated by this mutation. */
  locationAttachment: Maybe<LocationAttachment>;
  /** An edge for our `LocationAttachment`. May be used by Relay 1. */
  locationAttachmentEdge: Maybe<LocationAttachmentsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `LocationAttachment` mutation. */
export type UpdateLocationAttachmentPayloadLocationAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<LocationAttachmentsOrderBy>>;
};

/** All input for the `updateLocationByNodeId` mutation. */
export type UpdateLocationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Location` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Location` being updated. */
  patch: LocationPatch;
};

/** All input for the `updateLocation` mutation. */
export type UpdateLocationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `Location` being updated. */
  patch: LocationPatch;
};

/** The output of our update `Location` mutation. */
export type UpdateLocationPayload = {
  __typename?: 'UpdateLocationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Location` that was updated by this mutation. */
  location: Maybe<Location>;
  /** An edge for our `Location`. May be used by Relay 1. */
  locationEdge: Maybe<LocationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `Location`. */
  tenantByTenant: Maybe<Tenant>;
};


/** The output of our update `Location` mutation. */
export type UpdateLocationPayloadLocationEdgeArgs = {
  orderBy?: InputMaybe<Array<LocationsOrderBy>>;
};

/** All input for the `updateNabidkaByNodeId` mutation. */
export type UpdateNabidkaByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Nabidka` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Nabidka` being updated. */
  patch: NabidkaPatch;
};

/** All input for the `updateNabidka` mutation. */
export type UpdateNabidkaInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  nId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `Nabidka` being updated. */
  patch: NabidkaPatch;
};

/** All input for the `updateNabidkaItemByNiPartnerAndNiIdRodic` mutation. */
export type UpdateNabidkaItemByNiPartnerAndNiIdRodicInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  niIdRodic: Scalars['BigInt'];
  niPartner: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `NabidkaItem` being updated. */
  patch: NabidkaItemPatch;
};

/** All input for the `updateNabidkaItemByNodeId` mutation. */
export type UpdateNabidkaItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `NabidkaItem` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `NabidkaItem` being updated. */
  patch: NabidkaItemPatch;
};

/** All input for the `updateNabidkaItem` mutation. */
export type UpdateNabidkaItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  niId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `NabidkaItem` being updated. */
  patch: NabidkaItemPatch;
};

/** The output of our update `NabidkaItem` mutation. */
export type UpdateNabidkaItemPayload = {
  __typename?: 'UpdateNabidkaItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Nabidka` that is related to this `NabidkaItem`. */
  nabidkaByNiIdRodic: Maybe<Nabidka>;
  /** The `NabidkaItem` that was updated by this mutation. */
  nabidkaItem: Maybe<NabidkaItem>;
  /** An edge for our `NabidkaItem`. May be used by Relay 1. */
  nabidkaItemEdge: Maybe<NabidkaItemsEdge>;
  /** Reads a single `Pary` that is related to this `NabidkaItem`. */
  paryByNiPartner: Maybe<Pary>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `NabidkaItem` mutation. */
export type UpdateNabidkaItemPayloadNabidkaItemEdgeArgs = {
  orderBy?: InputMaybe<Array<NabidkaItemsOrderBy>>;
};

/** The output of our update `Nabidka` mutation. */
export type UpdateNabidkaPayload = {
  __typename?: 'UpdateNabidkaPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Nabidka` that was updated by this mutation. */
  nabidka: Maybe<Nabidka>;
  /** An edge for our `Nabidka`. May be used by Relay 1. */
  nabidkaEdge: Maybe<NabidkasEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Nabidka`. */
  userByNTrener: Maybe<User>;
};


/** The output of our update `Nabidka` mutation. */
export type UpdateNabidkaPayloadNabidkaEdgeArgs = {
  orderBy?: InputMaybe<Array<NabidkasOrderBy>>;
};

/** All input for the `updatePageByNodeId` mutation. */
export type UpdatePageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Page` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Page` being updated. */
  patch: PagePatch;
};

/** All input for the `updatePageByUrl` mutation. */
export type UpdatePageByUrlInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Page` being updated. */
  patch: PagePatch;
  url: Scalars['String'];
};

/** All input for the `updatePage` mutation. */
export type UpdatePageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `Page` being updated. */
  patch: PagePatch;
};

/** The output of our update `Page` mutation. */
export type UpdatePagePayload = {
  __typename?: 'UpdatePagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Page` that was updated by this mutation. */
  page: Maybe<Page>;
  /** An edge for our `Page`. May be used by Relay 1. */
  pageEdge: Maybe<PagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Page` mutation. */
export type UpdatePagePayloadPageEdgeArgs = {
  orderBy?: InputMaybe<Array<PagesOrderBy>>;
};

/** All input for the `updateParameterByNodeId` mutation. */
export type UpdateParameterByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Parameter` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Parameter` being updated. */
  patch: ParameterPatch;
};

/** All input for the `updateParameter` mutation. */
export type UpdateParameterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  paName: Scalars['String'];
  /** An object where the defined keys will be set on the `Parameter` being updated. */
  patch: ParameterPatch;
};

/** The output of our update `Parameter` mutation. */
export type UpdateParameterPayload = {
  __typename?: 'UpdateParameterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Parameter` that was updated by this mutation. */
  parameter: Maybe<Parameter>;
  /** An edge for our `Parameter`. May be used by Relay 1. */
  parameterEdge: Maybe<ParametersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Parameter` mutation. */
export type UpdateParameterPayloadParameterEdgeArgs = {
  orderBy?: InputMaybe<Array<ParametersOrderBy>>;
};

/** All input for the `updateParyByNodeId` mutation. */
export type UpdateParyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Pary` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Pary` being updated. */
  patch: ParyPatch;
};

/** All input for the `updatePary` mutation. */
export type UpdateParyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Pary` being updated. */
  patch: ParyPatch;
  pId: Scalars['BigInt'];
};

/** All input for the `updateParyNavrhByNodeId` mutation. */
export type UpdateParyNavrhByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ParyNavrh` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ParyNavrh` being updated. */
  patch: ParyNavrhPatch;
};

/** All input for the `updateParyNavrh` mutation. */
export type UpdateParyNavrhInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ParyNavrh` being updated. */
  patch: ParyNavrhPatch;
  pnId: Scalars['BigInt'];
};

/** The output of our update `ParyNavrh` mutation. */
export type UpdateParyNavrhPayload = {
  __typename?: 'UpdateParyNavrhPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ParyNavrh` that was updated by this mutation. */
  paryNavrh: Maybe<ParyNavrh>;
  /** An edge for our `ParyNavrh`. May be used by Relay 1. */
  paryNavrhEdge: Maybe<ParyNavrhsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnNavrhl: Maybe<User>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnPartnerka: Maybe<User>;
};


/** The output of our update `ParyNavrh` mutation. */
export type UpdateParyNavrhPayloadParyNavrhEdgeArgs = {
  orderBy?: InputMaybe<Array<ParyNavrhsOrderBy>>;
};

/** The output of our update `Pary` mutation. */
export type UpdateParyPayload = {
  __typename?: 'UpdateParyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Pary` that was updated by this mutation. */
  pary: Maybe<Pary>;
  /** An edge for our `Pary`. May be used by Relay 1. */
  paryEdge: Maybe<PariesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartnerka: Maybe<User>;
};


/** The output of our update `Pary` mutation. */
export type UpdateParyPayloadParyEdgeArgs = {
  orderBy?: InputMaybe<Array<PariesOrderBy>>;
};

/** All input for the `updatePermissionByNodeId` mutation. */
export type UpdatePermissionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Permission` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Permission` being updated. */
  patch: PermissionPatch;
};

/** All input for the `updatePermission` mutation. */
export type UpdatePermissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Permission` being updated. */
  patch: PermissionPatch;
  peId: Scalars['BigInt'];
};

/** The output of our update `Permission` mutation. */
export type UpdatePermissionPayload = {
  __typename?: 'UpdatePermissionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Permission` that was updated by this mutation. */
  permission: Maybe<Permission>;
  /** An edge for our `Permission`. May be used by Relay 1. */
  permissionEdge: Maybe<PermissionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Permission` mutation. */
export type UpdatePermissionPayloadPermissionEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
};

/** All input for the `updatePersonByNodeId` mutation. */
export type UpdatePersonByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Person` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Person` being updated. */
  patch: PersonPatch;
};

/** All input for the `updatePerson` mutation. */
export type UpdatePersonInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `Person` being updated. */
  patch: PersonPatch;
};

/** The output of our update `Person` mutation. */
export type UpdatePersonPayload = {
  __typename?: 'UpdatePersonPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Person` that was updated by this mutation. */
  person: Maybe<Person>;
  /** An edge for our `Person`. May be used by Relay 1. */
  personEdge: Maybe<PeopleEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Person` mutation. */
export type UpdatePersonPayloadPersonEdgeArgs = {
  orderBy?: InputMaybe<Array<PeopleOrderBy>>;
};

/** All input for the `updatePlatbyCategoryByNodeId` mutation. */
export type UpdatePlatbyCategoryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyCategory` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PlatbyCategory` being updated. */
  patch: PlatbyCategoryPatch;
};

/** All input for the `updatePlatbyCategoryGroupByNodeId` mutation. */
export type UpdatePlatbyCategoryGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyCategoryGroup` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PlatbyCategoryGroup` being updated. */
  patch: PlatbyCategoryGroupPatch;
};

/** All input for the `updatePlatbyCategoryGroup` mutation. */
export type UpdatePlatbyCategoryGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PlatbyCategoryGroup` being updated. */
  patch: PlatbyCategoryGroupPatch;
  pcgId: Scalars['BigInt'];
};

/** The output of our update `PlatbyCategoryGroup` mutation. */
export type UpdatePlatbyCategoryGroupPayload = {
  __typename?: 'UpdatePlatbyCategoryGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyCategoryGroup`. */
  platbyCategoryByPcgIdCategory: Maybe<PlatbyCategory>;
  /** The `PlatbyCategoryGroup` that was updated by this mutation. */
  platbyCategoryGroup: Maybe<PlatbyCategoryGroup>;
  /** An edge for our `PlatbyCategoryGroup`. May be used by Relay 1. */
  platbyCategoryGroupEdge: Maybe<PlatbyCategoryGroupsEdge>;
  /** Reads a single `PlatbyGroup` that is related to this `PlatbyCategoryGroup`. */
  platbyGroupByPcgIdGroup: Maybe<PlatbyGroup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `PlatbyCategoryGroup` mutation. */
export type UpdatePlatbyCategoryGroupPayloadPlatbyCategoryGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyCategoryGroupsOrderBy>>;
};

/** All input for the `updatePlatbyCategory` mutation. */
export type UpdatePlatbyCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PlatbyCategory` being updated. */
  patch: PlatbyCategoryPatch;
  pcId: Scalars['BigInt'];
};

/** The output of our update `PlatbyCategory` mutation. */
export type UpdatePlatbyCategoryPayload = {
  __typename?: 'UpdatePlatbyCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlatbyCategory` that was updated by this mutation. */
  platbyCategory: Maybe<PlatbyCategory>;
  /** An edge for our `PlatbyCategory`. May be used by Relay 1. */
  platbyCategoryEdge: Maybe<PlatbyCategoriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `PlatbyCategory` mutation. */
export type UpdatePlatbyCategoryPayloadPlatbyCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyCategoriesOrderBy>>;
};

/** All input for the `updatePlatbyGroupByNodeId` mutation. */
export type UpdatePlatbyGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyGroup` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PlatbyGroup` being updated. */
  patch: PlatbyGroupPatch;
};

/** All input for the `updatePlatbyGroup` mutation. */
export type UpdatePlatbyGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PlatbyGroup` being updated. */
  patch: PlatbyGroupPatch;
  pgId: Scalars['BigInt'];
};

/** The output of our update `PlatbyGroup` mutation. */
export type UpdatePlatbyGroupPayload = {
  __typename?: 'UpdatePlatbyGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlatbyGroup` that was updated by this mutation. */
  platbyGroup: Maybe<PlatbyGroup>;
  /** An edge for our `PlatbyGroup`. May be used by Relay 1. */
  platbyGroupEdge: Maybe<PlatbyGroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `PlatbyGroup` mutation. */
export type UpdatePlatbyGroupPayloadPlatbyGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyGroupsOrderBy>>;
};

/** All input for the `updatePlatbyGroupSkupinaByNodeId` mutation. */
export type UpdatePlatbyGroupSkupinaByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyGroupSkupina` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PlatbyGroupSkupina` being updated. */
  patch: PlatbyGroupSkupinaPatch;
};

/** All input for the `updatePlatbyGroupSkupina` mutation. */
export type UpdatePlatbyGroupSkupinaInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PlatbyGroupSkupina` being updated. */
  patch: PlatbyGroupSkupinaPatch;
  pgsId: Scalars['BigInt'];
};

/** The output of our update `PlatbyGroupSkupina` mutation. */
export type UpdatePlatbyGroupSkupinaPayload = {
  __typename?: 'UpdatePlatbyGroupSkupinaPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `PlatbyGroup` that is related to this `PlatbyGroupSkupina`. */
  platbyGroupByPgsIdGroup: Maybe<PlatbyGroup>;
  /** The `PlatbyGroupSkupina` that was updated by this mutation. */
  platbyGroupSkupina: Maybe<PlatbyGroupSkupina>;
  /** An edge for our `PlatbyGroupSkupina`. May be used by Relay 1. */
  platbyGroupSkupinaEdge: Maybe<PlatbyGroupSkupinasEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `PlatbyGroupSkupina`. */
  skupinyByPgsIdSkupina: Maybe<Skupiny>;
};


/** The output of our update `PlatbyGroupSkupina` mutation. */
export type UpdatePlatbyGroupSkupinaPayloadPlatbyGroupSkupinaEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyGroupSkupinasOrderBy>>;
};

/** All input for the `updatePlatbyItemByNodeId` mutation. */
export type UpdatePlatbyItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyItem` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PlatbyItem` being updated. */
  patch: PlatbyItemPatch;
};

/** All input for the `updatePlatbyItem` mutation. */
export type UpdatePlatbyItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PlatbyItem` being updated. */
  patch: PlatbyItemPatch;
  piId: Scalars['BigInt'];
};

/** The output of our update `PlatbyItem` mutation. */
export type UpdatePlatbyItemPayload = {
  __typename?: 'UpdatePlatbyItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
  platbyCategoryByPiIdCategory: Maybe<PlatbyCategory>;
  /** The `PlatbyItem` that was updated by this mutation. */
  platbyItem: Maybe<PlatbyItem>;
  /** An edge for our `PlatbyItem`. May be used by Relay 1. */
  platbyItemEdge: Maybe<PlatbyItemsEdge>;
  /** Reads a single `PlatbyRaw` that is related to this `PlatbyItem`. */
  platbyRawByPiIdRaw: Maybe<PlatbyRaw>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `PlatbyItem`. */
  userByPiIdUser: Maybe<User>;
};


/** The output of our update `PlatbyItem` mutation. */
export type UpdatePlatbyItemPayloadPlatbyItemEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyItemsOrderBy>>;
};

/** All input for the `updatePlatbyRawByNodeId` mutation. */
export type UpdatePlatbyRawByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyRaw` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PlatbyRaw` being updated. */
  patch: PlatbyRawPatch;
};

/** All input for the `updatePlatbyRaw` mutation. */
export type UpdatePlatbyRawInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PlatbyRaw` being updated. */
  patch: PlatbyRawPatch;
  prId: Scalars['BigInt'];
};

/** The output of our update `PlatbyRaw` mutation. */
export type UpdatePlatbyRawPayload = {
  __typename?: 'UpdatePlatbyRawPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlatbyRaw` that was updated by this mutation. */
  platbyRaw: Maybe<PlatbyRaw>;
  /** An edge for our `PlatbyRaw`. May be used by Relay 1. */
  platbyRawEdge: Maybe<PlatbyRawsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `PlatbyRaw` mutation. */
export type UpdatePlatbyRawPayloadPlatbyRawEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyRawsOrderBy>>;
};

/** All input for the `updateRoomAttachmentByNodeId` mutation. */
export type UpdateRoomAttachmentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `RoomAttachment` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `RoomAttachment` being updated. */
  patch: RoomAttachmentPatch;
};

/** All input for the `updateRoomAttachment` mutation. */
export type UpdateRoomAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  objectName: Scalars['String'];
  /** An object where the defined keys will be set on the `RoomAttachment` being updated. */
  patch: RoomAttachmentPatch;
  roomId: Scalars['BigInt'];
};

/** The output of our update `RoomAttachment` mutation. */
export type UpdateRoomAttachmentPayload = {
  __typename?: 'UpdateRoomAttachmentPayload';
  /** Reads a single `Attachment` that is related to this `RoomAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Room` that is related to this `RoomAttachment`. */
  room: Maybe<Room>;
  /** The `RoomAttachment` that was updated by this mutation. */
  roomAttachment: Maybe<RoomAttachment>;
  /** An edge for our `RoomAttachment`. May be used by Relay 1. */
  roomAttachmentEdge: Maybe<RoomAttachmentsEdge>;
};


/** The output of our update `RoomAttachment` mutation. */
export type UpdateRoomAttachmentPayloadRoomAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<RoomAttachmentsOrderBy>>;
};

/** All input for the `updateRoomByNodeId` mutation. */
export type UpdateRoomByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Room` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Room` being updated. */
  patch: RoomPatch;
};

/** All input for the `updateRoom` mutation. */
export type UpdateRoomInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `Room` being updated. */
  patch: RoomPatch;
};

/** The output of our update `Room` mutation. */
export type UpdateRoomPayload = {
  __typename?: 'UpdateRoomPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Location` that is related to this `Room`. */
  locationByLocation: Maybe<Location>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Room` that was updated by this mutation. */
  room: Maybe<Room>;
  /** An edge for our `Room`. May be used by Relay 1. */
  roomEdge: Maybe<RoomsEdge>;
};


/** The output of our update `Room` mutation. */
export type UpdateRoomPayloadRoomEdgeArgs = {
  orderBy?: InputMaybe<Array<RoomsOrderBy>>;
};

/** All input for the `updateRozpiByNodeId` mutation. */
export type UpdateRozpiByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Rozpi` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Rozpi` being updated. */
  patch: RozpiPatch;
};

/** All input for the `updateRozpi` mutation. */
export type UpdateRozpiInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Rozpi` being updated. */
  patch: RozpiPatch;
  rId: Scalars['BigInt'];
};

/** The output of our update `Rozpi` mutation. */
export type UpdateRozpiPayload = {
  __typename?: 'UpdateRozpiPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Rozpi` that was updated by this mutation. */
  rozpi: Maybe<Rozpi>;
  /** An edge for our `Rozpi`. May be used by Relay 1. */
  rozpiEdge: Maybe<RozpisEdge>;
  /** Reads a single `User` that is related to this `Rozpi`. */
  userByRTrener: Maybe<User>;
};


/** The output of our update `Rozpi` mutation. */
export type UpdateRozpiPayloadRozpiEdgeArgs = {
  orderBy?: InputMaybe<Array<RozpisOrderBy>>;
};

/** All input for the `updateRozpisItemByNodeId` mutation. */
export type UpdateRozpisItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `RozpisItem` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `RozpisItem` being updated. */
  patch: RozpisItemPatch;
};

/** All input for the `updateRozpisItem` mutation. */
export type UpdateRozpisItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `RozpisItem` being updated. */
  patch: RozpisItemPatch;
  riId: Scalars['BigInt'];
};

/** The output of our update `RozpisItem` mutation. */
export type UpdateRozpisItemPayload = {
  __typename?: 'UpdateRozpisItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Pary` that is related to this `RozpisItem`. */
  paryByRiPartner: Maybe<Pary>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Rozpi` that is related to this `RozpisItem`. */
  rozpiByRiIdRodic: Maybe<Rozpi>;
  /** The `RozpisItem` that was updated by this mutation. */
  rozpisItem: Maybe<RozpisItem>;
  /** An edge for our `RozpisItem`. May be used by Relay 1. */
  rozpisItemEdge: Maybe<RozpisItemsEdge>;
};


/** The output of our update `RozpisItem` mutation. */
export type UpdateRozpisItemPayloadRozpisItemEdgeArgs = {
  orderBy?: InputMaybe<Array<RozpisItemsOrderBy>>;
};

/** All input for the `updateSessionByNodeId` mutation. */
export type UpdateSessionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Session` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Session` being updated. */
  patch: SessionPatch;
};

/** All input for the `updateSession` mutation. */
export type UpdateSessionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Session` being updated. */
  patch: SessionPatch;
  ssId: Scalars['String'];
};

/** The output of our update `Session` mutation. */
export type UpdateSessionPayload = {
  __typename?: 'UpdateSessionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Session` that was updated by this mutation. */
  session: Maybe<Session>;
  /** An edge for our `Session`. May be used by Relay 1. */
  sessionEdge: Maybe<SessionsEdge>;
  /** Reads a single `User` that is related to this `Session`. */
  userBySsUser: Maybe<User>;
};


/** The output of our update `Session` mutation. */
export type UpdateSessionPayloadSessionEdgeArgs = {
  orderBy?: InputMaybe<Array<SessionsOrderBy>>;
};

/** All input for the `updateSkupinyByNodeId` mutation. */
export type UpdateSkupinyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Skupiny` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Skupiny` being updated. */
  patch: SkupinyPatch;
};

/** All input for the `updateSkupiny` mutation. */
export type UpdateSkupinyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Skupiny` being updated. */
  patch: SkupinyPatch;
  sId: Scalars['BigInt'];
};

/** The output of our update `Skupiny` mutation. */
export type UpdateSkupinyPayload = {
  __typename?: 'UpdateSkupinyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `CohortGroup` that is related to this `Skupiny`. */
  cohortGroupByCohortGroup: Maybe<CohortGroup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Skupiny` that was updated by this mutation. */
  skupiny: Maybe<Skupiny>;
  /** An edge for our `Skupiny`. May be used by Relay 1. */
  skupinyEdge: Maybe<SkupiniesEdge>;
};


/** The output of our update `Skupiny` mutation. */
export type UpdateSkupinyPayloadSkupinyEdgeArgs = {
  orderBy?: InputMaybe<Array<SkupiniesOrderBy>>;
};

/** All input for the `updateTenantAttachmentByNodeId` mutation. */
export type UpdateTenantAttachmentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TenantAttachment` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `TenantAttachment` being updated. */
  patch: TenantAttachmentPatch;
};

/** All input for the `updateTenantAttachment` mutation. */
export type UpdateTenantAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  objectName: Scalars['String'];
  /** An object where the defined keys will be set on the `TenantAttachment` being updated. */
  patch: TenantAttachmentPatch;
  tenantId: Scalars['BigInt'];
};

/** The output of our update `TenantAttachment` mutation. */
export type UpdateTenantAttachmentPayload = {
  __typename?: 'UpdateTenantAttachmentPayload';
  /** Reads a single `Attachment` that is related to this `TenantAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `TenantAttachment`. */
  tenant: Maybe<Tenant>;
  /** The `TenantAttachment` that was updated by this mutation. */
  tenantAttachment: Maybe<TenantAttachment>;
  /** An edge for our `TenantAttachment`. May be used by Relay 1. */
  tenantAttachmentEdge: Maybe<TenantAttachmentsEdge>;
};


/** The output of our update `TenantAttachment` mutation. */
export type UpdateTenantAttachmentPayloadTenantAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<TenantAttachmentsOrderBy>>;
};

/** All input for the `updateTenantByNodeId` mutation. */
export type UpdateTenantByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Tenant` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Tenant` being updated. */
  patch: TenantPatch;
};

/** All input for the `updateTenant` mutation. */
export type UpdateTenantInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `Tenant` being updated. */
  patch: TenantPatch;
};

/** The output of our update `Tenant` mutation. */
export type UpdateTenantPayload = {
  __typename?: 'UpdateTenantPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Tenant` that was updated by this mutation. */
  tenant: Maybe<Tenant>;
  /** An edge for our `Tenant`. May be used by Relay 1. */
  tenantEdge: Maybe<TenantsEdge>;
};


/** The output of our update `Tenant` mutation. */
export type UpdateTenantPayloadTenantEdgeArgs = {
  orderBy?: InputMaybe<Array<TenantsOrderBy>>;
};

/** All input for the `updateTenantPersonByNodeId` mutation. */
export type UpdateTenantPersonByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TenantPerson` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `TenantPerson` being updated. */
  patch: TenantPersonPatch;
};

/** All input for the `updateTenantPerson` mutation. */
export type UpdateTenantPersonInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `TenantPerson` being updated. */
  patch: TenantPersonPatch;
  personId: Scalars['BigInt'];
  tenantId: Scalars['BigInt'];
};

/** The output of our update `TenantPerson` mutation. */
export type UpdateTenantPersonPayload = {
  __typename?: 'UpdateTenantPersonPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Person` that is related to this `TenantPerson`. */
  person: Maybe<Person>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `TenantPerson`. */
  tenant: Maybe<Tenant>;
  /** The `TenantPerson` that was updated by this mutation. */
  tenantPerson: Maybe<TenantPerson>;
  /** An edge for our `TenantPerson`. May be used by Relay 1. */
  tenantPersonEdge: Maybe<TenantPeopleEdge>;
};


/** The output of our update `TenantPerson` mutation. */
export type UpdateTenantPersonPayloadTenantPersonEdgeArgs = {
  orderBy?: InputMaybe<Array<TenantPeopleOrderBy>>;
};

/** All input for the `updateUpozorneniByNodeId` mutation. */
export type UpdateUpozorneniByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Upozorneni` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Upozorneni` being updated. */
  patch: UpozorneniPatch;
};

/** All input for the `updateUpozorneni` mutation. */
export type UpdateUpozorneniInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Upozorneni` being updated. */
  patch: UpozorneniPatch;
  upId: Scalars['BigInt'];
};

/** The output of our update `Upozorneni` mutation. */
export type UpdateUpozorneniPayload = {
  __typename?: 'UpdateUpozorneniPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Upozorneni` that was updated by this mutation. */
  upozorneni: Maybe<Upozorneni>;
  /** An edge for our `Upozorneni`. May be used by Relay 1. */
  upozorneniEdge: Maybe<UpozornenisEdge>;
  /** Reads a single `User` that is related to this `Upozorneni`. */
  userByUpKdo: Maybe<User>;
};


/** The output of our update `Upozorneni` mutation. */
export type UpdateUpozorneniPayloadUpozorneniEdgeArgs = {
  orderBy?: InputMaybe<Array<UpozornenisOrderBy>>;
};

/** All input for the `updateUpozorneniSkupinyByNodeId` mutation. */
export type UpdateUpozorneniSkupinyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `UpozorneniSkupiny` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `UpozorneniSkupiny` being updated. */
  patch: UpozorneniSkupinyPatch;
};

/** All input for the `updateUpozorneniSkupiny` mutation. */
export type UpdateUpozorneniSkupinyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `UpozorneniSkupiny` being updated. */
  patch: UpozorneniSkupinyPatch;
  upsId: Scalars['BigInt'];
};

/** The output of our update `UpozorneniSkupiny` mutation. */
export type UpdateUpozorneniSkupinyPayload = {
  __typename?: 'UpdateUpozorneniSkupinyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
  skupinyByUpsIdSkupina: Maybe<Skupiny>;
  /** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
  upozorneniByUpsIdRodic: Maybe<Upozorneni>;
  /** The `UpozorneniSkupiny` that was updated by this mutation. */
  upozorneniSkupiny: Maybe<UpozorneniSkupiny>;
  /** An edge for our `UpozorneniSkupiny`. May be used by Relay 1. */
  upozorneniSkupinyEdge: Maybe<UpozorneniSkupiniesEdge>;
};


/** The output of our update `UpozorneniSkupiny` mutation. */
export type UpdateUpozorneniSkupinyPayloadUpozorneniSkupinyEdgeArgs = {
  orderBy?: InputMaybe<Array<UpozorneniSkupiniesOrderBy>>;
};

/** All input for the `updateUserByNodeId` mutation. */
export type UpdateUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `User` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
};

/** All input for the `updateUser` mutation. */
export type UpdateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
  uId: Scalars['BigInt'];
};

/** The output of our update `User` mutation. */
export type UpdateUserPayload = {
  __typename?: 'UpdateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Permission` that is related to this `User`. */
  permissionByUGroup: Maybe<Permission>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `User`. */
  skupinyByUSkupina: Maybe<Skupiny>;
  /** The `User` that was updated by this mutation. */
  user: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge: Maybe<UsersEdge>;
};


/** The output of our update `User` mutation. */
export type UpdateUserPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the `updateVideoByNodeId` mutation. */
export type UpdateVideoByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Video` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Video` being updated. */
  patch: VideoPatch;
};

/** All input for the `updateVideo` mutation. */
export type UpdateVideoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Video` being updated. */
  patch: VideoPatch;
  vId: Scalars['BigInt'];
};

/** All input for the `updateVideoListByNodeId` mutation. */
export type UpdateVideoListByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `VideoList` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `VideoList` being updated. */
  patch: VideoListPatch;
};

/** All input for the `updateVideoList` mutation. */
export type UpdateVideoListInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `VideoList` being updated. */
  patch: VideoListPatch;
  vlId: Scalars['BigInt'];
};

/** The output of our update `VideoList` mutation. */
export type UpdateVideoListPayload = {
  __typename?: 'UpdateVideoListPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `VideoList` that was updated by this mutation. */
  videoList: Maybe<VideoList>;
  /** An edge for our `VideoList`. May be used by Relay 1. */
  videoListEdge: Maybe<VideoListsEdge>;
};


/** The output of our update `VideoList` mutation. */
export type UpdateVideoListPayloadVideoListEdgeArgs = {
  orderBy?: InputMaybe<Array<VideoListsOrderBy>>;
};

/** The output of our update `Video` mutation. */
export type UpdateVideoPayload = {
  __typename?: 'UpdateVideoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Video` that was updated by this mutation. */
  video: Maybe<Video>;
  /** An edge for our `Video`. May be used by Relay 1. */
  videoEdge: Maybe<VideosEdge>;
};


/** The output of our update `Video` mutation. */
export type UpdateVideoPayloadVideoEdgeArgs = {
  orderBy?: InputMaybe<Array<VideosOrderBy>>;
};

/** All input for the `updateVideoSourceByNodeId` mutation. */
export type UpdateVideoSourceByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `VideoSource` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `VideoSource` being updated. */
  patch: VideoSourcePatch;
};

/** All input for the `updateVideoSource` mutation. */
export type UpdateVideoSourceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `VideoSource` being updated. */
  patch: VideoSourcePatch;
  vsId: Scalars['BigInt'];
};

/** The output of our update `VideoSource` mutation. */
export type UpdateVideoSourcePayload = {
  __typename?: 'UpdateVideoSourcePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `VideoSource` that was updated by this mutation. */
  videoSource: Maybe<VideoSource>;
  /** An edge for our `VideoSource`. May be used by Relay 1. */
  videoSourceEdge: Maybe<VideoSourcesEdge>;
};


/** The output of our update `VideoSource` mutation. */
export type UpdateVideoSourcePayloadVideoSourceEdgeArgs = {
  orderBy?: InputMaybe<Array<VideoSourcesOrderBy>>;
};

export type UploadFilePayload = {
  __typename?: 'UploadFilePayload';
  objectName: Scalars['String'];
  uploadUrl: Scalars['String'];
};

export type Upozorneni = Node & {
  __typename?: 'Upozorneni';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  scheduledSince: Maybe<Scalars['Datetime']>;
  scheduledUntil: Maybe<Scalars['Datetime']>;
  upBarvy: Scalars['BigInt'];
  upId: Scalars['BigInt'];
  upKdo: Maybe<Scalars['BigInt']>;
  upLock: Scalars['Boolean'];
  upNadpis: Scalars['String'];
  /** Reads and enables pagination through a set of `UpozorneniSkupiny`. */
  upozorneniSkupiniesByUpsIdRodic: UpozorneniSkupiniesConnection;
  upText: Scalars['String'];
  upTimestamp: Maybe<Scalars['Datetime']>;
  upTimestampAdd: Scalars['Datetime'];
  /** Reads a single `User` that is related to this `Upozorneni`. */
  userByUpKdo: Maybe<User>;
};


export type UpozorneniUpozorneniSkupiniesByUpsIdRodicArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<UpozorneniSkupinyCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UpozorneniSkupiniesOrderBy>>;
};

/**
 * A condition to be used against `Upozorneni` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type UpozorneniCondition = {
  /** Checks for equality with the object’s `scheduledSince` field. */
  scheduledSince?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `scheduledUntil` field. */
  scheduledUntil?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `upBarvy` field. */
  upBarvy?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `upId` field. */
  upId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `upKdo` field. */
  upKdo?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `upLock` field. */
  upLock?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `upNadpis` field. */
  upNadpis?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `upText` field. */
  upText?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `upTimestamp` field. */
  upTimestamp?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `upTimestampAdd` field. */
  upTimestampAdd?: InputMaybe<Scalars['Datetime']>;
};

/** An input for mutations affecting `Upozorneni` */
export type UpozorneniInput = {
  scheduledSince?: InputMaybe<Scalars['Datetime']>;
  scheduledUntil?: InputMaybe<Scalars['Datetime']>;
  upBarvy?: InputMaybe<Scalars['BigInt']>;
  upId?: InputMaybe<Scalars['BigInt']>;
  upKdo?: InputMaybe<Scalars['BigInt']>;
  upLock?: InputMaybe<Scalars['Boolean']>;
  upNadpis: Scalars['String'];
  upText: Scalars['String'];
  upTimestamp?: InputMaybe<Scalars['Datetime']>;
  upTimestampAdd?: InputMaybe<Scalars['Datetime']>;
};

/** Represents an update to a `Upozorneni`. Fields that are set will be updated. */
export type UpozorneniPatch = {
  scheduledSince?: InputMaybe<Scalars['Datetime']>;
  scheduledUntil?: InputMaybe<Scalars['Datetime']>;
  upBarvy?: InputMaybe<Scalars['BigInt']>;
  upId?: InputMaybe<Scalars['BigInt']>;
  upKdo?: InputMaybe<Scalars['BigInt']>;
  upLock?: InputMaybe<Scalars['Boolean']>;
  upNadpis?: InputMaybe<Scalars['String']>;
  upText?: InputMaybe<Scalars['String']>;
  upTimestamp?: InputMaybe<Scalars['Datetime']>;
  upTimestampAdd?: InputMaybe<Scalars['Datetime']>;
};

/** A connection to a list of `Upozorneni` values. */
export type UpozornenisConnection = {
  __typename?: 'UpozornenisConnection';
  /** A list of edges which contains the `Upozorneni` and cursor to aid in pagination. */
  edges: Array<UpozornenisEdge>;
  /** A list of `Upozorneni` objects. */
  nodes: Array<Upozorneni>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Upozorneni` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Upozorneni` edge in the connection. */
export type UpozornenisEdge = {
  __typename?: 'UpozornenisEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Upozorneni` at the end of the edge. */
  node: Upozorneni;
};

/** A connection to a list of `UpozorneniSkupiny` values. */
export type UpozorneniSkupiniesConnection = {
  __typename?: 'UpozorneniSkupiniesConnection';
  /** A list of edges which contains the `UpozorneniSkupiny` and cursor to aid in pagination. */
  edges: Array<UpozorneniSkupiniesEdge>;
  /** A list of `UpozorneniSkupiny` objects. */
  nodes: Array<UpozorneniSkupiny>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UpozorneniSkupiny` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `UpozorneniSkupiny` edge in the connection. */
export type UpozorneniSkupiniesEdge = {
  __typename?: 'UpozorneniSkupiniesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `UpozorneniSkupiny` at the end of the edge. */
  node: UpozorneniSkupiny;
};

/** Methods to use when ordering `UpozorneniSkupiny`. */
export enum UpozorneniSkupiniesOrderBy {
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SkupinyByUpsIdSkupinaCohortGroupAsc = 'SKUPINY_BY_UPS_ID_SKUPINA__COHORT_GROUP_ASC',
  SkupinyByUpsIdSkupinaCohortGroupDesc = 'SKUPINY_BY_UPS_ID_SKUPINA__COHORT_GROUP_DESC',
  SkupinyByUpsIdSkupinaInternalInfoAsc = 'SKUPINY_BY_UPS_ID_SKUPINA__INTERNAL_INFO_ASC',
  SkupinyByUpsIdSkupinaInternalInfoDesc = 'SKUPINY_BY_UPS_ID_SKUPINA__INTERNAL_INFO_DESC',
  SkupinyByUpsIdSkupinaOrderingAsc = 'SKUPINY_BY_UPS_ID_SKUPINA__ORDERING_ASC',
  SkupinyByUpsIdSkupinaOrderingDesc = 'SKUPINY_BY_UPS_ID_SKUPINA__ORDERING_DESC',
  SkupinyByUpsIdSkupinaSColorRgbAsc = 'SKUPINY_BY_UPS_ID_SKUPINA__S_COLOR_RGB_ASC',
  SkupinyByUpsIdSkupinaSColorRgbDesc = 'SKUPINY_BY_UPS_ID_SKUPINA__S_COLOR_RGB_DESC',
  SkupinyByUpsIdSkupinaSColorTextAsc = 'SKUPINY_BY_UPS_ID_SKUPINA__S_COLOR_TEXT_ASC',
  SkupinyByUpsIdSkupinaSColorTextDesc = 'SKUPINY_BY_UPS_ID_SKUPINA__S_COLOR_TEXT_DESC',
  SkupinyByUpsIdSkupinaSDescriptionAsc = 'SKUPINY_BY_UPS_ID_SKUPINA__S_DESCRIPTION_ASC',
  SkupinyByUpsIdSkupinaSDescriptionDesc = 'SKUPINY_BY_UPS_ID_SKUPINA__S_DESCRIPTION_DESC',
  SkupinyByUpsIdSkupinaSIdAsc = 'SKUPINY_BY_UPS_ID_SKUPINA__S_ID_ASC',
  SkupinyByUpsIdSkupinaSIdDesc = 'SKUPINY_BY_UPS_ID_SKUPINA__S_ID_DESC',
  SkupinyByUpsIdSkupinaSLocationAsc = 'SKUPINY_BY_UPS_ID_SKUPINA__S_LOCATION_ASC',
  SkupinyByUpsIdSkupinaSLocationDesc = 'SKUPINY_BY_UPS_ID_SKUPINA__S_LOCATION_DESC',
  SkupinyByUpsIdSkupinaSNameAsc = 'SKUPINY_BY_UPS_ID_SKUPINA__S_NAME_ASC',
  SkupinyByUpsIdSkupinaSNameDesc = 'SKUPINY_BY_UPS_ID_SKUPINA__S_NAME_DESC',
  SkupinyByUpsIdSkupinaSVisibleAsc = 'SKUPINY_BY_UPS_ID_SKUPINA__S_VISIBLE_ASC',
  SkupinyByUpsIdSkupinaSVisibleDesc = 'SKUPINY_BY_UPS_ID_SKUPINA__S_VISIBLE_DESC',
  UpozorneniByUpsIdRodicScheduledSinceAsc = 'UPOZORNENI_BY_UPS_ID_RODIC__SCHEDULED_SINCE_ASC',
  UpozorneniByUpsIdRodicScheduledSinceDesc = 'UPOZORNENI_BY_UPS_ID_RODIC__SCHEDULED_SINCE_DESC',
  UpozorneniByUpsIdRodicScheduledUntilAsc = 'UPOZORNENI_BY_UPS_ID_RODIC__SCHEDULED_UNTIL_ASC',
  UpozorneniByUpsIdRodicScheduledUntilDesc = 'UPOZORNENI_BY_UPS_ID_RODIC__SCHEDULED_UNTIL_DESC',
  UpozorneniByUpsIdRodicUpBarvyAsc = 'UPOZORNENI_BY_UPS_ID_RODIC__UP_BARVY_ASC',
  UpozorneniByUpsIdRodicUpBarvyDesc = 'UPOZORNENI_BY_UPS_ID_RODIC__UP_BARVY_DESC',
  UpozorneniByUpsIdRodicUpIdAsc = 'UPOZORNENI_BY_UPS_ID_RODIC__UP_ID_ASC',
  UpozorneniByUpsIdRodicUpIdDesc = 'UPOZORNENI_BY_UPS_ID_RODIC__UP_ID_DESC',
  UpozorneniByUpsIdRodicUpKdoAsc = 'UPOZORNENI_BY_UPS_ID_RODIC__UP_KDO_ASC',
  UpozorneniByUpsIdRodicUpKdoDesc = 'UPOZORNENI_BY_UPS_ID_RODIC__UP_KDO_DESC',
  UpozorneniByUpsIdRodicUpLockAsc = 'UPOZORNENI_BY_UPS_ID_RODIC__UP_LOCK_ASC',
  UpozorneniByUpsIdRodicUpLockDesc = 'UPOZORNENI_BY_UPS_ID_RODIC__UP_LOCK_DESC',
  UpozorneniByUpsIdRodicUpNadpisAsc = 'UPOZORNENI_BY_UPS_ID_RODIC__UP_NADPIS_ASC',
  UpozorneniByUpsIdRodicUpNadpisDesc = 'UPOZORNENI_BY_UPS_ID_RODIC__UP_NADPIS_DESC',
  UpozorneniByUpsIdRodicUpTextAsc = 'UPOZORNENI_BY_UPS_ID_RODIC__UP_TEXT_ASC',
  UpozorneniByUpsIdRodicUpTextDesc = 'UPOZORNENI_BY_UPS_ID_RODIC__UP_TEXT_DESC',
  UpozorneniByUpsIdRodicUpTimestampAddAsc = 'UPOZORNENI_BY_UPS_ID_RODIC__UP_TIMESTAMP_ADD_ASC',
  UpozorneniByUpsIdRodicUpTimestampAddDesc = 'UPOZORNENI_BY_UPS_ID_RODIC__UP_TIMESTAMP_ADD_DESC',
  UpozorneniByUpsIdRodicUpTimestampAsc = 'UPOZORNENI_BY_UPS_ID_RODIC__UP_TIMESTAMP_ASC',
  UpozorneniByUpsIdRodicUpTimestampDesc = 'UPOZORNENI_BY_UPS_ID_RODIC__UP_TIMESTAMP_DESC',
  UpsColorAsc = 'UPS_COLOR_ASC',
  UpsColorDesc = 'UPS_COLOR_DESC',
  UpsIdAsc = 'UPS_ID_ASC',
  UpsIdDesc = 'UPS_ID_DESC',
  UpsIdRodicAsc = 'UPS_ID_RODIC_ASC',
  UpsIdRodicDesc = 'UPS_ID_RODIC_DESC',
  UpsIdSkupinaAsc = 'UPS_ID_SKUPINA_ASC',
  UpsIdSkupinaDesc = 'UPS_ID_SKUPINA_DESC',
  UpsPopisAsc = 'UPS_POPIS_ASC',
  UpsPopisDesc = 'UPS_POPIS_DESC'
}

export type UpozorneniSkupiny = Node & {
  __typename?: 'UpozorneniSkupiny';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
  skupinyByUpsIdSkupina: Maybe<Skupiny>;
  /** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
  upozorneniByUpsIdRodic: Maybe<Upozorneni>;
  upsColor: Scalars['String'];
  upsId: Scalars['BigInt'];
  upsIdRodic: Scalars['BigInt'];
  upsIdSkupina: Scalars['BigInt'];
  upsPopis: Scalars['String'];
};

/**
 * A condition to be used against `UpozorneniSkupiny` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type UpozorneniSkupinyCondition = {
  /** Checks for equality with the object’s `upsColor` field. */
  upsColor?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `upsId` field. */
  upsId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `upsIdRodic` field. */
  upsIdRodic?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `upsIdSkupina` field. */
  upsIdSkupina?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `upsPopis` field. */
  upsPopis?: InputMaybe<Scalars['String']>;
};

/** An input for mutations affecting `UpozorneniSkupiny` */
export type UpozorneniSkupinyInput = {
  upsColor: Scalars['String'];
  upsId?: InputMaybe<Scalars['BigInt']>;
  upsIdRodic: Scalars['BigInt'];
  upsIdSkupina: Scalars['BigInt'];
  upsPopis: Scalars['String'];
};

/** Represents an update to a `UpozorneniSkupiny`. Fields that are set will be updated. */
export type UpozorneniSkupinyPatch = {
  upsColor?: InputMaybe<Scalars['String']>;
  upsId?: InputMaybe<Scalars['BigInt']>;
  upsIdRodic?: InputMaybe<Scalars['BigInt']>;
  upsIdSkupina?: InputMaybe<Scalars['BigInt']>;
  upsPopis?: InputMaybe<Scalars['String']>;
};

/** Methods to use when ordering `Upozorneni`. */
export enum UpozornenisOrderBy {
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ScheduledSinceAsc = 'SCHEDULED_SINCE_ASC',
  ScheduledSinceDesc = 'SCHEDULED_SINCE_DESC',
  ScheduledUntilAsc = 'SCHEDULED_UNTIL_ASC',
  ScheduledUntilDesc = 'SCHEDULED_UNTIL_DESC',
  UpBarvyAsc = 'UP_BARVY_ASC',
  UpBarvyDesc = 'UP_BARVY_DESC',
  UpIdAsc = 'UP_ID_ASC',
  UpIdDesc = 'UP_ID_DESC',
  UpKdoAsc = 'UP_KDO_ASC',
  UpKdoDesc = 'UP_KDO_DESC',
  UpLockAsc = 'UP_LOCK_ASC',
  UpLockDesc = 'UP_LOCK_DESC',
  UpNadpisAsc = 'UP_NADPIS_ASC',
  UpNadpisDesc = 'UP_NADPIS_DESC',
  UpTextAsc = 'UP_TEXT_ASC',
  UpTextDesc = 'UP_TEXT_DESC',
  UpTimestampAddAsc = 'UP_TIMESTAMP_ADD_ASC',
  UpTimestampAddDesc = 'UP_TIMESTAMP_ADD_DESC',
  UpTimestampAsc = 'UP_TIMESTAMP_ASC',
  UpTimestampDesc = 'UP_TIMESTAMP_DESC',
  UpozorneniSkupiniesByUpsIdRodicCountAsc = 'UPOZORNENI_SKUPINIES_BY_UPS_ID_RODIC__COUNT_ASC',
  UpozorneniSkupiniesByUpsIdRodicCountDesc = 'UPOZORNENI_SKUPINIES_BY_UPS_ID_RODIC__COUNT_DESC',
  UserByUpKdoUBanAsc = 'USER_BY_UP_KDO__U_BAN_ASC',
  UserByUpKdoUBanDesc = 'USER_BY_UP_KDO__U_BAN_DESC',
  UserByUpKdoUCityAsc = 'USER_BY_UP_KDO__U_CITY_ASC',
  UserByUpKdoUCityDesc = 'USER_BY_UP_KDO__U_CITY_DESC',
  UserByUpKdoUConfirmedAsc = 'USER_BY_UP_KDO__U_CONFIRMED_ASC',
  UserByUpKdoUConfirmedDesc = 'USER_BY_UP_KDO__U_CONFIRMED_DESC',
  UserByUpKdoUConscriptionNumberAsc = 'USER_BY_UP_KDO__U_CONSCRIPTION_NUMBER_ASC',
  UserByUpKdoUConscriptionNumberDesc = 'USER_BY_UP_KDO__U_CONSCRIPTION_NUMBER_DESC',
  UserByUpKdoUCreatedAtAsc = 'USER_BY_UP_KDO__U_CREATED_AT_ASC',
  UserByUpKdoUCreatedAtDesc = 'USER_BY_UP_KDO__U_CREATED_AT_DESC',
  UserByUpKdoUDancerAsc = 'USER_BY_UP_KDO__U_DANCER_ASC',
  UserByUpKdoUDancerDesc = 'USER_BY_UP_KDO__U_DANCER_DESC',
  UserByUpKdoUDistrictAsc = 'USER_BY_UP_KDO__U_DISTRICT_ASC',
  UserByUpKdoUDistrictDesc = 'USER_BY_UP_KDO__U_DISTRICT_DESC',
  UserByUpKdoUEmailAsc = 'USER_BY_UP_KDO__U_EMAIL_ASC',
  UserByUpKdoUEmailDesc = 'USER_BY_UP_KDO__U_EMAIL_DESC',
  UserByUpKdoUGdprSignedAtAsc = 'USER_BY_UP_KDO__U_GDPR_SIGNED_AT_ASC',
  UserByUpKdoUGdprSignedAtDesc = 'USER_BY_UP_KDO__U_GDPR_SIGNED_AT_DESC',
  UserByUpKdoUGroupAsc = 'USER_BY_UP_KDO__U_GROUP_ASC',
  UserByUpKdoUGroupDesc = 'USER_BY_UP_KDO__U_GROUP_DESC',
  UserByUpKdoUIdAsc = 'USER_BY_UP_KDO__U_ID_ASC',
  UserByUpKdoUIdDesc = 'USER_BY_UP_KDO__U_ID_DESC',
  UserByUpKdoUJmenoAsc = 'USER_BY_UP_KDO__U_JMENO_ASC',
  UserByUpKdoUJmenoDesc = 'USER_BY_UP_KDO__U_JMENO_DESC',
  UserByUpKdoULevelAsc = 'USER_BY_UP_KDO__U_LEVEL_ASC',
  UserByUpKdoULevelDesc = 'USER_BY_UP_KDO__U_LEVEL_DESC',
  UserByUpKdoULockAsc = 'USER_BY_UP_KDO__U_LOCK_ASC',
  UserByUpKdoULockDesc = 'USER_BY_UP_KDO__U_LOCK_DESC',
  UserByUpKdoULoginAsc = 'USER_BY_UP_KDO__U_LOGIN_ASC',
  UserByUpKdoULoginDesc = 'USER_BY_UP_KDO__U_LOGIN_DESC',
  UserByUpKdoUMemberSinceAsc = 'USER_BY_UP_KDO__U_MEMBER_SINCE_ASC',
  UserByUpKdoUMemberSinceDesc = 'USER_BY_UP_KDO__U_MEMBER_SINCE_DESC',
  UserByUpKdoUMemberUntilAsc = 'USER_BY_UP_KDO__U_MEMBER_UNTIL_ASC',
  UserByUpKdoUMemberUntilDesc = 'USER_BY_UP_KDO__U_MEMBER_UNTIL_DESC',
  UserByUpKdoUNarozeniAsc = 'USER_BY_UP_KDO__U_NAROZENI_ASC',
  UserByUpKdoUNarozeniDesc = 'USER_BY_UP_KDO__U_NAROZENI_DESC',
  UserByUpKdoUNationalityAsc = 'USER_BY_UP_KDO__U_NATIONALITY_ASC',
  UserByUpKdoUNationalityDesc = 'USER_BY_UP_KDO__U_NATIONALITY_DESC',
  UserByUpKdoUOrientationNumberAsc = 'USER_BY_UP_KDO__U_ORIENTATION_NUMBER_ASC',
  UserByUpKdoUOrientationNumberDesc = 'USER_BY_UP_KDO__U_ORIENTATION_NUMBER_DESC',
  UserByUpKdoUPassAsc = 'USER_BY_UP_KDO__U_PASS_ASC',
  UserByUpKdoUPassDesc = 'USER_BY_UP_KDO__U_PASS_DESC',
  UserByUpKdoUPohlaviAsc = 'USER_BY_UP_KDO__U_POHLAVI_ASC',
  UserByUpKdoUPohlaviDesc = 'USER_BY_UP_KDO__U_POHLAVI_DESC',
  UserByUpKdoUPostalCodeAsc = 'USER_BY_UP_KDO__U_POSTAL_CODE_ASC',
  UserByUpKdoUPostalCodeDesc = 'USER_BY_UP_KDO__U_POSTAL_CODE_DESC',
  UserByUpKdoUPoznamkyAsc = 'USER_BY_UP_KDO__U_POZNAMKY_ASC',
  UserByUpKdoUPoznamkyDesc = 'USER_BY_UP_KDO__U_POZNAMKY_DESC',
  UserByUpKdoUPrijmeniAsc = 'USER_BY_UP_KDO__U_PRIJMENI_ASC',
  UserByUpKdoUPrijmeniDesc = 'USER_BY_UP_KDO__U_PRIJMENI_DESC',
  UserByUpKdoURodneCisloAsc = 'USER_BY_UP_KDO__U_RODNE_CISLO_ASC',
  UserByUpKdoURodneCisloDesc = 'USER_BY_UP_KDO__U_RODNE_CISLO_DESC',
  UserByUpKdoUSkupinaAsc = 'USER_BY_UP_KDO__U_SKUPINA_ASC',
  UserByUpKdoUSkupinaDesc = 'USER_BY_UP_KDO__U_SKUPINA_DESC',
  UserByUpKdoUStreetAsc = 'USER_BY_UP_KDO__U_STREET_ASC',
  UserByUpKdoUStreetDesc = 'USER_BY_UP_KDO__U_STREET_DESC',
  UserByUpKdoUSystemAsc = 'USER_BY_UP_KDO__U_SYSTEM_ASC',
  UserByUpKdoUSystemDesc = 'USER_BY_UP_KDO__U_SYSTEM_DESC',
  UserByUpKdoUTeacherAsc = 'USER_BY_UP_KDO__U_TEACHER_ASC',
  UserByUpKdoUTeacherDesc = 'USER_BY_UP_KDO__U_TEACHER_DESC',
  UserByUpKdoUTelefonAsc = 'USER_BY_UP_KDO__U_TELEFON_ASC',
  UserByUpKdoUTelefonDesc = 'USER_BY_UP_KDO__U_TELEFON_DESC',
  UserByUpKdoUTimestampAsc = 'USER_BY_UP_KDO__U_TIMESTAMP_ASC',
  UserByUpKdoUTimestampDesc = 'USER_BY_UP_KDO__U_TIMESTAMP_DESC'
}

export type User = Node & {
  __typename?: 'User';
  /** Reads and enables pagination through a set of `Aktuality`. */
  aktualitiesByAtKdo: AktualitiesConnection;
  /** Reads and enables pagination through a set of `Attachment`. */
  attachmentsByUploadedBy: AttachmentsConnection;
  /** Reads and enables pagination through a set of `AttendeeExternal`. */
  attendeeExternalsByConfirmedBy: AttendeeExternalsConnection;
  /** Reads and enables pagination through a set of `AttendeeExternal`. */
  attendeeExternalsByManagedBy: AttendeeExternalsConnection;
  /** Reads and enables pagination through a set of `AttendeeUser`. */
  attendeeUsers: AttendeeUsersConnection;
  /** Reads and enables pagination through a set of `Dokumenty`. */
  dokumentiesByDKdo: DokumentiesConnection;
  fullName: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `GalerieFoto`. */
  galerieFotosByGfKdo: GalerieFotosConnection;
  /** Reads and enables pagination through a set of `Nabidka`. */
  nabidkasByNTrener: NabidkasConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads and enables pagination through a set of `Pary`. */
  pariesByPIdPartner: PariesConnection;
  /** Reads and enables pagination through a set of `Pary`. */
  pariesByPIdPartnerka: PariesConnection;
  /** Reads and enables pagination through a set of `ParyNavrh`. */
  paryNavrhsByPnNavrhl: ParyNavrhsConnection;
  /** Reads and enables pagination through a set of `ParyNavrh`. */
  paryNavrhsByPnPartner: ParyNavrhsConnection;
  /** Reads and enables pagination through a set of `ParyNavrh`. */
  paryNavrhsByPnPartnerka: ParyNavrhsConnection;
  /** Reads a single `Permission` that is related to this `User`. */
  permissionByUGroup: Maybe<Permission>;
  /** Reads and enables pagination through a set of `PlatbyItem`. */
  platbyItemsByPiIdUser: PlatbyItemsConnection;
  /** Reads and enables pagination through a set of `Rozpi`. */
  rozpisByRTrener: RozpisConnection;
  /** Reads and enables pagination through a set of `Session`. */
  sessionsBySsUser: SessionsConnection;
  /** Reads a single `Skupiny` that is related to this `User`. */
  skupinyByUSkupina: Maybe<Skupiny>;
  uBan: Scalars['Boolean'];
  uCity: Scalars['String'];
  uConfirmed: Scalars['Boolean'];
  uConscriptionNumber: Scalars['String'];
  uCreatedAt: Scalars['Datetime'];
  uDancer: Scalars['Boolean'];
  uDistrict: Scalars['String'];
  uEmail: Scalars['String'];
  uGdprSignedAt: Maybe<Scalars['Datetime']>;
  uGroup: Scalars['BigInt'];
  uId: Scalars['BigInt'];
  uJmeno: Scalars['String'];
  uLevel: Scalars['Int'];
  uLock: Scalars['Boolean'];
  uLogin: Scalars['String'];
  uMemberSince: Maybe<Scalars['Datetime']>;
  uMemberUntil: Maybe<Scalars['Datetime']>;
  uNarozeni: Scalars['Date'];
  uNationality: Scalars['String'];
  uOrientationNumber: Scalars['String'];
  uPass: Scalars['String'];
  uPohlavi: Scalars['String'];
  uPostalCode: Scalars['String'];
  uPoznamky: Scalars['String'];
  /** Reads and enables pagination through a set of `Upozorneni`. */
  upozornenisByUpKdo: UpozornenisConnection;
  uPrijmeni: Scalars['String'];
  uRodneCislo: Maybe<Scalars['String']>;
  uSkupina: Scalars['BigInt'];
  uStreet: Scalars['String'];
  uSystem: Scalars['Boolean'];
  uTeacher: Scalars['Boolean'];
  uTelefon: Scalars['String'];
  uTimestamp: Scalars['Datetime'];
};


export type UserAktualitiesByAtKdoArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AktualityCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AktualitiesOrderBy>>;
};


export type UserAttachmentsByUploadedByArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AttachmentCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AttachmentsOrderBy>>;
};


export type UserAttendeeExternalsByConfirmedByArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AttendeeExternalCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AttendeeExternalsOrderBy>>;
};


export type UserAttendeeExternalsByManagedByArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AttendeeExternalCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AttendeeExternalsOrderBy>>;
};


export type UserAttendeeUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AttendeeUserCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AttendeeUsersOrderBy>>;
};


export type UserDokumentiesByDKdoArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<DokumentyCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<DokumentiesOrderBy>>;
};


export type UserGalerieFotosByGfKdoArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<GalerieFotoCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GalerieFotosOrderBy>>;
};


export type UserNabidkasByNTrenerArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<NabidkaCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<NabidkasOrderBy>>;
};


export type UserPariesByPIdPartnerArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<ParyCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PariesOrderBy>>;
};


export type UserPariesByPIdPartnerkaArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<ParyCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PariesOrderBy>>;
};


export type UserParyNavrhsByPnNavrhlArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<ParyNavrhCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ParyNavrhsOrderBy>>;
};


export type UserParyNavrhsByPnPartnerArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<ParyNavrhCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ParyNavrhsOrderBy>>;
};


export type UserParyNavrhsByPnPartnerkaArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<ParyNavrhCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ParyNavrhsOrderBy>>;
};


export type UserPlatbyItemsByPiIdUserArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyItemsOrderBy>>;
};


export type UserRozpisByRTrenerArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<RozpiCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RozpisOrderBy>>;
};


export type UserSessionsBySsUserArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<SessionCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SessionsOrderBy>>;
};


export type UserUpozornenisByUpKdoArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<UpozorneniCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UpozornenisOrderBy>>;
};

/** A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UserCondition = {
  /** Checks for equality with the object’s `uBan` field. */
  uBan?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uCity` field. */
  uCity?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uConfirmed` field. */
  uConfirmed?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uConscriptionNumber` field. */
  uConscriptionNumber?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uCreatedAt` field. */
  uCreatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `uDancer` field. */
  uDancer?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uDistrict` field. */
  uDistrict?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uEmail` field. */
  uEmail?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uGdprSignedAt` field. */
  uGdprSignedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `uGroup` field. */
  uGroup?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `uId` field. */
  uId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `uJmeno` field. */
  uJmeno?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uLevel` field. */
  uLevel?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uLock` field. */
  uLock?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uLogin` field. */
  uLogin?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uMemberSince` field. */
  uMemberSince?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `uMemberUntil` field. */
  uMemberUntil?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `uNarozeni` field. */
  uNarozeni?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `uNationality` field. */
  uNationality?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uOrientationNumber` field. */
  uOrientationNumber?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uPass` field. */
  uPass?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uPohlavi` field. */
  uPohlavi?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uPostalCode` field. */
  uPostalCode?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uPoznamky` field. */
  uPoznamky?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uPrijmeni` field. */
  uPrijmeni?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uRodneCislo` field. */
  uRodneCislo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uSkupina` field. */
  uSkupina?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `uStreet` field. */
  uStreet?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uSystem` field. */
  uSystem?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uTeacher` field. */
  uTeacher?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uTelefon` field. */
  uTelefon?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uTimestamp` field. */
  uTimestamp?: InputMaybe<Scalars['Datetime']>;
};

/** An input for mutations affecting `User` */
export type UserInput = {
  uBan?: InputMaybe<Scalars['Boolean']>;
  uCity: Scalars['String'];
  uConfirmed?: InputMaybe<Scalars['Boolean']>;
  uConscriptionNumber?: InputMaybe<Scalars['String']>;
  uCreatedAt?: InputMaybe<Scalars['Datetime']>;
  uDancer?: InputMaybe<Scalars['Boolean']>;
  uDistrict?: InputMaybe<Scalars['String']>;
  uEmail: Scalars['String'];
  uGdprSignedAt?: InputMaybe<Scalars['Datetime']>;
  uGroup?: InputMaybe<Scalars['BigInt']>;
  uId?: InputMaybe<Scalars['BigInt']>;
  uJmeno: Scalars['String'];
  uLevel?: InputMaybe<Scalars['Int']>;
  uLock?: InputMaybe<Scalars['Boolean']>;
  uLogin: Scalars['String'];
  uMemberSince?: InputMaybe<Scalars['Datetime']>;
  uMemberUntil?: InputMaybe<Scalars['Datetime']>;
  uNarozeni: Scalars['Date'];
  uNationality: Scalars['String'];
  uOrientationNumber?: InputMaybe<Scalars['String']>;
  uPass: Scalars['String'];
  uPohlavi: Scalars['String'];
  uPostalCode: Scalars['String'];
  uPoznamky?: InputMaybe<Scalars['String']>;
  uPrijmeni: Scalars['String'];
  uRodneCislo?: InputMaybe<Scalars['String']>;
  uSkupina?: InputMaybe<Scalars['BigInt']>;
  uStreet: Scalars['String'];
  uSystem?: InputMaybe<Scalars['Boolean']>;
  uTeacher?: InputMaybe<Scalars['Boolean']>;
  uTelefon: Scalars['String'];
  uTimestamp?: InputMaybe<Scalars['Datetime']>;
};

/** Represents an update to a `User`. Fields that are set will be updated. */
export type UserPatch = {
  uBan?: InputMaybe<Scalars['Boolean']>;
  uCity?: InputMaybe<Scalars['String']>;
  uConfirmed?: InputMaybe<Scalars['Boolean']>;
  uConscriptionNumber?: InputMaybe<Scalars['String']>;
  uCreatedAt?: InputMaybe<Scalars['Datetime']>;
  uDancer?: InputMaybe<Scalars['Boolean']>;
  uDistrict?: InputMaybe<Scalars['String']>;
  uEmail?: InputMaybe<Scalars['String']>;
  uGdprSignedAt?: InputMaybe<Scalars['Datetime']>;
  uGroup?: InputMaybe<Scalars['BigInt']>;
  uId?: InputMaybe<Scalars['BigInt']>;
  uJmeno?: InputMaybe<Scalars['String']>;
  uLevel?: InputMaybe<Scalars['Int']>;
  uLock?: InputMaybe<Scalars['Boolean']>;
  uLogin?: InputMaybe<Scalars['String']>;
  uMemberSince?: InputMaybe<Scalars['Datetime']>;
  uMemberUntil?: InputMaybe<Scalars['Datetime']>;
  uNarozeni?: InputMaybe<Scalars['Date']>;
  uNationality?: InputMaybe<Scalars['String']>;
  uOrientationNumber?: InputMaybe<Scalars['String']>;
  uPass?: InputMaybe<Scalars['String']>;
  uPohlavi?: InputMaybe<Scalars['String']>;
  uPostalCode?: InputMaybe<Scalars['String']>;
  uPoznamky?: InputMaybe<Scalars['String']>;
  uPrijmeni?: InputMaybe<Scalars['String']>;
  uRodneCislo?: InputMaybe<Scalars['String']>;
  uSkupina?: InputMaybe<Scalars['BigInt']>;
  uStreet?: InputMaybe<Scalars['String']>;
  uSystem?: InputMaybe<Scalars['Boolean']>;
  uTeacher?: InputMaybe<Scalars['Boolean']>;
  uTelefon?: InputMaybe<Scalars['String']>;
  uTimestamp?: InputMaybe<Scalars['Datetime']>;
};

/** A connection to a list of `User` values. */
export type UsersConnection = {
  __typename?: 'UsersConnection';
  /** A list of edges which contains the `User` and cursor to aid in pagination. */
  edges: Array<UsersEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `User` edge in the connection. */
export type UsersEdge = {
  __typename?: 'UsersEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `User` at the end of the edge. */
  node: User;
};

/** Methods to use when ordering `User`. */
export enum UsersOrderBy {
  AktualitiesByAtKdoCountAsc = 'AKTUALITIES_BY_AT_KDO__COUNT_ASC',
  AktualitiesByAtKdoCountDesc = 'AKTUALITIES_BY_AT_KDO__COUNT_DESC',
  AttachmentsByUploadedByCountAsc = 'ATTACHMENTS_BY_UPLOADED_BY__COUNT_ASC',
  AttachmentsByUploadedByCountDesc = 'ATTACHMENTS_BY_UPLOADED_BY__COUNT_DESC',
  AttendeeExternalsByConfirmedByCountAsc = 'ATTENDEE_EXTERNALS_BY_CONFIRMED_BY__COUNT_ASC',
  AttendeeExternalsByConfirmedByCountDesc = 'ATTENDEE_EXTERNALS_BY_CONFIRMED_BY__COUNT_DESC',
  AttendeeExternalsByManagedByCountAsc = 'ATTENDEE_EXTERNALS_BY_MANAGED_BY__COUNT_ASC',
  AttendeeExternalsByManagedByCountDesc = 'ATTENDEE_EXTERNALS_BY_MANAGED_BY__COUNT_DESC',
  AttendeeUsersByUserIdCountAsc = 'ATTENDEE_USERS_BY_USER_ID__COUNT_ASC',
  AttendeeUsersByUserIdCountDesc = 'ATTENDEE_USERS_BY_USER_ID__COUNT_DESC',
  DokumentiesByDKdoCountAsc = 'DOKUMENTIES_BY_D_KDO__COUNT_ASC',
  DokumentiesByDKdoCountDesc = 'DOKUMENTIES_BY_D_KDO__COUNT_DESC',
  GalerieFotosByGfKdoCountAsc = 'GALERIE_FOTOS_BY_GF_KDO__COUNT_ASC',
  GalerieFotosByGfKdoCountDesc = 'GALERIE_FOTOS_BY_GF_KDO__COUNT_DESC',
  NabidkasByNTrenerCountAsc = 'NABIDKAS_BY_N_TRENER__COUNT_ASC',
  NabidkasByNTrenerCountDesc = 'NABIDKAS_BY_N_TRENER__COUNT_DESC',
  Natural = 'NATURAL',
  PariesByPIdPartnerCountAsc = 'PARIES_BY_P_ID_PARTNER__COUNT_ASC',
  PariesByPIdPartnerCountDesc = 'PARIES_BY_P_ID_PARTNER__COUNT_DESC',
  PariesByPIdPartnerkaCountAsc = 'PARIES_BY_P_ID_PARTNERKA__COUNT_ASC',
  PariesByPIdPartnerkaCountDesc = 'PARIES_BY_P_ID_PARTNERKA__COUNT_DESC',
  ParyNavrhsByPnNavrhlCountAsc = 'PARY_NAVRHS_BY_PN_NAVRHL__COUNT_ASC',
  ParyNavrhsByPnNavrhlCountDesc = 'PARY_NAVRHS_BY_PN_NAVRHL__COUNT_DESC',
  ParyNavrhsByPnPartnerCountAsc = 'PARY_NAVRHS_BY_PN_PARTNER__COUNT_ASC',
  ParyNavrhsByPnPartnerCountDesc = 'PARY_NAVRHS_BY_PN_PARTNER__COUNT_DESC',
  ParyNavrhsByPnPartnerkaCountAsc = 'PARY_NAVRHS_BY_PN_PARTNERKA__COUNT_ASC',
  ParyNavrhsByPnPartnerkaCountDesc = 'PARY_NAVRHS_BY_PN_PARTNERKA__COUNT_DESC',
  PermissionByUGroupPeAkceAsc = 'PERMISSION_BY_U_GROUP__PE_AKCE_ASC',
  PermissionByUGroupPeAkceDesc = 'PERMISSION_BY_U_GROUP__PE_AKCE_DESC',
  PermissionByUGroupPeAktualityAsc = 'PERMISSION_BY_U_GROUP__PE_AKTUALITY_ASC',
  PermissionByUGroupPeAktualityDesc = 'PERMISSION_BY_U_GROUP__PE_AKTUALITY_DESC',
  PermissionByUGroupPeAnketyAsc = 'PERMISSION_BY_U_GROUP__PE_ANKETY_ASC',
  PermissionByUGroupPeAnketyDesc = 'PERMISSION_BY_U_GROUP__PE_ANKETY_DESC',
  PermissionByUGroupPeDescriptionAsc = 'PERMISSION_BY_U_GROUP__PE_DESCRIPTION_ASC',
  PermissionByUGroupPeDescriptionDesc = 'PERMISSION_BY_U_GROUP__PE_DESCRIPTION_DESC',
  PermissionByUGroupPeDokumentyAsc = 'PERMISSION_BY_U_GROUP__PE_DOKUMENTY_ASC',
  PermissionByUGroupPeDokumentyDesc = 'PERMISSION_BY_U_GROUP__PE_DOKUMENTY_DESC',
  PermissionByUGroupPeGalerieAsc = 'PERMISSION_BY_U_GROUP__PE_GALERIE_ASC',
  PermissionByUGroupPeGalerieDesc = 'PERMISSION_BY_U_GROUP__PE_GALERIE_DESC',
  PermissionByUGroupPeIdAsc = 'PERMISSION_BY_U_GROUP__PE_ID_ASC',
  PermissionByUGroupPeIdDesc = 'PERMISSION_BY_U_GROUP__PE_ID_DESC',
  PermissionByUGroupPeInzerceAsc = 'PERMISSION_BY_U_GROUP__PE_INZERCE_ASC',
  PermissionByUGroupPeInzerceDesc = 'PERMISSION_BY_U_GROUP__PE_INZERCE_DESC',
  PermissionByUGroupPeKonzoleAsc = 'PERMISSION_BY_U_GROUP__PE_KONZOLE_ASC',
  PermissionByUGroupPeKonzoleDesc = 'PERMISSION_BY_U_GROUP__PE_KONZOLE_DESC',
  PermissionByUGroupPeMainAsc = 'PERMISSION_BY_U_GROUP__PE_MAIN_ASC',
  PermissionByUGroupPeMainDesc = 'PERMISSION_BY_U_GROUP__PE_MAIN_DESC',
  PermissionByUGroupPeNabidkaAsc = 'PERMISSION_BY_U_GROUP__PE_NABIDKA_ASC',
  PermissionByUGroupPeNabidkaDesc = 'PERMISSION_BY_U_GROUP__PE_NABIDKA_DESC',
  PermissionByUGroupPeNameAsc = 'PERMISSION_BY_U_GROUP__PE_NAME_ASC',
  PermissionByUGroupPeNameDesc = 'PERMISSION_BY_U_GROUP__PE_NAME_DESC',
  PermissionByUGroupPeNastenkaAsc = 'PERMISSION_BY_U_GROUP__PE_NASTENKA_ASC',
  PermissionByUGroupPeNastenkaDesc = 'PERMISSION_BY_U_GROUP__PE_NASTENKA_DESC',
  PermissionByUGroupPeNovinkyAsc = 'PERMISSION_BY_U_GROUP__PE_NOVINKY_ASC',
  PermissionByUGroupPeNovinkyDesc = 'PERMISSION_BY_U_GROUP__PE_NOVINKY_DESC',
  PermissionByUGroupPeParyAsc = 'PERMISSION_BY_U_GROUP__PE_PARY_ASC',
  PermissionByUGroupPeParyDesc = 'PERMISSION_BY_U_GROUP__PE_PARY_DESC',
  PermissionByUGroupPePermissionsAsc = 'PERMISSION_BY_U_GROUP__PE_PERMISSIONS_ASC',
  PermissionByUGroupPePermissionsDesc = 'PERMISSION_BY_U_GROUP__PE_PERMISSIONS_DESC',
  PermissionByUGroupPePlatbyAsc = 'PERMISSION_BY_U_GROUP__PE_PLATBY_ASC',
  PermissionByUGroupPePlatbyDesc = 'PERMISSION_BY_U_GROUP__PE_PLATBY_DESC',
  PermissionByUGroupPeRozpisAsc = 'PERMISSION_BY_U_GROUP__PE_ROZPIS_ASC',
  PermissionByUGroupPeRozpisDesc = 'PERMISSION_BY_U_GROUP__PE_ROZPIS_DESC',
  PermissionByUGroupPeSkupinyAsc = 'PERMISSION_BY_U_GROUP__PE_SKUPINY_ASC',
  PermissionByUGroupPeSkupinyDesc = 'PERMISSION_BY_U_GROUP__PE_SKUPINY_DESC',
  PermissionByUGroupPeUsersAsc = 'PERMISSION_BY_U_GROUP__PE_USERS_ASC',
  PermissionByUGroupPeUsersDesc = 'PERMISSION_BY_U_GROUP__PE_USERS_DESC',
  PlatbyItemsByPiIdUserCountAsc = 'PLATBY_ITEMS_BY_PI_ID_USER__COUNT_ASC',
  PlatbyItemsByPiIdUserCountDesc = 'PLATBY_ITEMS_BY_PI_ID_USER__COUNT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RozpisByRTrenerCountAsc = 'ROZPIS_BY_R_TRENER__COUNT_ASC',
  RozpisByRTrenerCountDesc = 'ROZPIS_BY_R_TRENER__COUNT_DESC',
  SessionsBySsUserCountAsc = 'SESSIONS_BY_SS_USER__COUNT_ASC',
  SessionsBySsUserCountDesc = 'SESSIONS_BY_SS_USER__COUNT_DESC',
  SkupinyByUSkupinaCohortGroupAsc = 'SKUPINY_BY_U_SKUPINA__COHORT_GROUP_ASC',
  SkupinyByUSkupinaCohortGroupDesc = 'SKUPINY_BY_U_SKUPINA__COHORT_GROUP_DESC',
  SkupinyByUSkupinaInternalInfoAsc = 'SKUPINY_BY_U_SKUPINA__INTERNAL_INFO_ASC',
  SkupinyByUSkupinaInternalInfoDesc = 'SKUPINY_BY_U_SKUPINA__INTERNAL_INFO_DESC',
  SkupinyByUSkupinaOrderingAsc = 'SKUPINY_BY_U_SKUPINA__ORDERING_ASC',
  SkupinyByUSkupinaOrderingDesc = 'SKUPINY_BY_U_SKUPINA__ORDERING_DESC',
  SkupinyByUSkupinaSColorRgbAsc = 'SKUPINY_BY_U_SKUPINA__S_COLOR_RGB_ASC',
  SkupinyByUSkupinaSColorRgbDesc = 'SKUPINY_BY_U_SKUPINA__S_COLOR_RGB_DESC',
  SkupinyByUSkupinaSColorTextAsc = 'SKUPINY_BY_U_SKUPINA__S_COLOR_TEXT_ASC',
  SkupinyByUSkupinaSColorTextDesc = 'SKUPINY_BY_U_SKUPINA__S_COLOR_TEXT_DESC',
  SkupinyByUSkupinaSDescriptionAsc = 'SKUPINY_BY_U_SKUPINA__S_DESCRIPTION_ASC',
  SkupinyByUSkupinaSDescriptionDesc = 'SKUPINY_BY_U_SKUPINA__S_DESCRIPTION_DESC',
  SkupinyByUSkupinaSIdAsc = 'SKUPINY_BY_U_SKUPINA__S_ID_ASC',
  SkupinyByUSkupinaSIdDesc = 'SKUPINY_BY_U_SKUPINA__S_ID_DESC',
  SkupinyByUSkupinaSLocationAsc = 'SKUPINY_BY_U_SKUPINA__S_LOCATION_ASC',
  SkupinyByUSkupinaSLocationDesc = 'SKUPINY_BY_U_SKUPINA__S_LOCATION_DESC',
  SkupinyByUSkupinaSNameAsc = 'SKUPINY_BY_U_SKUPINA__S_NAME_ASC',
  SkupinyByUSkupinaSNameDesc = 'SKUPINY_BY_U_SKUPINA__S_NAME_DESC',
  SkupinyByUSkupinaSVisibleAsc = 'SKUPINY_BY_U_SKUPINA__S_VISIBLE_ASC',
  SkupinyByUSkupinaSVisibleDesc = 'SKUPINY_BY_U_SKUPINA__S_VISIBLE_DESC',
  UBanAsc = 'U_BAN_ASC',
  UBanDesc = 'U_BAN_DESC',
  UCityAsc = 'U_CITY_ASC',
  UCityDesc = 'U_CITY_DESC',
  UConfirmedAsc = 'U_CONFIRMED_ASC',
  UConfirmedDesc = 'U_CONFIRMED_DESC',
  UConscriptionNumberAsc = 'U_CONSCRIPTION_NUMBER_ASC',
  UConscriptionNumberDesc = 'U_CONSCRIPTION_NUMBER_DESC',
  UCreatedAtAsc = 'U_CREATED_AT_ASC',
  UCreatedAtDesc = 'U_CREATED_AT_DESC',
  UDancerAsc = 'U_DANCER_ASC',
  UDancerDesc = 'U_DANCER_DESC',
  UDistrictAsc = 'U_DISTRICT_ASC',
  UDistrictDesc = 'U_DISTRICT_DESC',
  UEmailAsc = 'U_EMAIL_ASC',
  UEmailDesc = 'U_EMAIL_DESC',
  UGdprSignedAtAsc = 'U_GDPR_SIGNED_AT_ASC',
  UGdprSignedAtDesc = 'U_GDPR_SIGNED_AT_DESC',
  UGroupAsc = 'U_GROUP_ASC',
  UGroupDesc = 'U_GROUP_DESC',
  UIdAsc = 'U_ID_ASC',
  UIdDesc = 'U_ID_DESC',
  UJmenoAsc = 'U_JMENO_ASC',
  UJmenoDesc = 'U_JMENO_DESC',
  ULevelAsc = 'U_LEVEL_ASC',
  ULevelDesc = 'U_LEVEL_DESC',
  ULockAsc = 'U_LOCK_ASC',
  ULockDesc = 'U_LOCK_DESC',
  ULoginAsc = 'U_LOGIN_ASC',
  ULoginDesc = 'U_LOGIN_DESC',
  UMemberSinceAsc = 'U_MEMBER_SINCE_ASC',
  UMemberSinceDesc = 'U_MEMBER_SINCE_DESC',
  UMemberUntilAsc = 'U_MEMBER_UNTIL_ASC',
  UMemberUntilDesc = 'U_MEMBER_UNTIL_DESC',
  UNarozeniAsc = 'U_NAROZENI_ASC',
  UNarozeniDesc = 'U_NAROZENI_DESC',
  UNationalityAsc = 'U_NATIONALITY_ASC',
  UNationalityDesc = 'U_NATIONALITY_DESC',
  UOrientationNumberAsc = 'U_ORIENTATION_NUMBER_ASC',
  UOrientationNumberDesc = 'U_ORIENTATION_NUMBER_DESC',
  UPassAsc = 'U_PASS_ASC',
  UPassDesc = 'U_PASS_DESC',
  UPohlaviAsc = 'U_POHLAVI_ASC',
  UPohlaviDesc = 'U_POHLAVI_DESC',
  UPostalCodeAsc = 'U_POSTAL_CODE_ASC',
  UPostalCodeDesc = 'U_POSTAL_CODE_DESC',
  UPoznamkyAsc = 'U_POZNAMKY_ASC',
  UPoznamkyDesc = 'U_POZNAMKY_DESC',
  UPrijmeniAsc = 'U_PRIJMENI_ASC',
  UPrijmeniDesc = 'U_PRIJMENI_DESC',
  URodneCisloAsc = 'U_RODNE_CISLO_ASC',
  URodneCisloDesc = 'U_RODNE_CISLO_DESC',
  USkupinaAsc = 'U_SKUPINA_ASC',
  USkupinaDesc = 'U_SKUPINA_DESC',
  UStreetAsc = 'U_STREET_ASC',
  UStreetDesc = 'U_STREET_DESC',
  USystemAsc = 'U_SYSTEM_ASC',
  USystemDesc = 'U_SYSTEM_DESC',
  UTeacherAsc = 'U_TEACHER_ASC',
  UTeacherDesc = 'U_TEACHER_DESC',
  UTelefonAsc = 'U_TELEFON_ASC',
  UTelefonDesc = 'U_TELEFON_DESC',
  UTimestampAsc = 'U_TIMESTAMP_ASC',
  UTimestampDesc = 'U_TIMESTAMP_DESC',
  UpozornenisByUpKdoCountAsc = 'UPOZORNENIS_BY_UP_KDO__COUNT_ASC',
  UpozornenisByUpKdoCountDesc = 'UPOZORNENIS_BY_UP_KDO__COUNT_DESC'
}

/** All input for the `verifyFunction` mutation. */
export type VerifyFunctionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  f?: InputMaybe<Scalars['RegProc']>;
  relid?: InputMaybe<Scalars['RegClass']>;
};

/** The output of our `verifyFunction` mutation. */
export type VerifyFunctionPayload = {
  __typename?: 'VerifyFunctionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type Video = Node & {
  __typename?: 'Video';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  vAuthor: Scalars['String'];
  vCreatedAt: Scalars['Datetime'];
  vDescription: Scalars['String'];
  vId: Scalars['BigInt'];
  vPlaylist: Maybe<Scalars['String']>;
  vTitle: Scalars['String'];
  vUpdatedAt: Scalars['Datetime'];
  vUri: Scalars['String'];
};

/** A condition to be used against `Video` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type VideoCondition = {
  /** Checks for equality with the object’s `vAuthor` field. */
  vAuthor?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `vCreatedAt` field. */
  vCreatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `vDescription` field. */
  vDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `vId` field. */
  vId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vPlaylist` field. */
  vPlaylist?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `vTitle` field. */
  vTitle?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `vUpdatedAt` field. */
  vUpdatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `vUri` field. */
  vUri?: InputMaybe<Scalars['String']>;
};

/** An input for mutations affecting `Video` */
export type VideoInput = {
  vAuthor: Scalars['String'];
  vCreatedAt?: InputMaybe<Scalars['Datetime']>;
  vDescription: Scalars['String'];
  vId?: InputMaybe<Scalars['BigInt']>;
  vPlaylist?: InputMaybe<Scalars['String']>;
  vTitle: Scalars['String'];
  vUpdatedAt?: InputMaybe<Scalars['Datetime']>;
  vUri: Scalars['String'];
};

export type VideoList = Node & {
  __typename?: 'VideoList';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  vlCount: Scalars['BigInt'];
  vlCreatedAt: Scalars['Datetime'];
  vlDescription: Scalars['String'];
  vlId: Scalars['BigInt'];
  vlLastChecked: Maybe<Scalars['Datetime']>;
  vlTitle: Scalars['String'];
  vlUrl: Scalars['String'];
};

/**
 * A condition to be used against `VideoList` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type VideoListCondition = {
  /** Checks for equality with the object’s `vlCount` field. */
  vlCount?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vlCreatedAt` field. */
  vlCreatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `vlDescription` field. */
  vlDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `vlId` field. */
  vlId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vlLastChecked` field. */
  vlLastChecked?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `vlTitle` field. */
  vlTitle?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `vlUrl` field. */
  vlUrl?: InputMaybe<Scalars['String']>;
};

/** An input for mutations affecting `VideoList` */
export type VideoListInput = {
  vlCount: Scalars['BigInt'];
  vlCreatedAt: Scalars['Datetime'];
  vlDescription: Scalars['String'];
  vlId?: InputMaybe<Scalars['BigInt']>;
  vlLastChecked?: InputMaybe<Scalars['Datetime']>;
  vlTitle: Scalars['String'];
  vlUrl: Scalars['String'];
};

/** Represents an update to a `VideoList`. Fields that are set will be updated. */
export type VideoListPatch = {
  vlCount?: InputMaybe<Scalars['BigInt']>;
  vlCreatedAt?: InputMaybe<Scalars['Datetime']>;
  vlDescription?: InputMaybe<Scalars['String']>;
  vlId?: InputMaybe<Scalars['BigInt']>;
  vlLastChecked?: InputMaybe<Scalars['Datetime']>;
  vlTitle?: InputMaybe<Scalars['String']>;
  vlUrl?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `VideoList` values. */
export type VideoListsConnection = {
  __typename?: 'VideoListsConnection';
  /** A list of edges which contains the `VideoList` and cursor to aid in pagination. */
  edges: Array<VideoListsEdge>;
  /** A list of `VideoList` objects. */
  nodes: Array<VideoList>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VideoList` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `VideoList` edge in the connection. */
export type VideoListsEdge = {
  __typename?: 'VideoListsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `VideoList` at the end of the edge. */
  node: VideoList;
};

/** Methods to use when ordering `VideoList`. */
export enum VideoListsOrderBy {
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  VlCountAsc = 'VL_COUNT_ASC',
  VlCountDesc = 'VL_COUNT_DESC',
  VlCreatedAtAsc = 'VL_CREATED_AT_ASC',
  VlCreatedAtDesc = 'VL_CREATED_AT_DESC',
  VlDescriptionAsc = 'VL_DESCRIPTION_ASC',
  VlDescriptionDesc = 'VL_DESCRIPTION_DESC',
  VlIdAsc = 'VL_ID_ASC',
  VlIdDesc = 'VL_ID_DESC',
  VlLastCheckedAsc = 'VL_LAST_CHECKED_ASC',
  VlLastCheckedDesc = 'VL_LAST_CHECKED_DESC',
  VlTitleAsc = 'VL_TITLE_ASC',
  VlTitleDesc = 'VL_TITLE_DESC',
  VlUrlAsc = 'VL_URL_ASC',
  VlUrlDesc = 'VL_URL_DESC'
}

/** Represents an update to a `Video`. Fields that are set will be updated. */
export type VideoPatch = {
  vAuthor?: InputMaybe<Scalars['String']>;
  vCreatedAt?: InputMaybe<Scalars['Datetime']>;
  vDescription?: InputMaybe<Scalars['String']>;
  vId?: InputMaybe<Scalars['BigInt']>;
  vPlaylist?: InputMaybe<Scalars['String']>;
  vTitle?: InputMaybe<Scalars['String']>;
  vUpdatedAt?: InputMaybe<Scalars['Datetime']>;
  vUri?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Video` values. */
export type VideosConnection = {
  __typename?: 'VideosConnection';
  /** A list of edges which contains the `Video` and cursor to aid in pagination. */
  edges: Array<VideosEdge>;
  /** A list of `Video` objects. */
  nodes: Array<Video>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Video` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Video` edge in the connection. */
export type VideosEdge = {
  __typename?: 'VideosEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Video` at the end of the edge. */
  node: Video;
};

/** Methods to use when ordering `Video`. */
export enum VideosOrderBy {
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  VAuthorAsc = 'V_AUTHOR_ASC',
  VAuthorDesc = 'V_AUTHOR_DESC',
  VCreatedAtAsc = 'V_CREATED_AT_ASC',
  VCreatedAtDesc = 'V_CREATED_AT_DESC',
  VDescriptionAsc = 'V_DESCRIPTION_ASC',
  VDescriptionDesc = 'V_DESCRIPTION_DESC',
  VIdAsc = 'V_ID_ASC',
  VIdDesc = 'V_ID_DESC',
  VPlaylistAsc = 'V_PLAYLIST_ASC',
  VPlaylistDesc = 'V_PLAYLIST_DESC',
  VTitleAsc = 'V_TITLE_ASC',
  VTitleDesc = 'V_TITLE_DESC',
  VUpdatedAtAsc = 'V_UPDATED_AT_ASC',
  VUpdatedAtDesc = 'V_UPDATED_AT_DESC',
  VUriAsc = 'V_URI_ASC',
  VUriDesc = 'V_URI_DESC'
}

export type VideoSource = Node & {
  __typename?: 'VideoSource';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  vsCreatedAt: Scalars['Datetime'];
  vsDescription: Maybe<Scalars['String']>;
  vsId: Scalars['BigInt'];
  vsLastChecked: Maybe<Scalars['Datetime']>;
  vsTitle: Maybe<Scalars['String']>;
  vsUrl: Scalars['String'];
};

/**
 * A condition to be used against `VideoSource` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type VideoSourceCondition = {
  /** Checks for equality with the object’s `vsCreatedAt` field. */
  vsCreatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `vsDescription` field. */
  vsDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `vsId` field. */
  vsId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vsLastChecked` field. */
  vsLastChecked?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `vsTitle` field. */
  vsTitle?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `vsUrl` field. */
  vsUrl?: InputMaybe<Scalars['String']>;
};

/** An input for mutations affecting `VideoSource` */
export type VideoSourceInput = {
  vsCreatedAt?: InputMaybe<Scalars['Datetime']>;
  vsDescription?: InputMaybe<Scalars['String']>;
  vsId?: InputMaybe<Scalars['BigInt']>;
  vsLastChecked?: InputMaybe<Scalars['Datetime']>;
  vsTitle?: InputMaybe<Scalars['String']>;
  vsUrl: Scalars['String'];
};

/** Represents an update to a `VideoSource`. Fields that are set will be updated. */
export type VideoSourcePatch = {
  vsCreatedAt?: InputMaybe<Scalars['Datetime']>;
  vsDescription?: InputMaybe<Scalars['String']>;
  vsId?: InputMaybe<Scalars['BigInt']>;
  vsLastChecked?: InputMaybe<Scalars['Datetime']>;
  vsTitle?: InputMaybe<Scalars['String']>;
  vsUrl?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `VideoSource` values. */
export type VideoSourcesConnection = {
  __typename?: 'VideoSourcesConnection';
  /** A list of edges which contains the `VideoSource` and cursor to aid in pagination. */
  edges: Array<VideoSourcesEdge>;
  /** A list of `VideoSource` objects. */
  nodes: Array<VideoSource>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VideoSource` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `VideoSource` edge in the connection. */
export type VideoSourcesEdge = {
  __typename?: 'VideoSourcesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `VideoSource` at the end of the edge. */
  node: VideoSource;
};

/** Methods to use when ordering `VideoSource`. */
export enum VideoSourcesOrderBy {
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  VsCreatedAtAsc = 'VS_CREATED_AT_ASC',
  VsCreatedAtDesc = 'VS_CREATED_AT_DESC',
  VsDescriptionAsc = 'VS_DESCRIPTION_ASC',
  VsDescriptionDesc = 'VS_DESCRIPTION_DESC',
  VsIdAsc = 'VS_ID_ASC',
  VsIdDesc = 'VS_ID_DESC',
  VsLastCheckedAsc = 'VS_LAST_CHECKED_ASC',
  VsLastCheckedDesc = 'VS_LAST_CHECKED_DESC',
  VsTitleAsc = 'VS_TITLE_ASC',
  VsTitleDesc = 'VS_TITLE_DESC',
  VsUrlAsc = 'VS_URL_ASC',
  VsUrlDesc = 'VS_URL_DESC'
}
