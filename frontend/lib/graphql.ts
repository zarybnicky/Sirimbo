/* DO NOT EDIT! This file is auto-generated by graphql-code-generator - see `codegen.yml` */
/* eslint-disable */
import { useQuery, useMutation, UseQueryOptions, UseMutationOptions } from '@tanstack/react-query';
import { fetcher } from 'lib/query';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** A floating point number that requires more precision than IEEE 754 binary 64 */
  BigFloat: any;
  /**
   * A signed eight-byte integer. The upper big integer values are greater than the
   * max value for a JavaScript number. Therefore all big integers will be output as
   * strings and not numbers.
   */
  BigInt: string;
  /** A location in a connection that can be used for resuming pagination. */
  Cursor: any;
  /** The day, does not include a time. */
  Date: string;
  /**
   * A point in time as described by the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
   */
  Datetime: string;
  /** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
  JSON: { [key: string]: any };
  /** The exact time of day, does not include the date. May or may not have a timezone offset. */
  Time: string;
};

/** A `ActiveProspectsRecord` edge in the connection. */
export type ActiveProspectEdge = {
  __typename?: 'ActiveProspectEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `ActiveProspectsRecord` at the end of the edge. */
  node: ActiveProspectsRecord;
};

/** A connection to a list of `ActiveProspectsRecord` values. */
export type ActiveProspectsConnection = {
  __typename?: 'ActiveProspectsConnection';
  /** A list of edges which contains the `ActiveProspectsRecord` and cursor to aid in pagination. */
  edges: Array<ActiveProspectEdge>;
  /** A list of `ActiveProspectsRecord` objects. */
  nodes: Array<ActiveProspectsRecord>;
  /** The count of *all* `ActiveProspectsRecord` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** The return type of our `activeProspects` query. */
export type ActiveProspectsRecord = {
  __typename?: 'ActiveProspectsRecord';
  cohort: Maybe<CrmCohort>;
  data: Maybe<ProspectDatum>;
  id: Maybe<Scalars['BigInt']>;
  updatedAt: Maybe<Scalars['Datetime']>;
};

export type Akce = Node & {
  __typename?: 'Akce';
  aDo: Scalars['Date'];
  aDokumenty: Scalars['String'];
  aId: Scalars['BigInt'];
  aInfo: Scalars['String'];
  aJmeno: Scalars['String'];
  aKapacita: Scalars['BigInt'];
  /** Reads and enables pagination through a set of `AkceItem`. */
  akceItemsByAiIdRodic: AkceItemsConnection;
  aKde: Scalars['String'];
  aLock: Scalars['Boolean'];
  aOd: Scalars['Date'];
  aTimestamp: Maybe<Scalars['Datetime']>;
  aVisible: Scalars['Boolean'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
};


export type AkceAkceItemsByAiIdRodicArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AkceItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AkceItemsOrderBy>>;
};

/** A condition to be used against `Akce` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type AkceCondition = {
  /** Checks for equality with the object’s `aDo` field. */
  aDo?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `aDokumenty` field. */
  aDokumenty?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `aId` field. */
  aId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `aInfo` field. */
  aInfo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `aJmeno` field. */
  aJmeno?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `aKapacita` field. */
  aKapacita?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `aKde` field. */
  aKde?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `aLock` field. */
  aLock?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `aOd` field. */
  aOd?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `aTimestamp` field. */
  aTimestamp?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `aVisible` field. */
  aVisible?: InputMaybe<Scalars['Boolean']>;
};

/** An input for mutations affecting `Akce` */
export type AkceInput = {
  aDo: Scalars['Date'];
  aDokumenty: Scalars['String'];
  aId?: InputMaybe<Scalars['BigInt']>;
  aInfo: Scalars['String'];
  aJmeno: Scalars['String'];
  aKapacita?: InputMaybe<Scalars['BigInt']>;
  aKde: Scalars['String'];
  aLock?: InputMaybe<Scalars['Boolean']>;
  aOd: Scalars['Date'];
  aTimestamp?: InputMaybe<Scalars['Datetime']>;
  aVisible?: InputMaybe<Scalars['Boolean']>;
};

export type AkceItem = Node & {
  __typename?: 'AkceItem';
  aiId: Scalars['BigInt'];
  aiIdRodic: Scalars['BigInt'];
  aiRokNarozeni: Scalars['Int'];
  aiUser: Scalars['BigInt'];
  /** Reads a single `Akce` that is related to this `AkceItem`. */
  akceByAiIdRodic: Maybe<Akce>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `User` that is related to this `AkceItem`. */
  userByAiUser: Maybe<User>;
};

/**
 * A condition to be used against `AkceItem` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type AkceItemCondition = {
  /** Checks for equality with the object’s `aiId` field. */
  aiId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `aiIdRodic` field. */
  aiIdRodic?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `aiRokNarozeni` field. */
  aiRokNarozeni?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `aiUser` field. */
  aiUser?: InputMaybe<Scalars['BigInt']>;
};

/** An input for mutations affecting `AkceItem` */
export type AkceItemInput = {
  aiId?: InputMaybe<Scalars['BigInt']>;
  aiIdRodic: Scalars['BigInt'];
  aiRokNarozeni: Scalars['Int'];
  aiUser: Scalars['BigInt'];
};

/** Represents an update to a `AkceItem`. Fields that are set will be updated. */
export type AkceItemPatch = {
  aiId?: InputMaybe<Scalars['BigInt']>;
  aiIdRodic?: InputMaybe<Scalars['BigInt']>;
  aiRokNarozeni?: InputMaybe<Scalars['Int']>;
  aiUser?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `AkceItem` values. */
export type AkceItemsConnection = {
  __typename?: 'AkceItemsConnection';
  /** A list of edges which contains the `AkceItem` and cursor to aid in pagination. */
  edges: Array<AkceItemsEdge>;
  /** A list of `AkceItem` objects. */
  nodes: Array<AkceItem>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AkceItem` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `AkceItem` edge in the connection. */
export type AkceItemsEdge = {
  __typename?: 'AkceItemsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `AkceItem` at the end of the edge. */
  node: AkceItem;
};

/** Methods to use when ordering `AkceItem`. */
export enum AkceItemsOrderBy {
  AiIdAsc = 'AI_ID_ASC',
  AiIdDesc = 'AI_ID_DESC',
  AiIdRodicAsc = 'AI_ID_RODIC_ASC',
  AiIdRodicDesc = 'AI_ID_RODIC_DESC',
  AiRokNarozeniAsc = 'AI_ROK_NAROZENI_ASC',
  AiRokNarozeniDesc = 'AI_ROK_NAROZENI_DESC',
  AiUserAsc = 'AI_USER_ASC',
  AiUserDesc = 'AI_USER_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Represents an update to a `Akce`. Fields that are set will be updated. */
export type AkcePatch = {
  aDo?: InputMaybe<Scalars['Date']>;
  aDokumenty?: InputMaybe<Scalars['String']>;
  aId?: InputMaybe<Scalars['BigInt']>;
  aInfo?: InputMaybe<Scalars['String']>;
  aJmeno?: InputMaybe<Scalars['String']>;
  aKapacita?: InputMaybe<Scalars['BigInt']>;
  aKde?: InputMaybe<Scalars['String']>;
  aLock?: InputMaybe<Scalars['Boolean']>;
  aOd?: InputMaybe<Scalars['Date']>;
  aTimestamp?: InputMaybe<Scalars['Datetime']>;
  aVisible?: InputMaybe<Scalars['Boolean']>;
};

/** A connection to a list of `Akce` values. */
export type AkcesConnection = {
  __typename?: 'AkcesConnection';
  /** A list of edges which contains the `Akce` and cursor to aid in pagination. */
  edges: Array<AkcesEdge>;
  /** A list of `Akce` objects. */
  nodes: Array<Akce>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Akce` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Akce` edge in the connection. */
export type AkcesEdge = {
  __typename?: 'AkcesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Akce` at the end of the edge. */
  node: Akce;
};

/** Methods to use when ordering `Akce`. */
export enum AkcesOrderBy {
  ADoAsc = 'A_DO_ASC',
  ADoDesc = 'A_DO_DESC',
  ADokumentyAsc = 'A_DOKUMENTY_ASC',
  ADokumentyDesc = 'A_DOKUMENTY_DESC',
  AIdAsc = 'A_ID_ASC',
  AIdDesc = 'A_ID_DESC',
  AInfoAsc = 'A_INFO_ASC',
  AInfoDesc = 'A_INFO_DESC',
  AJmenoAsc = 'A_JMENO_ASC',
  AJmenoDesc = 'A_JMENO_DESC',
  AKapacitaAsc = 'A_KAPACITA_ASC',
  AKapacitaDesc = 'A_KAPACITA_DESC',
  AKdeAsc = 'A_KDE_ASC',
  AKdeDesc = 'A_KDE_DESC',
  ALockAsc = 'A_LOCK_ASC',
  ALockDesc = 'A_LOCK_DESC',
  AOdAsc = 'A_OD_ASC',
  AOdDesc = 'A_OD_DESC',
  ATimestampAsc = 'A_TIMESTAMP_ASC',
  ATimestampDesc = 'A_TIMESTAMP_DESC',
  AVisibleAsc = 'A_VISIBLE_ASC',
  AVisibleDesc = 'A_VISIBLE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `Aktuality` values. */
export type AktualitiesConnection = {
  __typename?: 'AktualitiesConnection';
  /** A list of edges which contains the `Aktuality` and cursor to aid in pagination. */
  edges: Array<AktualitiesEdge>;
  /** A list of `Aktuality` objects. */
  nodes: Array<Aktuality>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Aktuality` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Aktuality` edge in the connection. */
export type AktualitiesEdge = {
  __typename?: 'AktualitiesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Aktuality` at the end of the edge. */
  node: Aktuality;
};

/** Methods to use when ordering `Aktuality`. */
export enum AktualitiesOrderBy {
  AtFotoAsc = 'AT_FOTO_ASC',
  AtFotoDesc = 'AT_FOTO_DESC',
  AtFotoMainAsc = 'AT_FOTO_MAIN_ASC',
  AtFotoMainDesc = 'AT_FOTO_MAIN_DESC',
  AtIdAsc = 'AT_ID_ASC',
  AtIdDesc = 'AT_ID_DESC',
  AtJmenoAsc = 'AT_JMENO_ASC',
  AtJmenoDesc = 'AT_JMENO_DESC',
  AtKatAsc = 'AT_KAT_ASC',
  AtKatDesc = 'AT_KAT_DESC',
  AtKdoAsc = 'AT_KDO_ASC',
  AtKdoDesc = 'AT_KDO_DESC',
  AtPreviewAsc = 'AT_PREVIEW_ASC',
  AtPreviewDesc = 'AT_PREVIEW_DESC',
  AtTextAsc = 'AT_TEXT_ASC',
  AtTextDesc = 'AT_TEXT_DESC',
  AtTimestampAddAsc = 'AT_TIMESTAMP_ADD_ASC',
  AtTimestampAddDesc = 'AT_TIMESTAMP_ADD_DESC',
  AtTimestampAsc = 'AT_TIMESTAMP_ASC',
  AtTimestampDesc = 'AT_TIMESTAMP_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type Aktuality = Node & {
  __typename?: 'Aktuality';
  atFoto: Maybe<Scalars['BigInt']>;
  atFotoMain: Maybe<Scalars['BigInt']>;
  atId: Scalars['BigInt'];
  atJmeno: Scalars['String'];
  atKat: Scalars['String'];
  atKdo: Maybe<Scalars['BigInt']>;
  atPreview: Scalars['String'];
  atText: Scalars['String'];
  atTimestamp: Maybe<Scalars['Datetime']>;
  atTimestampAdd: Maybe<Scalars['Datetime']>;
  /** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
  galerieFotoByAtFotoMain: Maybe<GalerieFoto>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `User` that is related to this `Aktuality`. */
  userByAtKdo: Maybe<User>;
};

/**
 * A condition to be used against `Aktuality` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type AktualityCondition = {
  /** Checks for equality with the object’s `atFoto` field. */
  atFoto?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `atFotoMain` field. */
  atFotoMain?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `atId` field. */
  atId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `atJmeno` field. */
  atJmeno?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `atKat` field. */
  atKat?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `atKdo` field. */
  atKdo?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `atPreview` field. */
  atPreview?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `atText` field. */
  atText?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `atTimestamp` field. */
  atTimestamp?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `atTimestampAdd` field. */
  atTimestampAdd?: InputMaybe<Scalars['Datetime']>;
};

/** An input for mutations affecting `Aktuality` */
export type AktualityInput = {
  atFoto?: InputMaybe<Scalars['BigInt']>;
  atFotoMain?: InputMaybe<Scalars['BigInt']>;
  atId?: InputMaybe<Scalars['BigInt']>;
  atJmeno: Scalars['String'];
  atKat: Scalars['String'];
  atKdo?: InputMaybe<Scalars['BigInt']>;
  atPreview: Scalars['String'];
  atText: Scalars['String'];
  atTimestamp?: InputMaybe<Scalars['Datetime']>;
  atTimestampAdd?: InputMaybe<Scalars['Datetime']>;
};

/** Represents an update to a `Aktuality`. Fields that are set will be updated. */
export type AktualityPatch = {
  atFoto?: InputMaybe<Scalars['BigInt']>;
  atFotoMain?: InputMaybe<Scalars['BigInt']>;
  atId?: InputMaybe<Scalars['BigInt']>;
  atJmeno?: InputMaybe<Scalars['String']>;
  atKat?: InputMaybe<Scalars['String']>;
  atKdo?: InputMaybe<Scalars['BigInt']>;
  atPreview?: InputMaybe<Scalars['String']>;
  atText?: InputMaybe<Scalars['String']>;
  atTimestamp?: InputMaybe<Scalars['Datetime']>;
  atTimestampAdd?: InputMaybe<Scalars['Datetime']>;
};

/** All input for the `confirmUser` mutation. */
export type ConfirmUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  cohort: Scalars['BigInt'];
  grp: Scalars['BigInt'];
  id: Scalars['BigInt'];
};

/** The output of our `confirmUser` mutation. */
export type ConfirmUserPayload = {
  __typename?: 'ConfirmUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `Akce` mutation. */
export type CreateAkceInput = {
  /** The `Akce` to be created by this mutation. */
  akce: AkceInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** All input for the create `AkceItem` mutation. */
export type CreateAkceItemInput = {
  /** The `AkceItem` to be created by this mutation. */
  akceItem: AkceItemInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** The output of our create `AkceItem` mutation. */
export type CreateAkceItemPayload = {
  __typename?: 'CreateAkceItemPayload';
  /** Reads a single `Akce` that is related to this `AkceItem`. */
  akceByAiIdRodic: Maybe<Akce>;
  /** The `AkceItem` that was created by this mutation. */
  akceItem: Maybe<AkceItem>;
  /** An edge for our `AkceItem`. May be used by Relay 1. */
  akceItemEdge: Maybe<AkceItemsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `AkceItem`. */
  userByAiUser: Maybe<User>;
};


/** The output of our create `AkceItem` mutation. */
export type CreateAkceItemPayloadAkceItemEdgeArgs = {
  orderBy?: InputMaybe<Array<AkceItemsOrderBy>>;
};

/** The output of our create `Akce` mutation. */
export type CreateAkcePayload = {
  __typename?: 'CreateAkcePayload';
  /** The `Akce` that was created by this mutation. */
  akce: Maybe<Akce>;
  /** An edge for our `Akce`. May be used by Relay 1. */
  akceEdge: Maybe<AkcesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Akce` mutation. */
export type CreateAkcePayloadAkceEdgeArgs = {
  orderBy?: InputMaybe<Array<AkcesOrderBy>>;
};

/** All input for the create `Aktuality` mutation. */
export type CreateAktualityInput = {
  /** The `Aktuality` to be created by this mutation. */
  aktuality: AktualityInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Aktuality` mutation. */
export type CreateAktualityPayload = {
  __typename?: 'CreateAktualityPayload';
  /** The `Aktuality` that was created by this mutation. */
  aktuality: Maybe<Aktuality>;
  /** An edge for our `Aktuality`. May be used by Relay 1. */
  aktualityEdge: Maybe<AktualitiesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
  galerieFotoByAtFotoMain: Maybe<GalerieFoto>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Aktuality`. */
  userByAtKdo: Maybe<User>;
};


/** The output of our create `Aktuality` mutation. */
export type CreateAktualityPayloadAktualityEdgeArgs = {
  orderBy?: InputMaybe<Array<AktualitiesOrderBy>>;
};

/** All input for the `createCouple` mutation. */
export type CreateCoupleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  man: Scalars['BigInt'];
  woman: Scalars['BigInt'];
};

/** The output of our `createCouple` mutation. */
export type CreateCouplePayload = {
  __typename?: 'CreateCouplePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  paries: Maybe<Array<Pary>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `Dokumenty` mutation. */
export type CreateDokumentyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Dokumenty` to be created by this mutation. */
  dokumenty: DokumentyInput;
};

/** The output of our create `Dokumenty` mutation. */
export type CreateDokumentyPayload = {
  __typename?: 'CreateDokumentyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Dokumenty` that was created by this mutation. */
  dokumenty: Maybe<Dokumenty>;
  /** An edge for our `Dokumenty`. May be used by Relay 1. */
  dokumentyEdge: Maybe<DokumentiesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Dokumenty`. */
  userByDKdo: Maybe<User>;
};


/** The output of our create `Dokumenty` mutation. */
export type CreateDokumentyPayloadDokumentyEdgeArgs = {
  orderBy?: InputMaybe<Array<DokumentiesOrderBy>>;
};

/** All input for the create `GalerieDir` mutation. */
export type CreateGalerieDirInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `GalerieDir` to be created by this mutation. */
  galerieDir: GalerieDirInput;
};

/** The output of our create `GalerieDir` mutation. */
export type CreateGalerieDirPayload = {
  __typename?: 'CreateGalerieDirPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GalerieDir` that was created by this mutation. */
  galerieDir: Maybe<GalerieDir>;
  /** An edge for our `GalerieDir`. May be used by Relay 1. */
  galerieDirEdge: Maybe<GalerieDirsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `GalerieDir` mutation. */
export type CreateGalerieDirPayloadGalerieDirEdgeArgs = {
  orderBy?: InputMaybe<Array<GalerieDirsOrderBy>>;
};

/** All input for the create `GalerieFoto` mutation. */
export type CreateGalerieFotoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `GalerieFoto` to be created by this mutation. */
  galerieFoto: GalerieFotoInput;
};

/** The output of our create `GalerieFoto` mutation. */
export type CreateGalerieFotoPayload = {
  __typename?: 'CreateGalerieFotoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
  galerieDirByGfIdRodic: Maybe<GalerieDir>;
  /** The `GalerieFoto` that was created by this mutation. */
  galerieFoto: Maybe<GalerieFoto>;
  /** An edge for our `GalerieFoto`. May be used by Relay 1. */
  galerieFotoEdge: Maybe<GalerieFotosEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `GalerieFoto`. */
  userByGfKdo: Maybe<User>;
};


/** The output of our create `GalerieFoto` mutation. */
export type CreateGalerieFotoPayloadGalerieFotoEdgeArgs = {
  orderBy?: InputMaybe<Array<GalerieFotosOrderBy>>;
};

/** All input for the create `Nabidka` mutation. */
export type CreateNabidkaInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Nabidka` to be created by this mutation. */
  nabidka: NabidkaInput;
};

/** All input for the create `NabidkaItem` mutation. */
export type CreateNabidkaItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `NabidkaItem` to be created by this mutation. */
  nabidkaItem: NabidkaItemInput;
};

/** The output of our create `NabidkaItem` mutation. */
export type CreateNabidkaItemPayload = {
  __typename?: 'CreateNabidkaItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Nabidka` that is related to this `NabidkaItem`. */
  nabidkaByNiIdRodic: Maybe<Nabidka>;
  /** The `NabidkaItem` that was created by this mutation. */
  nabidkaItem: Maybe<NabidkaItem>;
  /** An edge for our `NabidkaItem`. May be used by Relay 1. */
  nabidkaItemEdge: Maybe<NabidkaItemsEdge>;
  /** Reads a single `Pary` that is related to this `NabidkaItem`. */
  paryByNiPartner: Maybe<Pary>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `NabidkaItem` mutation. */
export type CreateNabidkaItemPayloadNabidkaItemEdgeArgs = {
  orderBy?: InputMaybe<Array<NabidkaItemsOrderBy>>;
};

/** The output of our create `Nabidka` mutation. */
export type CreateNabidkaPayload = {
  __typename?: 'CreateNabidkaPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Nabidka` that was created by this mutation. */
  nabidka: Maybe<Nabidka>;
  /** An edge for our `Nabidka`. May be used by Relay 1. */
  nabidkaEdge: Maybe<NabidkasEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Nabidka`. */
  userByNTrener: Maybe<User>;
};


/** The output of our create `Nabidka` mutation. */
export type CreateNabidkaPayloadNabidkaEdgeArgs = {
  orderBy?: InputMaybe<Array<NabidkasOrderBy>>;
};

/** All input for the create `Page` mutation. */
export type CreatePageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Page` to be created by this mutation. */
  page: PageInput;
};

/** The output of our create `Page` mutation. */
export type CreatePagePayload = {
  __typename?: 'CreatePagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Page` that was created by this mutation. */
  page: Maybe<Page>;
  /** An edge for our `Page`. May be used by Relay 1. */
  pageEdge: Maybe<PagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Page` mutation. */
export type CreatePagePayloadPageEdgeArgs = {
  orderBy?: InputMaybe<Array<PagesOrderBy>>;
};

/** All input for the create `Parameter` mutation. */
export type CreateParameterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Parameter` to be created by this mutation. */
  parameter: ParameterInput;
};

/** The output of our create `Parameter` mutation. */
export type CreateParameterPayload = {
  __typename?: 'CreateParameterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Parameter` that was created by this mutation. */
  parameter: Maybe<Parameter>;
  /** An edge for our `Parameter`. May be used by Relay 1. */
  parameterEdge: Maybe<ParametersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Parameter` mutation. */
export type CreateParameterPayloadParameterEdgeArgs = {
  orderBy?: InputMaybe<Array<ParametersOrderBy>>;
};

/** All input for the create `Pary` mutation. */
export type CreateParyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Pary` to be created by this mutation. */
  pary: ParyInput;
};

/** All input for the create `ParyNavrh` mutation. */
export type CreateParyNavrhInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `ParyNavrh` to be created by this mutation. */
  paryNavrh: ParyNavrhInput;
};

/** The output of our create `ParyNavrh` mutation. */
export type CreateParyNavrhPayload = {
  __typename?: 'CreateParyNavrhPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ParyNavrh` that was created by this mutation. */
  paryNavrh: Maybe<ParyNavrh>;
  /** An edge for our `ParyNavrh`. May be used by Relay 1. */
  paryNavrhEdge: Maybe<ParyNavrhsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnNavrhl: Maybe<User>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnPartnerka: Maybe<User>;
};


/** The output of our create `ParyNavrh` mutation. */
export type CreateParyNavrhPayloadParyNavrhEdgeArgs = {
  orderBy?: InputMaybe<Array<ParyNavrhsOrderBy>>;
};

/** The output of our create `Pary` mutation. */
export type CreateParyPayload = {
  __typename?: 'CreateParyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Pary` that was created by this mutation. */
  pary: Maybe<Pary>;
  /** An edge for our `Pary`. May be used by Relay 1. */
  paryEdge: Maybe<PariesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartnerka: Maybe<User>;
};


/** The output of our create `Pary` mutation. */
export type CreateParyPayloadParyEdgeArgs = {
  orderBy?: InputMaybe<Array<PariesOrderBy>>;
};

/** All input for the create `Permission` mutation. */
export type CreatePermissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Permission` to be created by this mutation. */
  permission: PermissionInput;
};

/** The output of our create `Permission` mutation. */
export type CreatePermissionPayload = {
  __typename?: 'CreatePermissionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Permission` that was created by this mutation. */
  permission: Maybe<Permission>;
  /** An edge for our `Permission`. May be used by Relay 1. */
  permissionEdge: Maybe<PermissionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Permission` mutation. */
export type CreatePermissionPayloadPermissionEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
};

/** All input for the create `PlatbyCategoryGroup` mutation. */
export type CreatePlatbyCategoryGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `PlatbyCategoryGroup` to be created by this mutation. */
  platbyCategoryGroup: PlatbyCategoryGroupInput;
};

/** The output of our create `PlatbyCategoryGroup` mutation. */
export type CreatePlatbyCategoryGroupPayload = {
  __typename?: 'CreatePlatbyCategoryGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyCategoryGroup`. */
  platbyCategoryByPcgIdCategory: Maybe<PlatbyCategory>;
  /** The `PlatbyCategoryGroup` that was created by this mutation. */
  platbyCategoryGroup: Maybe<PlatbyCategoryGroup>;
  /** An edge for our `PlatbyCategoryGroup`. May be used by Relay 1. */
  platbyCategoryGroupEdge: Maybe<PlatbyCategoryGroupsEdge>;
  /** Reads a single `PlatbyGroup` that is related to this `PlatbyCategoryGroup`. */
  platbyGroupByPcgIdGroup: Maybe<PlatbyGroup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `PlatbyCategoryGroup` mutation. */
export type CreatePlatbyCategoryGroupPayloadPlatbyCategoryGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyCategoryGroupsOrderBy>>;
};

/** All input for the create `PlatbyCategory` mutation. */
export type CreatePlatbyCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `PlatbyCategory` to be created by this mutation. */
  platbyCategory: PlatbyCategoryInput;
};

/** The output of our create `PlatbyCategory` mutation. */
export type CreatePlatbyCategoryPayload = {
  __typename?: 'CreatePlatbyCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlatbyCategory` that was created by this mutation. */
  platbyCategory: Maybe<PlatbyCategory>;
  /** An edge for our `PlatbyCategory`. May be used by Relay 1. */
  platbyCategoryEdge: Maybe<PlatbyCategoriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `PlatbyCategory` mutation. */
export type CreatePlatbyCategoryPayloadPlatbyCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyCategoriesOrderBy>>;
};

/** All input for the create `PlatbyGroup` mutation. */
export type CreatePlatbyGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `PlatbyGroup` to be created by this mutation. */
  platbyGroup: PlatbyGroupInput;
};

/** The output of our create `PlatbyGroup` mutation. */
export type CreatePlatbyGroupPayload = {
  __typename?: 'CreatePlatbyGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlatbyGroup` that was created by this mutation. */
  platbyGroup: Maybe<PlatbyGroup>;
  /** An edge for our `PlatbyGroup`. May be used by Relay 1. */
  platbyGroupEdge: Maybe<PlatbyGroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `PlatbyGroup` mutation. */
export type CreatePlatbyGroupPayloadPlatbyGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyGroupsOrderBy>>;
};

/** All input for the create `PlatbyGroupSkupina` mutation. */
export type CreatePlatbyGroupSkupinaInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `PlatbyGroupSkupina` to be created by this mutation. */
  platbyGroupSkupina: PlatbyGroupSkupinaInput;
};

/** The output of our create `PlatbyGroupSkupina` mutation. */
export type CreatePlatbyGroupSkupinaPayload = {
  __typename?: 'CreatePlatbyGroupSkupinaPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `PlatbyGroup` that is related to this `PlatbyGroupSkupina`. */
  platbyGroupByPgsIdGroup: Maybe<PlatbyGroup>;
  /** The `PlatbyGroupSkupina` that was created by this mutation. */
  platbyGroupSkupina: Maybe<PlatbyGroupSkupina>;
  /** An edge for our `PlatbyGroupSkupina`. May be used by Relay 1. */
  platbyGroupSkupinaEdge: Maybe<PlatbyGroupSkupinasEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `PlatbyGroupSkupina`. */
  skupinyByPgsIdSkupina: Maybe<Skupiny>;
};


/** The output of our create `PlatbyGroupSkupina` mutation. */
export type CreatePlatbyGroupSkupinaPayloadPlatbyGroupSkupinaEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyGroupSkupinasOrderBy>>;
};

/** All input for the create `PlatbyItem` mutation. */
export type CreatePlatbyItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `PlatbyItem` to be created by this mutation. */
  platbyItem: PlatbyItemInput;
};

/** The output of our create `PlatbyItem` mutation. */
export type CreatePlatbyItemPayload = {
  __typename?: 'CreatePlatbyItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
  platbyCategoryByPiIdCategory: Maybe<PlatbyCategory>;
  /** The `PlatbyItem` that was created by this mutation. */
  platbyItem: Maybe<PlatbyItem>;
  /** An edge for our `PlatbyItem`. May be used by Relay 1. */
  platbyItemEdge: Maybe<PlatbyItemsEdge>;
  /** Reads a single `PlatbyRaw` that is related to this `PlatbyItem`. */
  platbyRawByPiIdRaw: Maybe<PlatbyRaw>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `PlatbyItem`. */
  userByPiIdUser: Maybe<User>;
};


/** The output of our create `PlatbyItem` mutation. */
export type CreatePlatbyItemPayloadPlatbyItemEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyItemsOrderBy>>;
};

/** All input for the create `PlatbyRaw` mutation. */
export type CreatePlatbyRawInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `PlatbyRaw` to be created by this mutation. */
  platbyRaw: PlatbyRawInput;
};

/** The output of our create `PlatbyRaw` mutation. */
export type CreatePlatbyRawPayload = {
  __typename?: 'CreatePlatbyRawPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlatbyRaw` that was created by this mutation. */
  platbyRaw: Maybe<PlatbyRaw>;
  /** An edge for our `PlatbyRaw`. May be used by Relay 1. */
  platbyRawEdge: Maybe<PlatbyRawsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `PlatbyRaw` mutation. */
export type CreatePlatbyRawPayloadPlatbyRawEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyRawsOrderBy>>;
};

/** All input for the create `Rozpi` mutation. */
export type CreateRozpiInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Rozpi` to be created by this mutation. */
  rozpi: RozpiInput;
};

/** The output of our create `Rozpi` mutation. */
export type CreateRozpiPayload = {
  __typename?: 'CreateRozpiPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Rozpi` that was created by this mutation. */
  rozpi: Maybe<Rozpi>;
  /** An edge for our `Rozpi`. May be used by Relay 1. */
  rozpiEdge: Maybe<RozpisEdge>;
  /** Reads a single `User` that is related to this `Rozpi`. */
  userByRTrener: Maybe<User>;
};


/** The output of our create `Rozpi` mutation. */
export type CreateRozpiPayloadRozpiEdgeArgs = {
  orderBy?: InputMaybe<Array<RozpisOrderBy>>;
};

/** All input for the create `RozpisItem` mutation. */
export type CreateRozpisItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `RozpisItem` to be created by this mutation. */
  rozpisItem: RozpisItemInput;
};

/** The output of our create `RozpisItem` mutation. */
export type CreateRozpisItemPayload = {
  __typename?: 'CreateRozpisItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Pary` that is related to this `RozpisItem`. */
  paryByRiPartner: Maybe<Pary>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Rozpi` that is related to this `RozpisItem`. */
  rozpiByRiIdRodic: Maybe<Rozpi>;
  /** The `RozpisItem` that was created by this mutation. */
  rozpisItem: Maybe<RozpisItem>;
  /** An edge for our `RozpisItem`. May be used by Relay 1. */
  rozpisItemEdge: Maybe<RozpisItemsEdge>;
};


/** The output of our create `RozpisItem` mutation. */
export type CreateRozpisItemPayloadRozpisItemEdgeArgs = {
  orderBy?: InputMaybe<Array<RozpisItemsOrderBy>>;
};

/** All input for the create `Session` mutation. */
export type CreateSessionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Session` to be created by this mutation. */
  session: SessionInput;
};

/** The output of our create `Session` mutation. */
export type CreateSessionPayload = {
  __typename?: 'CreateSessionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Session` that was created by this mutation. */
  session: Maybe<Session>;
  /** An edge for our `Session`. May be used by Relay 1. */
  sessionEdge: Maybe<SessionsEdge>;
  /** Reads a single `User` that is related to this `Session`. */
  userBySsUser: Maybe<User>;
};


/** The output of our create `Session` mutation. */
export type CreateSessionPayloadSessionEdgeArgs = {
  orderBy?: InputMaybe<Array<SessionsOrderBy>>;
};

/** All input for the create `Skupiny` mutation. */
export type CreateSkupinyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Skupiny` to be created by this mutation. */
  skupiny: SkupinyInput;
};

/** The output of our create `Skupiny` mutation. */
export type CreateSkupinyPayload = {
  __typename?: 'CreateSkupinyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Skupiny` that was created by this mutation. */
  skupiny: Maybe<Skupiny>;
  /** An edge for our `Skupiny`. May be used by Relay 1. */
  skupinyEdge: Maybe<SkupiniesEdge>;
};


/** The output of our create `Skupiny` mutation. */
export type CreateSkupinyPayloadSkupinyEdgeArgs = {
  orderBy?: InputMaybe<Array<SkupiniesOrderBy>>;
};

/** All input for the create `Upozorneni` mutation. */
export type CreateUpozorneniInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Upozorneni` to be created by this mutation. */
  upozorneni: UpozorneniInput;
};

/** The output of our create `Upozorneni` mutation. */
export type CreateUpozorneniPayload = {
  __typename?: 'CreateUpozorneniPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Upozorneni` that was created by this mutation. */
  upozorneni: Maybe<Upozorneni>;
  /** An edge for our `Upozorneni`. May be used by Relay 1. */
  upozorneniEdge: Maybe<UpozornenisEdge>;
  /** Reads a single `User` that is related to this `Upozorneni`. */
  userByUpKdo: Maybe<User>;
};


/** The output of our create `Upozorneni` mutation. */
export type CreateUpozorneniPayloadUpozorneniEdgeArgs = {
  orderBy?: InputMaybe<Array<UpozornenisOrderBy>>;
};

/** All input for the create `UpozorneniSkupiny` mutation. */
export type CreateUpozorneniSkupinyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `UpozorneniSkupiny` to be created by this mutation. */
  upozorneniSkupiny: UpozorneniSkupinyInput;
};

/** The output of our create `UpozorneniSkupiny` mutation. */
export type CreateUpozorneniSkupinyPayload = {
  __typename?: 'CreateUpozorneniSkupinyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
  skupinyByUpsIdSkupina: Maybe<Skupiny>;
  /** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
  upozorneniByUpsIdRodic: Maybe<Upozorneni>;
  /** The `UpozorneniSkupiny` that was created by this mutation. */
  upozorneniSkupiny: Maybe<UpozorneniSkupiny>;
  /** An edge for our `UpozorneniSkupiny`. May be used by Relay 1. */
  upozorneniSkupinyEdge: Maybe<UpozorneniSkupiniesEdge>;
};


/** The output of our create `UpozorneniSkupiny` mutation. */
export type CreateUpozorneniSkupinyPayloadUpozorneniSkupinyEdgeArgs = {
  orderBy?: InputMaybe<Array<UpozorneniSkupiniesOrderBy>>;
};

/** All input for the create `User` mutation. */
export type CreateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `User` to be created by this mutation. */
  user: UserInput;
};

/** The output of our create `User` mutation. */
export type CreateUserPayload = {
  __typename?: 'CreateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Permission` that is related to this `User`. */
  permissionByUGroup: Maybe<Permission>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `User`. */
  skupinyByUSkupina: Maybe<Skupiny>;
  /** The `User` that was created by this mutation. */
  user: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge: Maybe<UsersEdge>;
};


/** The output of our create `User` mutation. */
export type CreateUserPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the create `Video` mutation. */
export type CreateVideoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Video` to be created by this mutation. */
  video: VideoInput;
};

/** All input for the create `VideoList` mutation. */
export type CreateVideoListInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `VideoList` to be created by this mutation. */
  videoList: VideoListInput;
};

/** The output of our create `VideoList` mutation. */
export type CreateVideoListPayload = {
  __typename?: 'CreateVideoListPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `VideoList` that was created by this mutation. */
  videoList: Maybe<VideoList>;
  /** An edge for our `VideoList`. May be used by Relay 1. */
  videoListEdge: Maybe<VideoListsEdge>;
};


/** The output of our create `VideoList` mutation. */
export type CreateVideoListPayloadVideoListEdgeArgs = {
  orderBy?: InputMaybe<Array<VideoListsOrderBy>>;
};

/** The output of our create `Video` mutation. */
export type CreateVideoPayload = {
  __typename?: 'CreateVideoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Video` that was created by this mutation. */
  video: Maybe<Video>;
  /** An edge for our `Video`. May be used by Relay 1. */
  videoEdge: Maybe<VideosEdge>;
};


/** The output of our create `Video` mutation. */
export type CreateVideoPayloadVideoEdgeArgs = {
  orderBy?: InputMaybe<Array<VideosOrderBy>>;
};

/** All input for the create `VideoSource` mutation. */
export type CreateVideoSourceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `VideoSource` to be created by this mutation. */
  videoSource: VideoSourceInput;
};

/** The output of our create `VideoSource` mutation. */
export type CreateVideoSourcePayload = {
  __typename?: 'CreateVideoSourcePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `VideoSource` that was created by this mutation. */
  videoSource: Maybe<VideoSource>;
  /** An edge for our `VideoSource`. May be used by Relay 1. */
  videoSourceEdge: Maybe<VideoSourcesEdge>;
};


/** The output of our create `VideoSource` mutation. */
export type CreateVideoSourcePayloadVideoSourceEdgeArgs = {
  orderBy?: InputMaybe<Array<VideoSourcesOrderBy>>;
};

export enum CrmCohort {
  ContactMeLater = 'CONTACT_ME_LATER',
  Dancer = 'DANCER',
  FreeLesson = 'FREE_LESSON',
  Hobbyist = 'HOBBYIST',
  Showdance = 'SHOWDANCE'
}

/** A `BigInt` edge in the connection. */
export type CurrentCoupleIdEdge = {
  __typename?: 'CurrentCoupleIdEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `BigInt` at the end of the edge. */
  node: Maybe<Scalars['BigInt']>;
};

/** A connection to a list of `BigInt` values. */
export type CurrentCoupleIdsConnection = {
  __typename?: 'CurrentCoupleIdsConnection';
  /** A list of edges which contains the `BigInt` and cursor to aid in pagination. */
  edges: Array<CurrentCoupleIdEdge>;
  /** A list of `BigInt` objects. */
  nodes: Array<Maybe<Scalars['BigInt']>>;
  /** The count of *all* `BigInt` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** All input for the `deleteAkceByNodeId` mutation. */
export type DeleteAkceByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Akce` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteAkce` mutation. */
export type DeleteAkceInput = {
  aId: Scalars['BigInt'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** All input for the `deleteAkceItemByNodeId` mutation. */
export type DeleteAkceItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `AkceItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteAkceItem` mutation. */
export type DeleteAkceItemInput = {
  aiId: Scalars['BigInt'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** The output of our delete `AkceItem` mutation. */
export type DeleteAkceItemPayload = {
  __typename?: 'DeleteAkceItemPayload';
  /** Reads a single `Akce` that is related to this `AkceItem`. */
  akceByAiIdRodic: Maybe<Akce>;
  /** The `AkceItem` that was deleted by this mutation. */
  akceItem: Maybe<AkceItem>;
  /** An edge for our `AkceItem`. May be used by Relay 1. */
  akceItemEdge: Maybe<AkceItemsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedAkceItemNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `AkceItem`. */
  userByAiUser: Maybe<User>;
};


/** The output of our delete `AkceItem` mutation. */
export type DeleteAkceItemPayloadAkceItemEdgeArgs = {
  orderBy?: InputMaybe<Array<AkceItemsOrderBy>>;
};

/** The output of our delete `Akce` mutation. */
export type DeleteAkcePayload = {
  __typename?: 'DeleteAkcePayload';
  /** The `Akce` that was deleted by this mutation. */
  akce: Maybe<Akce>;
  /** An edge for our `Akce`. May be used by Relay 1. */
  akceEdge: Maybe<AkcesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedAkceNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Akce` mutation. */
export type DeleteAkcePayloadAkceEdgeArgs = {
  orderBy?: InputMaybe<Array<AkcesOrderBy>>;
};

/** All input for the `deleteAktualityByNodeId` mutation. */
export type DeleteAktualityByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Aktuality` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteAktuality` mutation. */
export type DeleteAktualityInput = {
  atId: Scalars['BigInt'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** The output of our delete `Aktuality` mutation. */
export type DeleteAktualityPayload = {
  __typename?: 'DeleteAktualityPayload';
  /** The `Aktuality` that was deleted by this mutation. */
  aktuality: Maybe<Aktuality>;
  /** An edge for our `Aktuality`. May be used by Relay 1. */
  aktualityEdge: Maybe<AktualitiesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedAktualityNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
  galerieFotoByAtFotoMain: Maybe<GalerieFoto>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Aktuality`. */
  userByAtKdo: Maybe<User>;
};


/** The output of our delete `Aktuality` mutation. */
export type DeleteAktualityPayloadAktualityEdgeArgs = {
  orderBy?: InputMaybe<Array<AktualitiesOrderBy>>;
};

/** All input for the `deleteDokumentyByNodeId` mutation. */
export type DeleteDokumentyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Dokumenty` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteDokumenty` mutation. */
export type DeleteDokumentyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  dId: Scalars['BigInt'];
};

/** The output of our delete `Dokumenty` mutation. */
export type DeleteDokumentyPayload = {
  __typename?: 'DeleteDokumentyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedDokumentyNodeId: Maybe<Scalars['ID']>;
  /** The `Dokumenty` that was deleted by this mutation. */
  dokumenty: Maybe<Dokumenty>;
  /** An edge for our `Dokumenty`. May be used by Relay 1. */
  dokumentyEdge: Maybe<DokumentiesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Dokumenty`. */
  userByDKdo: Maybe<User>;
};


/** The output of our delete `Dokumenty` mutation. */
export type DeleteDokumentyPayloadDokumentyEdgeArgs = {
  orderBy?: InputMaybe<Array<DokumentiesOrderBy>>;
};

/** All input for the `deleteGalerieDirByNodeId` mutation. */
export type DeleteGalerieDirByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GalerieDir` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteGalerieDir` mutation. */
export type DeleteGalerieDirInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  gdId: Scalars['BigInt'];
};

/** The output of our delete `GalerieDir` mutation. */
export type DeleteGalerieDirPayload = {
  __typename?: 'DeleteGalerieDirPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedGalerieDirNodeId: Maybe<Scalars['ID']>;
  /** The `GalerieDir` that was deleted by this mutation. */
  galerieDir: Maybe<GalerieDir>;
  /** An edge for our `GalerieDir`. May be used by Relay 1. */
  galerieDirEdge: Maybe<GalerieDirsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `GalerieDir` mutation. */
export type DeleteGalerieDirPayloadGalerieDirEdgeArgs = {
  orderBy?: InputMaybe<Array<GalerieDirsOrderBy>>;
};

/** All input for the `deleteGalerieFotoByNodeId` mutation. */
export type DeleteGalerieFotoByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GalerieFoto` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteGalerieFoto` mutation. */
export type DeleteGalerieFotoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  gfId: Scalars['BigInt'];
};

/** The output of our delete `GalerieFoto` mutation. */
export type DeleteGalerieFotoPayload = {
  __typename?: 'DeleteGalerieFotoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedGalerieFotoNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
  galerieDirByGfIdRodic: Maybe<GalerieDir>;
  /** The `GalerieFoto` that was deleted by this mutation. */
  galerieFoto: Maybe<GalerieFoto>;
  /** An edge for our `GalerieFoto`. May be used by Relay 1. */
  galerieFotoEdge: Maybe<GalerieFotosEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `GalerieFoto`. */
  userByGfKdo: Maybe<User>;
};


/** The output of our delete `GalerieFoto` mutation. */
export type DeleteGalerieFotoPayloadGalerieFotoEdgeArgs = {
  orderBy?: InputMaybe<Array<GalerieFotosOrderBy>>;
};

/** All input for the `deleteNabidkaByNodeId` mutation. */
export type DeleteNabidkaByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Nabidka` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteNabidka` mutation. */
export type DeleteNabidkaInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  nId: Scalars['BigInt'];
};

/** All input for the `deleteNabidkaItemByNodeId` mutation. */
export type DeleteNabidkaItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `NabidkaItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteNabidkaItem` mutation. */
export type DeleteNabidkaItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  niId: Scalars['BigInt'];
};

/** The output of our delete `NabidkaItem` mutation. */
export type DeleteNabidkaItemPayload = {
  __typename?: 'DeleteNabidkaItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedNabidkaItemNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `Nabidka` that is related to this `NabidkaItem`. */
  nabidkaByNiIdRodic: Maybe<Nabidka>;
  /** The `NabidkaItem` that was deleted by this mutation. */
  nabidkaItem: Maybe<NabidkaItem>;
  /** An edge for our `NabidkaItem`. May be used by Relay 1. */
  nabidkaItemEdge: Maybe<NabidkaItemsEdge>;
  /** Reads a single `Pary` that is related to this `NabidkaItem`. */
  paryByNiPartner: Maybe<Pary>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `NabidkaItem` mutation. */
export type DeleteNabidkaItemPayloadNabidkaItemEdgeArgs = {
  orderBy?: InputMaybe<Array<NabidkaItemsOrderBy>>;
};

/** The output of our delete `Nabidka` mutation. */
export type DeleteNabidkaPayload = {
  __typename?: 'DeleteNabidkaPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedNabidkaNodeId: Maybe<Scalars['ID']>;
  /** The `Nabidka` that was deleted by this mutation. */
  nabidka: Maybe<Nabidka>;
  /** An edge for our `Nabidka`. May be used by Relay 1. */
  nabidkaEdge: Maybe<NabidkasEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Nabidka`. */
  userByNTrener: Maybe<User>;
};


/** The output of our delete `Nabidka` mutation. */
export type DeleteNabidkaPayloadNabidkaEdgeArgs = {
  orderBy?: InputMaybe<Array<NabidkasOrderBy>>;
};

/** All input for the `deleteParameterByNodeId` mutation. */
export type DeleteParameterByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Parameter` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteParameter` mutation. */
export type DeleteParameterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  paName: Scalars['String'];
};

/** The output of our delete `Parameter` mutation. */
export type DeleteParameterPayload = {
  __typename?: 'DeleteParameterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedParameterNodeId: Maybe<Scalars['ID']>;
  /** The `Parameter` that was deleted by this mutation. */
  parameter: Maybe<Parameter>;
  /** An edge for our `Parameter`. May be used by Relay 1. */
  parameterEdge: Maybe<ParametersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Parameter` mutation. */
export type DeleteParameterPayloadParameterEdgeArgs = {
  orderBy?: InputMaybe<Array<ParametersOrderBy>>;
};

/** All input for the `deleteParyByNodeId` mutation. */
export type DeleteParyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Pary` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePary` mutation. */
export type DeleteParyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  pId: Scalars['BigInt'];
};

/** All input for the `deleteParyNavrhByNodeId` mutation. */
export type DeleteParyNavrhByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ParyNavrh` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteParyNavrh` mutation. */
export type DeleteParyNavrhInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  pnId: Scalars['BigInt'];
};

/** The output of our delete `ParyNavrh` mutation. */
export type DeleteParyNavrhPayload = {
  __typename?: 'DeleteParyNavrhPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedParyNavrhNodeId: Maybe<Scalars['ID']>;
  /** The `ParyNavrh` that was deleted by this mutation. */
  paryNavrh: Maybe<ParyNavrh>;
  /** An edge for our `ParyNavrh`. May be used by Relay 1. */
  paryNavrhEdge: Maybe<ParyNavrhsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnNavrhl: Maybe<User>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnPartnerka: Maybe<User>;
};


/** The output of our delete `ParyNavrh` mutation. */
export type DeleteParyNavrhPayloadParyNavrhEdgeArgs = {
  orderBy?: InputMaybe<Array<ParyNavrhsOrderBy>>;
};

/** The output of our delete `Pary` mutation. */
export type DeleteParyPayload = {
  __typename?: 'DeleteParyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedParyNodeId: Maybe<Scalars['ID']>;
  /** The `Pary` that was deleted by this mutation. */
  pary: Maybe<Pary>;
  /** An edge for our `Pary`. May be used by Relay 1. */
  paryEdge: Maybe<PariesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartnerka: Maybe<User>;
};


/** The output of our delete `Pary` mutation. */
export type DeleteParyPayloadParyEdgeArgs = {
  orderBy?: InputMaybe<Array<PariesOrderBy>>;
};

/** All input for the `deletePermissionByNodeId` mutation. */
export type DeletePermissionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Permission` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePermission` mutation. */
export type DeletePermissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  peId: Scalars['BigInt'];
};

/** The output of our delete `Permission` mutation. */
export type DeletePermissionPayload = {
  __typename?: 'DeletePermissionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedPermissionNodeId: Maybe<Scalars['ID']>;
  /** The `Permission` that was deleted by this mutation. */
  permission: Maybe<Permission>;
  /** An edge for our `Permission`. May be used by Relay 1. */
  permissionEdge: Maybe<PermissionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Permission` mutation. */
export type DeletePermissionPayloadPermissionEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
};

/** All input for the `deletePlatbyCategoryByNodeId` mutation. */
export type DeletePlatbyCategoryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyCategory` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePlatbyCategoryGroupByNodeId` mutation. */
export type DeletePlatbyCategoryGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyCategoryGroup` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePlatbyCategoryGroup` mutation. */
export type DeletePlatbyCategoryGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  pcgId: Scalars['BigInt'];
};

/** The output of our delete `PlatbyCategoryGroup` mutation. */
export type DeletePlatbyCategoryGroupPayload = {
  __typename?: 'DeletePlatbyCategoryGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedPlatbyCategoryGroupNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyCategoryGroup`. */
  platbyCategoryByPcgIdCategory: Maybe<PlatbyCategory>;
  /** The `PlatbyCategoryGroup` that was deleted by this mutation. */
  platbyCategoryGroup: Maybe<PlatbyCategoryGroup>;
  /** An edge for our `PlatbyCategoryGroup`. May be used by Relay 1. */
  platbyCategoryGroupEdge: Maybe<PlatbyCategoryGroupsEdge>;
  /** Reads a single `PlatbyGroup` that is related to this `PlatbyCategoryGroup`. */
  platbyGroupByPcgIdGroup: Maybe<PlatbyGroup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `PlatbyCategoryGroup` mutation. */
export type DeletePlatbyCategoryGroupPayloadPlatbyCategoryGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyCategoryGroupsOrderBy>>;
};

/** All input for the `deletePlatbyCategory` mutation. */
export type DeletePlatbyCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  pcId: Scalars['BigInt'];
};

/** The output of our delete `PlatbyCategory` mutation. */
export type DeletePlatbyCategoryPayload = {
  __typename?: 'DeletePlatbyCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedPlatbyCategoryNodeId: Maybe<Scalars['ID']>;
  /** The `PlatbyCategory` that was deleted by this mutation. */
  platbyCategory: Maybe<PlatbyCategory>;
  /** An edge for our `PlatbyCategory`. May be used by Relay 1. */
  platbyCategoryEdge: Maybe<PlatbyCategoriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `PlatbyCategory` mutation. */
export type DeletePlatbyCategoryPayloadPlatbyCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyCategoriesOrderBy>>;
};

/** All input for the `deletePlatbyGroupByNodeId` mutation. */
export type DeletePlatbyGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyGroup` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePlatbyGroup` mutation. */
export type DeletePlatbyGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  pgId: Scalars['BigInt'];
};

/** The output of our delete `PlatbyGroup` mutation. */
export type DeletePlatbyGroupPayload = {
  __typename?: 'DeletePlatbyGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedPlatbyGroupNodeId: Maybe<Scalars['ID']>;
  /** The `PlatbyGroup` that was deleted by this mutation. */
  platbyGroup: Maybe<PlatbyGroup>;
  /** An edge for our `PlatbyGroup`. May be used by Relay 1. */
  platbyGroupEdge: Maybe<PlatbyGroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `PlatbyGroup` mutation. */
export type DeletePlatbyGroupPayloadPlatbyGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyGroupsOrderBy>>;
};

/** All input for the `deletePlatbyGroupSkupinaByNodeId` mutation. */
export type DeletePlatbyGroupSkupinaByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyGroupSkupina` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePlatbyGroupSkupina` mutation. */
export type DeletePlatbyGroupSkupinaInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  pgsId: Scalars['BigInt'];
};

/** The output of our delete `PlatbyGroupSkupina` mutation. */
export type DeletePlatbyGroupSkupinaPayload = {
  __typename?: 'DeletePlatbyGroupSkupinaPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedPlatbyGroupSkupinaNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `PlatbyGroup` that is related to this `PlatbyGroupSkupina`. */
  platbyGroupByPgsIdGroup: Maybe<PlatbyGroup>;
  /** The `PlatbyGroupSkupina` that was deleted by this mutation. */
  platbyGroupSkupina: Maybe<PlatbyGroupSkupina>;
  /** An edge for our `PlatbyGroupSkupina`. May be used by Relay 1. */
  platbyGroupSkupinaEdge: Maybe<PlatbyGroupSkupinasEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `PlatbyGroupSkupina`. */
  skupinyByPgsIdSkupina: Maybe<Skupiny>;
};


/** The output of our delete `PlatbyGroupSkupina` mutation. */
export type DeletePlatbyGroupSkupinaPayloadPlatbyGroupSkupinaEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyGroupSkupinasOrderBy>>;
};

/** All input for the `deletePlatbyItemByNodeId` mutation. */
export type DeletePlatbyItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePlatbyItem` mutation. */
export type DeletePlatbyItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  piId: Scalars['BigInt'];
};

/** The output of our delete `PlatbyItem` mutation. */
export type DeletePlatbyItemPayload = {
  __typename?: 'DeletePlatbyItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedPlatbyItemNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
  platbyCategoryByPiIdCategory: Maybe<PlatbyCategory>;
  /** The `PlatbyItem` that was deleted by this mutation. */
  platbyItem: Maybe<PlatbyItem>;
  /** An edge for our `PlatbyItem`. May be used by Relay 1. */
  platbyItemEdge: Maybe<PlatbyItemsEdge>;
  /** Reads a single `PlatbyRaw` that is related to this `PlatbyItem`. */
  platbyRawByPiIdRaw: Maybe<PlatbyRaw>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `PlatbyItem`. */
  userByPiIdUser: Maybe<User>;
};


/** The output of our delete `PlatbyItem` mutation. */
export type DeletePlatbyItemPayloadPlatbyItemEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyItemsOrderBy>>;
};

/** All input for the `deletePlatbyRawByNodeId` mutation. */
export type DeletePlatbyRawByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyRaw` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePlatbyRaw` mutation. */
export type DeletePlatbyRawInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  prId: Scalars['BigInt'];
};

/** The output of our delete `PlatbyRaw` mutation. */
export type DeletePlatbyRawPayload = {
  __typename?: 'DeletePlatbyRawPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedPlatbyRawNodeId: Maybe<Scalars['ID']>;
  /** The `PlatbyRaw` that was deleted by this mutation. */
  platbyRaw: Maybe<PlatbyRaw>;
  /** An edge for our `PlatbyRaw`. May be used by Relay 1. */
  platbyRawEdge: Maybe<PlatbyRawsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `PlatbyRaw` mutation. */
export type DeletePlatbyRawPayloadPlatbyRawEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyRawsOrderBy>>;
};

/** All input for the `deleteRozpiByNodeId` mutation. */
export type DeleteRozpiByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Rozpi` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteRozpi` mutation. */
export type DeleteRozpiInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  rId: Scalars['BigInt'];
};

/** The output of our delete `Rozpi` mutation. */
export type DeleteRozpiPayload = {
  __typename?: 'DeleteRozpiPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedRozpiNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Rozpi` that was deleted by this mutation. */
  rozpi: Maybe<Rozpi>;
  /** An edge for our `Rozpi`. May be used by Relay 1. */
  rozpiEdge: Maybe<RozpisEdge>;
  /** Reads a single `User` that is related to this `Rozpi`. */
  userByRTrener: Maybe<User>;
};


/** The output of our delete `Rozpi` mutation. */
export type DeleteRozpiPayloadRozpiEdgeArgs = {
  orderBy?: InputMaybe<Array<RozpisOrderBy>>;
};

/** All input for the `deleteRozpisItemByNodeId` mutation. */
export type DeleteRozpisItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `RozpisItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteRozpisItem` mutation. */
export type DeleteRozpisItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  riId: Scalars['BigInt'];
};

/** The output of our delete `RozpisItem` mutation. */
export type DeleteRozpisItemPayload = {
  __typename?: 'DeleteRozpisItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedRozpisItemNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `Pary` that is related to this `RozpisItem`. */
  paryByRiPartner: Maybe<Pary>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Rozpi` that is related to this `RozpisItem`. */
  rozpiByRiIdRodic: Maybe<Rozpi>;
  /** The `RozpisItem` that was deleted by this mutation. */
  rozpisItem: Maybe<RozpisItem>;
  /** An edge for our `RozpisItem`. May be used by Relay 1. */
  rozpisItemEdge: Maybe<RozpisItemsEdge>;
};


/** The output of our delete `RozpisItem` mutation. */
export type DeleteRozpisItemPayloadRozpisItemEdgeArgs = {
  orderBy?: InputMaybe<Array<RozpisItemsOrderBy>>;
};

/** All input for the `deleteSessionByNodeId` mutation. */
export type DeleteSessionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Session` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteSession` mutation. */
export type DeleteSessionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  ssId: Scalars['String'];
};

/** The output of our delete `Session` mutation. */
export type DeleteSessionPayload = {
  __typename?: 'DeleteSessionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedSessionNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Session` that was deleted by this mutation. */
  session: Maybe<Session>;
  /** An edge for our `Session`. May be used by Relay 1. */
  sessionEdge: Maybe<SessionsEdge>;
  /** Reads a single `User` that is related to this `Session`. */
  userBySsUser: Maybe<User>;
};


/** The output of our delete `Session` mutation. */
export type DeleteSessionPayloadSessionEdgeArgs = {
  orderBy?: InputMaybe<Array<SessionsOrderBy>>;
};

/** All input for the `deleteSkupinyByNodeId` mutation. */
export type DeleteSkupinyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Skupiny` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteSkupiny` mutation. */
export type DeleteSkupinyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  sId: Scalars['BigInt'];
};

/** The output of our delete `Skupiny` mutation. */
export type DeleteSkupinyPayload = {
  __typename?: 'DeleteSkupinyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedSkupinyNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Skupiny` that was deleted by this mutation. */
  skupiny: Maybe<Skupiny>;
  /** An edge for our `Skupiny`. May be used by Relay 1. */
  skupinyEdge: Maybe<SkupiniesEdge>;
};


/** The output of our delete `Skupiny` mutation. */
export type DeleteSkupinyPayloadSkupinyEdgeArgs = {
  orderBy?: InputMaybe<Array<SkupiniesOrderBy>>;
};

/** All input for the `deleteUpozorneniByNodeId` mutation. */
export type DeleteUpozorneniByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Upozorneni` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteUpozorneni` mutation. */
export type DeleteUpozorneniInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  upId: Scalars['BigInt'];
};

/** The output of our delete `Upozorneni` mutation. */
export type DeleteUpozorneniPayload = {
  __typename?: 'DeleteUpozorneniPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedUpozorneniNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Upozorneni` that was deleted by this mutation. */
  upozorneni: Maybe<Upozorneni>;
  /** An edge for our `Upozorneni`. May be used by Relay 1. */
  upozorneniEdge: Maybe<UpozornenisEdge>;
  /** Reads a single `User` that is related to this `Upozorneni`. */
  userByUpKdo: Maybe<User>;
};


/** The output of our delete `Upozorneni` mutation. */
export type DeleteUpozorneniPayloadUpozorneniEdgeArgs = {
  orderBy?: InputMaybe<Array<UpozornenisOrderBy>>;
};

/** All input for the `deleteUpozorneniSkupinyByNodeId` mutation. */
export type DeleteUpozorneniSkupinyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `UpozorneniSkupiny` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteUpozorneniSkupiny` mutation. */
export type DeleteUpozorneniSkupinyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  upsId: Scalars['BigInt'];
};

/** The output of our delete `UpozorneniSkupiny` mutation. */
export type DeleteUpozorneniSkupinyPayload = {
  __typename?: 'DeleteUpozorneniSkupinyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedUpozorneniSkupinyNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
  skupinyByUpsIdSkupina: Maybe<Skupiny>;
  /** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
  upozorneniByUpsIdRodic: Maybe<Upozorneni>;
  /** The `UpozorneniSkupiny` that was deleted by this mutation. */
  upozorneniSkupiny: Maybe<UpozorneniSkupiny>;
  /** An edge for our `UpozorneniSkupiny`. May be used by Relay 1. */
  upozorneniSkupinyEdge: Maybe<UpozorneniSkupiniesEdge>;
};


/** The output of our delete `UpozorneniSkupiny` mutation. */
export type DeleteUpozorneniSkupinyPayloadUpozorneniSkupinyEdgeArgs = {
  orderBy?: InputMaybe<Array<UpozorneniSkupiniesOrderBy>>;
};

/** All input for the `deleteUserByNodeId` mutation. */
export type DeleteUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `User` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteUser` mutation. */
export type DeleteUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  uId: Scalars['BigInt'];
};

/** The output of our delete `User` mutation. */
export type DeleteUserPayload = {
  __typename?: 'DeleteUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedUserNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `Permission` that is related to this `User`. */
  permissionByUGroup: Maybe<Permission>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `User`. */
  skupinyByUSkupina: Maybe<Skupiny>;
  /** The `User` that was deleted by this mutation. */
  user: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge: Maybe<UsersEdge>;
};


/** The output of our delete `User` mutation. */
export type DeleteUserPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the `deleteVideoByNodeId` mutation. */
export type DeleteVideoByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Video` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteVideo` mutation. */
export type DeleteVideoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  vId: Scalars['BigInt'];
};

/** All input for the `deleteVideoListByNodeId` mutation. */
export type DeleteVideoListByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `VideoList` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteVideoList` mutation. */
export type DeleteVideoListInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  vlId: Scalars['BigInt'];
};

/** The output of our delete `VideoList` mutation. */
export type DeleteVideoListPayload = {
  __typename?: 'DeleteVideoListPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedVideoListNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `VideoList` that was deleted by this mutation. */
  videoList: Maybe<VideoList>;
  /** An edge for our `VideoList`. May be used by Relay 1. */
  videoListEdge: Maybe<VideoListsEdge>;
};


/** The output of our delete `VideoList` mutation. */
export type DeleteVideoListPayloadVideoListEdgeArgs = {
  orderBy?: InputMaybe<Array<VideoListsOrderBy>>;
};

/** The output of our delete `Video` mutation. */
export type DeleteVideoPayload = {
  __typename?: 'DeleteVideoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedVideoNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Video` that was deleted by this mutation. */
  video: Maybe<Video>;
  /** An edge for our `Video`. May be used by Relay 1. */
  videoEdge: Maybe<VideosEdge>;
};


/** The output of our delete `Video` mutation. */
export type DeleteVideoPayloadVideoEdgeArgs = {
  orderBy?: InputMaybe<Array<VideosOrderBy>>;
};

/** All input for the `deleteVideoSourceByNodeId` mutation. */
export type DeleteVideoSourceByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `VideoSource` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteVideoSource` mutation. */
export type DeleteVideoSourceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  vsId: Scalars['BigInt'];
};

/** The output of our delete `VideoSource` mutation. */
export type DeleteVideoSourcePayload = {
  __typename?: 'DeleteVideoSourcePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedVideoSourceNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `VideoSource` that was deleted by this mutation. */
  videoSource: Maybe<VideoSource>;
  /** An edge for our `VideoSource`. May be used by Relay 1. */
  videoSourceEdge: Maybe<VideoSourcesEdge>;
};


/** The output of our delete `VideoSource` mutation. */
export type DeleteVideoSourcePayloadVideoSourceEdgeArgs = {
  orderBy?: InputMaybe<Array<VideoSourcesOrderBy>>;
};

/** A connection to a list of `Dokumenty` values. */
export type DokumentiesConnection = {
  __typename?: 'DokumentiesConnection';
  /** A list of edges which contains the `Dokumenty` and cursor to aid in pagination. */
  edges: Array<DokumentiesEdge>;
  /** A list of `Dokumenty` objects. */
  nodes: Array<Dokumenty>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Dokumenty` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Dokumenty` edge in the connection. */
export type DokumentiesEdge = {
  __typename?: 'DokumentiesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Dokumenty` at the end of the edge. */
  node: Dokumenty;
};

/** Methods to use when ordering `Dokumenty`. */
export enum DokumentiesOrderBy {
  DFilenameAsc = 'D_FILENAME_ASC',
  DFilenameDesc = 'D_FILENAME_DESC',
  DIdAsc = 'D_ID_ASC',
  DIdDesc = 'D_ID_DESC',
  DKategorieAsc = 'D_KATEGORIE_ASC',
  DKategorieDesc = 'D_KATEGORIE_DESC',
  DKdoAsc = 'D_KDO_ASC',
  DKdoDesc = 'D_KDO_DESC',
  DNameAsc = 'D_NAME_ASC',
  DNameDesc = 'D_NAME_DESC',
  DPathAsc = 'D_PATH_ASC',
  DPathDesc = 'D_PATH_DESC',
  DTimestampAsc = 'D_TIMESTAMP_ASC',
  DTimestampDesc = 'D_TIMESTAMP_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type Dokumenty = Node & {
  __typename?: 'Dokumenty';
  dFilename: Scalars['String'];
  dId: Scalars['BigInt'];
  dKategorie: Scalars['Int'];
  dKdo: Scalars['BigInt'];
  dName: Scalars['String'];
  dPath: Scalars['String'];
  dTimestamp: Maybe<Scalars['Datetime']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `User` that is related to this `Dokumenty`. */
  userByDKdo: Maybe<User>;
};

/**
 * A condition to be used against `Dokumenty` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type DokumentyCondition = {
  /** Checks for equality with the object’s `dFilename` field. */
  dFilename?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `dId` field. */
  dId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `dKategorie` field. */
  dKategorie?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `dKdo` field. */
  dKdo?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `dName` field. */
  dName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `dPath` field. */
  dPath?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `dTimestamp` field. */
  dTimestamp?: InputMaybe<Scalars['Datetime']>;
};

/** An input for mutations affecting `Dokumenty` */
export type DokumentyInput = {
  dFilename: Scalars['String'];
  dId?: InputMaybe<Scalars['BigInt']>;
  dKategorie: Scalars['Int'];
  dKdo: Scalars['BigInt'];
  dName: Scalars['String'];
  dPath: Scalars['String'];
  dTimestamp?: InputMaybe<Scalars['Datetime']>;
};

/** Represents an update to a `Dokumenty`. Fields that are set will be updated. */
export type DokumentyPatch = {
  dFilename?: InputMaybe<Scalars['String']>;
  dId?: InputMaybe<Scalars['BigInt']>;
  dKategorie?: InputMaybe<Scalars['Int']>;
  dKdo?: InputMaybe<Scalars['BigInt']>;
  dName?: InputMaybe<Scalars['String']>;
  dPath?: InputMaybe<Scalars['String']>;
  dTimestamp?: InputMaybe<Scalars['Datetime']>;
};

/** All input for the `fixUnpairedCouples` mutation. */
export type FixUnpairedCouplesInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** The output of our `fixUnpairedCouples` mutation. */
export type FixUnpairedCouplesPayload = {
  __typename?: 'FixUnpairedCouplesPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  paries: Maybe<Array<Pary>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type GalerieDir = Node & {
  __typename?: 'GalerieDir';
  /** Reads and enables pagination through a set of `GalerieFoto`. */
  galerieFotosByGfIdRodic: GalerieFotosConnection;
  gdHidden: Scalars['Boolean'];
  gdId: Scalars['BigInt'];
  gdIdRodic: Scalars['BigInt'];
  gdLevel: Scalars['Int'];
  gdName: Scalars['String'];
  gdPath: Scalars['String'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
};


export type GalerieDirGalerieFotosByGfIdRodicArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<GalerieFotoCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GalerieFotosOrderBy>>;
};

/**
 * A condition to be used against `GalerieDir` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type GalerieDirCondition = {
  /** Checks for equality with the object’s `gdHidden` field. */
  gdHidden?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `gdId` field. */
  gdId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `gdIdRodic` field. */
  gdIdRodic?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `gdLevel` field. */
  gdLevel?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gdName` field. */
  gdName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `gdPath` field. */
  gdPath?: InputMaybe<Scalars['String']>;
};

/** An input for mutations affecting `GalerieDir` */
export type GalerieDirInput = {
  gdHidden?: InputMaybe<Scalars['Boolean']>;
  gdId?: InputMaybe<Scalars['BigInt']>;
  gdIdRodic: Scalars['BigInt'];
  gdLevel?: InputMaybe<Scalars['Int']>;
  gdName: Scalars['String'];
  gdPath: Scalars['String'];
};

/** Represents an update to a `GalerieDir`. Fields that are set will be updated. */
export type GalerieDirPatch = {
  gdHidden?: InputMaybe<Scalars['Boolean']>;
  gdId?: InputMaybe<Scalars['BigInt']>;
  gdIdRodic?: InputMaybe<Scalars['BigInt']>;
  gdLevel?: InputMaybe<Scalars['Int']>;
  gdName?: InputMaybe<Scalars['String']>;
  gdPath?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `GalerieDir` values. */
export type GalerieDirsConnection = {
  __typename?: 'GalerieDirsConnection';
  /** A list of edges which contains the `GalerieDir` and cursor to aid in pagination. */
  edges: Array<GalerieDirsEdge>;
  /** A list of `GalerieDir` objects. */
  nodes: Array<GalerieDir>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `GalerieDir` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `GalerieDir` edge in the connection. */
export type GalerieDirsEdge = {
  __typename?: 'GalerieDirsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `GalerieDir` at the end of the edge. */
  node: GalerieDir;
};

/** Methods to use when ordering `GalerieDir`. */
export enum GalerieDirsOrderBy {
  GdHiddenAsc = 'GD_HIDDEN_ASC',
  GdHiddenDesc = 'GD_HIDDEN_DESC',
  GdIdAsc = 'GD_ID_ASC',
  GdIdDesc = 'GD_ID_DESC',
  GdIdRodicAsc = 'GD_ID_RODIC_ASC',
  GdIdRodicDesc = 'GD_ID_RODIC_DESC',
  GdLevelAsc = 'GD_LEVEL_ASC',
  GdLevelDesc = 'GD_LEVEL_DESC',
  GdNameAsc = 'GD_NAME_ASC',
  GdNameDesc = 'GD_NAME_DESC',
  GdPathAsc = 'GD_PATH_ASC',
  GdPathDesc = 'GD_PATH_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type GalerieFoto = Node & {
  __typename?: 'GalerieFoto';
  /** Reads and enables pagination through a set of `Aktuality`. */
  aktualitiesByAtFotoMain: AktualitiesConnection;
  /** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
  galerieDirByGfIdRodic: Maybe<GalerieDir>;
  gfId: Scalars['BigInt'];
  gfIdRodic: Scalars['BigInt'];
  gfKdo: Scalars['BigInt'];
  gfName: Scalars['String'];
  gfPath: Scalars['String'];
  gfTimestamp: Maybe<Scalars['Datetime']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `User` that is related to this `GalerieFoto`. */
  userByGfKdo: Maybe<User>;
};


export type GalerieFotoAktualitiesByAtFotoMainArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AktualityCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AktualitiesOrderBy>>;
};

/**
 * A condition to be used against `GalerieFoto` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type GalerieFotoCondition = {
  /** Checks for equality with the object’s `gfId` field. */
  gfId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `gfIdRodic` field. */
  gfIdRodic?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `gfKdo` field. */
  gfKdo?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `gfName` field. */
  gfName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `gfPath` field. */
  gfPath?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `gfTimestamp` field. */
  gfTimestamp?: InputMaybe<Scalars['Datetime']>;
};

/** An input for mutations affecting `GalerieFoto` */
export type GalerieFotoInput = {
  gfId?: InputMaybe<Scalars['BigInt']>;
  gfIdRodic: Scalars['BigInt'];
  gfKdo: Scalars['BigInt'];
  gfName: Scalars['String'];
  gfPath: Scalars['String'];
  gfTimestamp?: InputMaybe<Scalars['Datetime']>;
};

/** Represents an update to a `GalerieFoto`. Fields that are set will be updated. */
export type GalerieFotoPatch = {
  gfId?: InputMaybe<Scalars['BigInt']>;
  gfIdRodic?: InputMaybe<Scalars['BigInt']>;
  gfKdo?: InputMaybe<Scalars['BigInt']>;
  gfName?: InputMaybe<Scalars['String']>;
  gfPath?: InputMaybe<Scalars['String']>;
  gfTimestamp?: InputMaybe<Scalars['Datetime']>;
};

/** A connection to a list of `GalerieFoto` values. */
export type GalerieFotosConnection = {
  __typename?: 'GalerieFotosConnection';
  /** A list of edges which contains the `GalerieFoto` and cursor to aid in pagination. */
  edges: Array<GalerieFotosEdge>;
  /** A list of `GalerieFoto` objects. */
  nodes: Array<GalerieFoto>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `GalerieFoto` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `GalerieFoto` edge in the connection. */
export type GalerieFotosEdge = {
  __typename?: 'GalerieFotosEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `GalerieFoto` at the end of the edge. */
  node: GalerieFoto;
};

/** Methods to use when ordering `GalerieFoto`. */
export enum GalerieFotosOrderBy {
  GfIdAsc = 'GF_ID_ASC',
  GfIdDesc = 'GF_ID_DESC',
  GfIdRodicAsc = 'GF_ID_RODIC_ASC',
  GfIdRodicDesc = 'GF_ID_RODIC_DESC',
  GfKdoAsc = 'GF_KDO_ASC',
  GfKdoDesc = 'GF_KDO_DESC',
  GfNameAsc = 'GF_NAME_ASC',
  GfNameDesc = 'GF_NAME_DESC',
  GfPathAsc = 'GF_PATH_ASC',
  GfPathDesc = 'GF_PATH_DESC',
  GfTimestampAsc = 'GF_TIMESTAMP_ASC',
  GfTimestampDesc = 'GF_TIMESTAMP_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** All input for the `login` mutation. */
export type LoginInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  login: Scalars['String'];
  passwd: Scalars['String'];
};

/** The output of our `login` mutation. */
export type LoginPayload = {
  __typename?: 'LoginPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  result: Maybe<LoginRecord>;
};

/** The return type of our `login` mutation. */
export type LoginRecord = {
  __typename?: 'LoginRecord';
  couple: Maybe<Pary>;
  sess: Maybe<Session>;
  usr: Maybe<User>;
};

/** All input for the `logout` mutation. */
export type LogoutInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** The output of our `logout` mutation. */
export type LogoutPayload = {
  __typename?: 'LogoutPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type Member = {
  __typename?: 'Member';
  paymentValid: Maybe<Scalars['Boolean']>;
  sColorRgb: Maybe<Scalars['String']>;
  sColorText: Maybe<Scalars['String']>;
  sDescription: Maybe<Scalars['String']>;
  sId: Maybe<Scalars['BigInt']>;
  sLocation: Maybe<Scalars['String']>;
  sName: Maybe<Scalars['String']>;
  sVisible: Maybe<Scalars['Boolean']>;
  uBan: Maybe<Scalars['Boolean']>;
  uCity: Maybe<Scalars['String']>;
  uConfirmed: Maybe<Scalars['Boolean']>;
  uConscriptionNumber: Maybe<Scalars['String']>;
  uCreatedAt: Maybe<Scalars['Datetime']>;
  uDancer: Maybe<Scalars['Boolean']>;
  uDistrict: Maybe<Scalars['String']>;
  uEmail: Maybe<Scalars['String']>;
  uGdprSignedAt: Maybe<Scalars['Datetime']>;
  uGroup: Maybe<Scalars['BigInt']>;
  uId: Maybe<Scalars['BigInt']>;
  uJmeno: Maybe<Scalars['String']>;
  uLevel: Maybe<Scalars['Int']>;
  uLock: Maybe<Scalars['Boolean']>;
  uLogin: Maybe<Scalars['String']>;
  uMemberSince: Maybe<Scalars['Datetime']>;
  uMemberUntil: Maybe<Scalars['Datetime']>;
  uNarozeni: Maybe<Scalars['Date']>;
  uNationality: Maybe<Scalars['String']>;
  uOrientationNumber: Maybe<Scalars['String']>;
  uPass: Maybe<Scalars['String']>;
  uPohlavi: Maybe<Scalars['String']>;
  uPostalCode: Maybe<Scalars['String']>;
  uPoznamky: Maybe<Scalars['String']>;
  uPrijmeni: Maybe<Scalars['String']>;
  uRodneCislo: Maybe<Scalars['String']>;
  uSkupina: Maybe<Scalars['BigInt']>;
  uStreet: Maybe<Scalars['String']>;
  uSystem: Maybe<Scalars['Boolean']>;
  uTeacher: Maybe<Scalars['Boolean']>;
  uTelefon: Maybe<Scalars['String']>;
  uTimestamp: Maybe<Scalars['Datetime']>;
};

/** A condition to be used against `Member` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type MemberCondition = {
  /** Checks for equality with the object’s `paymentValid` field. */
  paymentValid?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `sColorRgb` field. */
  sColorRgb?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sColorText` field. */
  sColorText?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sDescription` field. */
  sDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sId` field. */
  sId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `sLocation` field. */
  sLocation?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sName` field. */
  sName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sVisible` field. */
  sVisible?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uBan` field. */
  uBan?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uCity` field. */
  uCity?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uConfirmed` field. */
  uConfirmed?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uConscriptionNumber` field. */
  uConscriptionNumber?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uCreatedAt` field. */
  uCreatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `uDancer` field. */
  uDancer?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uDistrict` field. */
  uDistrict?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uEmail` field. */
  uEmail?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uGdprSignedAt` field. */
  uGdprSignedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `uGroup` field. */
  uGroup?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `uId` field. */
  uId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `uJmeno` field. */
  uJmeno?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uLevel` field. */
  uLevel?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uLock` field. */
  uLock?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uLogin` field. */
  uLogin?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uMemberSince` field. */
  uMemberSince?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `uMemberUntil` field. */
  uMemberUntil?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `uNarozeni` field. */
  uNarozeni?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `uNationality` field. */
  uNationality?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uOrientationNumber` field. */
  uOrientationNumber?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uPass` field. */
  uPass?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uPohlavi` field. */
  uPohlavi?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uPostalCode` field. */
  uPostalCode?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uPoznamky` field. */
  uPoznamky?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uPrijmeni` field. */
  uPrijmeni?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uRodneCislo` field. */
  uRodneCislo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uSkupina` field. */
  uSkupina?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `uStreet` field. */
  uStreet?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uSystem` field. */
  uSystem?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uTeacher` field. */
  uTeacher?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uTelefon` field. */
  uTelefon?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uTimestamp` field. */
  uTimestamp?: InputMaybe<Scalars['Datetime']>;
};

/** A connection to a list of `Member` values. */
export type MembersConnection = {
  __typename?: 'MembersConnection';
  /** A list of edges which contains the `Member` and cursor to aid in pagination. */
  edges: Array<MembersEdge>;
  /** A list of `Member` objects. */
  nodes: Array<Member>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Member` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Member` edge in the connection. */
export type MembersEdge = {
  __typename?: 'MembersEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Member` at the end of the edge. */
  node: Member;
};

/** Methods to use when ordering `Member`. */
export enum MembersOrderBy {
  Natural = 'NATURAL',
  PaymentValidAsc = 'PAYMENT_VALID_ASC',
  PaymentValidDesc = 'PAYMENT_VALID_DESC',
  SColorRgbAsc = 'S_COLOR_RGB_ASC',
  SColorRgbDesc = 'S_COLOR_RGB_DESC',
  SColorTextAsc = 'S_COLOR_TEXT_ASC',
  SColorTextDesc = 'S_COLOR_TEXT_DESC',
  SDescriptionAsc = 'S_DESCRIPTION_ASC',
  SDescriptionDesc = 'S_DESCRIPTION_DESC',
  SIdAsc = 'S_ID_ASC',
  SIdDesc = 'S_ID_DESC',
  SLocationAsc = 'S_LOCATION_ASC',
  SLocationDesc = 'S_LOCATION_DESC',
  SNameAsc = 'S_NAME_ASC',
  SNameDesc = 'S_NAME_DESC',
  SVisibleAsc = 'S_VISIBLE_ASC',
  SVisibleDesc = 'S_VISIBLE_DESC',
  UBanAsc = 'U_BAN_ASC',
  UBanDesc = 'U_BAN_DESC',
  UCityAsc = 'U_CITY_ASC',
  UCityDesc = 'U_CITY_DESC',
  UConfirmedAsc = 'U_CONFIRMED_ASC',
  UConfirmedDesc = 'U_CONFIRMED_DESC',
  UConscriptionNumberAsc = 'U_CONSCRIPTION_NUMBER_ASC',
  UConscriptionNumberDesc = 'U_CONSCRIPTION_NUMBER_DESC',
  UCreatedAtAsc = 'U_CREATED_AT_ASC',
  UCreatedAtDesc = 'U_CREATED_AT_DESC',
  UDancerAsc = 'U_DANCER_ASC',
  UDancerDesc = 'U_DANCER_DESC',
  UDistrictAsc = 'U_DISTRICT_ASC',
  UDistrictDesc = 'U_DISTRICT_DESC',
  UEmailAsc = 'U_EMAIL_ASC',
  UEmailDesc = 'U_EMAIL_DESC',
  UGdprSignedAtAsc = 'U_GDPR_SIGNED_AT_ASC',
  UGdprSignedAtDesc = 'U_GDPR_SIGNED_AT_DESC',
  UGroupAsc = 'U_GROUP_ASC',
  UGroupDesc = 'U_GROUP_DESC',
  UIdAsc = 'U_ID_ASC',
  UIdDesc = 'U_ID_DESC',
  UJmenoAsc = 'U_JMENO_ASC',
  UJmenoDesc = 'U_JMENO_DESC',
  ULevelAsc = 'U_LEVEL_ASC',
  ULevelDesc = 'U_LEVEL_DESC',
  ULockAsc = 'U_LOCK_ASC',
  ULockDesc = 'U_LOCK_DESC',
  ULoginAsc = 'U_LOGIN_ASC',
  ULoginDesc = 'U_LOGIN_DESC',
  UMemberSinceAsc = 'U_MEMBER_SINCE_ASC',
  UMemberSinceDesc = 'U_MEMBER_SINCE_DESC',
  UMemberUntilAsc = 'U_MEMBER_UNTIL_ASC',
  UMemberUntilDesc = 'U_MEMBER_UNTIL_DESC',
  UNarozeniAsc = 'U_NAROZENI_ASC',
  UNarozeniDesc = 'U_NAROZENI_DESC',
  UNationalityAsc = 'U_NATIONALITY_ASC',
  UNationalityDesc = 'U_NATIONALITY_DESC',
  UOrientationNumberAsc = 'U_ORIENTATION_NUMBER_ASC',
  UOrientationNumberDesc = 'U_ORIENTATION_NUMBER_DESC',
  UPassAsc = 'U_PASS_ASC',
  UPassDesc = 'U_PASS_DESC',
  UPohlaviAsc = 'U_POHLAVI_ASC',
  UPohlaviDesc = 'U_POHLAVI_DESC',
  UPostalCodeAsc = 'U_POSTAL_CODE_ASC',
  UPostalCodeDesc = 'U_POSTAL_CODE_DESC',
  UPoznamkyAsc = 'U_POZNAMKY_ASC',
  UPoznamkyDesc = 'U_POZNAMKY_DESC',
  UPrijmeniAsc = 'U_PRIJMENI_ASC',
  UPrijmeniDesc = 'U_PRIJMENI_DESC',
  URodneCisloAsc = 'U_RODNE_CISLO_ASC',
  URodneCisloDesc = 'U_RODNE_CISLO_DESC',
  USkupinaAsc = 'U_SKUPINA_ASC',
  USkupinaDesc = 'U_SKUPINA_DESC',
  UStreetAsc = 'U_STREET_ASC',
  UStreetDesc = 'U_STREET_DESC',
  USystemAsc = 'U_SYSTEM_ASC',
  USystemDesc = 'U_SYSTEM_DESC',
  UTeacherAsc = 'U_TEACHER_ASC',
  UTeacherDesc = 'U_TEACHER_DESC',
  UTelefonAsc = 'U_TELEFON_ASC',
  UTelefonDesc = 'U_TELEFON_DESC',
  UTimestampAsc = 'U_TIMESTAMP_ASC',
  UTimestampDesc = 'U_TIMESTAMP_DESC'
}

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  __typename?: 'Mutation';
  confirmUser: Maybe<ConfirmUserPayload>;
  /** Creates a single `Akce`. */
  createAkce: Maybe<CreateAkcePayload>;
  /** Creates a single `AkceItem`. */
  createAkceItem: Maybe<CreateAkceItemPayload>;
  /** Creates a single `Aktuality`. */
  createAktuality: Maybe<CreateAktualityPayload>;
  createCouple: Maybe<CreateCouplePayload>;
  /** Creates a single `Dokumenty`. */
  createDokumenty: Maybe<CreateDokumentyPayload>;
  /** Creates a single `GalerieDir`. */
  createGalerieDir: Maybe<CreateGalerieDirPayload>;
  /** Creates a single `GalerieFoto`. */
  createGalerieFoto: Maybe<CreateGalerieFotoPayload>;
  /** Creates a single `Nabidka`. */
  createNabidka: Maybe<CreateNabidkaPayload>;
  /** Creates a single `NabidkaItem`. */
  createNabidkaItem: Maybe<CreateNabidkaItemPayload>;
  /** Creates a single `Page`. */
  createPage: Maybe<CreatePagePayload>;
  /** Creates a single `Parameter`. */
  createParameter: Maybe<CreateParameterPayload>;
  /** Creates a single `Pary`. */
  createPary: Maybe<CreateParyPayload>;
  /** Creates a single `ParyNavrh`. */
  createParyNavrh: Maybe<CreateParyNavrhPayload>;
  /** Creates a single `Permission`. */
  createPermission: Maybe<CreatePermissionPayload>;
  /** Creates a single `PlatbyCategory`. */
  createPlatbyCategory: Maybe<CreatePlatbyCategoryPayload>;
  /** Creates a single `PlatbyCategoryGroup`. */
  createPlatbyCategoryGroup: Maybe<CreatePlatbyCategoryGroupPayload>;
  /** Creates a single `PlatbyGroup`. */
  createPlatbyGroup: Maybe<CreatePlatbyGroupPayload>;
  /** Creates a single `PlatbyGroupSkupina`. */
  createPlatbyGroupSkupina: Maybe<CreatePlatbyGroupSkupinaPayload>;
  /** Creates a single `PlatbyItem`. */
  createPlatbyItem: Maybe<CreatePlatbyItemPayload>;
  /** Creates a single `PlatbyRaw`. */
  createPlatbyRaw: Maybe<CreatePlatbyRawPayload>;
  /** Creates a single `Rozpi`. */
  createRozpi: Maybe<CreateRozpiPayload>;
  /** Creates a single `RozpisItem`. */
  createRozpisItem: Maybe<CreateRozpisItemPayload>;
  /** Creates a single `Session`. */
  createSession: Maybe<CreateSessionPayload>;
  /** Creates a single `Skupiny`. */
  createSkupiny: Maybe<CreateSkupinyPayload>;
  /** Creates a single `Upozorneni`. */
  createUpozorneni: Maybe<CreateUpozorneniPayload>;
  /** Creates a single `UpozorneniSkupiny`. */
  createUpozorneniSkupiny: Maybe<CreateUpozorneniSkupinyPayload>;
  /** Creates a single `User`. */
  createUser: Maybe<CreateUserPayload>;
  /** Creates a single `Video`. */
  createVideo: Maybe<CreateVideoPayload>;
  /** Creates a single `VideoList`. */
  createVideoList: Maybe<CreateVideoListPayload>;
  /** Creates a single `VideoSource`. */
  createVideoSource: Maybe<CreateVideoSourcePayload>;
  /** Deletes a single `Akce` using a unique key. */
  deleteAkce: Maybe<DeleteAkcePayload>;
  /** Deletes a single `Akce` using its globally unique id. */
  deleteAkceByNodeId: Maybe<DeleteAkcePayload>;
  /** Deletes a single `AkceItem` using a unique key. */
  deleteAkceItem: Maybe<DeleteAkceItemPayload>;
  /** Deletes a single `AkceItem` using its globally unique id. */
  deleteAkceItemByNodeId: Maybe<DeleteAkceItemPayload>;
  /** Deletes a single `Aktuality` using a unique key. */
  deleteAktuality: Maybe<DeleteAktualityPayload>;
  /** Deletes a single `Aktuality` using its globally unique id. */
  deleteAktualityByNodeId: Maybe<DeleteAktualityPayload>;
  /** Deletes a single `Dokumenty` using a unique key. */
  deleteDokumenty: Maybe<DeleteDokumentyPayload>;
  /** Deletes a single `Dokumenty` using its globally unique id. */
  deleteDokumentyByNodeId: Maybe<DeleteDokumentyPayload>;
  /** Deletes a single `GalerieDir` using a unique key. */
  deleteGalerieDir: Maybe<DeleteGalerieDirPayload>;
  /** Deletes a single `GalerieDir` using its globally unique id. */
  deleteGalerieDirByNodeId: Maybe<DeleteGalerieDirPayload>;
  /** Deletes a single `GalerieFoto` using a unique key. */
  deleteGalerieFoto: Maybe<DeleteGalerieFotoPayload>;
  /** Deletes a single `GalerieFoto` using its globally unique id. */
  deleteGalerieFotoByNodeId: Maybe<DeleteGalerieFotoPayload>;
  /** Deletes a single `Nabidka` using a unique key. */
  deleteNabidka: Maybe<DeleteNabidkaPayload>;
  /** Deletes a single `Nabidka` using its globally unique id. */
  deleteNabidkaByNodeId: Maybe<DeleteNabidkaPayload>;
  /** Deletes a single `NabidkaItem` using a unique key. */
  deleteNabidkaItem: Maybe<DeleteNabidkaItemPayload>;
  /** Deletes a single `NabidkaItem` using its globally unique id. */
  deleteNabidkaItemByNodeId: Maybe<DeleteNabidkaItemPayload>;
  /** Deletes a single `Parameter` using a unique key. */
  deleteParameter: Maybe<DeleteParameterPayload>;
  /** Deletes a single `Parameter` using its globally unique id. */
  deleteParameterByNodeId: Maybe<DeleteParameterPayload>;
  /** Deletes a single `Pary` using a unique key. */
  deletePary: Maybe<DeleteParyPayload>;
  /** Deletes a single `Pary` using its globally unique id. */
  deleteParyByNodeId: Maybe<DeleteParyPayload>;
  /** Deletes a single `ParyNavrh` using a unique key. */
  deleteParyNavrh: Maybe<DeleteParyNavrhPayload>;
  /** Deletes a single `ParyNavrh` using its globally unique id. */
  deleteParyNavrhByNodeId: Maybe<DeleteParyNavrhPayload>;
  /** Deletes a single `Permission` using a unique key. */
  deletePermission: Maybe<DeletePermissionPayload>;
  /** Deletes a single `Permission` using its globally unique id. */
  deletePermissionByNodeId: Maybe<DeletePermissionPayload>;
  /** Deletes a single `PlatbyCategory` using a unique key. */
  deletePlatbyCategory: Maybe<DeletePlatbyCategoryPayload>;
  /** Deletes a single `PlatbyCategory` using its globally unique id. */
  deletePlatbyCategoryByNodeId: Maybe<DeletePlatbyCategoryPayload>;
  /** Deletes a single `PlatbyCategoryGroup` using a unique key. */
  deletePlatbyCategoryGroup: Maybe<DeletePlatbyCategoryGroupPayload>;
  /** Deletes a single `PlatbyCategoryGroup` using its globally unique id. */
  deletePlatbyCategoryGroupByNodeId: Maybe<DeletePlatbyCategoryGroupPayload>;
  /** Deletes a single `PlatbyGroup` using a unique key. */
  deletePlatbyGroup: Maybe<DeletePlatbyGroupPayload>;
  /** Deletes a single `PlatbyGroup` using its globally unique id. */
  deletePlatbyGroupByNodeId: Maybe<DeletePlatbyGroupPayload>;
  /** Deletes a single `PlatbyGroupSkupina` using a unique key. */
  deletePlatbyGroupSkupina: Maybe<DeletePlatbyGroupSkupinaPayload>;
  /** Deletes a single `PlatbyGroupSkupina` using its globally unique id. */
  deletePlatbyGroupSkupinaByNodeId: Maybe<DeletePlatbyGroupSkupinaPayload>;
  /** Deletes a single `PlatbyItem` using a unique key. */
  deletePlatbyItem: Maybe<DeletePlatbyItemPayload>;
  /** Deletes a single `PlatbyItem` using its globally unique id. */
  deletePlatbyItemByNodeId: Maybe<DeletePlatbyItemPayload>;
  /** Deletes a single `PlatbyRaw` using a unique key. */
  deletePlatbyRaw: Maybe<DeletePlatbyRawPayload>;
  /** Deletes a single `PlatbyRaw` using its globally unique id. */
  deletePlatbyRawByNodeId: Maybe<DeletePlatbyRawPayload>;
  /** Deletes a single `Rozpi` using a unique key. */
  deleteRozpi: Maybe<DeleteRozpiPayload>;
  /** Deletes a single `Rozpi` using its globally unique id. */
  deleteRozpiByNodeId: Maybe<DeleteRozpiPayload>;
  /** Deletes a single `RozpisItem` using a unique key. */
  deleteRozpisItem: Maybe<DeleteRozpisItemPayload>;
  /** Deletes a single `RozpisItem` using its globally unique id. */
  deleteRozpisItemByNodeId: Maybe<DeleteRozpisItemPayload>;
  /** Deletes a single `Session` using a unique key. */
  deleteSession: Maybe<DeleteSessionPayload>;
  /** Deletes a single `Session` using its globally unique id. */
  deleteSessionByNodeId: Maybe<DeleteSessionPayload>;
  /** Deletes a single `Skupiny` using a unique key. */
  deleteSkupiny: Maybe<DeleteSkupinyPayload>;
  /** Deletes a single `Skupiny` using its globally unique id. */
  deleteSkupinyByNodeId: Maybe<DeleteSkupinyPayload>;
  /** Deletes a single `Upozorneni` using a unique key. */
  deleteUpozorneni: Maybe<DeleteUpozorneniPayload>;
  /** Deletes a single `Upozorneni` using its globally unique id. */
  deleteUpozorneniByNodeId: Maybe<DeleteUpozorneniPayload>;
  /** Deletes a single `UpozorneniSkupiny` using a unique key. */
  deleteUpozorneniSkupiny: Maybe<DeleteUpozorneniSkupinyPayload>;
  /** Deletes a single `UpozorneniSkupiny` using its globally unique id. */
  deleteUpozorneniSkupinyByNodeId: Maybe<DeleteUpozorneniSkupinyPayload>;
  /** Deletes a single `User` using a unique key. */
  deleteUser: Maybe<DeleteUserPayload>;
  /** Deletes a single `User` using its globally unique id. */
  deleteUserByNodeId: Maybe<DeleteUserPayload>;
  /** Deletes a single `Video` using a unique key. */
  deleteVideo: Maybe<DeleteVideoPayload>;
  /** Deletes a single `Video` using its globally unique id. */
  deleteVideoByNodeId: Maybe<DeleteVideoPayload>;
  /** Deletes a single `VideoList` using a unique key. */
  deleteVideoList: Maybe<DeleteVideoListPayload>;
  /** Deletes a single `VideoList` using its globally unique id. */
  deleteVideoListByNodeId: Maybe<DeleteVideoListPayload>;
  /** Deletes a single `VideoSource` using a unique key. */
  deleteVideoSource: Maybe<DeleteVideoSourcePayload>;
  /** Deletes a single `VideoSource` using its globally unique id. */
  deleteVideoSourceByNodeId: Maybe<DeleteVideoSourcePayload>;
  fixUnpairedCouples: Maybe<FixUnpairedCouplesPayload>;
  login: Maybe<LoginPayload>;
  logout: Maybe<LogoutPayload>;
  prospectFormDancer: Maybe<ProspectFormDancerPayload>;
  resetPassword: Maybe<ResetPasswordPayload>;
  /** Updates a single `Akce` using a unique key and a patch. */
  updateAkce: Maybe<UpdateAkcePayload>;
  /** Updates a single `Akce` using its globally unique id and a patch. */
  updateAkceByNodeId: Maybe<UpdateAkcePayload>;
  /** Updates a single `AkceItem` using a unique key and a patch. */
  updateAkceItem: Maybe<UpdateAkceItemPayload>;
  /** Updates a single `AkceItem` using its globally unique id and a patch. */
  updateAkceItemByNodeId: Maybe<UpdateAkceItemPayload>;
  /** Updates a single `Aktuality` using a unique key and a patch. */
  updateAktuality: Maybe<UpdateAktualityPayload>;
  /** Updates a single `Aktuality` using its globally unique id and a patch. */
  updateAktualityByNodeId: Maybe<UpdateAktualityPayload>;
  /** Updates a single `Dokumenty` using a unique key and a patch. */
  updateDokumenty: Maybe<UpdateDokumentyPayload>;
  /** Updates a single `Dokumenty` using its globally unique id and a patch. */
  updateDokumentyByNodeId: Maybe<UpdateDokumentyPayload>;
  /** Updates a single `GalerieDir` using a unique key and a patch. */
  updateGalerieDir: Maybe<UpdateGalerieDirPayload>;
  /** Updates a single `GalerieDir` using its globally unique id and a patch. */
  updateGalerieDirByNodeId: Maybe<UpdateGalerieDirPayload>;
  /** Updates a single `GalerieFoto` using a unique key and a patch. */
  updateGalerieFoto: Maybe<UpdateGalerieFotoPayload>;
  /** Updates a single `GalerieFoto` using its globally unique id and a patch. */
  updateGalerieFotoByNodeId: Maybe<UpdateGalerieFotoPayload>;
  /** Updates a single `Nabidka` using a unique key and a patch. */
  updateNabidka: Maybe<UpdateNabidkaPayload>;
  /** Updates a single `Nabidka` using its globally unique id and a patch. */
  updateNabidkaByNodeId: Maybe<UpdateNabidkaPayload>;
  /** Updates a single `NabidkaItem` using a unique key and a patch. */
  updateNabidkaItem: Maybe<UpdateNabidkaItemPayload>;
  /** Updates a single `NabidkaItem` using its globally unique id and a patch. */
  updateNabidkaItemByNodeId: Maybe<UpdateNabidkaItemPayload>;
  /** Updates a single `Page` using a unique key and a patch. */
  updatePage: Maybe<UpdatePagePayload>;
  /** Updates a single `Page` using its globally unique id and a patch. */
  updatePageByNodeId: Maybe<UpdatePagePayload>;
  /** Updates a single `Page` using a unique key and a patch. */
  updatePageByUrl: Maybe<UpdatePagePayload>;
  /** Updates a single `Parameter` using a unique key and a patch. */
  updateParameter: Maybe<UpdateParameterPayload>;
  /** Updates a single `Parameter` using its globally unique id and a patch. */
  updateParameterByNodeId: Maybe<UpdateParameterPayload>;
  /** Updates a single `Pary` using a unique key and a patch. */
  updatePary: Maybe<UpdateParyPayload>;
  /** Updates a single `Pary` using its globally unique id and a patch. */
  updateParyByNodeId: Maybe<UpdateParyPayload>;
  /** Updates a single `ParyNavrh` using a unique key and a patch. */
  updateParyNavrh: Maybe<UpdateParyNavrhPayload>;
  /** Updates a single `ParyNavrh` using its globally unique id and a patch. */
  updateParyNavrhByNodeId: Maybe<UpdateParyNavrhPayload>;
  /** Updates a single `Permission` using a unique key and a patch. */
  updatePermission: Maybe<UpdatePermissionPayload>;
  /** Updates a single `Permission` using its globally unique id and a patch. */
  updatePermissionByNodeId: Maybe<UpdatePermissionPayload>;
  /** Updates a single `PlatbyCategory` using a unique key and a patch. */
  updatePlatbyCategory: Maybe<UpdatePlatbyCategoryPayload>;
  /** Updates a single `PlatbyCategory` using its globally unique id and a patch. */
  updatePlatbyCategoryByNodeId: Maybe<UpdatePlatbyCategoryPayload>;
  /** Updates a single `PlatbyCategoryGroup` using a unique key and a patch. */
  updatePlatbyCategoryGroup: Maybe<UpdatePlatbyCategoryGroupPayload>;
  /** Updates a single `PlatbyCategoryGroup` using its globally unique id and a patch. */
  updatePlatbyCategoryGroupByNodeId: Maybe<UpdatePlatbyCategoryGroupPayload>;
  /** Updates a single `PlatbyGroup` using a unique key and a patch. */
  updatePlatbyGroup: Maybe<UpdatePlatbyGroupPayload>;
  /** Updates a single `PlatbyGroup` using its globally unique id and a patch. */
  updatePlatbyGroupByNodeId: Maybe<UpdatePlatbyGroupPayload>;
  /** Updates a single `PlatbyGroupSkupina` using a unique key and a patch. */
  updatePlatbyGroupSkupina: Maybe<UpdatePlatbyGroupSkupinaPayload>;
  /** Updates a single `PlatbyGroupSkupina` using its globally unique id and a patch. */
  updatePlatbyGroupSkupinaByNodeId: Maybe<UpdatePlatbyGroupSkupinaPayload>;
  /** Updates a single `PlatbyItem` using a unique key and a patch. */
  updatePlatbyItem: Maybe<UpdatePlatbyItemPayload>;
  /** Updates a single `PlatbyItem` using its globally unique id and a patch. */
  updatePlatbyItemByNodeId: Maybe<UpdatePlatbyItemPayload>;
  /** Updates a single `PlatbyRaw` using a unique key and a patch. */
  updatePlatbyRaw: Maybe<UpdatePlatbyRawPayload>;
  /** Updates a single `PlatbyRaw` using its globally unique id and a patch. */
  updatePlatbyRawByNodeId: Maybe<UpdatePlatbyRawPayload>;
  /** Updates a single `Rozpi` using a unique key and a patch. */
  updateRozpi: Maybe<UpdateRozpiPayload>;
  /** Updates a single `Rozpi` using its globally unique id and a patch. */
  updateRozpiByNodeId: Maybe<UpdateRozpiPayload>;
  /** Updates a single `RozpisItem` using a unique key and a patch. */
  updateRozpisItem: Maybe<UpdateRozpisItemPayload>;
  /** Updates a single `RozpisItem` using its globally unique id and a patch. */
  updateRozpisItemByNodeId: Maybe<UpdateRozpisItemPayload>;
  /** Updates a single `Session` using a unique key and a patch. */
  updateSession: Maybe<UpdateSessionPayload>;
  /** Updates a single `Session` using its globally unique id and a patch. */
  updateSessionByNodeId: Maybe<UpdateSessionPayload>;
  /** Updates a single `Skupiny` using a unique key and a patch. */
  updateSkupiny: Maybe<UpdateSkupinyPayload>;
  /** Updates a single `Skupiny` using its globally unique id and a patch. */
  updateSkupinyByNodeId: Maybe<UpdateSkupinyPayload>;
  /** Updates a single `Upozorneni` using a unique key and a patch. */
  updateUpozorneni: Maybe<UpdateUpozorneniPayload>;
  /** Updates a single `Upozorneni` using its globally unique id and a patch. */
  updateUpozorneniByNodeId: Maybe<UpdateUpozorneniPayload>;
  /** Updates a single `UpozorneniSkupiny` using a unique key and a patch. */
  updateUpozorneniSkupiny: Maybe<UpdateUpozorneniSkupinyPayload>;
  /** Updates a single `UpozorneniSkupiny` using its globally unique id and a patch. */
  updateUpozorneniSkupinyByNodeId: Maybe<UpdateUpozorneniSkupinyPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUser: Maybe<UpdateUserPayload>;
  /** Updates a single `User` using its globally unique id and a patch. */
  updateUserByNodeId: Maybe<UpdateUserPayload>;
  /** Updates a single `Video` using a unique key and a patch. */
  updateVideo: Maybe<UpdateVideoPayload>;
  /** Updates a single `Video` using its globally unique id and a patch. */
  updateVideoByNodeId: Maybe<UpdateVideoPayload>;
  /** Updates a single `VideoList` using a unique key and a patch. */
  updateVideoList: Maybe<UpdateVideoListPayload>;
  /** Updates a single `VideoList` using its globally unique id and a patch. */
  updateVideoListByNodeId: Maybe<UpdateVideoListPayload>;
  /** Updates a single `VideoSource` using a unique key and a patch. */
  updateVideoSource: Maybe<UpdateVideoSourcePayload>;
  /** Updates a single `VideoSource` using its globally unique id and a patch. */
  updateVideoSourceByNodeId: Maybe<UpdateVideoSourcePayload>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationConfirmUserArgs = {
  input: ConfirmUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAkceArgs = {
  input: CreateAkceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAkceItemArgs = {
  input: CreateAkceItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAktualityArgs = {
  input: CreateAktualityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCoupleArgs = {
  input: CreateCoupleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDokumentyArgs = {
  input: CreateDokumentyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGalerieDirArgs = {
  input: CreateGalerieDirInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGalerieFotoArgs = {
  input: CreateGalerieFotoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateNabidkaArgs = {
  input: CreateNabidkaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateNabidkaItemArgs = {
  input: CreateNabidkaItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePageArgs = {
  input: CreatePageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateParameterArgs = {
  input: CreateParameterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateParyArgs = {
  input: CreateParyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateParyNavrhArgs = {
  input: CreateParyNavrhInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePermissionArgs = {
  input: CreatePermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlatbyCategoryArgs = {
  input: CreatePlatbyCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlatbyCategoryGroupArgs = {
  input: CreatePlatbyCategoryGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlatbyGroupArgs = {
  input: CreatePlatbyGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlatbyGroupSkupinaArgs = {
  input: CreatePlatbyGroupSkupinaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlatbyItemArgs = {
  input: CreatePlatbyItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlatbyRawArgs = {
  input: CreatePlatbyRawInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRozpiArgs = {
  input: CreateRozpiInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRozpisItemArgs = {
  input: CreateRozpisItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSessionArgs = {
  input: CreateSessionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSkupinyArgs = {
  input: CreateSkupinyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUpozorneniArgs = {
  input: CreateUpozorneniInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUpozorneniSkupinyArgs = {
  input: CreateUpozorneniSkupinyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserArgs = {
  input: CreateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVideoArgs = {
  input: CreateVideoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVideoListArgs = {
  input: CreateVideoListInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVideoSourceArgs = {
  input: CreateVideoSourceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAkceArgs = {
  input: DeleteAkceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAkceByNodeIdArgs = {
  input: DeleteAkceByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAkceItemArgs = {
  input: DeleteAkceItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAkceItemByNodeIdArgs = {
  input: DeleteAkceItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAktualityArgs = {
  input: DeleteAktualityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAktualityByNodeIdArgs = {
  input: DeleteAktualityByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDokumentyArgs = {
  input: DeleteDokumentyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDokumentyByNodeIdArgs = {
  input: DeleteDokumentyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGalerieDirArgs = {
  input: DeleteGalerieDirInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGalerieDirByNodeIdArgs = {
  input: DeleteGalerieDirByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGalerieFotoArgs = {
  input: DeleteGalerieFotoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGalerieFotoByNodeIdArgs = {
  input: DeleteGalerieFotoByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNabidkaArgs = {
  input: DeleteNabidkaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNabidkaByNodeIdArgs = {
  input: DeleteNabidkaByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNabidkaItemArgs = {
  input: DeleteNabidkaItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNabidkaItemByNodeIdArgs = {
  input: DeleteNabidkaItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteParameterArgs = {
  input: DeleteParameterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteParameterByNodeIdArgs = {
  input: DeleteParameterByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteParyArgs = {
  input: DeleteParyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteParyByNodeIdArgs = {
  input: DeleteParyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteParyNavrhArgs = {
  input: DeleteParyNavrhInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteParyNavrhByNodeIdArgs = {
  input: DeleteParyNavrhByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePermissionArgs = {
  input: DeletePermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePermissionByNodeIdArgs = {
  input: DeletePermissionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyCategoryArgs = {
  input: DeletePlatbyCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyCategoryByNodeIdArgs = {
  input: DeletePlatbyCategoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyCategoryGroupArgs = {
  input: DeletePlatbyCategoryGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyCategoryGroupByNodeIdArgs = {
  input: DeletePlatbyCategoryGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyGroupArgs = {
  input: DeletePlatbyGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyGroupByNodeIdArgs = {
  input: DeletePlatbyGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyGroupSkupinaArgs = {
  input: DeletePlatbyGroupSkupinaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyGroupSkupinaByNodeIdArgs = {
  input: DeletePlatbyGroupSkupinaByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyItemArgs = {
  input: DeletePlatbyItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyItemByNodeIdArgs = {
  input: DeletePlatbyItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyRawArgs = {
  input: DeletePlatbyRawInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyRawByNodeIdArgs = {
  input: DeletePlatbyRawByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRozpiArgs = {
  input: DeleteRozpiInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRozpiByNodeIdArgs = {
  input: DeleteRozpiByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRozpisItemArgs = {
  input: DeleteRozpisItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRozpisItemByNodeIdArgs = {
  input: DeleteRozpisItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSessionArgs = {
  input: DeleteSessionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSessionByNodeIdArgs = {
  input: DeleteSessionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSkupinyArgs = {
  input: DeleteSkupinyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSkupinyByNodeIdArgs = {
  input: DeleteSkupinyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUpozorneniArgs = {
  input: DeleteUpozorneniInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUpozorneniByNodeIdArgs = {
  input: DeleteUpozorneniByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUpozorneniSkupinyArgs = {
  input: DeleteUpozorneniSkupinyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUpozorneniSkupinyByNodeIdArgs = {
  input: DeleteUpozorneniSkupinyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserArgs = {
  input: DeleteUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserByNodeIdArgs = {
  input: DeleteUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVideoArgs = {
  input: DeleteVideoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVideoByNodeIdArgs = {
  input: DeleteVideoByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVideoListArgs = {
  input: DeleteVideoListInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVideoListByNodeIdArgs = {
  input: DeleteVideoListByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVideoSourceArgs = {
  input: DeleteVideoSourceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVideoSourceByNodeIdArgs = {
  input: DeleteVideoSourceByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationFixUnpairedCouplesArgs = {
  input: FixUnpairedCouplesInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationLoginArgs = {
  input: LoginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationLogoutArgs = {
  input: LogoutInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationProspectFormDancerArgs = {
  input: ProspectFormDancerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationResetPasswordArgs = {
  input: ResetPasswordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAkceArgs = {
  input: UpdateAkceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAkceByNodeIdArgs = {
  input: UpdateAkceByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAkceItemArgs = {
  input: UpdateAkceItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAkceItemByNodeIdArgs = {
  input: UpdateAkceItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAktualityArgs = {
  input: UpdateAktualityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAktualityByNodeIdArgs = {
  input: UpdateAktualityByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDokumentyArgs = {
  input: UpdateDokumentyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDokumentyByNodeIdArgs = {
  input: UpdateDokumentyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGalerieDirArgs = {
  input: UpdateGalerieDirInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGalerieDirByNodeIdArgs = {
  input: UpdateGalerieDirByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGalerieFotoArgs = {
  input: UpdateGalerieFotoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGalerieFotoByNodeIdArgs = {
  input: UpdateGalerieFotoByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNabidkaArgs = {
  input: UpdateNabidkaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNabidkaByNodeIdArgs = {
  input: UpdateNabidkaByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNabidkaItemArgs = {
  input: UpdateNabidkaItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNabidkaItemByNodeIdArgs = {
  input: UpdateNabidkaItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePageArgs = {
  input: UpdatePageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePageByNodeIdArgs = {
  input: UpdatePageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePageByUrlArgs = {
  input: UpdatePageByUrlInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateParameterArgs = {
  input: UpdateParameterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateParameterByNodeIdArgs = {
  input: UpdateParameterByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateParyArgs = {
  input: UpdateParyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateParyByNodeIdArgs = {
  input: UpdateParyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateParyNavrhArgs = {
  input: UpdateParyNavrhInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateParyNavrhByNodeIdArgs = {
  input: UpdateParyNavrhByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePermissionArgs = {
  input: UpdatePermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePermissionByNodeIdArgs = {
  input: UpdatePermissionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyCategoryArgs = {
  input: UpdatePlatbyCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyCategoryByNodeIdArgs = {
  input: UpdatePlatbyCategoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyCategoryGroupArgs = {
  input: UpdatePlatbyCategoryGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyCategoryGroupByNodeIdArgs = {
  input: UpdatePlatbyCategoryGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyGroupArgs = {
  input: UpdatePlatbyGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyGroupByNodeIdArgs = {
  input: UpdatePlatbyGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyGroupSkupinaArgs = {
  input: UpdatePlatbyGroupSkupinaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyGroupSkupinaByNodeIdArgs = {
  input: UpdatePlatbyGroupSkupinaByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyItemArgs = {
  input: UpdatePlatbyItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyItemByNodeIdArgs = {
  input: UpdatePlatbyItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyRawArgs = {
  input: UpdatePlatbyRawInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyRawByNodeIdArgs = {
  input: UpdatePlatbyRawByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRozpiArgs = {
  input: UpdateRozpiInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRozpiByNodeIdArgs = {
  input: UpdateRozpiByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRozpisItemArgs = {
  input: UpdateRozpisItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRozpisItemByNodeIdArgs = {
  input: UpdateRozpisItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSessionArgs = {
  input: UpdateSessionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSessionByNodeIdArgs = {
  input: UpdateSessionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSkupinyArgs = {
  input: UpdateSkupinyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSkupinyByNodeIdArgs = {
  input: UpdateSkupinyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUpozorneniArgs = {
  input: UpdateUpozorneniInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUpozorneniByNodeIdArgs = {
  input: UpdateUpozorneniByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUpozorneniSkupinyArgs = {
  input: UpdateUpozorneniSkupinyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUpozorneniSkupinyByNodeIdArgs = {
  input: UpdateUpozorneniSkupinyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserArgs = {
  input: UpdateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByNodeIdArgs = {
  input: UpdateUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVideoArgs = {
  input: UpdateVideoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVideoByNodeIdArgs = {
  input: UpdateVideoByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVideoListArgs = {
  input: UpdateVideoListInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVideoListByNodeIdArgs = {
  input: UpdateVideoListByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVideoSourceArgs = {
  input: UpdateVideoSourceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVideoSourceByNodeIdArgs = {
  input: UpdateVideoSourceByNodeIdInput;
};

export type Nabidka = Node & {
  __typename?: 'Nabidka';
  /** Reads and enables pagination through a set of `NabidkaItem`. */
  nabidkaItemsByNiIdRodic: NabidkaItemsConnection;
  nDo: Scalars['Date'];
  nId: Scalars['BigInt'];
  nLock: Scalars['Boolean'];
  nMaxPocetHod: Scalars['Int'];
  nOd: Scalars['Date'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  nPocetHod: Scalars['Int'];
  nTimestamp: Maybe<Scalars['Datetime']>;
  nTrener: Scalars['BigInt'];
  nVisible: Scalars['Boolean'];
  /** Reads a single `User` that is related to this `Nabidka`. */
  userByNTrener: Maybe<User>;
};


export type NabidkaNabidkaItemsByNiIdRodicArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<NabidkaItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<NabidkaItemsOrderBy>>;
};

/** A condition to be used against `Nabidka` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type NabidkaCondition = {
  /** Checks for equality with the object’s `nDo` field. */
  nDo?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `nId` field. */
  nId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `nLock` field. */
  nLock?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `nMaxPocetHod` field. */
  nMaxPocetHod?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `nOd` field. */
  nOd?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `nPocetHod` field. */
  nPocetHod?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `nTimestamp` field. */
  nTimestamp?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `nTrener` field. */
  nTrener?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `nVisible` field. */
  nVisible?: InputMaybe<Scalars['Boolean']>;
};

/** An input for mutations affecting `Nabidka` */
export type NabidkaInput = {
  nDo: Scalars['Date'];
  nId?: InputMaybe<Scalars['BigInt']>;
  nLock?: InputMaybe<Scalars['Boolean']>;
  nMaxPocetHod?: InputMaybe<Scalars['Int']>;
  nOd: Scalars['Date'];
  nPocetHod?: InputMaybe<Scalars['Int']>;
  nTimestamp?: InputMaybe<Scalars['Datetime']>;
  nTrener: Scalars['BigInt'];
  nVisible?: InputMaybe<Scalars['Boolean']>;
};

export type NabidkaItem = Node & {
  __typename?: 'NabidkaItem';
  /** Reads a single `Nabidka` that is related to this `NabidkaItem`. */
  nabidkaByNiIdRodic: Maybe<Nabidka>;
  niId: Scalars['BigInt'];
  niIdRodic: Scalars['BigInt'];
  niLock: Scalars['Boolean'];
  niPartner: Scalars['BigInt'];
  niPocetHod: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `Pary` that is related to this `NabidkaItem`. */
  paryByNiPartner: Maybe<Pary>;
};

/**
 * A condition to be used against `NabidkaItem` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type NabidkaItemCondition = {
  /** Checks for equality with the object’s `niId` field. */
  niId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `niIdRodic` field. */
  niIdRodic?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `niLock` field. */
  niLock?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `niPartner` field. */
  niPartner?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `niPocetHod` field. */
  niPocetHod?: InputMaybe<Scalars['Int']>;
};

/** An input for mutations affecting `NabidkaItem` */
export type NabidkaItemInput = {
  niId?: InputMaybe<Scalars['BigInt']>;
  niIdRodic: Scalars['BigInt'];
  niLock?: InputMaybe<Scalars['Boolean']>;
  niPartner: Scalars['BigInt'];
  niPocetHod?: InputMaybe<Scalars['Int']>;
};

/** Represents an update to a `NabidkaItem`. Fields that are set will be updated. */
export type NabidkaItemPatch = {
  niId?: InputMaybe<Scalars['BigInt']>;
  niIdRodic?: InputMaybe<Scalars['BigInt']>;
  niLock?: InputMaybe<Scalars['Boolean']>;
  niPartner?: InputMaybe<Scalars['BigInt']>;
  niPocetHod?: InputMaybe<Scalars['Int']>;
};

/** A connection to a list of `NabidkaItem` values. */
export type NabidkaItemsConnection = {
  __typename?: 'NabidkaItemsConnection';
  /** A list of edges which contains the `NabidkaItem` and cursor to aid in pagination. */
  edges: Array<NabidkaItemsEdge>;
  /** A list of `NabidkaItem` objects. */
  nodes: Array<NabidkaItem>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `NabidkaItem` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `NabidkaItem` edge in the connection. */
export type NabidkaItemsEdge = {
  __typename?: 'NabidkaItemsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `NabidkaItem` at the end of the edge. */
  node: NabidkaItem;
};

/** Methods to use when ordering `NabidkaItem`. */
export enum NabidkaItemsOrderBy {
  Natural = 'NATURAL',
  NiIdAsc = 'NI_ID_ASC',
  NiIdDesc = 'NI_ID_DESC',
  NiIdRodicAsc = 'NI_ID_RODIC_ASC',
  NiIdRodicDesc = 'NI_ID_RODIC_DESC',
  NiLockAsc = 'NI_LOCK_ASC',
  NiLockDesc = 'NI_LOCK_DESC',
  NiPartnerAsc = 'NI_PARTNER_ASC',
  NiPartnerDesc = 'NI_PARTNER_DESC',
  NiPocetHodAsc = 'NI_POCET_HOD_ASC',
  NiPocetHodDesc = 'NI_POCET_HOD_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Represents an update to a `Nabidka`. Fields that are set will be updated. */
export type NabidkaPatch = {
  nDo?: InputMaybe<Scalars['Date']>;
  nId?: InputMaybe<Scalars['BigInt']>;
  nLock?: InputMaybe<Scalars['Boolean']>;
  nMaxPocetHod?: InputMaybe<Scalars['Int']>;
  nOd?: InputMaybe<Scalars['Date']>;
  nPocetHod?: InputMaybe<Scalars['Int']>;
  nTimestamp?: InputMaybe<Scalars['Datetime']>;
  nTrener?: InputMaybe<Scalars['BigInt']>;
  nVisible?: InputMaybe<Scalars['Boolean']>;
};

/** A connection to a list of `Nabidka` values. */
export type NabidkasConnection = {
  __typename?: 'NabidkasConnection';
  /** A list of edges which contains the `Nabidka` and cursor to aid in pagination. */
  edges: Array<NabidkasEdge>;
  /** A list of `Nabidka` objects. */
  nodes: Array<Nabidka>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Nabidka` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Nabidka` edge in the connection. */
export type NabidkasEdge = {
  __typename?: 'NabidkasEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Nabidka` at the end of the edge. */
  node: Nabidka;
};

/** Methods to use when ordering `Nabidka`. */
export enum NabidkasOrderBy {
  NDoAsc = 'N_DO_ASC',
  NDoDesc = 'N_DO_DESC',
  NIdAsc = 'N_ID_ASC',
  NIdDesc = 'N_ID_DESC',
  NLockAsc = 'N_LOCK_ASC',
  NLockDesc = 'N_LOCK_DESC',
  NMaxPocetHodAsc = 'N_MAX_POCET_HOD_ASC',
  NMaxPocetHodDesc = 'N_MAX_POCET_HOD_DESC',
  NOdAsc = 'N_OD_ASC',
  NOdDesc = 'N_OD_DESC',
  NPocetHodAsc = 'N_POCET_HOD_ASC',
  NPocetHodDesc = 'N_POCET_HOD_DESC',
  NTimestampAsc = 'N_TIMESTAMP_ASC',
  NTimestampDesc = 'N_TIMESTAMP_DESC',
  NTrenerAsc = 'N_TRENER_ASC',
  NTrenerDesc = 'N_TRENER_DESC',
  NVisibleAsc = 'N_VISIBLE_ASC',
  NVisibleDesc = 'N_VISIBLE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** An object with a globally unique `ID`. */
export type Node = {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
};

export type Page = Node & {
  __typename?: 'Page';
  content: Scalars['JSON'];
  createdAt: Scalars['Datetime'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  title: Scalars['String'];
  updatedAt: Scalars['Datetime'];
  url: Scalars['String'];
};

/** A condition to be used against `Page` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PageCondition = {
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `url` field. */
  url?: InputMaybe<Scalars['String']>;
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor: Maybe<Scalars['Cursor']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor: Maybe<Scalars['Cursor']>;
};

/** An input for mutations affecting `Page` */
export type PageInput = {
  content: Scalars['JSON'];
  createdAt?: InputMaybe<Scalars['Datetime']>;
  id?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['Datetime']>;
  url: Scalars['String'];
};

/** Represents an update to a `Page`. Fields that are set will be updated. */
export type PagePatch = {
  content?: InputMaybe<Scalars['JSON']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  id?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['Datetime']>;
  url?: InputMaybe<Scalars['String']>;
};

export type PageRevision = Node & {
  __typename?: 'PageRevision';
  content: Scalars['JSON'];
  createdAt: Scalars['Datetime'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  revNumber: Scalars['Int'];
  revOperation: Scalars['String'];
  revTimestamp: Maybe<Scalars['Datetime']>;
  title: Scalars['String'];
  updatedAt: Scalars['Datetime'];
  url: Scalars['String'];
};

/**
 * A condition to be used against `PageRevision` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PageRevisionCondition = {
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `revNumber` field. */
  revNumber?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `revOperation` field. */
  revOperation?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `revTimestamp` field. */
  revTimestamp?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `url` field. */
  url?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `PageRevision` values. */
export type PageRevisionsConnection = {
  __typename?: 'PageRevisionsConnection';
  /** A list of edges which contains the `PageRevision` and cursor to aid in pagination. */
  edges: Array<PageRevisionsEdge>;
  /** A list of `PageRevision` objects. */
  nodes: Array<PageRevision>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PageRevision` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PageRevision` edge in the connection. */
export type PageRevisionsEdge = {
  __typename?: 'PageRevisionsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `PageRevision` at the end of the edge. */
  node: PageRevision;
};

/** Methods to use when ordering `PageRevision`. */
export enum PageRevisionsOrderBy {
  ContentAsc = 'CONTENT_ASC',
  ContentDesc = 'CONTENT_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RevNumberAsc = 'REV_NUMBER_ASC',
  RevNumberDesc = 'REV_NUMBER_DESC',
  RevOperationAsc = 'REV_OPERATION_ASC',
  RevOperationDesc = 'REV_OPERATION_DESC',
  RevTimestampAsc = 'REV_TIMESTAMP_ASC',
  RevTimestampDesc = 'REV_TIMESTAMP_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UrlAsc = 'URL_ASC',
  UrlDesc = 'URL_DESC'
}

/** A connection to a list of `Page` values. */
export type PagesConnection = {
  __typename?: 'PagesConnection';
  /** A list of edges which contains the `Page` and cursor to aid in pagination. */
  edges: Array<PagesEdge>;
  /** A list of `Page` objects. */
  nodes: Array<Page>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Page` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Page` edge in the connection. */
export type PagesEdge = {
  __typename?: 'PagesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Page` at the end of the edge. */
  node: Page;
};

/** Methods to use when ordering `Page`. */
export enum PagesOrderBy {
  ContentAsc = 'CONTENT_ASC',
  ContentDesc = 'CONTENT_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UrlAsc = 'URL_ASC',
  UrlDesc = 'URL_DESC'
}

export type Parameter = Node & {
  __typename?: 'Parameter';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  paName: Scalars['String'];
  paValue: Scalars['String'];
};

/**
 * A condition to be used against `Parameter` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ParameterCondition = {
  /** Checks for equality with the object’s `paName` field. */
  paName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `paValue` field. */
  paValue?: InputMaybe<Scalars['String']>;
};

/** An input for mutations affecting `Parameter` */
export type ParameterInput = {
  paName: Scalars['String'];
  paValue: Scalars['String'];
};

/** Represents an update to a `Parameter`. Fields that are set will be updated. */
export type ParameterPatch = {
  paName?: InputMaybe<Scalars['String']>;
  paValue?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Parameter` values. */
export type ParametersConnection = {
  __typename?: 'ParametersConnection';
  /** A list of edges which contains the `Parameter` and cursor to aid in pagination. */
  edges: Array<ParametersEdge>;
  /** A list of `Parameter` objects. */
  nodes: Array<Parameter>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Parameter` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Parameter` edge in the connection. */
export type ParametersEdge = {
  __typename?: 'ParametersEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Parameter` at the end of the edge. */
  node: Parameter;
};

/** Methods to use when ordering `Parameter`. */
export enum ParametersOrderBy {
  Natural = 'NATURAL',
  PaNameAsc = 'PA_NAME_ASC',
  PaNameDesc = 'PA_NAME_DESC',
  PaValueAsc = 'PA_VALUE_ASC',
  PaValueDesc = 'PA_VALUE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `Pary` values. */
export type PariesConnection = {
  __typename?: 'PariesConnection';
  /** A list of edges which contains the `Pary` and cursor to aid in pagination. */
  edges: Array<PariesEdge>;
  /** A list of `Pary` objects. */
  nodes: Array<Pary>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Pary` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Pary` edge in the connection. */
export type PariesEdge = {
  __typename?: 'PariesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Pary` at the end of the edge. */
  node: Pary;
};

/** Methods to use when ordering `Pary`. */
export enum PariesOrderBy {
  Natural = 'NATURAL',
  PArchivAsc = 'P_ARCHIV_ASC',
  PArchivDesc = 'P_ARCHIV_DESC',
  PHodnoceniAsc = 'P_HODNOCENI_ASC',
  PHodnoceniDesc = 'P_HODNOCENI_DESC',
  PIdAsc = 'P_ID_ASC',
  PIdDesc = 'P_ID_DESC',
  PIdPartnerAsc = 'P_ID_PARTNER_ASC',
  PIdPartnerDesc = 'P_ID_PARTNER_DESC',
  PIdPartnerkaAsc = 'P_ID_PARTNERKA_ASC',
  PIdPartnerkaDesc = 'P_ID_PARTNERKA_DESC',
  PLatBodyAsc = 'P_LAT_BODY_ASC',
  PLatBodyDesc = 'P_LAT_BODY_DESC',
  PLatFinaleAsc = 'P_LAT_FINALE_ASC',
  PLatFinaleDesc = 'P_LAT_FINALE_DESC',
  PLatTridaAsc = 'P_LAT_TRIDA_ASC',
  PLatTridaDesc = 'P_LAT_TRIDA_DESC',
  PSttBodyAsc = 'P_STT_BODY_ASC',
  PSttBodyDesc = 'P_STT_BODY_DESC',
  PSttFinaleAsc = 'P_STT_FINALE_ASC',
  PSttFinaleDesc = 'P_STT_FINALE_DESC',
  PSttTridaAsc = 'P_STT_TRIDA_ASC',
  PSttTridaDesc = 'P_STT_TRIDA_DESC',
  PTimestampAddAsc = 'P_TIMESTAMP_ADD_ASC',
  PTimestampAddDesc = 'P_TIMESTAMP_ADD_DESC',
  PTimestampArchiveAsc = 'P_TIMESTAMP_ARCHIVE_ASC',
  PTimestampArchiveDesc = 'P_TIMESTAMP_ARCHIVE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type Pary = Node & {
  __typename?: 'Pary';
  /** Reads and enables pagination through a set of `NabidkaItem`. */
  nabidkaItemsByNiPartner: NabidkaItemsConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  pArchiv: Scalars['Boolean'];
  pHodnoceni: Scalars['Int'];
  pId: Scalars['BigInt'];
  pIdPartner: Scalars['BigInt'];
  pIdPartnerka: Maybe<Scalars['BigInt']>;
  pLatBody: Scalars['Int'];
  pLatFinale: Scalars['Boolean'];
  pLatTrida: ParyPLatTrida;
  pSttBody: Scalars['Int'];
  pSttFinale: Scalars['Boolean'];
  pSttTrida: ParyPSttTrida;
  pTimestampAdd: Scalars['Datetime'];
  pTimestampArchive: Maybe<Scalars['Datetime']>;
  /** Reads and enables pagination through a set of `RozpisItem`. */
  rozpisItemsByRiPartner: RozpisItemsConnection;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartnerka: Maybe<User>;
};


export type ParyNabidkaItemsByNiPartnerArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<NabidkaItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<NabidkaItemsOrderBy>>;
};


export type ParyRozpisItemsByRiPartnerArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<RozpisItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RozpisItemsOrderBy>>;
};

/** A condition to be used against `Pary` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ParyCondition = {
  /** Checks for equality with the object’s `pArchiv` field. */
  pArchiv?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `pHodnoceni` field. */
  pHodnoceni?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `pId` field. */
  pId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pIdPartner` field. */
  pIdPartner?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pIdPartnerka` field. */
  pIdPartnerka?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pLatBody` field. */
  pLatBody?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `pLatFinale` field. */
  pLatFinale?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `pLatTrida` field. */
  pLatTrida?: InputMaybe<ParyPLatTrida>;
  /** Checks for equality with the object’s `pSttBody` field. */
  pSttBody?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `pSttFinale` field. */
  pSttFinale?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `pSttTrida` field. */
  pSttTrida?: InputMaybe<ParyPSttTrida>;
  /** Checks for equality with the object’s `pTimestampAdd` field. */
  pTimestampAdd?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `pTimestampArchive` field. */
  pTimestampArchive?: InputMaybe<Scalars['Datetime']>;
};

/** An input for mutations affecting `Pary` */
export type ParyInput = {
  pArchiv?: InputMaybe<Scalars['Boolean']>;
  pHodnoceni?: InputMaybe<Scalars['Int']>;
  pId?: InputMaybe<Scalars['BigInt']>;
  pIdPartner: Scalars['BigInt'];
  pIdPartnerka?: InputMaybe<Scalars['BigInt']>;
  pLatBody?: InputMaybe<Scalars['Int']>;
  pLatFinale?: InputMaybe<Scalars['Boolean']>;
  pLatTrida?: InputMaybe<ParyPLatTrida>;
  pSttBody?: InputMaybe<Scalars['Int']>;
  pSttFinale?: InputMaybe<Scalars['Boolean']>;
  pSttTrida?: InputMaybe<ParyPSttTrida>;
  pTimestampAdd?: InputMaybe<Scalars['Datetime']>;
  pTimestampArchive?: InputMaybe<Scalars['Datetime']>;
};

export type ParyNavrh = Node & {
  __typename?: 'ParyNavrh';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  pnId: Scalars['BigInt'];
  pnNavrhl: Scalars['BigInt'];
  pnPartner: Scalars['BigInt'];
  pnPartnerka: Scalars['BigInt'];
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnNavrhl: Maybe<User>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnPartnerka: Maybe<User>;
};

/**
 * A condition to be used against `ParyNavrh` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ParyNavrhCondition = {
  /** Checks for equality with the object’s `pnId` field. */
  pnId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pnNavrhl` field. */
  pnNavrhl?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pnPartner` field. */
  pnPartner?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pnPartnerka` field. */
  pnPartnerka?: InputMaybe<Scalars['BigInt']>;
};

/** An input for mutations affecting `ParyNavrh` */
export type ParyNavrhInput = {
  pnId?: InputMaybe<Scalars['BigInt']>;
  pnNavrhl: Scalars['BigInt'];
  pnPartner: Scalars['BigInt'];
  pnPartnerka: Scalars['BigInt'];
};

/** Represents an update to a `ParyNavrh`. Fields that are set will be updated. */
export type ParyNavrhPatch = {
  pnId?: InputMaybe<Scalars['BigInt']>;
  pnNavrhl?: InputMaybe<Scalars['BigInt']>;
  pnPartner?: InputMaybe<Scalars['BigInt']>;
  pnPartnerka?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `ParyNavrh` values. */
export type ParyNavrhsConnection = {
  __typename?: 'ParyNavrhsConnection';
  /** A list of edges which contains the `ParyNavrh` and cursor to aid in pagination. */
  edges: Array<ParyNavrhsEdge>;
  /** A list of `ParyNavrh` objects. */
  nodes: Array<ParyNavrh>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ParyNavrh` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ParyNavrh` edge in the connection. */
export type ParyNavrhsEdge = {
  __typename?: 'ParyNavrhsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `ParyNavrh` at the end of the edge. */
  node: ParyNavrh;
};

/** Methods to use when ordering `ParyNavrh`. */
export enum ParyNavrhsOrderBy {
  Natural = 'NATURAL',
  PnIdAsc = 'PN_ID_ASC',
  PnIdDesc = 'PN_ID_DESC',
  PnNavrhlAsc = 'PN_NAVRHL_ASC',
  PnNavrhlDesc = 'PN_NAVRHL_DESC',
  PnPartnerAsc = 'PN_PARTNER_ASC',
  PnPartnerDesc = 'PN_PARTNER_DESC',
  PnPartnerkaAsc = 'PN_PARTNERKA_ASC',
  PnPartnerkaDesc = 'PN_PARTNERKA_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Represents an update to a `Pary`. Fields that are set will be updated. */
export type ParyPatch = {
  pArchiv?: InputMaybe<Scalars['Boolean']>;
  pHodnoceni?: InputMaybe<Scalars['Int']>;
  pId?: InputMaybe<Scalars['BigInt']>;
  pIdPartner?: InputMaybe<Scalars['BigInt']>;
  pIdPartnerka?: InputMaybe<Scalars['BigInt']>;
  pLatBody?: InputMaybe<Scalars['Int']>;
  pLatFinale?: InputMaybe<Scalars['Boolean']>;
  pLatTrida?: InputMaybe<ParyPLatTrida>;
  pSttBody?: InputMaybe<Scalars['Int']>;
  pSttFinale?: InputMaybe<Scalars['Boolean']>;
  pSttTrida?: InputMaybe<ParyPSttTrida>;
  pTimestampAdd?: InputMaybe<Scalars['Datetime']>;
  pTimestampArchive?: InputMaybe<Scalars['Datetime']>;
};

export enum ParyPLatTrida {
  A = 'A',
  B = 'B',
  C = 'C',
  D = 'D',
  H = 'H',
  M = 'M',
  Z = 'Z'
}

export enum ParyPSttTrida {
  A = 'A',
  B = 'B',
  C = 'C',
  D = 'D',
  H = 'H',
  M = 'M',
  Z = 'Z'
}

export type Permission = Node & {
  __typename?: 'Permission';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  peAkce: Scalars['Int'];
  peAktuality: Scalars['Int'];
  peAnkety: Scalars['Int'];
  peDescription: Scalars['String'];
  peDokumenty: Scalars['Int'];
  peGalerie: Scalars['Int'];
  peId: Scalars['BigInt'];
  peInzerce: Scalars['Int'];
  peKonzole: Scalars['Int'];
  peMain: Scalars['Int'];
  peNabidka: Scalars['Int'];
  peName: Scalars['String'];
  peNastenka: Scalars['Int'];
  peNovinky: Scalars['Int'];
  pePary: Scalars['Int'];
  pePermissions: Scalars['Int'];
  pePlatby: Scalars['Int'];
  peRozpis: Scalars['Int'];
  peSkupiny: Scalars['Int'];
  peUsers: Scalars['Int'];
  /** Reads and enables pagination through a set of `User`. */
  usersByUGroup: UsersConnection;
};


export type PermissionUsersByUGroupArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<UserCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/**
 * A condition to be used against `Permission` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PermissionCondition = {
  /** Checks for equality with the object’s `peAkce` field. */
  peAkce?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peAktuality` field. */
  peAktuality?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peAnkety` field. */
  peAnkety?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peDescription` field. */
  peDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `peDokumenty` field. */
  peDokumenty?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peGalerie` field. */
  peGalerie?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peId` field. */
  peId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `peInzerce` field. */
  peInzerce?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peKonzole` field. */
  peKonzole?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peMain` field. */
  peMain?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peNabidka` field. */
  peNabidka?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peName` field. */
  peName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `peNastenka` field. */
  peNastenka?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peNovinky` field. */
  peNovinky?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `pePary` field. */
  pePary?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `pePermissions` field. */
  pePermissions?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `pePlatby` field. */
  pePlatby?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peRozpis` field. */
  peRozpis?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peSkupiny` field. */
  peSkupiny?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `peUsers` field. */
  peUsers?: InputMaybe<Scalars['Int']>;
};

/** An input for mutations affecting `Permission` */
export type PermissionInput = {
  peAkce: Scalars['Int'];
  peAktuality: Scalars['Int'];
  peAnkety: Scalars['Int'];
  peDescription: Scalars['String'];
  peDokumenty: Scalars['Int'];
  peGalerie: Scalars['Int'];
  peId?: InputMaybe<Scalars['BigInt']>;
  peInzerce: Scalars['Int'];
  peKonzole: Scalars['Int'];
  peMain: Scalars['Int'];
  peNabidka: Scalars['Int'];
  peName: Scalars['String'];
  peNastenka: Scalars['Int'];
  peNovinky: Scalars['Int'];
  pePary: Scalars['Int'];
  pePermissions: Scalars['Int'];
  pePlatby: Scalars['Int'];
  peRozpis: Scalars['Int'];
  peSkupiny: Scalars['Int'];
  peUsers: Scalars['Int'];
};

/** Represents an update to a `Permission`. Fields that are set will be updated. */
export type PermissionPatch = {
  peAkce?: InputMaybe<Scalars['Int']>;
  peAktuality?: InputMaybe<Scalars['Int']>;
  peAnkety?: InputMaybe<Scalars['Int']>;
  peDescription?: InputMaybe<Scalars['String']>;
  peDokumenty?: InputMaybe<Scalars['Int']>;
  peGalerie?: InputMaybe<Scalars['Int']>;
  peId?: InputMaybe<Scalars['BigInt']>;
  peInzerce?: InputMaybe<Scalars['Int']>;
  peKonzole?: InputMaybe<Scalars['Int']>;
  peMain?: InputMaybe<Scalars['Int']>;
  peNabidka?: InputMaybe<Scalars['Int']>;
  peName?: InputMaybe<Scalars['String']>;
  peNastenka?: InputMaybe<Scalars['Int']>;
  peNovinky?: InputMaybe<Scalars['Int']>;
  pePary?: InputMaybe<Scalars['Int']>;
  pePermissions?: InputMaybe<Scalars['Int']>;
  pePlatby?: InputMaybe<Scalars['Int']>;
  peRozpis?: InputMaybe<Scalars['Int']>;
  peSkupiny?: InputMaybe<Scalars['Int']>;
  peUsers?: InputMaybe<Scalars['Int']>;
};

/** A connection to a list of `Permission` values. */
export type PermissionsConnection = {
  __typename?: 'PermissionsConnection';
  /** A list of edges which contains the `Permission` and cursor to aid in pagination. */
  edges: Array<PermissionsEdge>;
  /** A list of `Permission` objects. */
  nodes: Array<Permission>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Permission` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Permission` edge in the connection. */
export type PermissionsEdge = {
  __typename?: 'PermissionsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Permission` at the end of the edge. */
  node: Permission;
};

/** Methods to use when ordering `Permission`. */
export enum PermissionsOrderBy {
  Natural = 'NATURAL',
  PeAkceAsc = 'PE_AKCE_ASC',
  PeAkceDesc = 'PE_AKCE_DESC',
  PeAktualityAsc = 'PE_AKTUALITY_ASC',
  PeAktualityDesc = 'PE_AKTUALITY_DESC',
  PeAnketyAsc = 'PE_ANKETY_ASC',
  PeAnketyDesc = 'PE_ANKETY_DESC',
  PeDescriptionAsc = 'PE_DESCRIPTION_ASC',
  PeDescriptionDesc = 'PE_DESCRIPTION_DESC',
  PeDokumentyAsc = 'PE_DOKUMENTY_ASC',
  PeDokumentyDesc = 'PE_DOKUMENTY_DESC',
  PeGalerieAsc = 'PE_GALERIE_ASC',
  PeGalerieDesc = 'PE_GALERIE_DESC',
  PeIdAsc = 'PE_ID_ASC',
  PeIdDesc = 'PE_ID_DESC',
  PeInzerceAsc = 'PE_INZERCE_ASC',
  PeInzerceDesc = 'PE_INZERCE_DESC',
  PeKonzoleAsc = 'PE_KONZOLE_ASC',
  PeKonzoleDesc = 'PE_KONZOLE_DESC',
  PeMainAsc = 'PE_MAIN_ASC',
  PeMainDesc = 'PE_MAIN_DESC',
  PeNabidkaAsc = 'PE_NABIDKA_ASC',
  PeNabidkaDesc = 'PE_NABIDKA_DESC',
  PeNameAsc = 'PE_NAME_ASC',
  PeNameDesc = 'PE_NAME_DESC',
  PeNastenkaAsc = 'PE_NASTENKA_ASC',
  PeNastenkaDesc = 'PE_NASTENKA_DESC',
  PeNovinkyAsc = 'PE_NOVINKY_ASC',
  PeNovinkyDesc = 'PE_NOVINKY_DESC',
  PeParyAsc = 'PE_PARY_ASC',
  PeParyDesc = 'PE_PARY_DESC',
  PePermissionsAsc = 'PE_PERMISSIONS_ASC',
  PePermissionsDesc = 'PE_PERMISSIONS_DESC',
  PePlatbyAsc = 'PE_PLATBY_ASC',
  PePlatbyDesc = 'PE_PLATBY_DESC',
  PeRozpisAsc = 'PE_ROZPIS_ASC',
  PeRozpisDesc = 'PE_ROZPIS_DESC',
  PeSkupinyAsc = 'PE_SKUPINY_ASC',
  PeSkupinyDesc = 'PE_SKUPINY_DESC',
  PeUsersAsc = 'PE_USERS_ASC',
  PeUsersDesc = 'PE_USERS_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `PlatbyCategory` values. */
export type PlatbyCategoriesConnection = {
  __typename?: 'PlatbyCategoriesConnection';
  /** A list of edges which contains the `PlatbyCategory` and cursor to aid in pagination. */
  edges: Array<PlatbyCategoriesEdge>;
  /** A list of `PlatbyCategory` objects. */
  nodes: Array<PlatbyCategory>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PlatbyCategory` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PlatbyCategory` edge in the connection. */
export type PlatbyCategoriesEdge = {
  __typename?: 'PlatbyCategoriesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `PlatbyCategory` at the end of the edge. */
  node: PlatbyCategory;
};

/** Methods to use when ordering `PlatbyCategory`. */
export enum PlatbyCategoriesOrderBy {
  Natural = 'NATURAL',
  PcAmountAsc = 'PC_AMOUNT_ASC',
  PcAmountDesc = 'PC_AMOUNT_DESC',
  PcArchiveAsc = 'PC_ARCHIVE_ASC',
  PcArchiveDesc = 'PC_ARCHIVE_DESC',
  PcDateDueAsc = 'PC_DATE_DUE_ASC',
  PcDateDueDesc = 'PC_DATE_DUE_DESC',
  PcIdAsc = 'PC_ID_ASC',
  PcIdDesc = 'PC_ID_DESC',
  PcNameAsc = 'PC_NAME_ASC',
  PcNameDesc = 'PC_NAME_DESC',
  PcSymbolAsc = 'PC_SYMBOL_ASC',
  PcSymbolDesc = 'PC_SYMBOL_DESC',
  PcUseBaseAsc = 'PC_USE_BASE_ASC',
  PcUseBaseDesc = 'PC_USE_BASE_DESC',
  PcUsePrefixAsc = 'PC_USE_PREFIX_ASC',
  PcUsePrefixDesc = 'PC_USE_PREFIX_DESC',
  PcValidFromAsc = 'PC_VALID_FROM_ASC',
  PcValidFromDesc = 'PC_VALID_FROM_DESC',
  PcValidToAsc = 'PC_VALID_TO_ASC',
  PcValidToDesc = 'PC_VALID_TO_DESC',
  PcVisibleAsc = 'PC_VISIBLE_ASC',
  PcVisibleDesc = 'PC_VISIBLE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type PlatbyCategory = Node & {
  __typename?: 'PlatbyCategory';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  pcAmount: Scalars['BigFloat'];
  pcArchive: Scalars['Boolean'];
  pcDateDue: Scalars['Date'];
  pcId: Scalars['BigInt'];
  pcName: Scalars['String'];
  pcSymbol: Scalars['BigInt'];
  pcUseBase: Scalars['Boolean'];
  pcUsePrefix: Scalars['Boolean'];
  pcValidFrom: Scalars['Date'];
  pcValidTo: Scalars['Date'];
  pcVisible: Scalars['Boolean'];
  /** Reads and enables pagination through a set of `PlatbyCategoryGroup`. */
  platbyCategoryGroupsByPcgIdCategory: PlatbyCategoryGroupsConnection;
  /** Reads and enables pagination through a set of `PlatbyItem`. */
  platbyItemsByPiIdCategory: PlatbyItemsConnection;
};


export type PlatbyCategoryPlatbyCategoryGroupsByPcgIdCategoryArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyCategoryGroupCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyCategoryGroupsOrderBy>>;
};


export type PlatbyCategoryPlatbyItemsByPiIdCategoryArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyItemsOrderBy>>;
};

/**
 * A condition to be used against `PlatbyCategory` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PlatbyCategoryCondition = {
  /** Checks for equality with the object’s `pcAmount` field. */
  pcAmount?: InputMaybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `pcArchive` field. */
  pcArchive?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `pcDateDue` field. */
  pcDateDue?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `pcId` field. */
  pcId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pcName` field. */
  pcName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `pcSymbol` field. */
  pcSymbol?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pcUseBase` field. */
  pcUseBase?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `pcUsePrefix` field. */
  pcUsePrefix?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `pcValidFrom` field. */
  pcValidFrom?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `pcValidTo` field. */
  pcValidTo?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `pcVisible` field. */
  pcVisible?: InputMaybe<Scalars['Boolean']>;
};

export type PlatbyCategoryGroup = Node & {
  __typename?: 'PlatbyCategoryGroup';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  pcgId: Scalars['BigInt'];
  pcgIdCategory: Scalars['BigInt'];
  pcgIdGroup: Scalars['BigInt'];
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyCategoryGroup`. */
  platbyCategoryByPcgIdCategory: Maybe<PlatbyCategory>;
  /** Reads a single `PlatbyGroup` that is related to this `PlatbyCategoryGroup`. */
  platbyGroupByPcgIdGroup: Maybe<PlatbyGroup>;
};

/**
 * A condition to be used against `PlatbyCategoryGroup` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type PlatbyCategoryGroupCondition = {
  /** Checks for equality with the object’s `pcgId` field. */
  pcgId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pcgIdCategory` field. */
  pcgIdCategory?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pcgIdGroup` field. */
  pcgIdGroup?: InputMaybe<Scalars['BigInt']>;
};

/** An input for mutations affecting `PlatbyCategoryGroup` */
export type PlatbyCategoryGroupInput = {
  pcgId?: InputMaybe<Scalars['BigInt']>;
  pcgIdCategory: Scalars['BigInt'];
  pcgIdGroup: Scalars['BigInt'];
};

/** Represents an update to a `PlatbyCategoryGroup`. Fields that are set will be updated. */
export type PlatbyCategoryGroupPatch = {
  pcgId?: InputMaybe<Scalars['BigInt']>;
  pcgIdCategory?: InputMaybe<Scalars['BigInt']>;
  pcgIdGroup?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `PlatbyCategoryGroup` values. */
export type PlatbyCategoryGroupsConnection = {
  __typename?: 'PlatbyCategoryGroupsConnection';
  /** A list of edges which contains the `PlatbyCategoryGroup` and cursor to aid in pagination. */
  edges: Array<PlatbyCategoryGroupsEdge>;
  /** A list of `PlatbyCategoryGroup` objects. */
  nodes: Array<PlatbyCategoryGroup>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PlatbyCategoryGroup` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PlatbyCategoryGroup` edge in the connection. */
export type PlatbyCategoryGroupsEdge = {
  __typename?: 'PlatbyCategoryGroupsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `PlatbyCategoryGroup` at the end of the edge. */
  node: PlatbyCategoryGroup;
};

/** Methods to use when ordering `PlatbyCategoryGroup`. */
export enum PlatbyCategoryGroupsOrderBy {
  Natural = 'NATURAL',
  PcgIdAsc = 'PCG_ID_ASC',
  PcgIdCategoryAsc = 'PCG_ID_CATEGORY_ASC',
  PcgIdCategoryDesc = 'PCG_ID_CATEGORY_DESC',
  PcgIdDesc = 'PCG_ID_DESC',
  PcgIdGroupAsc = 'PCG_ID_GROUP_ASC',
  PcgIdGroupDesc = 'PCG_ID_GROUP_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** An input for mutations affecting `PlatbyCategory` */
export type PlatbyCategoryInput = {
  pcAmount: Scalars['BigFloat'];
  pcArchive?: InputMaybe<Scalars['Boolean']>;
  pcDateDue: Scalars['Date'];
  pcId?: InputMaybe<Scalars['BigInt']>;
  pcName: Scalars['String'];
  pcSymbol: Scalars['BigInt'];
  pcUseBase?: InputMaybe<Scalars['Boolean']>;
  pcUsePrefix?: InputMaybe<Scalars['Boolean']>;
  pcValidFrom: Scalars['Date'];
  pcValidTo: Scalars['Date'];
  pcVisible?: InputMaybe<Scalars['Boolean']>;
};

/** Represents an update to a `PlatbyCategory`. Fields that are set will be updated. */
export type PlatbyCategoryPatch = {
  pcAmount?: InputMaybe<Scalars['BigFloat']>;
  pcArchive?: InputMaybe<Scalars['Boolean']>;
  pcDateDue?: InputMaybe<Scalars['Date']>;
  pcId?: InputMaybe<Scalars['BigInt']>;
  pcName?: InputMaybe<Scalars['String']>;
  pcSymbol?: InputMaybe<Scalars['BigInt']>;
  pcUseBase?: InputMaybe<Scalars['Boolean']>;
  pcUsePrefix?: InputMaybe<Scalars['Boolean']>;
  pcValidFrom?: InputMaybe<Scalars['Date']>;
  pcValidTo?: InputMaybe<Scalars['Date']>;
  pcVisible?: InputMaybe<Scalars['Boolean']>;
};

export type PlatbyGroup = Node & {
  __typename?: 'PlatbyGroup';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  pgBase: Scalars['BigInt'];
  pgDescription: Scalars['String'];
  pgId: Scalars['BigInt'];
  pgName: Scalars['String'];
  pgType: Scalars['BigFloat'];
  /** Reads and enables pagination through a set of `PlatbyCategoryGroup`. */
  platbyCategoryGroupsByPcgIdGroup: PlatbyCategoryGroupsConnection;
  /** Reads and enables pagination through a set of `PlatbyGroupSkupina`. */
  platbyGroupSkupinasByPgsIdGroup: PlatbyGroupSkupinasConnection;
};


export type PlatbyGroupPlatbyCategoryGroupsByPcgIdGroupArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyCategoryGroupCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyCategoryGroupsOrderBy>>;
};


export type PlatbyGroupPlatbyGroupSkupinasByPgsIdGroupArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyGroupSkupinaCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyGroupSkupinasOrderBy>>;
};

/**
 * A condition to be used against `PlatbyGroup` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PlatbyGroupCondition = {
  /** Checks for equality with the object’s `pgBase` field. */
  pgBase?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pgDescription` field. */
  pgDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `pgId` field. */
  pgId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pgName` field. */
  pgName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `pgType` field. */
  pgType?: InputMaybe<Scalars['BigFloat']>;
};

/** An input for mutations affecting `PlatbyGroup` */
export type PlatbyGroupInput = {
  pgBase?: InputMaybe<Scalars['BigInt']>;
  pgDescription: Scalars['String'];
  pgId?: InputMaybe<Scalars['BigInt']>;
  pgName: Scalars['String'];
  pgType?: InputMaybe<Scalars['BigFloat']>;
};

/** Represents an update to a `PlatbyGroup`. Fields that are set will be updated. */
export type PlatbyGroupPatch = {
  pgBase?: InputMaybe<Scalars['BigInt']>;
  pgDescription?: InputMaybe<Scalars['String']>;
  pgId?: InputMaybe<Scalars['BigInt']>;
  pgName?: InputMaybe<Scalars['String']>;
  pgType?: InputMaybe<Scalars['BigFloat']>;
};

/** A connection to a list of `PlatbyGroup` values. */
export type PlatbyGroupsConnection = {
  __typename?: 'PlatbyGroupsConnection';
  /** A list of edges which contains the `PlatbyGroup` and cursor to aid in pagination. */
  edges: Array<PlatbyGroupsEdge>;
  /** A list of `PlatbyGroup` objects. */
  nodes: Array<PlatbyGroup>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PlatbyGroup` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PlatbyGroup` edge in the connection. */
export type PlatbyGroupsEdge = {
  __typename?: 'PlatbyGroupsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `PlatbyGroup` at the end of the edge. */
  node: PlatbyGroup;
};

export type PlatbyGroupSkupina = Node & {
  __typename?: 'PlatbyGroupSkupina';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  pgsId: Scalars['BigInt'];
  pgsIdGroup: Scalars['BigInt'];
  pgsIdSkupina: Scalars['BigInt'];
  /** Reads a single `PlatbyGroup` that is related to this `PlatbyGroupSkupina`. */
  platbyGroupByPgsIdGroup: Maybe<PlatbyGroup>;
  /** Reads a single `Skupiny` that is related to this `PlatbyGroupSkupina`. */
  skupinyByPgsIdSkupina: Maybe<Skupiny>;
};

/**
 * A condition to be used against `PlatbyGroupSkupina` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PlatbyGroupSkupinaCondition = {
  /** Checks for equality with the object’s `pgsId` field. */
  pgsId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pgsIdGroup` field. */
  pgsIdGroup?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pgsIdSkupina` field. */
  pgsIdSkupina?: InputMaybe<Scalars['BigInt']>;
};

/** An input for mutations affecting `PlatbyGroupSkupina` */
export type PlatbyGroupSkupinaInput = {
  pgsId?: InputMaybe<Scalars['BigInt']>;
  pgsIdGroup: Scalars['BigInt'];
  pgsIdSkupina: Scalars['BigInt'];
};

/** Represents an update to a `PlatbyGroupSkupina`. Fields that are set will be updated. */
export type PlatbyGroupSkupinaPatch = {
  pgsId?: InputMaybe<Scalars['BigInt']>;
  pgsIdGroup?: InputMaybe<Scalars['BigInt']>;
  pgsIdSkupina?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `PlatbyGroupSkupina` values. */
export type PlatbyGroupSkupinasConnection = {
  __typename?: 'PlatbyGroupSkupinasConnection';
  /** A list of edges which contains the `PlatbyGroupSkupina` and cursor to aid in pagination. */
  edges: Array<PlatbyGroupSkupinasEdge>;
  /** A list of `PlatbyGroupSkupina` objects. */
  nodes: Array<PlatbyGroupSkupina>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PlatbyGroupSkupina` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PlatbyGroupSkupina` edge in the connection. */
export type PlatbyGroupSkupinasEdge = {
  __typename?: 'PlatbyGroupSkupinasEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `PlatbyGroupSkupina` at the end of the edge. */
  node: PlatbyGroupSkupina;
};

/** Methods to use when ordering `PlatbyGroupSkupina`. */
export enum PlatbyGroupSkupinasOrderBy {
  Natural = 'NATURAL',
  PgsIdAsc = 'PGS_ID_ASC',
  PgsIdDesc = 'PGS_ID_DESC',
  PgsIdGroupAsc = 'PGS_ID_GROUP_ASC',
  PgsIdGroupDesc = 'PGS_ID_GROUP_DESC',
  PgsIdSkupinaAsc = 'PGS_ID_SKUPINA_ASC',
  PgsIdSkupinaDesc = 'PGS_ID_SKUPINA_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Methods to use when ordering `PlatbyGroup`. */
export enum PlatbyGroupsOrderBy {
  Natural = 'NATURAL',
  PgBaseAsc = 'PG_BASE_ASC',
  PgBaseDesc = 'PG_BASE_DESC',
  PgDescriptionAsc = 'PG_DESCRIPTION_ASC',
  PgDescriptionDesc = 'PG_DESCRIPTION_DESC',
  PgIdAsc = 'PG_ID_ASC',
  PgIdDesc = 'PG_ID_DESC',
  PgNameAsc = 'PG_NAME_ASC',
  PgNameDesc = 'PG_NAME_DESC',
  PgTypeAsc = 'PG_TYPE_ASC',
  PgTypeDesc = 'PG_TYPE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type PlatbyItem = Node & {
  __typename?: 'PlatbyItem';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  piAmount: Scalars['BigFloat'];
  piDate: Scalars['Date'];
  piId: Scalars['BigInt'];
  piIdCategory: Scalars['BigInt'];
  piIdRaw: Maybe<Scalars['BigInt']>;
  piIdUser: Maybe<Scalars['BigInt']>;
  piPrefix: Scalars['Int'];
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
  platbyCategoryByPiIdCategory: Maybe<PlatbyCategory>;
  /** Reads a single `PlatbyRaw` that is related to this `PlatbyItem`. */
  platbyRawByPiIdRaw: Maybe<PlatbyRaw>;
  /** Reads a single `User` that is related to this `PlatbyItem`. */
  userByPiIdUser: Maybe<User>;
};

/**
 * A condition to be used against `PlatbyItem` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PlatbyItemCondition = {
  /** Checks for equality with the object’s `piAmount` field. */
  piAmount?: InputMaybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `piDate` field. */
  piDate?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `piId` field. */
  piId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `piIdCategory` field. */
  piIdCategory?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `piIdRaw` field. */
  piIdRaw?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `piIdUser` field. */
  piIdUser?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `piPrefix` field. */
  piPrefix?: InputMaybe<Scalars['Int']>;
};

/** An input for mutations affecting `PlatbyItem` */
export type PlatbyItemInput = {
  piAmount: Scalars['BigFloat'];
  piDate: Scalars['Date'];
  piId?: InputMaybe<Scalars['BigInt']>;
  piIdCategory: Scalars['BigInt'];
  piIdRaw?: InputMaybe<Scalars['BigInt']>;
  piIdUser?: InputMaybe<Scalars['BigInt']>;
  piPrefix?: InputMaybe<Scalars['Int']>;
};

/** Represents an update to a `PlatbyItem`. Fields that are set will be updated. */
export type PlatbyItemPatch = {
  piAmount?: InputMaybe<Scalars['BigFloat']>;
  piDate?: InputMaybe<Scalars['Date']>;
  piId?: InputMaybe<Scalars['BigInt']>;
  piIdCategory?: InputMaybe<Scalars['BigInt']>;
  piIdRaw?: InputMaybe<Scalars['BigInt']>;
  piIdUser?: InputMaybe<Scalars['BigInt']>;
  piPrefix?: InputMaybe<Scalars['Int']>;
};

/** A connection to a list of `PlatbyItem` values. */
export type PlatbyItemsConnection = {
  __typename?: 'PlatbyItemsConnection';
  /** A list of edges which contains the `PlatbyItem` and cursor to aid in pagination. */
  edges: Array<PlatbyItemsEdge>;
  /** A list of `PlatbyItem` objects. */
  nodes: Array<PlatbyItem>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PlatbyItem` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PlatbyItem` edge in the connection. */
export type PlatbyItemsEdge = {
  __typename?: 'PlatbyItemsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `PlatbyItem` at the end of the edge. */
  node: PlatbyItem;
};

/** Methods to use when ordering `PlatbyItem`. */
export enum PlatbyItemsOrderBy {
  Natural = 'NATURAL',
  PiAmountAsc = 'PI_AMOUNT_ASC',
  PiAmountDesc = 'PI_AMOUNT_DESC',
  PiDateAsc = 'PI_DATE_ASC',
  PiDateDesc = 'PI_DATE_DESC',
  PiIdAsc = 'PI_ID_ASC',
  PiIdCategoryAsc = 'PI_ID_CATEGORY_ASC',
  PiIdCategoryDesc = 'PI_ID_CATEGORY_DESC',
  PiIdDesc = 'PI_ID_DESC',
  PiIdRawAsc = 'PI_ID_RAW_ASC',
  PiIdRawDesc = 'PI_ID_RAW_DESC',
  PiIdUserAsc = 'PI_ID_USER_ASC',
  PiIdUserDesc = 'PI_ID_USER_DESC',
  PiPrefixAsc = 'PI_PREFIX_ASC',
  PiPrefixDesc = 'PI_PREFIX_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type PlatbyRaw = Node & {
  __typename?: 'PlatbyRaw';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads and enables pagination through a set of `PlatbyItem`. */
  platbyItemsByPiIdRaw: PlatbyItemsConnection;
  prDiscarded: Scalars['Boolean'];
  prHash: Scalars['String'];
  prId: Scalars['BigInt'];
  prRaw: Scalars['String'];
  prSorted: Scalars['Boolean'];
};


export type PlatbyRawPlatbyItemsByPiIdRawArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyItemsOrderBy>>;
};

/**
 * A condition to be used against `PlatbyRaw` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PlatbyRawCondition = {
  /** Checks for equality with the object’s `prDiscarded` field. */
  prDiscarded?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `prHash` field. */
  prHash?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `prId` field. */
  prId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `prRaw` field. */
  prRaw?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `prSorted` field. */
  prSorted?: InputMaybe<Scalars['Boolean']>;
};

/** An input for mutations affecting `PlatbyRaw` */
export type PlatbyRawInput = {
  prDiscarded?: InputMaybe<Scalars['Boolean']>;
  prHash: Scalars['String'];
  prId?: InputMaybe<Scalars['BigInt']>;
  prRaw: Scalars['String'];
  prSorted?: InputMaybe<Scalars['Boolean']>;
};

/** Represents an update to a `PlatbyRaw`. Fields that are set will be updated. */
export type PlatbyRawPatch = {
  prDiscarded?: InputMaybe<Scalars['Boolean']>;
  prHash?: InputMaybe<Scalars['String']>;
  prId?: InputMaybe<Scalars['BigInt']>;
  prRaw?: InputMaybe<Scalars['String']>;
  prSorted?: InputMaybe<Scalars['Boolean']>;
};

/** A connection to a list of `PlatbyRaw` values. */
export type PlatbyRawsConnection = {
  __typename?: 'PlatbyRawsConnection';
  /** A list of edges which contains the `PlatbyRaw` and cursor to aid in pagination. */
  edges: Array<PlatbyRawsEdge>;
  /** A list of `PlatbyRaw` objects. */
  nodes: Array<PlatbyRaw>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PlatbyRaw` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PlatbyRaw` edge in the connection. */
export type PlatbyRawsEdge = {
  __typename?: 'PlatbyRawsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `PlatbyRaw` at the end of the edge. */
  node: PlatbyRaw;
};

/** Methods to use when ordering `PlatbyRaw`. */
export enum PlatbyRawsOrderBy {
  Natural = 'NATURAL',
  PrDiscardedAsc = 'PR_DISCARDED_ASC',
  PrDiscardedDesc = 'PR_DISCARDED_DESC',
  PrHashAsc = 'PR_HASH_ASC',
  PrHashDesc = 'PR_HASH_DESC',
  PrIdAsc = 'PR_ID_ASC',
  PrIdDesc = 'PR_ID_DESC',
  PrRawAsc = 'PR_RAW_ASC',
  PrRawDesc = 'PR_RAW_DESC',
  PrSortedAsc = 'PR_SORTED_ASC',
  PrSortedDesc = 'PR_SORTED_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type ProspectDatum = {
  __typename?: 'ProspectDatum';
  email: Maybe<Scalars['String']>;
  name: Maybe<Scalars['String']>;
  phone: Maybe<Scalars['String']>;
  surname: Maybe<Scalars['String']>;
  yearofbirth: Maybe<Scalars['String']>;
};

/** An input for mutations affecting `ProspectDatum` */
export type ProspectDatumInput = {
  email?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  phone?: InputMaybe<Scalars['String']>;
  surname?: InputMaybe<Scalars['String']>;
  yearofbirth?: InputMaybe<Scalars['String']>;
};

/** All input for the `prospectFormDancer` mutation. */
export type ProspectFormDancerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  cohort: CrmCohort;
  note: Scalars['String'];
  origin: Scalars['String'];
  prospectData: ProspectDatumInput;
};

/** The output of our `prospectFormDancer` mutation. */
export type ProspectFormDancerPayload = {
  __typename?: 'ProspectFormDancerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** The root query type which gives access points into the data universe. */
export type Query = Node & {
  __typename?: 'Query';
  /** Reads and enables pagination through a set of `Pary`. */
  activeCouples: Maybe<PariesConnection>;
  activeProspects: Maybe<ActiveProspectsConnection>;
  akce: Maybe<Akce>;
  /** Reads a single `Akce` using its globally unique `ID`. */
  akceByNodeId: Maybe<Akce>;
  akceItem: Maybe<AkceItem>;
  /** Reads a single `AkceItem` using its globally unique `ID`. */
  akceItemByNodeId: Maybe<AkceItem>;
  /** Reads and enables pagination through a set of `AkceItem`. */
  akceItems: Maybe<AkceItemsConnection>;
  /** Reads and enables pagination through a set of `Akce`. */
  akces: Maybe<AkcesConnection>;
  /** Reads and enables pagination through a set of `Aktuality`. */
  aktualities: Maybe<AktualitiesConnection>;
  aktuality: Maybe<Aktuality>;
  /** Reads a single `Aktuality` using its globally unique `ID`. */
  aktualityByNodeId: Maybe<Aktuality>;
  currentCoupleIds: Maybe<CurrentCoupleIdsConnection>;
  /** Reads and enables pagination through a set of `Permission`. */
  currentPermissions: Maybe<PermissionsConnection>;
  currentSessionId: Maybe<Scalars['String']>;
  currentUserId: Maybe<Scalars['BigInt']>;
  /** Reads and enables pagination through a set of `Dokumenty`. */
  dokumenties: Maybe<DokumentiesConnection>;
  dokumenty: Maybe<Dokumenty>;
  /** Reads a single `Dokumenty` using its globally unique `ID`. */
  dokumentyByNodeId: Maybe<Dokumenty>;
  galerieDir: Maybe<GalerieDir>;
  /** Reads a single `GalerieDir` using its globally unique `ID`. */
  galerieDirByNodeId: Maybe<GalerieDir>;
  /** Reads and enables pagination through a set of `GalerieDir`. */
  galerieDirs: Maybe<GalerieDirsConnection>;
  galerieFoto: Maybe<GalerieFoto>;
  /** Reads a single `GalerieFoto` using its globally unique `ID`. */
  galerieFotoByNodeId: Maybe<GalerieFoto>;
  /** Reads and enables pagination through a set of `GalerieFoto`. */
  galerieFotos: Maybe<GalerieFotosConnection>;
  getCurrentUser: Maybe<User>;
  /** Reads and enables pagination through a set of `Member`. */
  members: Maybe<MembersConnection>;
  /** Reads and enables pagination through a set of `RozpisItem`. */
  myLessons: Maybe<RozpisItemsConnection>;
  nabidka: Maybe<Nabidka>;
  /** Reads a single `Nabidka` using its globally unique `ID`. */
  nabidkaByNodeId: Maybe<Nabidka>;
  nabidkaItem: Maybe<NabidkaItem>;
  /** Reads a single `NabidkaItem` using its globally unique `ID`. */
  nabidkaItemByNodeId: Maybe<NabidkaItem>;
  /** Reads and enables pagination through a set of `NabidkaItem`. */
  nabidkaItems: Maybe<NabidkaItemsConnection>;
  /** Reads and enables pagination through a set of `Nabidka`. */
  nabidkas: Maybe<NabidkasConnection>;
  /** Fetches an object given its globally unique `ID`. */
  node: Maybe<Node>;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID'];
  page: Maybe<Page>;
  /** Reads a single `Page` using its globally unique `ID`. */
  pageByNodeId: Maybe<Page>;
  pageByUrl: Maybe<Page>;
  pageRevision: Maybe<PageRevision>;
  /** Reads a single `PageRevision` using its globally unique `ID`. */
  pageRevisionByNodeId: Maybe<PageRevision>;
  /** Reads and enables pagination through a set of `PageRevision`. */
  pageRevisions: Maybe<PageRevisionsConnection>;
  /** Reads and enables pagination through a set of `Page`. */
  pages: Maybe<PagesConnection>;
  parameter: Maybe<Parameter>;
  /** Reads a single `Parameter` using its globally unique `ID`. */
  parameterByNodeId: Maybe<Parameter>;
  /** Reads and enables pagination through a set of `Parameter`. */
  parameters: Maybe<ParametersConnection>;
  /** Reads and enables pagination through a set of `Pary`. */
  paries: Maybe<PariesConnection>;
  pary: Maybe<Pary>;
  /** Reads a single `Pary` using its globally unique `ID`. */
  paryByNodeId: Maybe<Pary>;
  paryNavrh: Maybe<ParyNavrh>;
  /** Reads a single `ParyNavrh` using its globally unique `ID`. */
  paryNavrhByNodeId: Maybe<ParyNavrh>;
  /** Reads and enables pagination through a set of `ParyNavrh`. */
  paryNavrhs: Maybe<ParyNavrhsConnection>;
  permission: Maybe<Permission>;
  /** Reads a single `Permission` using its globally unique `ID`. */
  permissionByNodeId: Maybe<Permission>;
  /** Reads and enables pagination through a set of `Permission`. */
  permissions: Maybe<PermissionsConnection>;
  /** Reads and enables pagination through a set of `PlatbyCategory`. */
  platbyCategories: Maybe<PlatbyCategoriesConnection>;
  platbyCategory: Maybe<PlatbyCategory>;
  /** Reads a single `PlatbyCategory` using its globally unique `ID`. */
  platbyCategoryByNodeId: Maybe<PlatbyCategory>;
  platbyCategoryGroup: Maybe<PlatbyCategoryGroup>;
  /** Reads a single `PlatbyCategoryGroup` using its globally unique `ID`. */
  platbyCategoryGroupByNodeId: Maybe<PlatbyCategoryGroup>;
  /** Reads and enables pagination through a set of `PlatbyCategoryGroup`. */
  platbyCategoryGroups: Maybe<PlatbyCategoryGroupsConnection>;
  platbyGroup: Maybe<PlatbyGroup>;
  /** Reads a single `PlatbyGroup` using its globally unique `ID`. */
  platbyGroupByNodeId: Maybe<PlatbyGroup>;
  /** Reads and enables pagination through a set of `PlatbyGroup`. */
  platbyGroups: Maybe<PlatbyGroupsConnection>;
  platbyGroupSkupina: Maybe<PlatbyGroupSkupina>;
  /** Reads a single `PlatbyGroupSkupina` using its globally unique `ID`. */
  platbyGroupSkupinaByNodeId: Maybe<PlatbyGroupSkupina>;
  /** Reads and enables pagination through a set of `PlatbyGroupSkupina`. */
  platbyGroupSkupinas: Maybe<PlatbyGroupSkupinasConnection>;
  platbyItem: Maybe<PlatbyItem>;
  /** Reads a single `PlatbyItem` using its globally unique `ID`. */
  platbyItemByNodeId: Maybe<PlatbyItem>;
  /** Reads and enables pagination through a set of `PlatbyItem`. */
  platbyItems: Maybe<PlatbyItemsConnection>;
  platbyRaw: Maybe<PlatbyRaw>;
  /** Reads a single `PlatbyRaw` using its globally unique `ID`. */
  platbyRawByNodeId: Maybe<PlatbyRaw>;
  /** Reads and enables pagination through a set of `PlatbyRaw`. */
  platbyRaws: Maybe<PlatbyRawsConnection>;
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
  /** Reads and enables pagination through a set of `Nabidka`. */
  reservationsForRange: Maybe<NabidkasConnection>;
  rozpi: Maybe<Rozpi>;
  /** Reads a single `Rozpi` using its globally unique `ID`. */
  rozpiByNodeId: Maybe<Rozpi>;
  /** Reads and enables pagination through a set of `Rozpi`. */
  rozpis: Maybe<RozpisConnection>;
  rozpisItem: Maybe<RozpisItem>;
  /** Reads a single `RozpisItem` using its globally unique `ID`. */
  rozpisItemByNodeId: Maybe<RozpisItem>;
  /** Reads and enables pagination through a set of `RozpisItem`. */
  rozpisItems: Maybe<RozpisItemsConnection>;
  /** Reads and enables pagination through a set of `Rozpi`. */
  schedulesForRange: Maybe<RozpisConnection>;
  session: Maybe<Session>;
  /** Reads a single `Session` using its globally unique `ID`. */
  sessionByNodeId: Maybe<Session>;
  /** Reads and enables pagination through a set of `Session`. */
  sessions: Maybe<SessionsConnection>;
  /** Reads and enables pagination through a set of `Skupiny`. */
  skupinies: Maybe<SkupiniesConnection>;
  skupiny: Maybe<Skupiny>;
  /** Reads a single `Skupiny` using its globally unique `ID`. */
  skupinyByNodeId: Maybe<Skupiny>;
  /** Reads and enables pagination through a set of `Video`. */
  titleVideos: Maybe<VideosConnection>;
  /** Reads and enables pagination through a set of `User`. */
  trainers: Maybe<UsersConnection>;
  upozorneni: Maybe<Upozorneni>;
  /** Reads a single `Upozorneni` using its globally unique `ID`. */
  upozorneniByNodeId: Maybe<Upozorneni>;
  /** Reads and enables pagination through a set of `Upozorneni`. */
  upozornenis: Maybe<UpozornenisConnection>;
  /** Reads and enables pagination through a set of `UpozorneniSkupiny`. */
  upozorneniSkupinies: Maybe<UpozorneniSkupiniesConnection>;
  upozorneniSkupiny: Maybe<UpozorneniSkupiny>;
  /** Reads a single `UpozorneniSkupiny` using its globally unique `ID`. */
  upozorneniSkupinyByNodeId: Maybe<UpozorneniSkupiny>;
  user: Maybe<User>;
  /** Reads a single `User` using its globally unique `ID`. */
  userByNodeId: Maybe<User>;
  /** Reads and enables pagination through a set of `User`. */
  users: Maybe<UsersConnection>;
  video: Maybe<Video>;
  /** Reads a single `Video` using its globally unique `ID`. */
  videoByNodeId: Maybe<Video>;
  videoList: Maybe<VideoList>;
  /** Reads a single `VideoList` using its globally unique `ID`. */
  videoListByNodeId: Maybe<VideoList>;
  /** Reads and enables pagination through a set of `VideoList`. */
  videoLists: Maybe<VideoListsConnection>;
  /** Reads and enables pagination through a set of `Video`. */
  videos: Maybe<VideosConnection>;
  videoSource: Maybe<VideoSource>;
  /** Reads a single `VideoSource` using its globally unique `ID`. */
  videoSourceByNodeId: Maybe<VideoSource>;
  /** Reads and enables pagination through a set of `VideoSource`. */
  videoSources: Maybe<VideoSourcesConnection>;
};


/** The root query type which gives access points into the data universe. */
export type QueryActiveCouplesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryActiveProspectsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAkceArgs = {
  aId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAkceByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAkceItemArgs = {
  aiId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAkceItemByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAkceItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AkceItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AkceItemsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAkcesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AkceCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AkcesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAktualitiesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AktualityCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AktualitiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAktualityArgs = {
  atId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAktualityByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCurrentCoupleIdsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCurrentPermissionsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDokumentiesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<DokumentyCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<DokumentiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDokumentyArgs = {
  dId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDokumentyByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGalerieDirArgs = {
  gdId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGalerieDirByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGalerieDirsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<GalerieDirCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GalerieDirsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGalerieFotoArgs = {
  gfId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGalerieFotoByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGalerieFotosArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<GalerieFotoCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GalerieFotosOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMembersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<MemberCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<MembersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMyLessonsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  endDate?: InputMaybe<Scalars['Date']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  startDate?: InputMaybe<Scalars['Date']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNabidkaArgs = {
  nId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNabidkaByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNabidkaItemArgs = {
  niId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNabidkaItemByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNabidkaItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<NabidkaItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<NabidkaItemsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNabidkasArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<NabidkaCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<NabidkasOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNodeArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPageArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPageByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPageByUrlArgs = {
  url: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPageRevisionArgs = {
  id: Scalars['Int'];
  revNumber: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPageRevisionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPageRevisionsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PageRevisionCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PageRevisionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPagesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PageCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PagesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryParameterArgs = {
  paName: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryParameterByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryParametersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<ParameterCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ParametersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPariesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<ParyCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PariesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryParyArgs = {
  pId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryParyByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryParyNavrhArgs = {
  pnId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryParyNavrhByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryParyNavrhsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<ParyNavrhCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ParyNavrhsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionArgs = {
  peId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PermissionCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyCategoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyCategoryCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyCategoriesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyCategoryArgs = {
  pcId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyCategoryByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyCategoryGroupArgs = {
  pcgId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyCategoryGroupByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyCategoryGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyCategoryGroupCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyCategoryGroupsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyGroupArgs = {
  pgId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyGroupByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyGroupCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyGroupsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyGroupSkupinaArgs = {
  pgsId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyGroupSkupinaByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyGroupSkupinasArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyGroupSkupinaCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyGroupSkupinasOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyItemArgs = {
  piId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyItemByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyItemsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyRawArgs = {
  prId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyRawByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyRawsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyRawCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyRawsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReservationsForRangeArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  endDate?: InputMaybe<Scalars['Date']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  startDate?: InputMaybe<Scalars['Date']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRozpiArgs = {
  rId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRozpiByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRozpisArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<RozpiCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RozpisOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRozpisItemArgs = {
  riId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRozpisItemByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRozpisItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<RozpisItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RozpisItemsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySchedulesForRangeArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  endDate?: InputMaybe<Scalars['Date']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  startDate?: InputMaybe<Scalars['Date']>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySessionArgs = {
  ssId: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySessionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySessionsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<SessionCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SessionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySkupiniesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<SkupinyCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SkupiniesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySkupinyArgs = {
  sId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySkupinyByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTitleVideosArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTrainersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUpozorneniArgs = {
  upId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUpozorneniByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUpozornenisArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<UpozorneniCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UpozornenisOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUpozorneniSkupiniesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<UpozorneniSkupinyCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UpozorneniSkupiniesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUpozorneniSkupinyArgs = {
  upsId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUpozorneniSkupinyByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserArgs = {
  uId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<UserCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVideoArgs = {
  vId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVideoByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVideoListArgs = {
  vlId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVideoListByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVideoListsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<VideoListCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VideoListsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVideosArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<VideoCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VideosOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVideoSourceArgs = {
  vsId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVideoSourceByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVideoSourcesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<VideoSourceCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VideoSourcesOrderBy>>;
};

/** All input for the `resetPassword` mutation. */
export type ResetPasswordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  email: Scalars['String'];
  login: Scalars['String'];
};

/** The output of our `resetPassword` mutation. */
export type ResetPasswordPayload = {
  __typename?: 'ResetPasswordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type Rozpi = Node & {
  __typename?: 'Rozpi';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  rDatum: Scalars['Date'];
  rId: Scalars['BigInt'];
  rKde: Scalars['String'];
  rLock: Scalars['Boolean'];
  /** Reads and enables pagination through a set of `RozpisItem`. */
  rozpisItemsByRiIdRodic: RozpisItemsConnection;
  rTimestamp: Maybe<Scalars['Datetime']>;
  rTrener: Scalars['BigInt'];
  rVisible: Scalars['Boolean'];
  /** Reads a single `User` that is related to this `Rozpi`. */
  userByRTrener: Maybe<User>;
};


export type RozpiRozpisItemsByRiIdRodicArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<RozpisItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RozpisItemsOrderBy>>;
};

/** A condition to be used against `Rozpi` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type RozpiCondition = {
  /** Checks for equality with the object’s `rDatum` field. */
  rDatum?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `rId` field. */
  rId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `rKde` field. */
  rKde?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `rLock` field. */
  rLock?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `rTimestamp` field. */
  rTimestamp?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `rTrener` field. */
  rTrener?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `rVisible` field. */
  rVisible?: InputMaybe<Scalars['Boolean']>;
};

/** An input for mutations affecting `Rozpi` */
export type RozpiInput = {
  rDatum: Scalars['Date'];
  rId?: InputMaybe<Scalars['BigInt']>;
  rKde: Scalars['String'];
  rLock?: InputMaybe<Scalars['Boolean']>;
  rTimestamp?: InputMaybe<Scalars['Datetime']>;
  rTrener: Scalars['BigInt'];
  rVisible?: InputMaybe<Scalars['Boolean']>;
};

/** Represents an update to a `Rozpi`. Fields that are set will be updated. */
export type RozpiPatch = {
  rDatum?: InputMaybe<Scalars['Date']>;
  rId?: InputMaybe<Scalars['BigInt']>;
  rKde?: InputMaybe<Scalars['String']>;
  rLock?: InputMaybe<Scalars['Boolean']>;
  rTimestamp?: InputMaybe<Scalars['Datetime']>;
  rTrener?: InputMaybe<Scalars['BigInt']>;
  rVisible?: InputMaybe<Scalars['Boolean']>;
};

/** A connection to a list of `Rozpi` values. */
export type RozpisConnection = {
  __typename?: 'RozpisConnection';
  /** A list of edges which contains the `Rozpi` and cursor to aid in pagination. */
  edges: Array<RozpisEdge>;
  /** A list of `Rozpi` objects. */
  nodes: Array<Rozpi>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Rozpi` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Rozpi` edge in the connection. */
export type RozpisEdge = {
  __typename?: 'RozpisEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Rozpi` at the end of the edge. */
  node: Rozpi;
};

export type RozpisItem = Node & {
  __typename?: 'RozpisItem';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `Pary` that is related to this `RozpisItem`. */
  paryByRiPartner: Maybe<Pary>;
  riDo: Scalars['Time'];
  riId: Scalars['BigInt'];
  riIdRodic: Scalars['BigInt'];
  riLock: Scalars['Boolean'];
  riOd: Scalars['Time'];
  riPartner: Maybe<Scalars['BigInt']>;
  /** Reads a single `Rozpi` that is related to this `RozpisItem`. */
  rozpiByRiIdRodic: Maybe<Rozpi>;
};

/**
 * A condition to be used against `RozpisItem` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type RozpisItemCondition = {
  /** Checks for equality with the object’s `riDo` field. */
  riDo?: InputMaybe<Scalars['Time']>;
  /** Checks for equality with the object’s `riId` field. */
  riId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `riIdRodic` field. */
  riIdRodic?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `riLock` field. */
  riLock?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `riOd` field. */
  riOd?: InputMaybe<Scalars['Time']>;
  /** Checks for equality with the object’s `riPartner` field. */
  riPartner?: InputMaybe<Scalars['BigInt']>;
};

/** An input for mutations affecting `RozpisItem` */
export type RozpisItemInput = {
  riDo: Scalars['Time'];
  riId?: InputMaybe<Scalars['BigInt']>;
  riIdRodic: Scalars['BigInt'];
  riLock?: InputMaybe<Scalars['Boolean']>;
  riOd: Scalars['Time'];
  riPartner?: InputMaybe<Scalars['BigInt']>;
};

/** Represents an update to a `RozpisItem`. Fields that are set will be updated. */
export type RozpisItemPatch = {
  riDo?: InputMaybe<Scalars['Time']>;
  riId?: InputMaybe<Scalars['BigInt']>;
  riIdRodic?: InputMaybe<Scalars['BigInt']>;
  riLock?: InputMaybe<Scalars['Boolean']>;
  riOd?: InputMaybe<Scalars['Time']>;
  riPartner?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `RozpisItem` values. */
export type RozpisItemsConnection = {
  __typename?: 'RozpisItemsConnection';
  /** A list of edges which contains the `RozpisItem` and cursor to aid in pagination. */
  edges: Array<RozpisItemsEdge>;
  /** A list of `RozpisItem` objects. */
  nodes: Array<RozpisItem>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `RozpisItem` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `RozpisItem` edge in the connection. */
export type RozpisItemsEdge = {
  __typename?: 'RozpisItemsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `RozpisItem` at the end of the edge. */
  node: RozpisItem;
};

/** Methods to use when ordering `RozpisItem`. */
export enum RozpisItemsOrderBy {
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RiDoAsc = 'RI_DO_ASC',
  RiDoDesc = 'RI_DO_DESC',
  RiIdAsc = 'RI_ID_ASC',
  RiIdDesc = 'RI_ID_DESC',
  RiIdRodicAsc = 'RI_ID_RODIC_ASC',
  RiIdRodicDesc = 'RI_ID_RODIC_DESC',
  RiLockAsc = 'RI_LOCK_ASC',
  RiLockDesc = 'RI_LOCK_DESC',
  RiOdAsc = 'RI_OD_ASC',
  RiOdDesc = 'RI_OD_DESC',
  RiPartnerAsc = 'RI_PARTNER_ASC',
  RiPartnerDesc = 'RI_PARTNER_DESC'
}

/** Methods to use when ordering `Rozpi`. */
export enum RozpisOrderBy {
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RDatumAsc = 'R_DATUM_ASC',
  RDatumDesc = 'R_DATUM_DESC',
  RIdAsc = 'R_ID_ASC',
  RIdDesc = 'R_ID_DESC',
  RKdeAsc = 'R_KDE_ASC',
  RKdeDesc = 'R_KDE_DESC',
  RLockAsc = 'R_LOCK_ASC',
  RLockDesc = 'R_LOCK_DESC',
  RTimestampAsc = 'R_TIMESTAMP_ASC',
  RTimestampDesc = 'R_TIMESTAMP_DESC',
  RTrenerAsc = 'R_TRENER_ASC',
  RTrenerDesc = 'R_TRENER_DESC',
  RVisibleAsc = 'R_VISIBLE_ASC',
  RVisibleDesc = 'R_VISIBLE_DESC'
}

export type Session = Node & {
  __typename?: 'Session';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  ssId: Scalars['String'];
  ssLifetime: Scalars['BigInt'];
  ssUpdatedAt: Scalars['Datetime'];
  ssUser: Maybe<Scalars['BigInt']>;
  /** Reads a single `User` that is related to this `Session`. */
  userBySsUser: Maybe<User>;
};

/** A condition to be used against `Session` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type SessionCondition = {
  /** Checks for equality with the object’s `ssId` field. */
  ssId?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `ssLifetime` field. */
  ssLifetime?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `ssUpdatedAt` field. */
  ssUpdatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `ssUser` field. */
  ssUser?: InputMaybe<Scalars['BigInt']>;
};

/** An input for mutations affecting `Session` */
export type SessionInput = {
  ssId: Scalars['String'];
  ssLifetime: Scalars['BigInt'];
  ssUpdatedAt?: InputMaybe<Scalars['Datetime']>;
  ssUser?: InputMaybe<Scalars['BigInt']>;
};

/** Represents an update to a `Session`. Fields that are set will be updated. */
export type SessionPatch = {
  ssId?: InputMaybe<Scalars['String']>;
  ssLifetime?: InputMaybe<Scalars['BigInt']>;
  ssUpdatedAt?: InputMaybe<Scalars['Datetime']>;
  ssUser?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `Session` values. */
export type SessionsConnection = {
  __typename?: 'SessionsConnection';
  /** A list of edges which contains the `Session` and cursor to aid in pagination. */
  edges: Array<SessionsEdge>;
  /** A list of `Session` objects. */
  nodes: Array<Session>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Session` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Session` edge in the connection. */
export type SessionsEdge = {
  __typename?: 'SessionsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Session` at the end of the edge. */
  node: Session;
};

/** Methods to use when ordering `Session`. */
export enum SessionsOrderBy {
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SsIdAsc = 'SS_ID_ASC',
  SsIdDesc = 'SS_ID_DESC',
  SsLifetimeAsc = 'SS_LIFETIME_ASC',
  SsLifetimeDesc = 'SS_LIFETIME_DESC',
  SsUpdatedAtAsc = 'SS_UPDATED_AT_ASC',
  SsUpdatedAtDesc = 'SS_UPDATED_AT_DESC',
  SsUserAsc = 'SS_USER_ASC',
  SsUserDesc = 'SS_USER_DESC'
}

/** A connection to a list of `Skupiny` values. */
export type SkupiniesConnection = {
  __typename?: 'SkupiniesConnection';
  /** A list of edges which contains the `Skupiny` and cursor to aid in pagination. */
  edges: Array<SkupiniesEdge>;
  /** A list of `Skupiny` objects. */
  nodes: Array<Skupiny>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Skupiny` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Skupiny` edge in the connection. */
export type SkupiniesEdge = {
  __typename?: 'SkupiniesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Skupiny` at the end of the edge. */
  node: Skupiny;
};

/** Methods to use when ordering `Skupiny`. */
export enum SkupiniesOrderBy {
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SColorRgbAsc = 'S_COLOR_RGB_ASC',
  SColorRgbDesc = 'S_COLOR_RGB_DESC',
  SColorTextAsc = 'S_COLOR_TEXT_ASC',
  SColorTextDesc = 'S_COLOR_TEXT_DESC',
  SDescriptionAsc = 'S_DESCRIPTION_ASC',
  SDescriptionDesc = 'S_DESCRIPTION_DESC',
  SIdAsc = 'S_ID_ASC',
  SIdDesc = 'S_ID_DESC',
  SLocationAsc = 'S_LOCATION_ASC',
  SLocationDesc = 'S_LOCATION_DESC',
  SNameAsc = 'S_NAME_ASC',
  SNameDesc = 'S_NAME_DESC',
  SVisibleAsc = 'S_VISIBLE_ASC',
  SVisibleDesc = 'S_VISIBLE_DESC'
}

export type Skupiny = Node & {
  __typename?: 'Skupiny';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads and enables pagination through a set of `PlatbyGroupSkupina`. */
  platbyGroupSkupinasByPgsIdSkupina: PlatbyGroupSkupinasConnection;
  sColorRgb: Scalars['String'];
  sColorText: Scalars['String'];
  sDescription: Scalars['String'];
  sId: Scalars['BigInt'];
  sLocation: Scalars['String'];
  sName: Scalars['String'];
  sVisible: Scalars['Boolean'];
  /** Reads and enables pagination through a set of `UpozorneniSkupiny`. */
  upozorneniSkupiniesByUpsIdSkupina: UpozorneniSkupiniesConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByUSkupina: UsersConnection;
};


export type SkupinyPlatbyGroupSkupinasByPgsIdSkupinaArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyGroupSkupinaCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyGroupSkupinasOrderBy>>;
};


export type SkupinyUpozorneniSkupiniesByUpsIdSkupinaArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<UpozorneniSkupinyCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UpozorneniSkupiniesOrderBy>>;
};


export type SkupinyUsersByUSkupinaArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<UserCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** A condition to be used against `Skupiny` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type SkupinyCondition = {
  /** Checks for equality with the object’s `sColorRgb` field. */
  sColorRgb?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sColorText` field. */
  sColorText?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sDescription` field. */
  sDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sId` field. */
  sId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `sLocation` field. */
  sLocation?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sName` field. */
  sName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `sVisible` field. */
  sVisible?: InputMaybe<Scalars['Boolean']>;
};

/** An input for mutations affecting `Skupiny` */
export type SkupinyInput = {
  sColorRgb: Scalars['String'];
  sColorText: Scalars['String'];
  sDescription: Scalars['String'];
  sId?: InputMaybe<Scalars['BigInt']>;
  sLocation?: InputMaybe<Scalars['String']>;
  sName: Scalars['String'];
  sVisible?: InputMaybe<Scalars['Boolean']>;
};

/** Represents an update to a `Skupiny`. Fields that are set will be updated. */
export type SkupinyPatch = {
  sColorRgb?: InputMaybe<Scalars['String']>;
  sColorText?: InputMaybe<Scalars['String']>;
  sDescription?: InputMaybe<Scalars['String']>;
  sId?: InputMaybe<Scalars['BigInt']>;
  sLocation?: InputMaybe<Scalars['String']>;
  sName?: InputMaybe<Scalars['String']>;
  sVisible?: InputMaybe<Scalars['Boolean']>;
};

/** All input for the `updateAkceByNodeId` mutation. */
export type UpdateAkceByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Akce` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Akce` being updated. */
  patch: AkcePatch;
};

/** All input for the `updateAkce` mutation. */
export type UpdateAkceInput = {
  aId: Scalars['BigInt'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Akce` being updated. */
  patch: AkcePatch;
};

/** All input for the `updateAkceItemByNodeId` mutation. */
export type UpdateAkceItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `AkceItem` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `AkceItem` being updated. */
  patch: AkceItemPatch;
};

/** All input for the `updateAkceItem` mutation. */
export type UpdateAkceItemInput = {
  aiId: Scalars['BigInt'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `AkceItem` being updated. */
  patch: AkceItemPatch;
};

/** The output of our update `AkceItem` mutation. */
export type UpdateAkceItemPayload = {
  __typename?: 'UpdateAkceItemPayload';
  /** Reads a single `Akce` that is related to this `AkceItem`. */
  akceByAiIdRodic: Maybe<Akce>;
  /** The `AkceItem` that was updated by this mutation. */
  akceItem: Maybe<AkceItem>;
  /** An edge for our `AkceItem`. May be used by Relay 1. */
  akceItemEdge: Maybe<AkceItemsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `AkceItem`. */
  userByAiUser: Maybe<User>;
};


/** The output of our update `AkceItem` mutation. */
export type UpdateAkceItemPayloadAkceItemEdgeArgs = {
  orderBy?: InputMaybe<Array<AkceItemsOrderBy>>;
};

/** The output of our update `Akce` mutation. */
export type UpdateAkcePayload = {
  __typename?: 'UpdateAkcePayload';
  /** The `Akce` that was updated by this mutation. */
  akce: Maybe<Akce>;
  /** An edge for our `Akce`. May be used by Relay 1. */
  akceEdge: Maybe<AkcesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Akce` mutation. */
export type UpdateAkcePayloadAkceEdgeArgs = {
  orderBy?: InputMaybe<Array<AkcesOrderBy>>;
};

/** All input for the `updateAktualityByNodeId` mutation. */
export type UpdateAktualityByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Aktuality` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Aktuality` being updated. */
  patch: AktualityPatch;
};

/** All input for the `updateAktuality` mutation. */
export type UpdateAktualityInput = {
  atId: Scalars['BigInt'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Aktuality` being updated. */
  patch: AktualityPatch;
};

/** The output of our update `Aktuality` mutation. */
export type UpdateAktualityPayload = {
  __typename?: 'UpdateAktualityPayload';
  /** The `Aktuality` that was updated by this mutation. */
  aktuality: Maybe<Aktuality>;
  /** An edge for our `Aktuality`. May be used by Relay 1. */
  aktualityEdge: Maybe<AktualitiesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
  galerieFotoByAtFotoMain: Maybe<GalerieFoto>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Aktuality`. */
  userByAtKdo: Maybe<User>;
};


/** The output of our update `Aktuality` mutation. */
export type UpdateAktualityPayloadAktualityEdgeArgs = {
  orderBy?: InputMaybe<Array<AktualitiesOrderBy>>;
};

/** All input for the `updateDokumentyByNodeId` mutation. */
export type UpdateDokumentyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Dokumenty` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Dokumenty` being updated. */
  patch: DokumentyPatch;
};

/** All input for the `updateDokumenty` mutation. */
export type UpdateDokumentyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  dId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `Dokumenty` being updated. */
  patch: DokumentyPatch;
};

/** The output of our update `Dokumenty` mutation. */
export type UpdateDokumentyPayload = {
  __typename?: 'UpdateDokumentyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Dokumenty` that was updated by this mutation. */
  dokumenty: Maybe<Dokumenty>;
  /** An edge for our `Dokumenty`. May be used by Relay 1. */
  dokumentyEdge: Maybe<DokumentiesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Dokumenty`. */
  userByDKdo: Maybe<User>;
};


/** The output of our update `Dokumenty` mutation. */
export type UpdateDokumentyPayloadDokumentyEdgeArgs = {
  orderBy?: InputMaybe<Array<DokumentiesOrderBy>>;
};

/** All input for the `updateGalerieDirByNodeId` mutation. */
export type UpdateGalerieDirByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GalerieDir` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `GalerieDir` being updated. */
  patch: GalerieDirPatch;
};

/** All input for the `updateGalerieDir` mutation. */
export type UpdateGalerieDirInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  gdId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `GalerieDir` being updated. */
  patch: GalerieDirPatch;
};

/** The output of our update `GalerieDir` mutation. */
export type UpdateGalerieDirPayload = {
  __typename?: 'UpdateGalerieDirPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GalerieDir` that was updated by this mutation. */
  galerieDir: Maybe<GalerieDir>;
  /** An edge for our `GalerieDir`. May be used by Relay 1. */
  galerieDirEdge: Maybe<GalerieDirsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `GalerieDir` mutation. */
export type UpdateGalerieDirPayloadGalerieDirEdgeArgs = {
  orderBy?: InputMaybe<Array<GalerieDirsOrderBy>>;
};

/** All input for the `updateGalerieFotoByNodeId` mutation. */
export type UpdateGalerieFotoByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GalerieFoto` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `GalerieFoto` being updated. */
  patch: GalerieFotoPatch;
};

/** All input for the `updateGalerieFoto` mutation. */
export type UpdateGalerieFotoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  gfId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `GalerieFoto` being updated. */
  patch: GalerieFotoPatch;
};

/** The output of our update `GalerieFoto` mutation. */
export type UpdateGalerieFotoPayload = {
  __typename?: 'UpdateGalerieFotoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
  galerieDirByGfIdRodic: Maybe<GalerieDir>;
  /** The `GalerieFoto` that was updated by this mutation. */
  galerieFoto: Maybe<GalerieFoto>;
  /** An edge for our `GalerieFoto`. May be used by Relay 1. */
  galerieFotoEdge: Maybe<GalerieFotosEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `GalerieFoto`. */
  userByGfKdo: Maybe<User>;
};


/** The output of our update `GalerieFoto` mutation. */
export type UpdateGalerieFotoPayloadGalerieFotoEdgeArgs = {
  orderBy?: InputMaybe<Array<GalerieFotosOrderBy>>;
};

/** All input for the `updateNabidkaByNodeId` mutation. */
export type UpdateNabidkaByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Nabidka` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Nabidka` being updated. */
  patch: NabidkaPatch;
};

/** All input for the `updateNabidka` mutation. */
export type UpdateNabidkaInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  nId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `Nabidka` being updated. */
  patch: NabidkaPatch;
};

/** All input for the `updateNabidkaItemByNodeId` mutation. */
export type UpdateNabidkaItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `NabidkaItem` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `NabidkaItem` being updated. */
  patch: NabidkaItemPatch;
};

/** All input for the `updateNabidkaItem` mutation. */
export type UpdateNabidkaItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  niId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `NabidkaItem` being updated. */
  patch: NabidkaItemPatch;
};

/** The output of our update `NabidkaItem` mutation. */
export type UpdateNabidkaItemPayload = {
  __typename?: 'UpdateNabidkaItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Nabidka` that is related to this `NabidkaItem`. */
  nabidkaByNiIdRodic: Maybe<Nabidka>;
  /** The `NabidkaItem` that was updated by this mutation. */
  nabidkaItem: Maybe<NabidkaItem>;
  /** An edge for our `NabidkaItem`. May be used by Relay 1. */
  nabidkaItemEdge: Maybe<NabidkaItemsEdge>;
  /** Reads a single `Pary` that is related to this `NabidkaItem`. */
  paryByNiPartner: Maybe<Pary>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `NabidkaItem` mutation. */
export type UpdateNabidkaItemPayloadNabidkaItemEdgeArgs = {
  orderBy?: InputMaybe<Array<NabidkaItemsOrderBy>>;
};

/** The output of our update `Nabidka` mutation. */
export type UpdateNabidkaPayload = {
  __typename?: 'UpdateNabidkaPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Nabidka` that was updated by this mutation. */
  nabidka: Maybe<Nabidka>;
  /** An edge for our `Nabidka`. May be used by Relay 1. */
  nabidkaEdge: Maybe<NabidkasEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Nabidka`. */
  userByNTrener: Maybe<User>;
};


/** The output of our update `Nabidka` mutation. */
export type UpdateNabidkaPayloadNabidkaEdgeArgs = {
  orderBy?: InputMaybe<Array<NabidkasOrderBy>>;
};

/** All input for the `updatePageByNodeId` mutation. */
export type UpdatePageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Page` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Page` being updated. */
  patch: PagePatch;
};

/** All input for the `updatePageByUrl` mutation. */
export type UpdatePageByUrlInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Page` being updated. */
  patch: PagePatch;
  url: Scalars['String'];
};

/** All input for the `updatePage` mutation. */
export type UpdatePageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `Page` being updated. */
  patch: PagePatch;
};

/** The output of our update `Page` mutation. */
export type UpdatePagePayload = {
  __typename?: 'UpdatePagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Page` that was updated by this mutation. */
  page: Maybe<Page>;
  /** An edge for our `Page`. May be used by Relay 1. */
  pageEdge: Maybe<PagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Page` mutation. */
export type UpdatePagePayloadPageEdgeArgs = {
  orderBy?: InputMaybe<Array<PagesOrderBy>>;
};

/** All input for the `updateParameterByNodeId` mutation. */
export type UpdateParameterByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Parameter` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Parameter` being updated. */
  patch: ParameterPatch;
};

/** All input for the `updateParameter` mutation. */
export type UpdateParameterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  paName: Scalars['String'];
  /** An object where the defined keys will be set on the `Parameter` being updated. */
  patch: ParameterPatch;
};

/** The output of our update `Parameter` mutation. */
export type UpdateParameterPayload = {
  __typename?: 'UpdateParameterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Parameter` that was updated by this mutation. */
  parameter: Maybe<Parameter>;
  /** An edge for our `Parameter`. May be used by Relay 1. */
  parameterEdge: Maybe<ParametersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Parameter` mutation. */
export type UpdateParameterPayloadParameterEdgeArgs = {
  orderBy?: InputMaybe<Array<ParametersOrderBy>>;
};

/** All input for the `updateParyByNodeId` mutation. */
export type UpdateParyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Pary` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Pary` being updated. */
  patch: ParyPatch;
};

/** All input for the `updatePary` mutation. */
export type UpdateParyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Pary` being updated. */
  patch: ParyPatch;
  pId: Scalars['BigInt'];
};

/** All input for the `updateParyNavrhByNodeId` mutation. */
export type UpdateParyNavrhByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ParyNavrh` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ParyNavrh` being updated. */
  patch: ParyNavrhPatch;
};

/** All input for the `updateParyNavrh` mutation. */
export type UpdateParyNavrhInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ParyNavrh` being updated. */
  patch: ParyNavrhPatch;
  pnId: Scalars['BigInt'];
};

/** The output of our update `ParyNavrh` mutation. */
export type UpdateParyNavrhPayload = {
  __typename?: 'UpdateParyNavrhPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ParyNavrh` that was updated by this mutation. */
  paryNavrh: Maybe<ParyNavrh>;
  /** An edge for our `ParyNavrh`. May be used by Relay 1. */
  paryNavrhEdge: Maybe<ParyNavrhsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnNavrhl: Maybe<User>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnPartnerka: Maybe<User>;
};


/** The output of our update `ParyNavrh` mutation. */
export type UpdateParyNavrhPayloadParyNavrhEdgeArgs = {
  orderBy?: InputMaybe<Array<ParyNavrhsOrderBy>>;
};

/** The output of our update `Pary` mutation. */
export type UpdateParyPayload = {
  __typename?: 'UpdateParyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Pary` that was updated by this mutation. */
  pary: Maybe<Pary>;
  /** An edge for our `Pary`. May be used by Relay 1. */
  paryEdge: Maybe<PariesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartnerka: Maybe<User>;
};


/** The output of our update `Pary` mutation. */
export type UpdateParyPayloadParyEdgeArgs = {
  orderBy?: InputMaybe<Array<PariesOrderBy>>;
};

/** All input for the `updatePermissionByNodeId` mutation. */
export type UpdatePermissionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Permission` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Permission` being updated. */
  patch: PermissionPatch;
};

/** All input for the `updatePermission` mutation. */
export type UpdatePermissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Permission` being updated. */
  patch: PermissionPatch;
  peId: Scalars['BigInt'];
};

/** The output of our update `Permission` mutation. */
export type UpdatePermissionPayload = {
  __typename?: 'UpdatePermissionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Permission` that was updated by this mutation. */
  permission: Maybe<Permission>;
  /** An edge for our `Permission`. May be used by Relay 1. */
  permissionEdge: Maybe<PermissionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Permission` mutation. */
export type UpdatePermissionPayloadPermissionEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
};

/** All input for the `updatePlatbyCategoryByNodeId` mutation. */
export type UpdatePlatbyCategoryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyCategory` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PlatbyCategory` being updated. */
  patch: PlatbyCategoryPatch;
};

/** All input for the `updatePlatbyCategoryGroupByNodeId` mutation. */
export type UpdatePlatbyCategoryGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyCategoryGroup` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PlatbyCategoryGroup` being updated. */
  patch: PlatbyCategoryGroupPatch;
};

/** All input for the `updatePlatbyCategoryGroup` mutation. */
export type UpdatePlatbyCategoryGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PlatbyCategoryGroup` being updated. */
  patch: PlatbyCategoryGroupPatch;
  pcgId: Scalars['BigInt'];
};

/** The output of our update `PlatbyCategoryGroup` mutation. */
export type UpdatePlatbyCategoryGroupPayload = {
  __typename?: 'UpdatePlatbyCategoryGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyCategoryGroup`. */
  platbyCategoryByPcgIdCategory: Maybe<PlatbyCategory>;
  /** The `PlatbyCategoryGroup` that was updated by this mutation. */
  platbyCategoryGroup: Maybe<PlatbyCategoryGroup>;
  /** An edge for our `PlatbyCategoryGroup`. May be used by Relay 1. */
  platbyCategoryGroupEdge: Maybe<PlatbyCategoryGroupsEdge>;
  /** Reads a single `PlatbyGroup` that is related to this `PlatbyCategoryGroup`. */
  platbyGroupByPcgIdGroup: Maybe<PlatbyGroup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `PlatbyCategoryGroup` mutation. */
export type UpdatePlatbyCategoryGroupPayloadPlatbyCategoryGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyCategoryGroupsOrderBy>>;
};

/** All input for the `updatePlatbyCategory` mutation. */
export type UpdatePlatbyCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PlatbyCategory` being updated. */
  patch: PlatbyCategoryPatch;
  pcId: Scalars['BigInt'];
};

/** The output of our update `PlatbyCategory` mutation. */
export type UpdatePlatbyCategoryPayload = {
  __typename?: 'UpdatePlatbyCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlatbyCategory` that was updated by this mutation. */
  platbyCategory: Maybe<PlatbyCategory>;
  /** An edge for our `PlatbyCategory`. May be used by Relay 1. */
  platbyCategoryEdge: Maybe<PlatbyCategoriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `PlatbyCategory` mutation. */
export type UpdatePlatbyCategoryPayloadPlatbyCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyCategoriesOrderBy>>;
};

/** All input for the `updatePlatbyGroupByNodeId` mutation. */
export type UpdatePlatbyGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyGroup` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PlatbyGroup` being updated. */
  patch: PlatbyGroupPatch;
};

/** All input for the `updatePlatbyGroup` mutation. */
export type UpdatePlatbyGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PlatbyGroup` being updated. */
  patch: PlatbyGroupPatch;
  pgId: Scalars['BigInt'];
};

/** The output of our update `PlatbyGroup` mutation. */
export type UpdatePlatbyGroupPayload = {
  __typename?: 'UpdatePlatbyGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlatbyGroup` that was updated by this mutation. */
  platbyGroup: Maybe<PlatbyGroup>;
  /** An edge for our `PlatbyGroup`. May be used by Relay 1. */
  platbyGroupEdge: Maybe<PlatbyGroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `PlatbyGroup` mutation. */
export type UpdatePlatbyGroupPayloadPlatbyGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyGroupsOrderBy>>;
};

/** All input for the `updatePlatbyGroupSkupinaByNodeId` mutation. */
export type UpdatePlatbyGroupSkupinaByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyGroupSkupina` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PlatbyGroupSkupina` being updated. */
  patch: PlatbyGroupSkupinaPatch;
};

/** All input for the `updatePlatbyGroupSkupina` mutation. */
export type UpdatePlatbyGroupSkupinaInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PlatbyGroupSkupina` being updated. */
  patch: PlatbyGroupSkupinaPatch;
  pgsId: Scalars['BigInt'];
};

/** The output of our update `PlatbyGroupSkupina` mutation. */
export type UpdatePlatbyGroupSkupinaPayload = {
  __typename?: 'UpdatePlatbyGroupSkupinaPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `PlatbyGroup` that is related to this `PlatbyGroupSkupina`. */
  platbyGroupByPgsIdGroup: Maybe<PlatbyGroup>;
  /** The `PlatbyGroupSkupina` that was updated by this mutation. */
  platbyGroupSkupina: Maybe<PlatbyGroupSkupina>;
  /** An edge for our `PlatbyGroupSkupina`. May be used by Relay 1. */
  platbyGroupSkupinaEdge: Maybe<PlatbyGroupSkupinasEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `PlatbyGroupSkupina`. */
  skupinyByPgsIdSkupina: Maybe<Skupiny>;
};


/** The output of our update `PlatbyGroupSkupina` mutation. */
export type UpdatePlatbyGroupSkupinaPayloadPlatbyGroupSkupinaEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyGroupSkupinasOrderBy>>;
};

/** All input for the `updatePlatbyItemByNodeId` mutation. */
export type UpdatePlatbyItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyItem` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PlatbyItem` being updated. */
  patch: PlatbyItemPatch;
};

/** All input for the `updatePlatbyItem` mutation. */
export type UpdatePlatbyItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PlatbyItem` being updated. */
  patch: PlatbyItemPatch;
  piId: Scalars['BigInt'];
};

/** The output of our update `PlatbyItem` mutation. */
export type UpdatePlatbyItemPayload = {
  __typename?: 'UpdatePlatbyItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
  platbyCategoryByPiIdCategory: Maybe<PlatbyCategory>;
  /** The `PlatbyItem` that was updated by this mutation. */
  platbyItem: Maybe<PlatbyItem>;
  /** An edge for our `PlatbyItem`. May be used by Relay 1. */
  platbyItemEdge: Maybe<PlatbyItemsEdge>;
  /** Reads a single `PlatbyRaw` that is related to this `PlatbyItem`. */
  platbyRawByPiIdRaw: Maybe<PlatbyRaw>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `PlatbyItem`. */
  userByPiIdUser: Maybe<User>;
};


/** The output of our update `PlatbyItem` mutation. */
export type UpdatePlatbyItemPayloadPlatbyItemEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyItemsOrderBy>>;
};

/** All input for the `updatePlatbyRawByNodeId` mutation. */
export type UpdatePlatbyRawByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlatbyRaw` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PlatbyRaw` being updated. */
  patch: PlatbyRawPatch;
};

/** All input for the `updatePlatbyRaw` mutation. */
export type UpdatePlatbyRawInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PlatbyRaw` being updated. */
  patch: PlatbyRawPatch;
  prId: Scalars['BigInt'];
};

/** The output of our update `PlatbyRaw` mutation. */
export type UpdatePlatbyRawPayload = {
  __typename?: 'UpdatePlatbyRawPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlatbyRaw` that was updated by this mutation. */
  platbyRaw: Maybe<PlatbyRaw>;
  /** An edge for our `PlatbyRaw`. May be used by Relay 1. */
  platbyRawEdge: Maybe<PlatbyRawsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `PlatbyRaw` mutation. */
export type UpdatePlatbyRawPayloadPlatbyRawEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyRawsOrderBy>>;
};

/** All input for the `updateRozpiByNodeId` mutation. */
export type UpdateRozpiByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Rozpi` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Rozpi` being updated. */
  patch: RozpiPatch;
};

/** All input for the `updateRozpi` mutation. */
export type UpdateRozpiInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Rozpi` being updated. */
  patch: RozpiPatch;
  rId: Scalars['BigInt'];
};

/** The output of our update `Rozpi` mutation. */
export type UpdateRozpiPayload = {
  __typename?: 'UpdateRozpiPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Rozpi` that was updated by this mutation. */
  rozpi: Maybe<Rozpi>;
  /** An edge for our `Rozpi`. May be used by Relay 1. */
  rozpiEdge: Maybe<RozpisEdge>;
  /** Reads a single `User` that is related to this `Rozpi`. */
  userByRTrener: Maybe<User>;
};


/** The output of our update `Rozpi` mutation. */
export type UpdateRozpiPayloadRozpiEdgeArgs = {
  orderBy?: InputMaybe<Array<RozpisOrderBy>>;
};

/** All input for the `updateRozpisItemByNodeId` mutation. */
export type UpdateRozpisItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `RozpisItem` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `RozpisItem` being updated. */
  patch: RozpisItemPatch;
};

/** All input for the `updateRozpisItem` mutation. */
export type UpdateRozpisItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `RozpisItem` being updated. */
  patch: RozpisItemPatch;
  riId: Scalars['BigInt'];
};

/** The output of our update `RozpisItem` mutation. */
export type UpdateRozpisItemPayload = {
  __typename?: 'UpdateRozpisItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Pary` that is related to this `RozpisItem`. */
  paryByRiPartner: Maybe<Pary>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Rozpi` that is related to this `RozpisItem`. */
  rozpiByRiIdRodic: Maybe<Rozpi>;
  /** The `RozpisItem` that was updated by this mutation. */
  rozpisItem: Maybe<RozpisItem>;
  /** An edge for our `RozpisItem`. May be used by Relay 1. */
  rozpisItemEdge: Maybe<RozpisItemsEdge>;
};


/** The output of our update `RozpisItem` mutation. */
export type UpdateRozpisItemPayloadRozpisItemEdgeArgs = {
  orderBy?: InputMaybe<Array<RozpisItemsOrderBy>>;
};

/** All input for the `updateSessionByNodeId` mutation. */
export type UpdateSessionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Session` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Session` being updated. */
  patch: SessionPatch;
};

/** All input for the `updateSession` mutation. */
export type UpdateSessionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Session` being updated. */
  patch: SessionPatch;
  ssId: Scalars['String'];
};

/** The output of our update `Session` mutation. */
export type UpdateSessionPayload = {
  __typename?: 'UpdateSessionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Session` that was updated by this mutation. */
  session: Maybe<Session>;
  /** An edge for our `Session`. May be used by Relay 1. */
  sessionEdge: Maybe<SessionsEdge>;
  /** Reads a single `User` that is related to this `Session`. */
  userBySsUser: Maybe<User>;
};


/** The output of our update `Session` mutation. */
export type UpdateSessionPayloadSessionEdgeArgs = {
  orderBy?: InputMaybe<Array<SessionsOrderBy>>;
};

/** All input for the `updateSkupinyByNodeId` mutation. */
export type UpdateSkupinyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Skupiny` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Skupiny` being updated. */
  patch: SkupinyPatch;
};

/** All input for the `updateSkupiny` mutation. */
export type UpdateSkupinyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Skupiny` being updated. */
  patch: SkupinyPatch;
  sId: Scalars['BigInt'];
};

/** The output of our update `Skupiny` mutation. */
export type UpdateSkupinyPayload = {
  __typename?: 'UpdateSkupinyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Skupiny` that was updated by this mutation. */
  skupiny: Maybe<Skupiny>;
  /** An edge for our `Skupiny`. May be used by Relay 1. */
  skupinyEdge: Maybe<SkupiniesEdge>;
};


/** The output of our update `Skupiny` mutation. */
export type UpdateSkupinyPayloadSkupinyEdgeArgs = {
  orderBy?: InputMaybe<Array<SkupiniesOrderBy>>;
};

/** All input for the `updateUpozorneniByNodeId` mutation. */
export type UpdateUpozorneniByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Upozorneni` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Upozorneni` being updated. */
  patch: UpozorneniPatch;
};

/** All input for the `updateUpozorneni` mutation. */
export type UpdateUpozorneniInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Upozorneni` being updated. */
  patch: UpozorneniPatch;
  upId: Scalars['BigInt'];
};

/** The output of our update `Upozorneni` mutation. */
export type UpdateUpozorneniPayload = {
  __typename?: 'UpdateUpozorneniPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Upozorneni` that was updated by this mutation. */
  upozorneni: Maybe<Upozorneni>;
  /** An edge for our `Upozorneni`. May be used by Relay 1. */
  upozorneniEdge: Maybe<UpozornenisEdge>;
  /** Reads a single `User` that is related to this `Upozorneni`. */
  userByUpKdo: Maybe<User>;
};


/** The output of our update `Upozorneni` mutation. */
export type UpdateUpozorneniPayloadUpozorneniEdgeArgs = {
  orderBy?: InputMaybe<Array<UpozornenisOrderBy>>;
};

/** All input for the `updateUpozorneniSkupinyByNodeId` mutation. */
export type UpdateUpozorneniSkupinyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `UpozorneniSkupiny` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `UpozorneniSkupiny` being updated. */
  patch: UpozorneniSkupinyPatch;
};

/** All input for the `updateUpozorneniSkupiny` mutation. */
export type UpdateUpozorneniSkupinyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `UpozorneniSkupiny` being updated. */
  patch: UpozorneniSkupinyPatch;
  upsId: Scalars['BigInt'];
};

/** The output of our update `UpozorneniSkupiny` mutation. */
export type UpdateUpozorneniSkupinyPayload = {
  __typename?: 'UpdateUpozorneniSkupinyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
  skupinyByUpsIdSkupina: Maybe<Skupiny>;
  /** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
  upozorneniByUpsIdRodic: Maybe<Upozorneni>;
  /** The `UpozorneniSkupiny` that was updated by this mutation. */
  upozorneniSkupiny: Maybe<UpozorneniSkupiny>;
  /** An edge for our `UpozorneniSkupiny`. May be used by Relay 1. */
  upozorneniSkupinyEdge: Maybe<UpozorneniSkupiniesEdge>;
};


/** The output of our update `UpozorneniSkupiny` mutation. */
export type UpdateUpozorneniSkupinyPayloadUpozorneniSkupinyEdgeArgs = {
  orderBy?: InputMaybe<Array<UpozorneniSkupiniesOrderBy>>;
};

/** All input for the `updateUserByNodeId` mutation. */
export type UpdateUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `User` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
};

/** All input for the `updateUser` mutation. */
export type UpdateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
  uId: Scalars['BigInt'];
};

/** The output of our update `User` mutation. */
export type UpdateUserPayload = {
  __typename?: 'UpdateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Permission` that is related to this `User`. */
  permissionByUGroup: Maybe<Permission>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `User`. */
  skupinyByUSkupina: Maybe<Skupiny>;
  /** The `User` that was updated by this mutation. */
  user: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge: Maybe<UsersEdge>;
};


/** The output of our update `User` mutation. */
export type UpdateUserPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the `updateVideoByNodeId` mutation. */
export type UpdateVideoByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Video` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Video` being updated. */
  patch: VideoPatch;
};

/** All input for the `updateVideo` mutation. */
export type UpdateVideoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Video` being updated. */
  patch: VideoPatch;
  vId: Scalars['BigInt'];
};

/** All input for the `updateVideoListByNodeId` mutation. */
export type UpdateVideoListByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `VideoList` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `VideoList` being updated. */
  patch: VideoListPatch;
};

/** All input for the `updateVideoList` mutation. */
export type UpdateVideoListInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `VideoList` being updated. */
  patch: VideoListPatch;
  vlId: Scalars['BigInt'];
};

/** The output of our update `VideoList` mutation. */
export type UpdateVideoListPayload = {
  __typename?: 'UpdateVideoListPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `VideoList` that was updated by this mutation. */
  videoList: Maybe<VideoList>;
  /** An edge for our `VideoList`. May be used by Relay 1. */
  videoListEdge: Maybe<VideoListsEdge>;
};


/** The output of our update `VideoList` mutation. */
export type UpdateVideoListPayloadVideoListEdgeArgs = {
  orderBy?: InputMaybe<Array<VideoListsOrderBy>>;
};

/** The output of our update `Video` mutation. */
export type UpdateVideoPayload = {
  __typename?: 'UpdateVideoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Video` that was updated by this mutation. */
  video: Maybe<Video>;
  /** An edge for our `Video`. May be used by Relay 1. */
  videoEdge: Maybe<VideosEdge>;
};


/** The output of our update `Video` mutation. */
export type UpdateVideoPayloadVideoEdgeArgs = {
  orderBy?: InputMaybe<Array<VideosOrderBy>>;
};

/** All input for the `updateVideoSourceByNodeId` mutation. */
export type UpdateVideoSourceByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `VideoSource` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `VideoSource` being updated. */
  patch: VideoSourcePatch;
};

/** All input for the `updateVideoSource` mutation. */
export type UpdateVideoSourceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `VideoSource` being updated. */
  patch: VideoSourcePatch;
  vsId: Scalars['BigInt'];
};

/** The output of our update `VideoSource` mutation. */
export type UpdateVideoSourcePayload = {
  __typename?: 'UpdateVideoSourcePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `VideoSource` that was updated by this mutation. */
  videoSource: Maybe<VideoSource>;
  /** An edge for our `VideoSource`. May be used by Relay 1. */
  videoSourceEdge: Maybe<VideoSourcesEdge>;
};


/** The output of our update `VideoSource` mutation. */
export type UpdateVideoSourcePayloadVideoSourceEdgeArgs = {
  orderBy?: InputMaybe<Array<VideoSourcesOrderBy>>;
};

export type Upozorneni = Node & {
  __typename?: 'Upozorneni';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  upBarvy: Scalars['BigInt'];
  upId: Scalars['BigInt'];
  upKdo: Maybe<Scalars['BigInt']>;
  upLock: Scalars['Boolean'];
  upNadpis: Scalars['String'];
  /** Reads and enables pagination through a set of `UpozorneniSkupiny`. */
  upozorneniSkupiniesByUpsIdRodic: UpozorneniSkupiniesConnection;
  upText: Scalars['String'];
  upTimestamp: Maybe<Scalars['Datetime']>;
  upTimestampAdd: Scalars['Datetime'];
  /** Reads a single `User` that is related to this `Upozorneni`. */
  userByUpKdo: Maybe<User>;
};


export type UpozorneniUpozorneniSkupiniesByUpsIdRodicArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<UpozorneniSkupinyCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UpozorneniSkupiniesOrderBy>>;
};

/**
 * A condition to be used against `Upozorneni` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type UpozorneniCondition = {
  /** Checks for equality with the object’s `upBarvy` field. */
  upBarvy?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `upId` field. */
  upId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `upKdo` field. */
  upKdo?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `upLock` field. */
  upLock?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `upNadpis` field. */
  upNadpis?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `upText` field. */
  upText?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `upTimestamp` field. */
  upTimestamp?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `upTimestampAdd` field. */
  upTimestampAdd?: InputMaybe<Scalars['Datetime']>;
};

/** An input for mutations affecting `Upozorneni` */
export type UpozorneniInput = {
  upBarvy?: InputMaybe<Scalars['BigInt']>;
  upId?: InputMaybe<Scalars['BigInt']>;
  upKdo?: InputMaybe<Scalars['BigInt']>;
  upLock?: InputMaybe<Scalars['Boolean']>;
  upNadpis: Scalars['String'];
  upText: Scalars['String'];
  upTimestamp?: InputMaybe<Scalars['Datetime']>;
  upTimestampAdd?: InputMaybe<Scalars['Datetime']>;
};

/** Represents an update to a `Upozorneni`. Fields that are set will be updated. */
export type UpozorneniPatch = {
  upBarvy?: InputMaybe<Scalars['BigInt']>;
  upId?: InputMaybe<Scalars['BigInt']>;
  upKdo?: InputMaybe<Scalars['BigInt']>;
  upLock?: InputMaybe<Scalars['Boolean']>;
  upNadpis?: InputMaybe<Scalars['String']>;
  upText?: InputMaybe<Scalars['String']>;
  upTimestamp?: InputMaybe<Scalars['Datetime']>;
  upTimestampAdd?: InputMaybe<Scalars['Datetime']>;
};

/** A connection to a list of `Upozorneni` values. */
export type UpozornenisConnection = {
  __typename?: 'UpozornenisConnection';
  /** A list of edges which contains the `Upozorneni` and cursor to aid in pagination. */
  edges: Array<UpozornenisEdge>;
  /** A list of `Upozorneni` objects. */
  nodes: Array<Upozorneni>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Upozorneni` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Upozorneni` edge in the connection. */
export type UpozornenisEdge = {
  __typename?: 'UpozornenisEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Upozorneni` at the end of the edge. */
  node: Upozorneni;
};

/** A connection to a list of `UpozorneniSkupiny` values. */
export type UpozorneniSkupiniesConnection = {
  __typename?: 'UpozorneniSkupiniesConnection';
  /** A list of edges which contains the `UpozorneniSkupiny` and cursor to aid in pagination. */
  edges: Array<UpozorneniSkupiniesEdge>;
  /** A list of `UpozorneniSkupiny` objects. */
  nodes: Array<UpozorneniSkupiny>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UpozorneniSkupiny` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `UpozorneniSkupiny` edge in the connection. */
export type UpozorneniSkupiniesEdge = {
  __typename?: 'UpozorneniSkupiniesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `UpozorneniSkupiny` at the end of the edge. */
  node: UpozorneniSkupiny;
};

/** Methods to use when ordering `UpozorneniSkupiny`. */
export enum UpozorneniSkupiniesOrderBy {
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpsColorAsc = 'UPS_COLOR_ASC',
  UpsColorDesc = 'UPS_COLOR_DESC',
  UpsIdAsc = 'UPS_ID_ASC',
  UpsIdDesc = 'UPS_ID_DESC',
  UpsIdRodicAsc = 'UPS_ID_RODIC_ASC',
  UpsIdRodicDesc = 'UPS_ID_RODIC_DESC',
  UpsIdSkupinaAsc = 'UPS_ID_SKUPINA_ASC',
  UpsIdSkupinaDesc = 'UPS_ID_SKUPINA_DESC',
  UpsPopisAsc = 'UPS_POPIS_ASC',
  UpsPopisDesc = 'UPS_POPIS_DESC'
}

export type UpozorneniSkupiny = Node & {
  __typename?: 'UpozorneniSkupiny';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
  skupinyByUpsIdSkupina: Maybe<Skupiny>;
  /** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
  upozorneniByUpsIdRodic: Maybe<Upozorneni>;
  upsColor: Scalars['String'];
  upsId: Scalars['BigInt'];
  upsIdRodic: Scalars['BigInt'];
  upsIdSkupina: Scalars['BigInt'];
  upsPopis: Scalars['String'];
};

/**
 * A condition to be used against `UpozorneniSkupiny` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type UpozorneniSkupinyCondition = {
  /** Checks for equality with the object’s `upsColor` field. */
  upsColor?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `upsId` field. */
  upsId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `upsIdRodic` field. */
  upsIdRodic?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `upsIdSkupina` field. */
  upsIdSkupina?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `upsPopis` field. */
  upsPopis?: InputMaybe<Scalars['String']>;
};

/** An input for mutations affecting `UpozorneniSkupiny` */
export type UpozorneniSkupinyInput = {
  upsColor: Scalars['String'];
  upsId?: InputMaybe<Scalars['BigInt']>;
  upsIdRodic: Scalars['BigInt'];
  upsIdSkupina: Scalars['BigInt'];
  upsPopis: Scalars['String'];
};

/** Represents an update to a `UpozorneniSkupiny`. Fields that are set will be updated. */
export type UpozorneniSkupinyPatch = {
  upsColor?: InputMaybe<Scalars['String']>;
  upsId?: InputMaybe<Scalars['BigInt']>;
  upsIdRodic?: InputMaybe<Scalars['BigInt']>;
  upsIdSkupina?: InputMaybe<Scalars['BigInt']>;
  upsPopis?: InputMaybe<Scalars['String']>;
};

/** Methods to use when ordering `Upozorneni`. */
export enum UpozornenisOrderBy {
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpBarvyAsc = 'UP_BARVY_ASC',
  UpBarvyDesc = 'UP_BARVY_DESC',
  UpIdAsc = 'UP_ID_ASC',
  UpIdDesc = 'UP_ID_DESC',
  UpKdoAsc = 'UP_KDO_ASC',
  UpKdoDesc = 'UP_KDO_DESC',
  UpLockAsc = 'UP_LOCK_ASC',
  UpLockDesc = 'UP_LOCK_DESC',
  UpNadpisAsc = 'UP_NADPIS_ASC',
  UpNadpisDesc = 'UP_NADPIS_DESC',
  UpTextAsc = 'UP_TEXT_ASC',
  UpTextDesc = 'UP_TEXT_DESC',
  UpTimestampAddAsc = 'UP_TIMESTAMP_ADD_ASC',
  UpTimestampAddDesc = 'UP_TIMESTAMP_ADD_DESC',
  UpTimestampAsc = 'UP_TIMESTAMP_ASC',
  UpTimestampDesc = 'UP_TIMESTAMP_DESC'
}

export type User = Node & {
  __typename?: 'User';
  /** Reads and enables pagination through a set of `AkceItem`. */
  akceItemsByAiUser: AkceItemsConnection;
  /** Reads and enables pagination through a set of `Aktuality`. */
  aktualitiesByAtKdo: AktualitiesConnection;
  /** Reads and enables pagination through a set of `Dokumenty`. */
  dokumentiesByDKdo: DokumentiesConnection;
  /** Reads and enables pagination through a set of `GalerieFoto`. */
  galerieFotosByGfKdo: GalerieFotosConnection;
  /** Reads and enables pagination through a set of `Nabidka`. */
  nabidkasByNTrener: NabidkasConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads and enables pagination through a set of `Pary`. */
  pariesByPIdPartner: PariesConnection;
  /** Reads and enables pagination through a set of `Pary`. */
  pariesByPIdPartnerka: PariesConnection;
  /** Reads and enables pagination through a set of `ParyNavrh`. */
  paryNavrhsByPnNavrhl: ParyNavrhsConnection;
  /** Reads and enables pagination through a set of `ParyNavrh`. */
  paryNavrhsByPnPartner: ParyNavrhsConnection;
  /** Reads and enables pagination through a set of `ParyNavrh`. */
  paryNavrhsByPnPartnerka: ParyNavrhsConnection;
  /** Reads a single `Permission` that is related to this `User`. */
  permissionByUGroup: Maybe<Permission>;
  /** Reads and enables pagination through a set of `PlatbyItem`. */
  platbyItemsByPiIdUser: PlatbyItemsConnection;
  /** Reads and enables pagination through a set of `Rozpi`. */
  rozpisByRTrener: RozpisConnection;
  /** Reads and enables pagination through a set of `Session`. */
  sessionsBySsUser: SessionsConnection;
  /** Reads a single `Skupiny` that is related to this `User`. */
  skupinyByUSkupina: Maybe<Skupiny>;
  uBan: Scalars['Boolean'];
  uCity: Scalars['String'];
  uConfirmed: Scalars['Boolean'];
  uConscriptionNumber: Scalars['String'];
  uCreatedAt: Scalars['Datetime'];
  uDancer: Scalars['Boolean'];
  uDistrict: Scalars['String'];
  uEmail: Scalars['String'];
  uGdprSignedAt: Maybe<Scalars['Datetime']>;
  uGroup: Scalars['BigInt'];
  uId: Scalars['BigInt'];
  uJmeno: Scalars['String'];
  uLevel: Scalars['Int'];
  uLock: Scalars['Boolean'];
  uLogin: Scalars['String'];
  uMemberSince: Maybe<Scalars['Datetime']>;
  uMemberUntil: Maybe<Scalars['Datetime']>;
  uNarozeni: Scalars['Date'];
  uNationality: Scalars['String'];
  uOrientationNumber: Scalars['String'];
  uPass: Scalars['String'];
  uPohlavi: Scalars['String'];
  uPostalCode: Scalars['String'];
  uPoznamky: Scalars['String'];
  /** Reads and enables pagination through a set of `Upozorneni`. */
  upozornenisByUpKdo: UpozornenisConnection;
  uPrijmeni: Scalars['String'];
  uRodneCislo: Maybe<Scalars['String']>;
  uSkupina: Scalars['BigInt'];
  uStreet: Scalars['String'];
  uSystem: Scalars['Boolean'];
  uTeacher: Scalars['Boolean'];
  uTelefon: Scalars['String'];
  uTimestamp: Scalars['Datetime'];
};


export type UserAkceItemsByAiUserArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AkceItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AkceItemsOrderBy>>;
};


export type UserAktualitiesByAtKdoArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<AktualityCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AktualitiesOrderBy>>;
};


export type UserDokumentiesByDKdoArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<DokumentyCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<DokumentiesOrderBy>>;
};


export type UserGalerieFotosByGfKdoArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<GalerieFotoCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GalerieFotosOrderBy>>;
};


export type UserNabidkasByNTrenerArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<NabidkaCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<NabidkasOrderBy>>;
};


export type UserPariesByPIdPartnerArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<ParyCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PariesOrderBy>>;
};


export type UserPariesByPIdPartnerkaArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<ParyCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PariesOrderBy>>;
};


export type UserParyNavrhsByPnNavrhlArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<ParyNavrhCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ParyNavrhsOrderBy>>;
};


export type UserParyNavrhsByPnPartnerArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<ParyNavrhCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ParyNavrhsOrderBy>>;
};


export type UserParyNavrhsByPnPartnerkaArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<ParyNavrhCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ParyNavrhsOrderBy>>;
};


export type UserPlatbyItemsByPiIdUserArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<PlatbyItemCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlatbyItemsOrderBy>>;
};


export type UserRozpisByRTrenerArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<RozpiCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RozpisOrderBy>>;
};


export type UserSessionsBySsUserArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<SessionCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SessionsOrderBy>>;
};


export type UserUpozornenisByUpKdoArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<UpozorneniCondition>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UpozornenisOrderBy>>;
};

/** A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UserCondition = {
  /** Checks for equality with the object’s `uBan` field. */
  uBan?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uCity` field. */
  uCity?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uConfirmed` field. */
  uConfirmed?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uConscriptionNumber` field. */
  uConscriptionNumber?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uCreatedAt` field. */
  uCreatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `uDancer` field. */
  uDancer?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uDistrict` field. */
  uDistrict?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uEmail` field. */
  uEmail?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uGdprSignedAt` field. */
  uGdprSignedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `uGroup` field. */
  uGroup?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `uId` field. */
  uId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `uJmeno` field. */
  uJmeno?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uLevel` field. */
  uLevel?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uLock` field. */
  uLock?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uLogin` field. */
  uLogin?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uMemberSince` field. */
  uMemberSince?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `uMemberUntil` field. */
  uMemberUntil?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `uNarozeni` field. */
  uNarozeni?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the object’s `uNationality` field. */
  uNationality?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uOrientationNumber` field. */
  uOrientationNumber?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uPass` field. */
  uPass?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uPohlavi` field. */
  uPohlavi?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uPostalCode` field. */
  uPostalCode?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uPoznamky` field. */
  uPoznamky?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uPrijmeni` field. */
  uPrijmeni?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uRodneCislo` field. */
  uRodneCislo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uSkupina` field. */
  uSkupina?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `uStreet` field. */
  uStreet?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uSystem` field. */
  uSystem?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uTeacher` field. */
  uTeacher?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `uTelefon` field. */
  uTelefon?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `uTimestamp` field. */
  uTimestamp?: InputMaybe<Scalars['Datetime']>;
};

/** An input for mutations affecting `User` */
export type UserInput = {
  uBan?: InputMaybe<Scalars['Boolean']>;
  uCity: Scalars['String'];
  uConfirmed?: InputMaybe<Scalars['Boolean']>;
  uConscriptionNumber?: InputMaybe<Scalars['String']>;
  uCreatedAt?: InputMaybe<Scalars['Datetime']>;
  uDancer?: InputMaybe<Scalars['Boolean']>;
  uDistrict?: InputMaybe<Scalars['String']>;
  uEmail: Scalars['String'];
  uGdprSignedAt?: InputMaybe<Scalars['Datetime']>;
  uGroup?: InputMaybe<Scalars['BigInt']>;
  uId?: InputMaybe<Scalars['BigInt']>;
  uJmeno: Scalars['String'];
  uLevel?: InputMaybe<Scalars['Int']>;
  uLock?: InputMaybe<Scalars['Boolean']>;
  uLogin: Scalars['String'];
  uMemberSince?: InputMaybe<Scalars['Datetime']>;
  uMemberUntil?: InputMaybe<Scalars['Datetime']>;
  uNarozeni: Scalars['Date'];
  uNationality: Scalars['String'];
  uOrientationNumber?: InputMaybe<Scalars['String']>;
  uPass: Scalars['String'];
  uPohlavi: Scalars['String'];
  uPostalCode: Scalars['String'];
  uPoznamky?: InputMaybe<Scalars['String']>;
  uPrijmeni: Scalars['String'];
  uRodneCislo?: InputMaybe<Scalars['String']>;
  uSkupina?: InputMaybe<Scalars['BigInt']>;
  uStreet: Scalars['String'];
  uSystem?: InputMaybe<Scalars['Boolean']>;
  uTeacher?: InputMaybe<Scalars['Boolean']>;
  uTelefon: Scalars['String'];
  uTimestamp?: InputMaybe<Scalars['Datetime']>;
};

/** Represents an update to a `User`. Fields that are set will be updated. */
export type UserPatch = {
  uBan?: InputMaybe<Scalars['Boolean']>;
  uCity?: InputMaybe<Scalars['String']>;
  uConfirmed?: InputMaybe<Scalars['Boolean']>;
  uConscriptionNumber?: InputMaybe<Scalars['String']>;
  uCreatedAt?: InputMaybe<Scalars['Datetime']>;
  uDancer?: InputMaybe<Scalars['Boolean']>;
  uDistrict?: InputMaybe<Scalars['String']>;
  uEmail?: InputMaybe<Scalars['String']>;
  uGdprSignedAt?: InputMaybe<Scalars['Datetime']>;
  uGroup?: InputMaybe<Scalars['BigInt']>;
  uId?: InputMaybe<Scalars['BigInt']>;
  uJmeno?: InputMaybe<Scalars['String']>;
  uLevel?: InputMaybe<Scalars['Int']>;
  uLock?: InputMaybe<Scalars['Boolean']>;
  uLogin?: InputMaybe<Scalars['String']>;
  uMemberSince?: InputMaybe<Scalars['Datetime']>;
  uMemberUntil?: InputMaybe<Scalars['Datetime']>;
  uNarozeni?: InputMaybe<Scalars['Date']>;
  uNationality?: InputMaybe<Scalars['String']>;
  uOrientationNumber?: InputMaybe<Scalars['String']>;
  uPass?: InputMaybe<Scalars['String']>;
  uPohlavi?: InputMaybe<Scalars['String']>;
  uPostalCode?: InputMaybe<Scalars['String']>;
  uPoznamky?: InputMaybe<Scalars['String']>;
  uPrijmeni?: InputMaybe<Scalars['String']>;
  uRodneCislo?: InputMaybe<Scalars['String']>;
  uSkupina?: InputMaybe<Scalars['BigInt']>;
  uStreet?: InputMaybe<Scalars['String']>;
  uSystem?: InputMaybe<Scalars['Boolean']>;
  uTeacher?: InputMaybe<Scalars['Boolean']>;
  uTelefon?: InputMaybe<Scalars['String']>;
  uTimestamp?: InputMaybe<Scalars['Datetime']>;
};

/** A connection to a list of `User` values. */
export type UsersConnection = {
  __typename?: 'UsersConnection';
  /** A list of edges which contains the `User` and cursor to aid in pagination. */
  edges: Array<UsersEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `User` edge in the connection. */
export type UsersEdge = {
  __typename?: 'UsersEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `User` at the end of the edge. */
  node: User;
};

/** Methods to use when ordering `User`. */
export enum UsersOrderBy {
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UBanAsc = 'U_BAN_ASC',
  UBanDesc = 'U_BAN_DESC',
  UCityAsc = 'U_CITY_ASC',
  UCityDesc = 'U_CITY_DESC',
  UConfirmedAsc = 'U_CONFIRMED_ASC',
  UConfirmedDesc = 'U_CONFIRMED_DESC',
  UConscriptionNumberAsc = 'U_CONSCRIPTION_NUMBER_ASC',
  UConscriptionNumberDesc = 'U_CONSCRIPTION_NUMBER_DESC',
  UCreatedAtAsc = 'U_CREATED_AT_ASC',
  UCreatedAtDesc = 'U_CREATED_AT_DESC',
  UDancerAsc = 'U_DANCER_ASC',
  UDancerDesc = 'U_DANCER_DESC',
  UDistrictAsc = 'U_DISTRICT_ASC',
  UDistrictDesc = 'U_DISTRICT_DESC',
  UEmailAsc = 'U_EMAIL_ASC',
  UEmailDesc = 'U_EMAIL_DESC',
  UGdprSignedAtAsc = 'U_GDPR_SIGNED_AT_ASC',
  UGdprSignedAtDesc = 'U_GDPR_SIGNED_AT_DESC',
  UGroupAsc = 'U_GROUP_ASC',
  UGroupDesc = 'U_GROUP_DESC',
  UIdAsc = 'U_ID_ASC',
  UIdDesc = 'U_ID_DESC',
  UJmenoAsc = 'U_JMENO_ASC',
  UJmenoDesc = 'U_JMENO_DESC',
  ULevelAsc = 'U_LEVEL_ASC',
  ULevelDesc = 'U_LEVEL_DESC',
  ULockAsc = 'U_LOCK_ASC',
  ULockDesc = 'U_LOCK_DESC',
  ULoginAsc = 'U_LOGIN_ASC',
  ULoginDesc = 'U_LOGIN_DESC',
  UMemberSinceAsc = 'U_MEMBER_SINCE_ASC',
  UMemberSinceDesc = 'U_MEMBER_SINCE_DESC',
  UMemberUntilAsc = 'U_MEMBER_UNTIL_ASC',
  UMemberUntilDesc = 'U_MEMBER_UNTIL_DESC',
  UNarozeniAsc = 'U_NAROZENI_ASC',
  UNarozeniDesc = 'U_NAROZENI_DESC',
  UNationalityAsc = 'U_NATIONALITY_ASC',
  UNationalityDesc = 'U_NATIONALITY_DESC',
  UOrientationNumberAsc = 'U_ORIENTATION_NUMBER_ASC',
  UOrientationNumberDesc = 'U_ORIENTATION_NUMBER_DESC',
  UPassAsc = 'U_PASS_ASC',
  UPassDesc = 'U_PASS_DESC',
  UPohlaviAsc = 'U_POHLAVI_ASC',
  UPohlaviDesc = 'U_POHLAVI_DESC',
  UPostalCodeAsc = 'U_POSTAL_CODE_ASC',
  UPostalCodeDesc = 'U_POSTAL_CODE_DESC',
  UPoznamkyAsc = 'U_POZNAMKY_ASC',
  UPoznamkyDesc = 'U_POZNAMKY_DESC',
  UPrijmeniAsc = 'U_PRIJMENI_ASC',
  UPrijmeniDesc = 'U_PRIJMENI_DESC',
  URodneCisloAsc = 'U_RODNE_CISLO_ASC',
  URodneCisloDesc = 'U_RODNE_CISLO_DESC',
  USkupinaAsc = 'U_SKUPINA_ASC',
  USkupinaDesc = 'U_SKUPINA_DESC',
  UStreetAsc = 'U_STREET_ASC',
  UStreetDesc = 'U_STREET_DESC',
  USystemAsc = 'U_SYSTEM_ASC',
  USystemDesc = 'U_SYSTEM_DESC',
  UTeacherAsc = 'U_TEACHER_ASC',
  UTeacherDesc = 'U_TEACHER_DESC',
  UTelefonAsc = 'U_TELEFON_ASC',
  UTelefonDesc = 'U_TELEFON_DESC',
  UTimestampAsc = 'U_TIMESTAMP_ASC',
  UTimestampDesc = 'U_TIMESTAMP_DESC'
}

export type Video = Node & {
  __typename?: 'Video';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  vAuthor: Scalars['String'];
  vCreatedAt: Scalars['Datetime'];
  vDescription: Scalars['String'];
  vId: Scalars['BigInt'];
  vPlaylist: Maybe<Scalars['String']>;
  vTitle: Scalars['String'];
  vUpdatedAt: Scalars['Datetime'];
  vUri: Scalars['String'];
};

/** A condition to be used against `Video` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type VideoCondition = {
  /** Checks for equality with the object’s `vAuthor` field. */
  vAuthor?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `vCreatedAt` field. */
  vCreatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `vDescription` field. */
  vDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `vId` field. */
  vId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vPlaylist` field. */
  vPlaylist?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `vTitle` field. */
  vTitle?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `vUpdatedAt` field. */
  vUpdatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `vUri` field. */
  vUri?: InputMaybe<Scalars['String']>;
};

/** An input for mutations affecting `Video` */
export type VideoInput = {
  vAuthor: Scalars['String'];
  vCreatedAt?: InputMaybe<Scalars['Datetime']>;
  vDescription: Scalars['String'];
  vId?: InputMaybe<Scalars['BigInt']>;
  vPlaylist?: InputMaybe<Scalars['String']>;
  vTitle: Scalars['String'];
  vUpdatedAt?: InputMaybe<Scalars['Datetime']>;
  vUri: Scalars['String'];
};

export type VideoList = Node & {
  __typename?: 'VideoList';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  vlCount: Scalars['BigInt'];
  vlCreatedAt: Scalars['Datetime'];
  vlDescription: Scalars['String'];
  vlId: Scalars['BigInt'];
  vlLastChecked: Maybe<Scalars['Datetime']>;
  vlTitle: Scalars['String'];
  vlUrl: Scalars['String'];
};

/**
 * A condition to be used against `VideoList` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type VideoListCondition = {
  /** Checks for equality with the object’s `vlCount` field. */
  vlCount?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vlCreatedAt` field. */
  vlCreatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `vlDescription` field. */
  vlDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `vlId` field. */
  vlId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vlLastChecked` field. */
  vlLastChecked?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `vlTitle` field. */
  vlTitle?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `vlUrl` field. */
  vlUrl?: InputMaybe<Scalars['String']>;
};

/** An input for mutations affecting `VideoList` */
export type VideoListInput = {
  vlCount: Scalars['BigInt'];
  vlCreatedAt: Scalars['Datetime'];
  vlDescription: Scalars['String'];
  vlId?: InputMaybe<Scalars['BigInt']>;
  vlLastChecked?: InputMaybe<Scalars['Datetime']>;
  vlTitle: Scalars['String'];
  vlUrl: Scalars['String'];
};

/** Represents an update to a `VideoList`. Fields that are set will be updated. */
export type VideoListPatch = {
  vlCount?: InputMaybe<Scalars['BigInt']>;
  vlCreatedAt?: InputMaybe<Scalars['Datetime']>;
  vlDescription?: InputMaybe<Scalars['String']>;
  vlId?: InputMaybe<Scalars['BigInt']>;
  vlLastChecked?: InputMaybe<Scalars['Datetime']>;
  vlTitle?: InputMaybe<Scalars['String']>;
  vlUrl?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `VideoList` values. */
export type VideoListsConnection = {
  __typename?: 'VideoListsConnection';
  /** A list of edges which contains the `VideoList` and cursor to aid in pagination. */
  edges: Array<VideoListsEdge>;
  /** A list of `VideoList` objects. */
  nodes: Array<VideoList>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VideoList` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `VideoList` edge in the connection. */
export type VideoListsEdge = {
  __typename?: 'VideoListsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `VideoList` at the end of the edge. */
  node: VideoList;
};

/** Methods to use when ordering `VideoList`. */
export enum VideoListsOrderBy {
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  VlCountAsc = 'VL_COUNT_ASC',
  VlCountDesc = 'VL_COUNT_DESC',
  VlCreatedAtAsc = 'VL_CREATED_AT_ASC',
  VlCreatedAtDesc = 'VL_CREATED_AT_DESC',
  VlDescriptionAsc = 'VL_DESCRIPTION_ASC',
  VlDescriptionDesc = 'VL_DESCRIPTION_DESC',
  VlIdAsc = 'VL_ID_ASC',
  VlIdDesc = 'VL_ID_DESC',
  VlLastCheckedAsc = 'VL_LAST_CHECKED_ASC',
  VlLastCheckedDesc = 'VL_LAST_CHECKED_DESC',
  VlTitleAsc = 'VL_TITLE_ASC',
  VlTitleDesc = 'VL_TITLE_DESC',
  VlUrlAsc = 'VL_URL_ASC',
  VlUrlDesc = 'VL_URL_DESC'
}

/** Represents an update to a `Video`. Fields that are set will be updated. */
export type VideoPatch = {
  vAuthor?: InputMaybe<Scalars['String']>;
  vCreatedAt?: InputMaybe<Scalars['Datetime']>;
  vDescription?: InputMaybe<Scalars['String']>;
  vId?: InputMaybe<Scalars['BigInt']>;
  vPlaylist?: InputMaybe<Scalars['String']>;
  vTitle?: InputMaybe<Scalars['String']>;
  vUpdatedAt?: InputMaybe<Scalars['Datetime']>;
  vUri?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Video` values. */
export type VideosConnection = {
  __typename?: 'VideosConnection';
  /** A list of edges which contains the `Video` and cursor to aid in pagination. */
  edges: Array<VideosEdge>;
  /** A list of `Video` objects. */
  nodes: Array<Video>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Video` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Video` edge in the connection. */
export type VideosEdge = {
  __typename?: 'VideosEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Video` at the end of the edge. */
  node: Video;
};

/** Methods to use when ordering `Video`. */
export enum VideosOrderBy {
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  VAuthorAsc = 'V_AUTHOR_ASC',
  VAuthorDesc = 'V_AUTHOR_DESC',
  VCreatedAtAsc = 'V_CREATED_AT_ASC',
  VCreatedAtDesc = 'V_CREATED_AT_DESC',
  VDescriptionAsc = 'V_DESCRIPTION_ASC',
  VDescriptionDesc = 'V_DESCRIPTION_DESC',
  VIdAsc = 'V_ID_ASC',
  VIdDesc = 'V_ID_DESC',
  VPlaylistAsc = 'V_PLAYLIST_ASC',
  VPlaylistDesc = 'V_PLAYLIST_DESC',
  VTitleAsc = 'V_TITLE_ASC',
  VTitleDesc = 'V_TITLE_DESC',
  VUpdatedAtAsc = 'V_UPDATED_AT_ASC',
  VUpdatedAtDesc = 'V_UPDATED_AT_DESC',
  VUriAsc = 'V_URI_ASC',
  VUriDesc = 'V_URI_DESC'
}

export type VideoSource = Node & {
  __typename?: 'VideoSource';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  vsCreatedAt: Scalars['Datetime'];
  vsDescription: Maybe<Scalars['String']>;
  vsId: Scalars['BigInt'];
  vsLastChecked: Maybe<Scalars['Datetime']>;
  vsTitle: Maybe<Scalars['String']>;
  vsUrl: Scalars['String'];
};

/**
 * A condition to be used against `VideoSource` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type VideoSourceCondition = {
  /** Checks for equality with the object’s `vsCreatedAt` field. */
  vsCreatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `vsDescription` field. */
  vsDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `vsId` field. */
  vsId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vsLastChecked` field. */
  vsLastChecked?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `vsTitle` field. */
  vsTitle?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `vsUrl` field. */
  vsUrl?: InputMaybe<Scalars['String']>;
};

/** An input for mutations affecting `VideoSource` */
export type VideoSourceInput = {
  vsCreatedAt?: InputMaybe<Scalars['Datetime']>;
  vsDescription?: InputMaybe<Scalars['String']>;
  vsId?: InputMaybe<Scalars['BigInt']>;
  vsLastChecked?: InputMaybe<Scalars['Datetime']>;
  vsTitle?: InputMaybe<Scalars['String']>;
  vsUrl: Scalars['String'];
};

/** Represents an update to a `VideoSource`. Fields that are set will be updated. */
export type VideoSourcePatch = {
  vsCreatedAt?: InputMaybe<Scalars['Datetime']>;
  vsDescription?: InputMaybe<Scalars['String']>;
  vsId?: InputMaybe<Scalars['BigInt']>;
  vsLastChecked?: InputMaybe<Scalars['Datetime']>;
  vsTitle?: InputMaybe<Scalars['String']>;
  vsUrl?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `VideoSource` values. */
export type VideoSourcesConnection = {
  __typename?: 'VideoSourcesConnection';
  /** A list of edges which contains the `VideoSource` and cursor to aid in pagination. */
  edges: Array<VideoSourcesEdge>;
  /** A list of `VideoSource` objects. */
  nodes: Array<VideoSource>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VideoSource` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `VideoSource` edge in the connection. */
export type VideoSourcesEdge = {
  __typename?: 'VideoSourcesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `VideoSource` at the end of the edge. */
  node: VideoSource;
};

/** Methods to use when ordering `VideoSource`. */
export enum VideoSourcesOrderBy {
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  VsCreatedAtAsc = 'VS_CREATED_AT_ASC',
  VsCreatedAtDesc = 'VS_CREATED_AT_DESC',
  VsDescriptionAsc = 'VS_DESCRIPTION_ASC',
  VsDescriptionDesc = 'VS_DESCRIPTION_DESC',
  VsIdAsc = 'VS_ID_ASC',
  VsIdDesc = 'VS_ID_DESC',
  VsLastCheckedAsc = 'VS_LAST_CHECKED_ASC',
  VsLastCheckedDesc = 'VS_LAST_CHECKED_DESC',
  VsTitleAsc = 'VS_TITLE_ASC',
  VsTitleDesc = 'VS_TITLE_DESC',
  VsUrlAsc = 'VS_URL_ASC',
  VsUrlDesc = 'VS_URL_DESC'
}

export type AnnouncementFragment = { __typename: 'Upozorneni', upId: string, upKdo: string | null, upLock: boolean, upNadpis: string, upText: string, upTimestamp: string | null, upTimestampAdd: string, userByUpKdo: { __typename?: 'User', uId: string, uJmeno: string, uPrijmeni: string } | null, upozorneniSkupiniesByUpsIdRodic: { __typename?: 'UpozorneniSkupiniesConnection', nodes: Array<{ __typename?: 'UpozorneniSkupiny', skupinyByUpsIdSkupina: { __typename?: 'Skupiny', sId: string, sName: string, sDescription: string, sColorText: string, sColorRgb: string } | null }> } };

export type AnnouncementListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
}>;


export type AnnouncementListQuery = { __typename?: 'Query', upozornenis: { __typename?: 'UpozornenisConnection', totalCount: number, nodes: Array<{ __typename: 'Upozorneni', upId: string, upKdo: string | null, upLock: boolean, upNadpis: string, upText: string, upTimestamp: string | null, upTimestampAdd: string, userByUpKdo: { __typename?: 'User', uId: string, uJmeno: string, uPrijmeni: string } | null, upozorneniSkupiniesByUpsIdRodic: { __typename?: 'UpozorneniSkupiniesConnection', nodes: Array<{ __typename?: 'UpozorneniSkupiny', skupinyByUpsIdSkupina: { __typename?: 'Skupiny', sId: string, sName: string, sDescription: string, sColorText: string, sColorRgb: string } | null }> } }> } | null };

export type AnnouncementQueryVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type AnnouncementQuery = { __typename?: 'Query', upozorneni: { __typename: 'Upozorneni', upId: string, upKdo: string | null, upLock: boolean, upNadpis: string, upText: string, upTimestamp: string | null, upTimestampAdd: string, userByUpKdo: { __typename?: 'User', uId: string, uJmeno: string, uPrijmeni: string } | null, upozorneniSkupiniesByUpsIdRodic: { __typename?: 'UpozorneniSkupiniesConnection', nodes: Array<{ __typename?: 'UpozorneniSkupiny', skupinyByUpsIdSkupina: { __typename?: 'Skupiny', sId: string, sName: string, sDescription: string, sColorText: string, sColorRgb: string } | null }> } } | null };

export type CreateAnnouncementMutationVariables = Exact<{
  input: UpozorneniInput;
}>;


export type CreateAnnouncementMutation = { __typename?: 'Mutation', createUpozorneni: { __typename: 'CreateUpozorneniPayload' } | null };

export type UpdateAnnouncementMutationVariables = Exact<{
  id: Scalars['BigInt'];
  patch: UpozorneniPatch;
}>;


export type UpdateAnnouncementMutation = { __typename?: 'Mutation', updateUpozorneni: { __typename: 'UpdateUpozorneniPayload' } | null };

export type DeleteAnnouncementMutationVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type DeleteAnnouncementMutation = { __typename?: 'Mutation', deleteUpozorneni: { __typename: 'DeleteUpozorneniPayload' } | null };

export type ArticleFragment = { __typename: 'Aktuality', atId: string, atPreview: string, atJmeno: string, atText: string, atFoto: string | null, atFotoMain: string | null, atTimestamp: string | null, atTimestampAdd: string | null, galerieFotoByAtFotoMain: { __typename?: 'GalerieFoto', gfPath: string } | null };

export type ArticleQueryVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type ArticleQuery = { __typename?: 'Query', aktuality: { __typename: 'Aktuality', atId: string, atPreview: string, atJmeno: string, atText: string, atFoto: string | null, atFotoMain: string | null, atTimestamp: string | null, atTimestampAdd: string | null, galerieFotoByAtFotoMain: { __typename?: 'GalerieFoto', gfPath: string } | null } | null };

export type ArticlesQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
}>;


export type ArticlesQuery = { __typename?: 'Query', aktualities: { __typename?: 'AktualitiesConnection', totalCount: number, nodes: Array<{ __typename: 'Aktuality', atId: string, atPreview: string, atJmeno: string, atText: string, atFoto: string | null, atFotoMain: string | null, atTimestamp: string | null, atTimestampAdd: string | null, galerieFotoByAtFotoMain: { __typename?: 'GalerieFoto', gfPath: string } | null }> } | null };

export type CreateArticleMutationVariables = Exact<{
  input: AktualityInput;
}>;


export type CreateArticleMutation = { __typename?: 'Mutation', createAktuality: { __typename: 'CreateAktualityPayload' } | null };

export type UpdateArticleMutationVariables = Exact<{
  id: Scalars['BigInt'];
  patch: AktualityPatch;
}>;


export type UpdateArticleMutation = { __typename?: 'Mutation', updateAktuality: { __typename: 'UpdateAktualityPayload' } | null };

export type DeleteArticleMutationVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type DeleteArticleMutation = { __typename?: 'Mutation', deleteAktuality: { __typename: 'DeleteAktualityPayload' } | null };

export type CohortFragment = { __typename: 'Skupiny', sId: string, sName: string, sDescription: string, sLocation: string, sVisible: boolean, sColorRgb: string };

export type CohortListQueryVariables = Exact<{
  visible?: InputMaybe<Scalars['Boolean']>;
}>;


export type CohortListQuery = { __typename?: 'Query', skupinies: { __typename?: 'SkupiniesConnection', nodes: Array<{ __typename: 'Skupiny', sId: string, sName: string, sDescription: string, sLocation: string, sVisible: boolean, sColorRgb: string, platbyGroupSkupinasByPgsIdSkupina: { __typename?: 'PlatbyGroupSkupinasConnection', nodes: Array<{ __typename?: 'PlatbyGroupSkupina', pgsIdGroup: string }> } }> } | null };

export type CohortMembersQueryVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type CohortMembersQuery = { __typename?: 'Query', members: { __typename?: 'MembersConnection', nodes: Array<{ __typename?: 'Member', uJmeno: string | null, uPrijmeni: string | null, uRodneCislo: string | null, uTelefon: string | null, uEmail: string | null }> } | null };

export type CohortQueryVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type CohortQuery = { __typename?: 'Query', skupiny: { __typename: 'Skupiny', sId: string, sName: string, sDescription: string, sLocation: string, sVisible: boolean, sColorRgb: string } | null };

export type CreateCohortMutationVariables = Exact<{
  input: SkupinyInput;
}>;


export type CreateCohortMutation = { __typename?: 'Mutation', createSkupiny: { __typename: 'CreateSkupinyPayload' } | null };

export type UpdateCohortMutationVariables = Exact<{
  id: Scalars['BigInt'];
  patch: SkupinyPatch;
}>;


export type UpdateCohortMutation = { __typename?: 'Mutation', updateSkupiny: { __typename: 'UpdateSkupinyPayload' } | null };

export type DeleteCohortMutationVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type DeleteCohortMutation = { __typename?: 'Mutation', deleteSkupiny: { __typename: 'DeleteSkupinyPayload' } | null };

export type CoupleListQueryVariables = Exact<{ [key: string]: never; }>;


export type CoupleListQuery = { __typename?: 'Query', activeCouples: { __typename?: 'PariesConnection', totalCount: number, nodes: Array<{ __typename?: 'Pary', pId: string, userByPIdPartner: { __typename?: 'User', uJmeno: string, uPrijmeni: string } | null, userByPIdPartnerka: { __typename?: 'User', uJmeno: string, uPrijmeni: string } | null }> } | null };

export type CreateCoupleMutationVariables = Exact<{
  man: Scalars['BigInt'];
  woman: Scalars['BigInt'];
}>;


export type CreateCoupleMutation = { __typename?: 'Mutation', createCouple: { __typename?: 'CreateCouplePayload', paries: Array<{ __typename?: 'Pary', pId: string }> | null } | null };

export type DeleteCoupleMutationVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type DeleteCoupleMutation = { __typename?: 'Mutation', deletePary: { __typename: 'DeleteParyPayload' } | null };

export type FixUnpairedCouplesMutationVariables = Exact<{ [key: string]: never; }>;


export type FixUnpairedCouplesMutation = { __typename?: 'Mutation', fixUnpairedCouples: { __typename?: 'FixUnpairedCouplesPayload', paries: Array<{ __typename?: 'Pary', pId: string }> | null } | null };

export type ActiveProspectsQueryVariables = Exact<{ [key: string]: never; }>;


export type ActiveProspectsQuery = { __typename?: 'Query', activeProspects: { __typename?: 'ActiveProspectsConnection', totalCount: number, nodes: Array<{ __typename?: 'ActiveProspectsRecord', id: string | null, cohort: CrmCohort | null, updatedAt: string | null, data: { __typename?: 'ProspectDatum', name: string | null, surname: string | null, email: string | null, phone: string | null, yearofbirth: string | null } | null }> } | null };

export type SubmitProspectFormMutationVariables = Exact<{
  cohort: CrmCohort;
  origin: Scalars['String'];
  prospectData: ProspectDatumInput;
}>;


export type SubmitProspectFormMutation = { __typename?: 'Mutation', prospectFormDancer: { __typename?: 'ProspectFormDancerPayload', clientMutationId: string | null } | null };

export type UserFragment = { __typename?: 'User', uId: string, uLogin: string, uJmeno: string, uPrijmeni: string, uEmail: string, uTelefon: string, uConfirmed: boolean, uTeacher: boolean, uDancer: boolean, uSystem: boolean, uLock: boolean, uBan: boolean, uGroup: string, uSkupina: string, uTimestamp: string, uStreet: string, uRodneCislo: string | null, uPoznamky: string, uPostalCode: string, uPohlavi: string, uOrientationNumber: string, uNationality: string, uNarozeni: string, uMemberUntil: string | null, uMemberSince: string | null, uGdprSignedAt: string | null, uDistrict: string, uCreatedAt: string, uConscriptionNumber: string, uCity: string };

export type UserAuthFragment = { __typename?: 'User', uId: string, uLogin: string, uJmeno: string, uPrijmeni: string, uEmail: string, uTelefon: string, uConfirmed: boolean, uTeacher: boolean, uDancer: boolean, uSystem: boolean, uLock: boolean, uBan: boolean, uGroup: string, uSkupina: string, uTimestamp: string, uStreet: string, uRodneCislo: string | null, uPoznamky: string, uPostalCode: string, uPohlavi: string, uOrientationNumber: string, uNationality: string, uNarozeni: string, uMemberUntil: string | null, uMemberSince: string | null, uGdprSignedAt: string | null, uDistrict: string, uCreatedAt: string, uConscriptionNumber: string, uCity: string, permissionByUGroup: { __typename: 'Permission', peAkce: number, peAnkety: number, peAktuality: number, peDescription: string, peDokumenty: number, peGalerie: number, peId: string, peKonzole: number, peInzerce: number, peNabidka: number, peMain: number, peName: string, peNastenka: number, peNovinky: number, pePary: number, pePermissions: number, pePlatby: number, peRozpis: number, peSkupiny: number, peUsers: number } | null };

export type CouplePartialFragment = { __typename?: 'Pary', pId: string, pIdPartner: string, pIdPartnerka: string | null, pArchiv: boolean };

export type CurrentUserQueryVariables = Exact<{ [key: string]: never; }>;


export type CurrentUserQuery = { __typename?: 'Query', getCurrentUser: { __typename?: 'User', uId: string, uLogin: string, uJmeno: string, uPrijmeni: string, uEmail: string, uTelefon: string, uConfirmed: boolean, uTeacher: boolean, uDancer: boolean, uSystem: boolean, uLock: boolean, uBan: boolean, uGroup: string, uSkupina: string, uTimestamp: string, uStreet: string, uRodneCislo: string | null, uPoznamky: string, uPostalCode: string, uPohlavi: string, uOrientationNumber: string, uNationality: string, uNarozeni: string, uMemberUntil: string | null, uMemberSince: string | null, uGdprSignedAt: string | null, uDistrict: string, uCreatedAt: string, uConscriptionNumber: string, uCity: string, permissionByUGroup: { __typename: 'Permission', peAkce: number, peAnkety: number, peAktuality: number, peDescription: string, peDokumenty: number, peGalerie: number, peId: string, peKonzole: number, peInzerce: number, peNabidka: number, peMain: number, peName: string, peNastenka: number, peNovinky: number, pePary: number, pePermissions: number, pePlatby: number, peRozpis: number, peSkupiny: number, peUsers: number } | null } | null };

export type LoginMutationVariables = Exact<{
  login: Scalars['String'];
  passwd: Scalars['String'];
}>;


export type LoginMutation = { __typename?: 'Mutation', login: { __typename?: 'LoginPayload', result: { __typename?: 'LoginRecord', usr: { __typename?: 'User', uId: string, uLogin: string, uJmeno: string, uPrijmeni: string, uEmail: string, uTelefon: string, uConfirmed: boolean, uTeacher: boolean, uDancer: boolean, uSystem: boolean, uLock: boolean, uBan: boolean, uGroup: string, uSkupina: string, uTimestamp: string, uStreet: string, uRodneCislo: string | null, uPoznamky: string, uPostalCode: string, uPohlavi: string, uOrientationNumber: string, uNationality: string, uNarozeni: string, uMemberUntil: string | null, uMemberSince: string | null, uGdprSignedAt: string | null, uDistrict: string, uCreatedAt: string, uConscriptionNumber: string, uCity: string, permissionByUGroup: { __typename: 'Permission', peAkce: number, peAnkety: number, peAktuality: number, peDescription: string, peDokumenty: number, peGalerie: number, peId: string, peKonzole: number, peInzerce: number, peNabidka: number, peMain: number, peName: string, peNastenka: number, peNovinky: number, pePary: number, pePermissions: number, pePlatby: number, peRozpis: number, peSkupiny: number, peUsers: number } | null } | null, couple: { __typename?: 'Pary', pId: string, pIdPartner: string, pIdPartnerka: string | null, pArchiv: boolean } | null } | null } | null };

export type LogoutMutationVariables = Exact<{ [key: string]: never; }>;


export type LogoutMutation = { __typename?: 'Mutation', logout: { __typename: 'LogoutPayload' } | null };

export type RegisterMutationVariables = Exact<{
  input: CreateUserInput;
}>;


export type RegisterMutation = { __typename?: 'Mutation', createUser: { __typename?: 'CreateUserPayload', user: { __typename?: 'User', uId: string } | null } | null };

export type ResetPasswordMutationVariables = Exact<{
  input: ResetPasswordInput;
}>;


export type ResetPasswordMutation = { __typename?: 'Mutation', resetPassword: { __typename: 'ResetPasswordPayload' } | null };

export type FileFragment = { __typename: 'Dokumenty', dId: string, dName: string, dFilename: string, dKategorie: number, dTimestamp: string | null };

export type FileListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  category?: InputMaybe<Scalars['Int']>;
}>;


export type FileListQuery = { __typename?: 'Query', dokumenties: { __typename?: 'DokumentiesConnection', totalCount: number, nodes: Array<{ __typename: 'Dokumenty', dId: string, dName: string, dFilename: string, dKategorie: number, dTimestamp: string | null, userByDKdo: { __typename?: 'User', uJmeno: string, uPrijmeni: string } | null }> } | null };

export type FileQueryVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type FileQuery = { __typename?: 'Query', dokumenty: { __typename: 'Dokumenty', dId: string, dName: string, dFilename: string, dKategorie: number, dTimestamp: string | null } | null };

export type CreateFileMutationVariables = Exact<{
  input: DokumentyInput;
}>;


export type CreateFileMutation = { __typename?: 'Mutation', createDokumenty: { __typename: 'CreateDokumentyPayload' } | null };

export type UpdateFileMutationVariables = Exact<{
  id: Scalars['BigInt'];
  patch: DokumentyPatch;
}>;


export type UpdateFileMutation = { __typename?: 'Mutation', updateDokumenty: { __typename: 'UpdateDokumentyPayload' } | null };

export type DeleteFileMutationVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type DeleteFileMutation = { __typename?: 'Mutation', deleteDokumenty: { __typename: 'DeleteDokumentyPayload' } | null };

export type EventFragment = { __typename: 'Akce', aId: string, aOd: string, aDo: string, aInfo: string, aDokumenty: string, aJmeno: string, aKapacita: string, aKde: string, aLock: boolean, aTimestamp: string | null, aVisible: boolean };

export type EventWithItemsFragment = { __typename: 'Akce', aId: string, aOd: string, aDo: string, aInfo: string, aDokumenty: string, aJmeno: string, aKapacita: string, aKde: string, aLock: boolean, aTimestamp: string | null, aVisible: boolean, akceItemsByAiIdRodic: { __typename?: 'AkceItemsConnection', totalCount: number, nodes: Array<{ __typename: 'AkceItem', aiId: string, userByAiUser: { __typename?: 'User', uId: string, uJmeno: string, uPrijmeni: string } | null }> } };

export type EventItemFragment = { __typename: 'AkceItem', aiId: string, userByAiUser: { __typename?: 'User', uJmeno: string, uPrijmeni: string, uRodneCislo: string | null, uTelefon: string, uEmail: string } | null };

export type EventParticipantsQueryVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type EventParticipantsQuery = { __typename?: 'Query', akce: { __typename?: 'Akce', aJmeno: string, akceItemsByAiIdRodic: { __typename?: 'AkceItemsConnection', nodes: Array<{ __typename: 'AkceItem', aiId: string, userByAiUser: { __typename?: 'User', uJmeno: string, uPrijmeni: string, uRodneCislo: string | null, uTelefon: string, uEmail: string } | null }> } } | null };

export type EventListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  visible?: InputMaybe<Scalars['Boolean']>;
}>;


export type EventListQuery = { __typename?: 'Query', akces: { __typename?: 'AkcesConnection', totalCount: number, nodes: Array<{ __typename: 'Akce', aId: string, aOd: string, aDo: string, aInfo: string, aDokumenty: string, aJmeno: string, aKapacita: string, aKde: string, aLock: boolean, aTimestamp: string | null, aVisible: boolean, akceItemsByAiIdRodic: { __typename?: 'AkceItemsConnection', totalCount: number, nodes: Array<{ __typename: 'AkceItem', aiId: string, userByAiUser: { __typename?: 'User', uId: string, uJmeno: string, uPrijmeni: string } | null }> } }> } | null };

export type EventQueryVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type EventQuery = { __typename?: 'Query', akce: { __typename: 'Akce', aId: string, aOd: string, aDo: string, aInfo: string, aDokumenty: string, aJmeno: string, aKapacita: string, aKde: string, aLock: boolean, aTimestamp: string | null, aVisible: boolean } | null };

export type ToggleEventVisibleMutationVariables = Exact<{
  id: Scalars['BigInt'];
  visible: Scalars['Boolean'];
}>;


export type ToggleEventVisibleMutation = { __typename?: 'Mutation', updateAkce: { __typename?: 'UpdateAkcePayload', akce: { __typename?: 'Akce', aId: string } | null } | null };

export type CreateEventMutationVariables = Exact<{
  input: AkceInput;
}>;


export type CreateEventMutation = { __typename?: 'Mutation', createAkce: { __typename: 'CreateAkcePayload' } | null };

export type UpdateEventMutationVariables = Exact<{
  id: Scalars['BigInt'];
  patch: AkcePatch;
}>;


export type UpdateEventMutation = { __typename?: 'Mutation', updateAkce: { __typename: 'UpdateAkcePayload' } | null };

export type DeleteEventMutationVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type DeleteEventMutation = { __typename?: 'Mutation', deleteAkce: { __typename: 'DeleteAkcePayload' } | null };

export type GalleryPhotoFragment = { __typename: 'GalerieFoto', nodeId: string, gfId: string, gfIdRodic: string, gfKdo: string, gfName: string, gfPath: string, gfTimestamp: string | null };

export type GalleryDirFragment = { __typename: 'GalerieDir', nodeId: string, gdId: string, gdIdRodic: string, gdName: string, gdPath: string, gdLevel: number, gdHidden: boolean };

export type GalleryDirQueryVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type GalleryDirQuery = { __typename?: 'Query', galerieDir: { __typename: 'GalerieDir', nodeId: string, gdId: string, gdIdRodic: string, gdName: string, gdPath: string, gdLevel: number, gdHidden: boolean, galerieFotosByGfIdRodic: { __typename?: 'GalerieFotosConnection', nodes: Array<{ __typename: 'GalerieFoto', nodeId: string, gfId: string, gfIdRodic: string, gfKdo: string, gfName: string, gfPath: string, gfTimestamp: string | null }> } } | null, galerieDirs: { __typename?: 'GalerieDirsConnection', nodes: Array<{ __typename: 'GalerieDir', nodeId: string, gdId: string, gdIdRodic: string, gdName: string, gdPath: string, gdLevel: number, gdHidden: boolean, galerieFotosByGfIdRodic: { __typename?: 'GalerieFotosConnection', nodes: Array<{ __typename: 'GalerieFoto', nodeId: string, gfId: string, gfIdRodic: string, gfKdo: string, gfName: string, gfPath: string, gfTimestamp: string | null }> } }> } | null };

export type GalleryDirListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
}>;


export type GalleryDirListQuery = { __typename?: 'Query', galerieDirs: { __typename?: 'GalerieDirsConnection', totalCount: number, nodes: Array<{ __typename: 'GalerieDir', nodeId: string, gdId: string, gdIdRodic: string, gdName: string, gdPath: string, gdLevel: number, gdHidden: boolean }> } | null };

export type ToggleGalleryDirVisibleMutationVariables = Exact<{
  id: Scalars['BigInt'];
  visible: Scalars['Boolean'];
}>;


export type ToggleGalleryDirVisibleMutation = { __typename?: 'Mutation', updateGalerieDir: { __typename?: 'UpdateGalerieDirPayload', galerieDir: { __typename?: 'GalerieDir', gdId: string } | null } | null };

export type CreateGalleryDirMutationVariables = Exact<{
  input: GalerieDirInput;
}>;


export type CreateGalleryDirMutation = { __typename?: 'Mutation', createGalerieDir: { __typename: 'CreateGalerieDirPayload' } | null };

export type UpdateGalleryDirMutationVariables = Exact<{
  id: Scalars['BigInt'];
  patch: GalerieDirPatch;
}>;


export type UpdateGalleryDirMutation = { __typename?: 'Mutation', updateGalerieDir: { __typename: 'UpdateGalerieDirPayload' } | null };

export type DeleteGalleryDirMutationVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type DeleteGalleryDirMutation = { __typename?: 'Mutation', deleteGalerieDir: { __typename: 'DeleteGalerieDirPayload' } | null };

export type GalleryPhotoQueryVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type GalleryPhotoQuery = { __typename?: 'Query', galerieFoto: { __typename: 'GalerieFoto', nodeId: string, gfId: string, gfIdRodic: string, gfKdo: string, gfName: string, gfPath: string, gfTimestamp: string | null } | null };

export type CreateGalleryPhotoMutationVariables = Exact<{
  input: GalerieFotoInput;
}>;


export type CreateGalleryPhotoMutation = { __typename?: 'Mutation', createGalerieFoto: { __typename: 'CreateGalerieFotoPayload' } | null };

export type UpdateGalleryPhotoMutationVariables = Exact<{
  id: Scalars['BigInt'];
  patch: GalerieFotoPatch;
}>;


export type UpdateGalleryPhotoMutation = { __typename?: 'Mutation', updateGalerieFoto: { __typename: 'UpdateGalerieFotoPayload' } | null };

export type DeleteGalleryPhotoMutationVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type DeleteGalleryPhotoMutation = { __typename?: 'Mutation', deleteGalerieFoto: { __typename: 'DeleteGalerieFotoPayload' } | null };

export type PageFragment = { __typename: 'Page', nodeId: string, id: number, url: string, title: string, content: { [key: string]: any }, createdAt: string, updatedAt: string };

export type PageQueryVariables = Exact<{
  url: Scalars['String'];
}>;


export type PageQuery = { __typename?: 'Query', pageByUrl: { __typename?: 'Page', content: { [key: string]: any } } | null };

export type PageListQueryVariables = Exact<{ [key: string]: never; }>;


export type PageListQuery = { __typename?: 'Query', pages: { __typename?: 'PagesConnection', nodes: Array<{ __typename: 'Page', nodeId: string, id: number, url: string, title: string, content: { [key: string]: any }, createdAt: string, updatedAt: string }> } | null };

export type PageRevisionsQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type PageRevisionsQuery = { __typename?: 'Query', pageRevisions: { __typename?: 'PageRevisionsConnection', nodes: Array<{ __typename?: 'PageRevision', revNumber: number, revOperation: string, revTimestamp: string | null, id: number, url: string, title: string, content: { [key: string]: any }, createdAt: string, updatedAt: string }> } | null };

export type CreatePageMutationVariables = Exact<{
  input: PageInput;
}>;


export type CreatePageMutation = { __typename?: 'Mutation', createPage: { __typename?: 'CreatePagePayload', page: { __typename: 'Page', nodeId: string, id: number, url: string, title: string, content: { [key: string]: any }, createdAt: string, updatedAt: string } | null } | null };

export type UpdatePageMutationVariables = Exact<{
  id: Scalars['Int'];
  patch: PagePatch;
}>;


export type UpdatePageMutation = { __typename?: 'Mutation', updatePage: { __typename?: 'UpdatePagePayload', page: { __typename: 'Page', nodeId: string, id: number, url: string, title: string, content: { [key: string]: any }, createdAt: string, updatedAt: string } | null } | null };

export type MenuQueryVariables = Exact<{ [key: string]: never; }>;


export type MenuQuery = { __typename?: 'Query', parameter: { __typename?: 'Parameter', paValue: string } | null };

export type ParameterListQueryVariables = Exact<{ [key: string]: never; }>;


export type ParameterListQuery = { __typename?: 'Query', parameters: { __typename?: 'ParametersConnection', totalCount: number, nodes: Array<{ __typename?: 'Parameter', paName: string, paValue: string }> } | null };

export type CreateParameterMutationVariables = Exact<{
  input: ParameterInput;
}>;


export type CreateParameterMutation = { __typename?: 'Mutation', createParameter: { __typename: 'CreateParameterPayload' } | null };

export type UpdateParameterMutationVariables = Exact<{
  id: Scalars['String'];
  value: Scalars['String'];
}>;


export type UpdateParameterMutation = { __typename?: 'Mutation', updateParameter: { __typename: 'UpdateParameterPayload' } | null };

export type DeleteParameterMutationVariables = Exact<{
  id: Scalars['String'];
}>;


export type DeleteParameterMutation = { __typename?: 'Mutation', deleteParameter: { __typename: 'DeleteParameterPayload' } | null };

export type PaymentGroupFragment = { __typename: 'PlatbyGroup', pgId: string, pgName: string, pgType: any, pgDescription: string, pgBase: string };

export type PaymentGroupListQueryVariables = Exact<{ [key: string]: never; }>;


export type PaymentGroupListQuery = { __typename?: 'Query', platbyGroups: { __typename?: 'PlatbyGroupsConnection', totalCount: number, nodes: Array<{ __typename: 'PlatbyGroup', pgId: string, pgName: string, pgType: any, pgDescription: string, pgBase: string }> } | null };

export type PaymentGroupQueryVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type PaymentGroupQuery = { __typename?: 'Query', platbyGroup: { __typename: 'PlatbyGroup', pgId: string, pgName: string, pgType: any, pgDescription: string, pgBase: string } | null };

export type CreatePaymentGroupMutationVariables = Exact<{
  input: PlatbyGroupInput;
}>;


export type CreatePaymentGroupMutation = { __typename?: 'Mutation', createPlatbyGroup: { __typename: 'CreatePlatbyGroupPayload' } | null };

export type UpdatePaymentGroupMutationVariables = Exact<{
  id: Scalars['BigInt'];
  patch: PlatbyGroupPatch;
}>;


export type UpdatePaymentGroupMutation = { __typename?: 'Mutation', updatePlatbyGroup: { __typename: 'UpdatePlatbyGroupPayload' } | null };

export type DeletePaymentGroupMutationVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type DeletePaymentGroupMutation = { __typename?: 'Mutation', deletePlatbyGroup: { __typename: 'DeletePlatbyGroupPayload' } | null };

export type PaymentItemFragment = { __typename: 'PlatbyItem', piId: string, piIdCategory: string, piIdRaw: string | null, piIdUser: string | null, piAmount: any, piPrefix: number, piDate: string, userByPiIdUser: { __typename?: 'User', uId: string, uJmeno: string, uPrijmeni: string } | null, platbyCategoryByPiIdCategory: { __typename?: 'PlatbyCategory', pcId: string, pcName: string } | null };

export type PaymentItemListQueryVariables = Exact<{ [key: string]: never; }>;


export type PaymentItemListQuery = { __typename?: 'Query', platbyItems: { __typename?: 'PlatbyItemsConnection', totalCount: number, nodes: Array<{ __typename: 'PlatbyItem', piId: string, piIdCategory: string, piIdRaw: string | null, piIdUser: string | null, piAmount: any, piPrefix: number, piDate: string, userByPiIdUser: { __typename?: 'User', uId: string, uJmeno: string, uPrijmeni: string } | null, platbyCategoryByPiIdCategory: { __typename?: 'PlatbyCategory', pcId: string, pcName: string } | null }> } | null };

export type PaymentItemQueryVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type PaymentItemQuery = { __typename?: 'Query', platbyItem: { __typename: 'PlatbyItem', piId: string, piIdCategory: string, piIdRaw: string | null, piIdUser: string | null, piAmount: any, piPrefix: number, piDate: string, userByPiIdUser: { __typename?: 'User', uId: string, uJmeno: string, uPrijmeni: string } | null, platbyCategoryByPiIdCategory: { __typename?: 'PlatbyCategory', pcId: string, pcName: string } | null } | null };

export type CreatePaymentItemMutationVariables = Exact<{
  input: PlatbyItemInput;
}>;


export type CreatePaymentItemMutation = { __typename?: 'Mutation', createPlatbyItem: { __typename: 'CreatePlatbyItemPayload' } | null };

export type UpdatePaymentItemMutationVariables = Exact<{
  id: Scalars['BigInt'];
  patch: PlatbyItemPatch;
}>;


export type UpdatePaymentItemMutation = { __typename?: 'Mutation', updatePlatbyItem: { __typename: 'UpdatePlatbyItemPayload' } | null };

export type DeletePaymentItemMutationVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type DeletePaymentItemMutation = { __typename?: 'Mutation', deletePlatbyItem: { __typename: 'DeletePlatbyItemPayload' } | null };

export type PaymentCategoryFragment = { __typename: 'PlatbyCategory', pcId: string, pcName: string, pcSymbol: string, pcAmount: any, pcDateDue: string, pcValidFrom: string, pcValidTo: string, pcUsePrefix: boolean, pcUseBase: boolean, pcArchive: boolean, pcVisible: boolean };

export type PaymentCategoryListQueryVariables = Exact<{ [key: string]: never; }>;


export type PaymentCategoryListQuery = { __typename?: 'Query', platbyCategories: { __typename?: 'PlatbyCategoriesConnection', totalCount: number, nodes: Array<{ __typename: 'PlatbyCategory', pcId: string, pcName: string, pcSymbol: string, pcAmount: any, pcDateDue: string, pcValidFrom: string, pcValidTo: string, pcUsePrefix: boolean, pcUseBase: boolean, pcArchive: boolean, pcVisible: boolean }> } | null };

export type PaymentCategoryQueryVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type PaymentCategoryQuery = { __typename?: 'Query', platbyCategory: { __typename: 'PlatbyCategory', pcId: string, pcName: string, pcSymbol: string, pcAmount: any, pcDateDue: string, pcValidFrom: string, pcValidTo: string, pcUsePrefix: boolean, pcUseBase: boolean, pcArchive: boolean, pcVisible: boolean } | null };

export type CreatePaymentCategoryMutationVariables = Exact<{
  input: PlatbyCategoryInput;
}>;


export type CreatePaymentCategoryMutation = { __typename?: 'Mutation', createPlatbyCategory: { __typename: 'CreatePlatbyCategoryPayload' } | null };

export type UpdatePaymentCategoryMutationVariables = Exact<{
  id: Scalars['BigInt'];
  patch: PlatbyCategoryPatch;
}>;


export type UpdatePaymentCategoryMutation = { __typename?: 'Mutation', updatePlatbyCategory: { __typename: 'UpdatePlatbyCategoryPayload' } | null };

export type DeletePaymentCategoryMutationVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type DeletePaymentCategoryMutation = { __typename?: 'Mutation', deletePlatbyCategory: { __typename: 'DeletePlatbyCategoryPayload' } | null };

export type ReservationItemFragment = { __typename: 'NabidkaItem', niId: string, niPartner: string, niPocetHod: number, niLock: boolean, paryByNiPartner: { __typename?: 'Pary', pId: string, userByPIdPartner: { __typename?: 'User', uJmeno: string, uPrijmeni: string, uId: string } | null } | null };

export type ReservationFragment = { __typename: 'Nabidka', nId: string, nOd: string, nDo: string, nPocetHod: number, nMaxPocetHod: number, nLock: boolean, nTimestamp: string | null, nVisible: boolean, nTrener: string, nabidkaItemsByNiIdRodic: { __typename?: 'NabidkaItemsConnection', nodes: Array<{ __typename: 'NabidkaItem', niId: string, niPartner: string, niPocetHod: number, niLock: boolean, paryByNiPartner: { __typename?: 'Pary', pId: string, userByPIdPartner: { __typename?: 'User', uJmeno: string, uPrijmeni: string, uId: string } | null } | null }> }, userByNTrener: { __typename?: 'User', uJmeno: string, uPrijmeni: string, uId: string } | null };

export type ReservationListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
}>;


export type ReservationListQuery = { __typename?: 'Query', nabidkas: { __typename?: 'NabidkasConnection', totalCount: number, nodes: Array<{ __typename: 'Nabidka', nId: string, nOd: string, nDo: string, nPocetHod: number, nMaxPocetHod: number, nLock: boolean, nTimestamp: string | null, nVisible: boolean, nTrener: string, nabidkaItemsByNiIdRodic: { __typename?: 'NabidkaItemsConnection', nodes: Array<{ __typename: 'NabidkaItem', niId: string, niPartner: string, niPocetHod: number, niLock: boolean, paryByNiPartner: { __typename?: 'Pary', pId: string, userByPIdPartner: { __typename?: 'User', uJmeno: string, uPrijmeni: string, uId: string } | null } | null }> }, userByNTrener: { __typename?: 'User', uJmeno: string, uPrijmeni: string, uId: string } | null }> } | null };

export type ReservationQueryVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type ReservationQuery = { __typename?: 'Query', nabidka: { __typename: 'Nabidka', nId: string, nOd: string, nDo: string, nPocetHod: number, nMaxPocetHod: number, nLock: boolean, nTimestamp: string | null, nVisible: boolean, nTrener: string, nabidkaItemsByNiIdRodic: { __typename?: 'NabidkaItemsConnection', nodes: Array<{ __typename: 'NabidkaItem', niId: string, niPartner: string, niPocetHod: number, niLock: boolean, paryByNiPartner: { __typename?: 'Pary', pId: string, userByPIdPartner: { __typename?: 'User', uJmeno: string, uPrijmeni: string, uId: string } | null } | null }> }, userByNTrener: { __typename?: 'User', uJmeno: string, uPrijmeni: string, uId: string } | null } | null };

export type ReservationRangeQueryVariables = Exact<{
  startDate: Scalars['Date'];
  endDate: Scalars['Date'];
}>;


export type ReservationRangeQuery = { __typename?: 'Query', reservationsForRange: { __typename?: 'NabidkasConnection', nodes: Array<{ __typename: 'Nabidka', nId: string, nOd: string, nDo: string, nPocetHod: number, nMaxPocetHod: number, nLock: boolean, nTimestamp: string | null, nVisible: boolean, nTrener: string, nabidkaItemsByNiIdRodic: { __typename?: 'NabidkaItemsConnection', nodes: Array<{ __typename: 'NabidkaItem', niId: string, niPartner: string, niPocetHod: number, niLock: boolean, paryByNiPartner: { __typename?: 'Pary', pId: string, userByPIdPartner: { __typename?: 'User', uJmeno: string, uPrijmeni: string, uId: string } | null } | null }> }, userByNTrener: { __typename?: 'User', uJmeno: string, uPrijmeni: string, uId: string } | null }> } | null };

export type ToggleReservationVisibleMutationVariables = Exact<{
  id: Scalars['BigInt'];
  visible: Scalars['Boolean'];
}>;


export type ToggleReservationVisibleMutation = { __typename?: 'Mutation', updateNabidka: { __typename?: 'UpdateNabidkaPayload', nabidka: { __typename?: 'Nabidka', nId: string } | null } | null };

export type CreateReservationMutationVariables = Exact<{
  input: NabidkaInput;
}>;


export type CreateReservationMutation = { __typename?: 'Mutation', createNabidka: { __typename: 'CreateNabidkaPayload' } | null };

export type UpdateReservationMutationVariables = Exact<{
  id: Scalars['BigInt'];
  patch: NabidkaPatch;
}>;


export type UpdateReservationMutation = { __typename?: 'Mutation', updateNabidka: { __typename: 'UpdateNabidkaPayload' } | null };

export type DeleteReservationMutationVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type DeleteReservationMutation = { __typename?: 'Mutation', deleteNabidka: { __typename: 'DeleteNabidkaPayload' } | null };

export type RoleFragment = { __typename: 'Permission', peAkce: number, peAnkety: number, peAktuality: number, peDescription: string, peDokumenty: number, peGalerie: number, peId: string, peKonzole: number, peInzerce: number, peNabidka: number, peMain: number, peName: string, peNastenka: number, peNovinky: number, pePary: number, pePermissions: number, pePlatby: number, peRozpis: number, peSkupiny: number, peUsers: number };

export type RoleListQueryVariables = Exact<{ [key: string]: never; }>;


export type RoleListQuery = { __typename?: 'Query', permissions: { __typename?: 'PermissionsConnection', totalCount: number, nodes: Array<{ __typename: 'Permission', peAkce: number, peAnkety: number, peAktuality: number, peDescription: string, peDokumenty: number, peGalerie: number, peId: string, peKonzole: number, peInzerce: number, peNabidka: number, peMain: number, peName: string, peNastenka: number, peNovinky: number, pePary: number, pePermissions: number, pePlatby: number, peRozpis: number, peSkupiny: number, peUsers: number }> } | null };

export type RoleQueryVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type RoleQuery = { __typename?: 'Query', permission: { __typename: 'Permission', peAkce: number, peAnkety: number, peAktuality: number, peDescription: string, peDokumenty: number, peGalerie: number, peId: string, peKonzole: number, peInzerce: number, peNabidka: number, peMain: number, peName: string, peNastenka: number, peNovinky: number, pePary: number, pePermissions: number, pePlatby: number, peRozpis: number, peSkupiny: number, peUsers: number } | null };

export type CreateRoleMutationVariables = Exact<{
  input: PermissionInput;
}>;


export type CreateRoleMutation = { __typename?: 'Mutation', createPermission: { __typename?: 'CreatePermissionPayload', permission: { __typename?: 'Permission', peId: string } | null } | null };

export type UpdateRoleMutationVariables = Exact<{
  id: Scalars['BigInt'];
  patch: PermissionPatch;
}>;


export type UpdateRoleMutation = { __typename?: 'Mutation', updatePermission: { __typename: 'UpdatePermissionPayload' } | null };

export type DeleteRoleMutationVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type DeleteRoleMutation = { __typename?: 'Mutation', deletePermission: { __typename: 'DeletePermissionPayload' } | null };

export type ScheduleItemFragment = { __typename: 'RozpisItem', riOd: string, riDo: string, riId: string, riLock: boolean, riPartner: string | null, paryByRiPartner: { __typename?: 'Pary', pId: string, userByPIdPartner: { __typename?: 'User', uJmeno: string, uId: string, uPrijmeni: string } | null, userByPIdPartnerka: { __typename?: 'User', uId: string, uJmeno: string, uPrijmeni: string } | null } | null };

export type LessonFragment = { __typename: 'RozpisItem', riId: string, riOd: string, riDo: string, rozpiByRiIdRodic: { __typename?: 'Rozpi', rId: string, rDatum: string, rKde: string, userByRTrener: { __typename?: 'User', uId: string, uJmeno: string, uPrijmeni: string } | null } | null, paryByRiPartner: { __typename?: 'Pary', userByPIdPartner: { __typename?: 'User', uId: string, uJmeno: string, uPrijmeni: string } | null } | null };

export type ScheduleFragment = { __typename: 'Rozpi', rDatum: string, rId: string, rKde: string, rLock: boolean, rTrener: string, rVisible: boolean, userByRTrener: { __typename?: 'User', uJmeno: string, uId: string, uPrijmeni: string } | null, rozpisItemsByRiIdRodic: { __typename?: 'RozpisItemsConnection', nodes: Array<{ __typename: 'RozpisItem', riOd: string, riDo: string, riId: string, riLock: boolean, riPartner: string | null, paryByRiPartner: { __typename?: 'Pary', pId: string, userByPIdPartner: { __typename?: 'User', uJmeno: string, uId: string, uPrijmeni: string } | null, userByPIdPartnerka: { __typename?: 'User', uId: string, uJmeno: string, uPrijmeni: string } | null } | null }> } };

export type ScheduleRangeQueryVariables = Exact<{
  startDate: Scalars['Date'];
  endDate: Scalars['Date'];
}>;


export type ScheduleRangeQuery = { __typename?: 'Query', schedulesForRange: { __typename?: 'RozpisConnection', nodes: Array<{ __typename: 'Rozpi', rDatum: string, rId: string, rKde: string, rLock: boolean, rTrener: string, rVisible: boolean, userByRTrener: { __typename?: 'User', uJmeno: string, uId: string, uPrijmeni: string } | null, rozpisItemsByRiIdRodic: { __typename?: 'RozpisItemsConnection', nodes: Array<{ __typename: 'RozpisItem', riOd: string, riDo: string, riId: string, riLock: boolean, riPartner: string | null, paryByRiPartner: { __typename?: 'Pary', pId: string, userByPIdPartner: { __typename?: 'User', uJmeno: string, uId: string, uPrijmeni: string } | null, userByPIdPartnerka: { __typename?: 'User', uId: string, uJmeno: string, uPrijmeni: string } | null } | null }> } }> } | null };

export type ScheduleListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
}>;


export type ScheduleListQuery = { __typename?: 'Query', rozpis: { __typename?: 'RozpisConnection', totalCount: number, nodes: Array<{ __typename?: 'Rozpi', rDatum: string, rId: string, rKde: string, rLock: boolean, rTimestamp: string | null, rTrener: string, rVisible: boolean, userByRTrener: { __typename?: 'User', uId: string, uJmeno: string, uPrijmeni: string } | null, rozpisItemsByRiIdRodic: { __typename?: 'RozpisItemsConnection', nodes: Array<{ __typename?: 'RozpisItem', riDo: string, riOd: string, riId: string, riPartner: string | null }> } }> } | null };

export type MyLessonsQueryVariables = Exact<{
  startDate?: InputMaybe<Scalars['Date']>;
  endDate?: InputMaybe<Scalars['Date']>;
}>;


export type MyLessonsQuery = { __typename?: 'Query', currentSessionId: string | null, currentUserId: string | null, currentCoupleIds: { __typename?: 'CurrentCoupleIdsConnection', nodes: Array<string | null> } | null, myLessons: { __typename?: 'RozpisItemsConnection', nodes: Array<{ __typename: 'RozpisItem', riId: string, riOd: string, riDo: string, rozpiByRiIdRodic: { __typename?: 'Rozpi', rId: string, rDatum: string, rKde: string, userByRTrener: { __typename?: 'User', uId: string, uJmeno: string, uPrijmeni: string } | null } | null, paryByRiPartner: { __typename?: 'Pary', userByPIdPartner: { __typename?: 'User', uId: string, uJmeno: string, uPrijmeni: string } | null } | null }> } | null };

export type ScheduleQueryVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type ScheduleQuery = { __typename?: 'Query', rozpi: { __typename: 'Rozpi', rDatum: string, rId: string, rKde: string, rLock: boolean, rTrener: string, rVisible: boolean, userByRTrener: { __typename?: 'User', uJmeno: string, uId: string, uPrijmeni: string } | null, rozpisItemsByRiIdRodic: { __typename?: 'RozpisItemsConnection', nodes: Array<{ __typename: 'RozpisItem', riOd: string, riDo: string, riId: string, riLock: boolean, riPartner: string | null, paryByRiPartner: { __typename?: 'Pary', pId: string, userByPIdPartner: { __typename?: 'User', uJmeno: string, uId: string, uPrijmeni: string } | null, userByPIdPartnerka: { __typename?: 'User', uId: string, uJmeno: string, uPrijmeni: string } | null } | null }> } } | null };

export type ToggleScheduleVisibleMutationVariables = Exact<{
  id: Scalars['BigInt'];
  visible: Scalars['Boolean'];
}>;


export type ToggleScheduleVisibleMutation = { __typename?: 'Mutation', updateRozpi: { __typename?: 'UpdateRozpiPayload', rozpi: { __typename?: 'Rozpi', rId: string } | null } | null };

export type CreateScheduleMutationVariables = Exact<{
  input: RozpiInput;
}>;


export type CreateScheduleMutation = { __typename?: 'Mutation', createRozpi: { __typename: 'CreateRozpiPayload' } | null };

export type UpdateScheduleMutationVariables = Exact<{
  id: Scalars['BigInt'];
  patch: RozpiPatch;
}>;


export type UpdateScheduleMutation = { __typename?: 'Mutation', updateRozpi: { __typename: 'UpdateRozpiPayload' } | null };

export type DeleteScheduleMutationVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type DeleteScheduleMutation = { __typename?: 'Mutation', deleteRozpi: { __typename: 'DeleteRozpiPayload' } | null };

export type UserQueryVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type UserQuery = { __typename?: 'Query', user: { __typename?: 'User', uId: string, uLogin: string, uJmeno: string, uPrijmeni: string, uEmail: string, uTelefon: string, uConfirmed: boolean, uTeacher: boolean, uDancer: boolean, uSystem: boolean, uLock: boolean, uBan: boolean, uGroup: string, uSkupina: string, uTimestamp: string, uStreet: string, uRodneCislo: string | null, uPoznamky: string, uPostalCode: string, uPohlavi: string, uOrientationNumber: string, uNationality: string, uNarozeni: string, uMemberUntil: string | null, uMemberSince: string | null, uGdprSignedAt: string | null, uDistrict: string, uCreatedAt: string, uConscriptionNumber: string, uCity: string } | null };

export type UserListQueryVariables = Exact<{
  confirmed?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
}>;


export type UserListQuery = { __typename?: 'Query', users: { __typename?: 'UsersConnection', totalCount: number, nodes: Array<{ __typename?: 'User', uId: string, uLogin: string, uJmeno: string, uPrijmeni: string, uEmail: string, uTelefon: string, uConfirmed: boolean, uTeacher: boolean, uDancer: boolean, uSystem: boolean, uLock: boolean, uBan: boolean, uGroup: string, uSkupina: string, uTimestamp: string, uStreet: string, uRodneCislo: string | null, uPoznamky: string, uPostalCode: string, uPohlavi: string, uOrientationNumber: string, uNationality: string, uNarozeni: string, uMemberUntil: string | null, uMemberSince: string | null, uGdprSignedAt: string | null, uDistrict: string, uCreatedAt: string, uConscriptionNumber: string, uCity: string }> } | null };

export type MemberListQueryVariables = Exact<{
  cohortId?: InputMaybe<Scalars['BigInt']>;
}>;


export type MemberListQuery = { __typename?: 'Query', members: { __typename?: 'MembersConnection', totalCount: number, nodes: Array<{ __typename?: 'Member', uId: string | null, uJmeno: string | null, uPrijmeni: string | null, uEmail: string | null, uTelefon: string | null, uRodneCislo: string | null, sId: string | null, sName: string | null, sColorRgb: string | null, sDescription: string | null, sVisible: boolean | null, paymentValid: boolean | null }> } | null };

export type TrainerListQueryVariables = Exact<{ [key: string]: never; }>;


export type TrainerListQuery = { __typename?: 'Query', trainers: { __typename?: 'UsersConnection', totalCount: number, nodes: Array<{ __typename?: 'User', uId: string, uLogin: string, uJmeno: string, uPrijmeni: string, uEmail: string, uTelefon: string, uConfirmed: boolean, uTeacher: boolean, uDancer: boolean, uSystem: boolean, uLock: boolean, uBan: boolean, uGroup: string, uSkupina: string, uTimestamp: string, uStreet: string, uRodneCislo: string | null, uPoznamky: string, uPostalCode: string, uPohlavi: string, uOrientationNumber: string, uNationality: string, uNarozeni: string, uMemberUntil: string | null, uMemberSince: string | null, uGdprSignedAt: string | null, uDistrict: string, uCreatedAt: string, uConscriptionNumber: string, uCity: string }> } | null };

export type ConfirmUserMutationVariables = Exact<{
  id: Scalars['BigInt'];
  role: Scalars['BigInt'];
  cohort: Scalars['BigInt'];
}>;


export type ConfirmUserMutation = { __typename?: 'Mutation', confirmUser: { __typename: 'ConfirmUserPayload' } | null };

export type CreateUserMutationVariables = Exact<{
  input: UserInput;
}>;


export type CreateUserMutation = { __typename?: 'Mutation', createUser: { __typename: 'CreateUserPayload' } | null };

export type UpdateUserMutationVariables = Exact<{
  id: Scalars['BigInt'];
  patch: UserPatch;
}>;


export type UpdateUserMutation = { __typename?: 'Mutation', updateUser: { __typename: 'UpdateUserPayload' } | null };

export type DeleteUserMutationVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type DeleteUserMutation = { __typename?: 'Mutation', deleteUser: { __typename: 'DeleteUserPayload' } | null };

export type TitleVideosQueryVariables = Exact<{ [key: string]: never; }>;


export type TitleVideosQuery = { __typename?: 'Query', titleVideos: { __typename?: 'VideosConnection', nodes: Array<{ __typename?: 'Video', vTitle: string, vUri: string }> } | null };

export type VideoSourceFragment = { __typename: 'VideoSource', vsId: string, vsTitle: string | null, vsUrl: string, vsDescription: string | null, vsLastChecked: string | null, vsCreatedAt: string };

export type VideoSourceQueryVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type VideoSourceQuery = { __typename?: 'Query', videoSource: { __typename: 'VideoSource', vsId: string, vsTitle: string | null, vsUrl: string, vsDescription: string | null, vsLastChecked: string | null, vsCreatedAt: string } | null };

export type VideoSourceListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
}>;


export type VideoSourceListQuery = { __typename?: 'Query', videoSources: { __typename?: 'VideoSourcesConnection', nodes: Array<{ __typename: 'VideoSource', vsId: string, vsTitle: string | null, vsUrl: string, vsDescription: string | null, vsLastChecked: string | null, vsCreatedAt: string }> } | null };

export type CreateVideoSourceMutationVariables = Exact<{
  input: VideoSourceInput;
}>;


export type CreateVideoSourceMutation = { __typename?: 'Mutation', createVideoSource: { __typename: 'CreateVideoSourcePayload' } | null };

export type UpdateVideoSourceMutationVariables = Exact<{
  id: Scalars['BigInt'];
  patch: VideoSourcePatch;
}>;


export type UpdateVideoSourceMutation = { __typename?: 'Mutation', updateVideoSource: { __typename: 'UpdateVideoSourcePayload' } | null };

export type DeleteVideoSourceMutationVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type DeleteVideoSourceMutation = { __typename?: 'Mutation', deleteVideoSource: { __typename: 'DeleteVideoSourcePayload' } | null };

export type VideoFragment = { __typename: 'Video', vId: string, vAuthor: string, vPlaylist: string | null, vTitle: string, vDescription: string, vUri: string, vCreatedAt: string };

export type VideoQueryVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type VideoQuery = { __typename?: 'Query', video: { __typename: 'Video', vId: string, vAuthor: string, vPlaylist: string | null, vTitle: string, vDescription: string, vUri: string, vCreatedAt: string } | null };

export type VideoListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
}>;


export type VideoListQuery = { __typename?: 'Query', videos: { __typename?: 'VideosConnection', nodes: Array<{ __typename: 'Video', vId: string, vAuthor: string, vPlaylist: string | null, vTitle: string, vDescription: string, vUri: string, vCreatedAt: string }> } | null };

export type CreateVideoMutationVariables = Exact<{
  input: VideoInput;
}>;


export type CreateVideoMutation = { __typename?: 'Mutation', createVideo: { __typename: 'CreateVideoPayload' } | null };

export type UpdateVideoMutationVariables = Exact<{
  id: Scalars['BigInt'];
  patch: VideoPatch;
}>;


export type UpdateVideoMutation = { __typename?: 'Mutation', updateVideo: { __typename: 'UpdateVideoPayload' } | null };

export type DeleteVideoMutationVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type DeleteVideoMutation = { __typename?: 'Mutation', deleteVideo: { __typename: 'DeleteVideoPayload' } | null };

export const AnnouncementFragmentDoc = `
    fragment Announcement on Upozorneni {
  __typename
  upId
  upKdo
  upLock
  upNadpis
  upText
  upTimestamp
  upTimestampAdd
  userByUpKdo {
    uId
    uJmeno
    uPrijmeni
  }
  upozorneniSkupiniesByUpsIdRodic {
    nodes {
      skupinyByUpsIdSkupina {
        sId
        sName
        sDescription
        sColorText
        sColorRgb
      }
    }
  }
}
    `;
export const ArticleFragmentDoc = `
    fragment Article on Aktuality {
  __typename
  atId
  atPreview
  atJmeno
  atText
  atFoto
  atFotoMain
  atTimestamp
  atTimestampAdd
  galerieFotoByAtFotoMain {
    gfPath
  }
}
    `;
export const CohortFragmentDoc = `
    fragment Cohort on Skupiny {
  __typename
  sId
  sName
  sDescription
  sLocation
  sVisible
  sColorRgb
}
    `;
export const UserFragmentDoc = `
    fragment User on User {
  uId
  uLogin
  uJmeno
  uPrijmeni
  uEmail
  uTelefon
  uConfirmed
  uTeacher
  uDancer
  uSystem
  uLock
  uBan
  uGroup
  uSkupina
  uTimestamp
  uStreet
  uRodneCislo
  uPoznamky
  uPostalCode
  uPohlavi
  uOrientationNumber
  uNationality
  uNarozeni
  uMemberUntil
  uMemberSince
  uGdprSignedAt
  uDistrict
  uCreatedAt
  uConscriptionNumber
  uCity
}
    `;
export const RoleFragmentDoc = `
    fragment Role on Permission {
  __typename
  peAkce
  peAnkety
  peAktuality
  peDescription
  peDokumenty
  peGalerie
  peId
  peKonzole
  peInzerce
  peNabidka
  peMain
  peName
  peNastenka
  peNovinky
  pePary
  pePermissions
  pePlatby
  peRozpis
  peSkupiny
  peUsers
}
    `;
export const UserAuthFragmentDoc = `
    fragment UserAuth on User {
  ...User
  permissionByUGroup {
    ...Role
  }
}
    ${UserFragmentDoc}
${RoleFragmentDoc}`;
export const CouplePartialFragmentDoc = `
    fragment CouplePartial on Pary {
  pId
  pIdPartner
  pIdPartnerka
  pArchiv
}
    `;
export const FileFragmentDoc = `
    fragment File on Dokumenty {
  __typename
  dId
  dName
  dFilename
  dKategorie
  dTimestamp
}
    `;
export const EventFragmentDoc = `
    fragment Event on Akce {
  __typename
  aId
  aOd
  aDo
  aInfo
  aDokumenty
  aJmeno
  aKapacita
  aKde
  aLock
  aTimestamp
  aVisible
}
    `;
export const EventWithItemsFragmentDoc = `
    fragment EventWithItems on Akce {
  ...Event
  akceItemsByAiIdRodic {
    totalCount
    nodes {
      __typename
      aiId
      userByAiUser {
        uId
        uJmeno
        uPrijmeni
      }
    }
  }
}
    ${EventFragmentDoc}`;
export const EventItemFragmentDoc = `
    fragment EventItem on AkceItem {
  __typename
  aiId
  userByAiUser {
    uJmeno
    uPrijmeni
    uRodneCislo
    uTelefon
    uEmail
  }
}
    `;
export const GalleryPhotoFragmentDoc = `
    fragment GalleryPhoto on GalerieFoto {
  __typename
  nodeId
  gfId
  gfIdRodic
  gfKdo
  gfName
  gfPath
  gfTimestamp
}
    `;
export const GalleryDirFragmentDoc = `
    fragment GalleryDir on GalerieDir {
  __typename
  nodeId
  gdId
  gdIdRodic
  gdName
  gdPath
  gdLevel
  gdHidden
}
    `;
export const PageFragmentDoc = `
    fragment Page on Page {
  __typename
  nodeId
  id
  url
  title
  content
  createdAt
  updatedAt
}
    `;
export const PaymentGroupFragmentDoc = `
    fragment PaymentGroup on PlatbyGroup {
  __typename
  pgId
  pgName
  pgType
  pgDescription
  pgBase
}
    `;
export const PaymentItemFragmentDoc = `
    fragment PaymentItem on PlatbyItem {
  __typename
  piId
  piIdCategory
  piIdRaw
  piIdUser
  piAmount
  piPrefix
  piDate
  userByPiIdUser {
    uId
    uJmeno
    uPrijmeni
  }
  platbyCategoryByPiIdCategory {
    pcId
    pcName
  }
}
    `;
export const PaymentCategoryFragmentDoc = `
    fragment PaymentCategory on PlatbyCategory {
  __typename
  pcId
  pcName
  pcSymbol
  pcAmount
  pcDateDue
  pcValidFrom
  pcValidTo
  pcUsePrefix
  pcUseBase
  pcArchive
  pcVisible
}
    `;
export const ReservationItemFragmentDoc = `
    fragment ReservationItem on NabidkaItem {
  __typename
  niId
  niPartner
  niPocetHod
  niLock
  paryByNiPartner {
    pId
    userByPIdPartner {
      uJmeno
      uPrijmeni
      uId
    }
  }
}
    `;
export const ReservationFragmentDoc = `
    fragment Reservation on Nabidka {
  __typename
  nId
  nOd
  nDo
  nPocetHod
  nMaxPocetHod
  nLock
  nTimestamp
  nVisible
  nTrener
  nabidkaItemsByNiIdRodic(orderBy: [NI_POCET_HOD_DESC]) {
    nodes {
      ...ReservationItem
    }
  }
  userByNTrener {
    uJmeno
    uPrijmeni
    uId
  }
}
    ${ReservationItemFragmentDoc}`;
export const LessonFragmentDoc = `
    fragment Lesson on RozpisItem {
  __typename
  riId
  riOd
  riDo
  rozpiByRiIdRodic {
    rId
    rDatum
    rKde
    userByRTrener {
      uId
      uJmeno
      uPrijmeni
    }
  }
  paryByRiPartner {
    userByPIdPartner {
      uId
      uJmeno
      uPrijmeni
    }
  }
}
    `;
export const ScheduleItemFragmentDoc = `
    fragment ScheduleItem on RozpisItem {
  __typename
  riOd
  riDo
  riId
  riLock
  riPartner
  paryByRiPartner {
    pId
    userByPIdPartner {
      uJmeno
      uId
      uPrijmeni
    }
    userByPIdPartnerka {
      uId
      uJmeno
      uPrijmeni
    }
  }
}
    `;
export const ScheduleFragmentDoc = `
    fragment Schedule on Rozpi {
  __typename
  rDatum
  rId
  rKde
  rLock
  rTrener
  rVisible
  userByRTrener {
    uJmeno
    uId
    uPrijmeni
  }
  rozpisItemsByRiIdRodic(orderBy: [RI_OD_ASC]) {
    nodes {
      ...ScheduleItem
    }
  }
}
    ${ScheduleItemFragmentDoc}`;
export const VideoSourceFragmentDoc = `
    fragment VideoSource on VideoSource {
  __typename
  vsId
  vsTitle
  vsUrl
  vsDescription
  vsLastChecked
  vsCreatedAt
}
    `;
export const VideoFragmentDoc = `
    fragment Video on Video {
  __typename
  vId
  vAuthor
  vPlaylist
  vTitle
  vDescription
  vUri
  vCreatedAt
}
    `;
export const AnnouncementListDocument = `
    query AnnouncementList($limit: Int, $offset: Int) {
  upozornenis(first: $limit, offset: $offset, orderBy: [UP_TIMESTAMP_ADD_DESC]) {
    totalCount
    nodes {
      ...Announcement
    }
  }
}
    ${AnnouncementFragmentDoc}`;
export const useAnnouncementListQuery = <
      TData = AnnouncementListQuery,
      TError = unknown
    >(
      variables?: AnnouncementListQueryVariables,
      options?: UseQueryOptions<AnnouncementListQuery, TError, TData>
    ) =>
    useQuery<AnnouncementListQuery, TError, TData>(
      variables === undefined ? ['AnnouncementList'] : ['AnnouncementList', variables],
      fetcher<AnnouncementListQuery, AnnouncementListQueryVariables>(AnnouncementListDocument, variables),
      options
    );

useAnnouncementListQuery.getKey = (variables?: AnnouncementListQueryVariables) => variables === undefined ? ['AnnouncementList'] : ['AnnouncementList', variables];
;

useAnnouncementListQuery.fetcher = (variables?: AnnouncementListQueryVariables, options?: RequestInit['headers']) => fetcher<AnnouncementListQuery, AnnouncementListQueryVariables>(AnnouncementListDocument, variables, options);
export const AnnouncementDocument = `
    query Announcement($id: BigInt!) {
  upozorneni(upId: $id) {
    ...Announcement
  }
}
    ${AnnouncementFragmentDoc}`;
export const useAnnouncementQuery = <
      TData = AnnouncementQuery,
      TError = unknown
    >(
      variables: AnnouncementQueryVariables,
      options?: UseQueryOptions<AnnouncementQuery, TError, TData>
    ) =>
    useQuery<AnnouncementQuery, TError, TData>(
      ['Announcement', variables],
      fetcher<AnnouncementQuery, AnnouncementQueryVariables>(AnnouncementDocument, variables),
      options
    );

useAnnouncementQuery.getKey = (variables: AnnouncementQueryVariables) => ['Announcement', variables];
;

useAnnouncementQuery.fetcher = (variables: AnnouncementQueryVariables, options?: RequestInit['headers']) => fetcher<AnnouncementQuery, AnnouncementQueryVariables>(AnnouncementDocument, variables, options);
export const CreateAnnouncementDocument = `
    mutation CreateAnnouncement($input: UpozorneniInput!) {
  createUpozorneni(input: {upozorneni: $input}) {
    __typename
  }
}
    `;
export const useCreateAnnouncementMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<CreateAnnouncementMutation, TError, CreateAnnouncementMutationVariables, TContext>) =>
    useMutation<CreateAnnouncementMutation, TError, CreateAnnouncementMutationVariables, TContext>(
      ['CreateAnnouncement'],
      (variables?: CreateAnnouncementMutationVariables) => fetcher<CreateAnnouncementMutation, CreateAnnouncementMutationVariables>(CreateAnnouncementDocument, variables)(),
      options
    );
useCreateAnnouncementMutation.getKey = () => ['CreateAnnouncement'];

useCreateAnnouncementMutation.fetcher = (variables: CreateAnnouncementMutationVariables, options?: RequestInit['headers']) => fetcher<CreateAnnouncementMutation, CreateAnnouncementMutationVariables>(CreateAnnouncementDocument, variables, options);
export const UpdateAnnouncementDocument = `
    mutation UpdateAnnouncement($id: BigInt!, $patch: UpozorneniPatch!) {
  updateUpozorneni(input: {upId: $id, patch: $patch}) {
    __typename
  }
}
    `;
export const useUpdateAnnouncementMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateAnnouncementMutation, TError, UpdateAnnouncementMutationVariables, TContext>) =>
    useMutation<UpdateAnnouncementMutation, TError, UpdateAnnouncementMutationVariables, TContext>(
      ['UpdateAnnouncement'],
      (variables?: UpdateAnnouncementMutationVariables) => fetcher<UpdateAnnouncementMutation, UpdateAnnouncementMutationVariables>(UpdateAnnouncementDocument, variables)(),
      options
    );
useUpdateAnnouncementMutation.getKey = () => ['UpdateAnnouncement'];

useUpdateAnnouncementMutation.fetcher = (variables: UpdateAnnouncementMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateAnnouncementMutation, UpdateAnnouncementMutationVariables>(UpdateAnnouncementDocument, variables, options);
export const DeleteAnnouncementDocument = `
    mutation DeleteAnnouncement($id: BigInt!) {
  deleteUpozorneni(input: {upId: $id}) {
    __typename
  }
}
    `;
export const useDeleteAnnouncementMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteAnnouncementMutation, TError, DeleteAnnouncementMutationVariables, TContext>) =>
    useMutation<DeleteAnnouncementMutation, TError, DeleteAnnouncementMutationVariables, TContext>(
      ['DeleteAnnouncement'],
      (variables?: DeleteAnnouncementMutationVariables) => fetcher<DeleteAnnouncementMutation, DeleteAnnouncementMutationVariables>(DeleteAnnouncementDocument, variables)(),
      options
    );
useDeleteAnnouncementMutation.getKey = () => ['DeleteAnnouncement'];

useDeleteAnnouncementMutation.fetcher = (variables: DeleteAnnouncementMutationVariables, options?: RequestInit['headers']) => fetcher<DeleteAnnouncementMutation, DeleteAnnouncementMutationVariables>(DeleteAnnouncementDocument, variables, options);
export const ArticleDocument = `
    query Article($id: BigInt!) {
  aktuality(atId: $id) {
    ...Article
  }
}
    ${ArticleFragmentDoc}`;
export const useArticleQuery = <
      TData = ArticleQuery,
      TError = unknown
    >(
      variables: ArticleQueryVariables,
      options?: UseQueryOptions<ArticleQuery, TError, TData>
    ) =>
    useQuery<ArticleQuery, TError, TData>(
      ['Article', variables],
      fetcher<ArticleQuery, ArticleQueryVariables>(ArticleDocument, variables),
      options
    );

useArticleQuery.getKey = (variables: ArticleQueryVariables) => ['Article', variables];
;

useArticleQuery.fetcher = (variables: ArticleQueryVariables, options?: RequestInit['headers']) => fetcher<ArticleQuery, ArticleQueryVariables>(ArticleDocument, variables, options);
export const ArticlesDocument = `
    query Articles($limit: Int, $offset: Int) {
  aktualities(first: $limit, offset: $offset, orderBy: [AT_TIMESTAMP_ADD_DESC]) {
    totalCount
    nodes {
      ...Article
    }
  }
}
    ${ArticleFragmentDoc}`;
export const useArticlesQuery = <
      TData = ArticlesQuery,
      TError = unknown
    >(
      variables?: ArticlesQueryVariables,
      options?: UseQueryOptions<ArticlesQuery, TError, TData>
    ) =>
    useQuery<ArticlesQuery, TError, TData>(
      variables === undefined ? ['Articles'] : ['Articles', variables],
      fetcher<ArticlesQuery, ArticlesQueryVariables>(ArticlesDocument, variables),
      options
    );

useArticlesQuery.getKey = (variables?: ArticlesQueryVariables) => variables === undefined ? ['Articles'] : ['Articles', variables];
;

useArticlesQuery.fetcher = (variables?: ArticlesQueryVariables, options?: RequestInit['headers']) => fetcher<ArticlesQuery, ArticlesQueryVariables>(ArticlesDocument, variables, options);
export const CreateArticleDocument = `
    mutation CreateArticle($input: AktualityInput!) {
  createAktuality(input: {aktuality: $input}) {
    __typename
  }
}
    `;
export const useCreateArticleMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<CreateArticleMutation, TError, CreateArticleMutationVariables, TContext>) =>
    useMutation<CreateArticleMutation, TError, CreateArticleMutationVariables, TContext>(
      ['CreateArticle'],
      (variables?: CreateArticleMutationVariables) => fetcher<CreateArticleMutation, CreateArticleMutationVariables>(CreateArticleDocument, variables)(),
      options
    );
useCreateArticleMutation.getKey = () => ['CreateArticle'];

useCreateArticleMutation.fetcher = (variables: CreateArticleMutationVariables, options?: RequestInit['headers']) => fetcher<CreateArticleMutation, CreateArticleMutationVariables>(CreateArticleDocument, variables, options);
export const UpdateArticleDocument = `
    mutation UpdateArticle($id: BigInt!, $patch: AktualityPatch!) {
  updateAktuality(input: {atId: $id, patch: $patch}) {
    __typename
  }
}
    `;
export const useUpdateArticleMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateArticleMutation, TError, UpdateArticleMutationVariables, TContext>) =>
    useMutation<UpdateArticleMutation, TError, UpdateArticleMutationVariables, TContext>(
      ['UpdateArticle'],
      (variables?: UpdateArticleMutationVariables) => fetcher<UpdateArticleMutation, UpdateArticleMutationVariables>(UpdateArticleDocument, variables)(),
      options
    );
useUpdateArticleMutation.getKey = () => ['UpdateArticle'];

useUpdateArticleMutation.fetcher = (variables: UpdateArticleMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateArticleMutation, UpdateArticleMutationVariables>(UpdateArticleDocument, variables, options);
export const DeleteArticleDocument = `
    mutation DeleteArticle($id: BigInt!) {
  deleteAktuality(input: {atId: $id}) {
    __typename
  }
}
    `;
export const useDeleteArticleMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteArticleMutation, TError, DeleteArticleMutationVariables, TContext>) =>
    useMutation<DeleteArticleMutation, TError, DeleteArticleMutationVariables, TContext>(
      ['DeleteArticle'],
      (variables?: DeleteArticleMutationVariables) => fetcher<DeleteArticleMutation, DeleteArticleMutationVariables>(DeleteArticleDocument, variables)(),
      options
    );
useDeleteArticleMutation.getKey = () => ['DeleteArticle'];

useDeleteArticleMutation.fetcher = (variables: DeleteArticleMutationVariables, options?: RequestInit['headers']) => fetcher<DeleteArticleMutation, DeleteArticleMutationVariables>(DeleteArticleDocument, variables, options);
export const CohortListDocument = `
    query CohortList($visible: Boolean) {
  skupinies(condition: {sVisible: $visible}) {
    nodes {
      ...Cohort
      platbyGroupSkupinasByPgsIdSkupina {
        nodes {
          pgsIdGroup
        }
      }
    }
  }
}
    ${CohortFragmentDoc}`;
export const useCohortListQuery = <
      TData = CohortListQuery,
      TError = unknown
    >(
      variables?: CohortListQueryVariables,
      options?: UseQueryOptions<CohortListQuery, TError, TData>
    ) =>
    useQuery<CohortListQuery, TError, TData>(
      variables === undefined ? ['CohortList'] : ['CohortList', variables],
      fetcher<CohortListQuery, CohortListQueryVariables>(CohortListDocument, variables),
      options
    );

useCohortListQuery.getKey = (variables?: CohortListQueryVariables) => variables === undefined ? ['CohortList'] : ['CohortList', variables];
;

useCohortListQuery.fetcher = (variables?: CohortListQueryVariables, options?: RequestInit['headers']) => fetcher<CohortListQuery, CohortListQueryVariables>(CohortListDocument, variables, options);
export const CohortMembersDocument = `
    query CohortMembers($id: BigInt!) {
  members(condition: {sId: $id}) {
    nodes {
      uJmeno
      uPrijmeni
      uRodneCislo
      uTelefon
      uEmail
    }
  }
}
    `;
export const useCohortMembersQuery = <
      TData = CohortMembersQuery,
      TError = unknown
    >(
      variables: CohortMembersQueryVariables,
      options?: UseQueryOptions<CohortMembersQuery, TError, TData>
    ) =>
    useQuery<CohortMembersQuery, TError, TData>(
      ['CohortMembers', variables],
      fetcher<CohortMembersQuery, CohortMembersQueryVariables>(CohortMembersDocument, variables),
      options
    );

useCohortMembersQuery.getKey = (variables: CohortMembersQueryVariables) => ['CohortMembers', variables];
;

useCohortMembersQuery.fetcher = (variables: CohortMembersQueryVariables, options?: RequestInit['headers']) => fetcher<CohortMembersQuery, CohortMembersQueryVariables>(CohortMembersDocument, variables, options);
export const CohortDocument = `
    query Cohort($id: BigInt!) {
  skupiny(sId: $id) {
    ...Cohort
  }
}
    ${CohortFragmentDoc}`;
export const useCohortQuery = <
      TData = CohortQuery,
      TError = unknown
    >(
      variables: CohortQueryVariables,
      options?: UseQueryOptions<CohortQuery, TError, TData>
    ) =>
    useQuery<CohortQuery, TError, TData>(
      ['Cohort', variables],
      fetcher<CohortQuery, CohortQueryVariables>(CohortDocument, variables),
      options
    );

useCohortQuery.getKey = (variables: CohortQueryVariables) => ['Cohort', variables];
;

useCohortQuery.fetcher = (variables: CohortQueryVariables, options?: RequestInit['headers']) => fetcher<CohortQuery, CohortQueryVariables>(CohortDocument, variables, options);
export const CreateCohortDocument = `
    mutation CreateCohort($input: SkupinyInput!) {
  createSkupiny(input: {skupiny: $input}) {
    __typename
  }
}
    `;
export const useCreateCohortMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<CreateCohortMutation, TError, CreateCohortMutationVariables, TContext>) =>
    useMutation<CreateCohortMutation, TError, CreateCohortMutationVariables, TContext>(
      ['CreateCohort'],
      (variables?: CreateCohortMutationVariables) => fetcher<CreateCohortMutation, CreateCohortMutationVariables>(CreateCohortDocument, variables)(),
      options
    );
useCreateCohortMutation.getKey = () => ['CreateCohort'];

useCreateCohortMutation.fetcher = (variables: CreateCohortMutationVariables, options?: RequestInit['headers']) => fetcher<CreateCohortMutation, CreateCohortMutationVariables>(CreateCohortDocument, variables, options);
export const UpdateCohortDocument = `
    mutation UpdateCohort($id: BigInt!, $patch: SkupinyPatch!) {
  updateSkupiny(input: {sId: $id, patch: $patch}) {
    __typename
  }
}
    `;
export const useUpdateCohortMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateCohortMutation, TError, UpdateCohortMutationVariables, TContext>) =>
    useMutation<UpdateCohortMutation, TError, UpdateCohortMutationVariables, TContext>(
      ['UpdateCohort'],
      (variables?: UpdateCohortMutationVariables) => fetcher<UpdateCohortMutation, UpdateCohortMutationVariables>(UpdateCohortDocument, variables)(),
      options
    );
useUpdateCohortMutation.getKey = () => ['UpdateCohort'];

useUpdateCohortMutation.fetcher = (variables: UpdateCohortMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateCohortMutation, UpdateCohortMutationVariables>(UpdateCohortDocument, variables, options);
export const DeleteCohortDocument = `
    mutation DeleteCohort($id: BigInt!) {
  deleteSkupiny(input: {sId: $id}) {
    __typename
  }
}
    `;
export const useDeleteCohortMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteCohortMutation, TError, DeleteCohortMutationVariables, TContext>) =>
    useMutation<DeleteCohortMutation, TError, DeleteCohortMutationVariables, TContext>(
      ['DeleteCohort'],
      (variables?: DeleteCohortMutationVariables) => fetcher<DeleteCohortMutation, DeleteCohortMutationVariables>(DeleteCohortDocument, variables)(),
      options
    );
useDeleteCohortMutation.getKey = () => ['DeleteCohort'];

useDeleteCohortMutation.fetcher = (variables: DeleteCohortMutationVariables, options?: RequestInit['headers']) => fetcher<DeleteCohortMutation, DeleteCohortMutationVariables>(DeleteCohortDocument, variables, options);
export const CoupleListDocument = `
    query CoupleList {
  activeCouples {
    totalCount
    nodes {
      pId
      userByPIdPartner {
        uJmeno
        uPrijmeni
      }
      userByPIdPartnerka {
        uJmeno
        uPrijmeni
      }
    }
  }
}
    `;
export const useCoupleListQuery = <
      TData = CoupleListQuery,
      TError = unknown
    >(
      variables?: CoupleListQueryVariables,
      options?: UseQueryOptions<CoupleListQuery, TError, TData>
    ) =>
    useQuery<CoupleListQuery, TError, TData>(
      variables === undefined ? ['CoupleList'] : ['CoupleList', variables],
      fetcher<CoupleListQuery, CoupleListQueryVariables>(CoupleListDocument, variables),
      options
    );

useCoupleListQuery.getKey = (variables?: CoupleListQueryVariables) => variables === undefined ? ['CoupleList'] : ['CoupleList', variables];
;

useCoupleListQuery.fetcher = (variables?: CoupleListQueryVariables, options?: RequestInit['headers']) => fetcher<CoupleListQuery, CoupleListQueryVariables>(CoupleListDocument, variables, options);
export const CreateCoupleDocument = `
    mutation CreateCouple($man: BigInt!, $woman: BigInt!) {
  createCouple(input: {man: $man, woman: $woman}) {
    paries {
      pId
    }
  }
}
    `;
export const useCreateCoupleMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<CreateCoupleMutation, TError, CreateCoupleMutationVariables, TContext>) =>
    useMutation<CreateCoupleMutation, TError, CreateCoupleMutationVariables, TContext>(
      ['CreateCouple'],
      (variables?: CreateCoupleMutationVariables) => fetcher<CreateCoupleMutation, CreateCoupleMutationVariables>(CreateCoupleDocument, variables)(),
      options
    );
useCreateCoupleMutation.getKey = () => ['CreateCouple'];

useCreateCoupleMutation.fetcher = (variables: CreateCoupleMutationVariables, options?: RequestInit['headers']) => fetcher<CreateCoupleMutation, CreateCoupleMutationVariables>(CreateCoupleDocument, variables, options);
export const DeleteCoupleDocument = `
    mutation DeleteCouple($id: BigInt!) {
  deletePary(input: {pId: $id}) {
    __typename
  }
}
    `;
export const useDeleteCoupleMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteCoupleMutation, TError, DeleteCoupleMutationVariables, TContext>) =>
    useMutation<DeleteCoupleMutation, TError, DeleteCoupleMutationVariables, TContext>(
      ['DeleteCouple'],
      (variables?: DeleteCoupleMutationVariables) => fetcher<DeleteCoupleMutation, DeleteCoupleMutationVariables>(DeleteCoupleDocument, variables)(),
      options
    );
useDeleteCoupleMutation.getKey = () => ['DeleteCouple'];

useDeleteCoupleMutation.fetcher = (variables: DeleteCoupleMutationVariables, options?: RequestInit['headers']) => fetcher<DeleteCoupleMutation, DeleteCoupleMutationVariables>(DeleteCoupleDocument, variables, options);
export const FixUnpairedCouplesDocument = `
    mutation FixUnpairedCouples {
  fixUnpairedCouples(input: {}) {
    paries {
      pId
    }
  }
}
    `;
export const useFixUnpairedCouplesMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<FixUnpairedCouplesMutation, TError, FixUnpairedCouplesMutationVariables, TContext>) =>
    useMutation<FixUnpairedCouplesMutation, TError, FixUnpairedCouplesMutationVariables, TContext>(
      ['FixUnpairedCouples'],
      (variables?: FixUnpairedCouplesMutationVariables) => fetcher<FixUnpairedCouplesMutation, FixUnpairedCouplesMutationVariables>(FixUnpairedCouplesDocument, variables)(),
      options
    );
useFixUnpairedCouplesMutation.getKey = () => ['FixUnpairedCouples'];

useFixUnpairedCouplesMutation.fetcher = (variables?: FixUnpairedCouplesMutationVariables, options?: RequestInit['headers']) => fetcher<FixUnpairedCouplesMutation, FixUnpairedCouplesMutationVariables>(FixUnpairedCouplesDocument, variables, options);
export const ActiveProspectsDocument = `
    query ActiveProspects {
  activeProspects {
    totalCount
    nodes {
      id
      data {
        name
        surname
        email
        phone
        yearofbirth
      }
      cohort
      updatedAt
    }
  }
}
    `;
export const useActiveProspectsQuery = <
      TData = ActiveProspectsQuery,
      TError = unknown
    >(
      variables?: ActiveProspectsQueryVariables,
      options?: UseQueryOptions<ActiveProspectsQuery, TError, TData>
    ) =>
    useQuery<ActiveProspectsQuery, TError, TData>(
      variables === undefined ? ['ActiveProspects'] : ['ActiveProspects', variables],
      fetcher<ActiveProspectsQuery, ActiveProspectsQueryVariables>(ActiveProspectsDocument, variables),
      options
    );

useActiveProspectsQuery.getKey = (variables?: ActiveProspectsQueryVariables) => variables === undefined ? ['ActiveProspects'] : ['ActiveProspects', variables];
;

useActiveProspectsQuery.fetcher = (variables?: ActiveProspectsQueryVariables, options?: RequestInit['headers']) => fetcher<ActiveProspectsQuery, ActiveProspectsQueryVariables>(ActiveProspectsDocument, variables, options);
export const SubmitProspectFormDocument = `
    mutation SubmitProspectForm($cohort: CrmCohort!, $origin: String!, $prospectData: ProspectDatumInput!) {
  prospectFormDancer(
    input: {cohort: $cohort, origin: $origin, prospectData: $prospectData, note: ""}
  ) {
    clientMutationId
  }
}
    `;
export const useSubmitProspectFormMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<SubmitProspectFormMutation, TError, SubmitProspectFormMutationVariables, TContext>) =>
    useMutation<SubmitProspectFormMutation, TError, SubmitProspectFormMutationVariables, TContext>(
      ['SubmitProspectForm'],
      (variables?: SubmitProspectFormMutationVariables) => fetcher<SubmitProspectFormMutation, SubmitProspectFormMutationVariables>(SubmitProspectFormDocument, variables)(),
      options
    );
useSubmitProspectFormMutation.getKey = () => ['SubmitProspectForm'];

useSubmitProspectFormMutation.fetcher = (variables: SubmitProspectFormMutationVariables, options?: RequestInit['headers']) => fetcher<SubmitProspectFormMutation, SubmitProspectFormMutationVariables>(SubmitProspectFormDocument, variables, options);
export const CurrentUserDocument = `
    query CurrentUser {
  getCurrentUser {
    ...UserAuth
  }
}
    ${UserAuthFragmentDoc}`;
export const useCurrentUserQuery = <
      TData = CurrentUserQuery,
      TError = unknown
    >(
      variables?: CurrentUserQueryVariables,
      options?: UseQueryOptions<CurrentUserQuery, TError, TData>
    ) =>
    useQuery<CurrentUserQuery, TError, TData>(
      variables === undefined ? ['CurrentUser'] : ['CurrentUser', variables],
      fetcher<CurrentUserQuery, CurrentUserQueryVariables>(CurrentUserDocument, variables),
      options
    );

useCurrentUserQuery.getKey = (variables?: CurrentUserQueryVariables) => variables === undefined ? ['CurrentUser'] : ['CurrentUser', variables];
;

useCurrentUserQuery.fetcher = (variables?: CurrentUserQueryVariables, options?: RequestInit['headers']) => fetcher<CurrentUserQuery, CurrentUserQueryVariables>(CurrentUserDocument, variables, options);
export const LoginDocument = `
    mutation Login($login: String!, $passwd: String!) {
  login(input: {login: $login, passwd: $passwd}) {
    result {
      usr {
        ...User
        permissionByUGroup {
          ...Role
        }
      }
      couple {
        ...CouplePartial
      }
    }
  }
}
    ${UserFragmentDoc}
${RoleFragmentDoc}
${CouplePartialFragmentDoc}`;
export const useLoginMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<LoginMutation, TError, LoginMutationVariables, TContext>) =>
    useMutation<LoginMutation, TError, LoginMutationVariables, TContext>(
      ['Login'],
      (variables?: LoginMutationVariables) => fetcher<LoginMutation, LoginMutationVariables>(LoginDocument, variables)(),
      options
    );
useLoginMutation.getKey = () => ['Login'];

useLoginMutation.fetcher = (variables: LoginMutationVariables, options?: RequestInit['headers']) => fetcher<LoginMutation, LoginMutationVariables>(LoginDocument, variables, options);
export const LogoutDocument = `
    mutation Logout {
  logout(input: {}) {
    __typename
  }
}
    `;
export const useLogoutMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<LogoutMutation, TError, LogoutMutationVariables, TContext>) =>
    useMutation<LogoutMutation, TError, LogoutMutationVariables, TContext>(
      ['Logout'],
      (variables?: LogoutMutationVariables) => fetcher<LogoutMutation, LogoutMutationVariables>(LogoutDocument, variables)(),
      options
    );
useLogoutMutation.getKey = () => ['Logout'];

useLogoutMutation.fetcher = (variables?: LogoutMutationVariables, options?: RequestInit['headers']) => fetcher<LogoutMutation, LogoutMutationVariables>(LogoutDocument, variables, options);
export const RegisterDocument = `
    mutation Register($input: CreateUserInput!) {
  createUser(input: $input) {
    user {
      uId
    }
  }
}
    `;
export const useRegisterMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<RegisterMutation, TError, RegisterMutationVariables, TContext>) =>
    useMutation<RegisterMutation, TError, RegisterMutationVariables, TContext>(
      ['Register'],
      (variables?: RegisterMutationVariables) => fetcher<RegisterMutation, RegisterMutationVariables>(RegisterDocument, variables)(),
      options
    );
useRegisterMutation.getKey = () => ['Register'];

useRegisterMutation.fetcher = (variables: RegisterMutationVariables, options?: RequestInit['headers']) => fetcher<RegisterMutation, RegisterMutationVariables>(RegisterDocument, variables, options);
export const ResetPasswordDocument = `
    mutation ResetPassword($input: ResetPasswordInput!) {
  resetPassword(input: $input) {
    __typename
  }
}
    `;
export const useResetPasswordMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<ResetPasswordMutation, TError, ResetPasswordMutationVariables, TContext>) =>
    useMutation<ResetPasswordMutation, TError, ResetPasswordMutationVariables, TContext>(
      ['ResetPassword'],
      (variables?: ResetPasswordMutationVariables) => fetcher<ResetPasswordMutation, ResetPasswordMutationVariables>(ResetPasswordDocument, variables)(),
      options
    );
useResetPasswordMutation.getKey = () => ['ResetPassword'];

useResetPasswordMutation.fetcher = (variables: ResetPasswordMutationVariables, options?: RequestInit['headers']) => fetcher<ResetPasswordMutation, ResetPasswordMutationVariables>(ResetPasswordDocument, variables, options);
export const FileListDocument = `
    query FileList($limit: Int, $offset: Int, $category: Int) {
  dokumenties(
    offset: $offset
    first: $limit
    condition: {dKategorie: $category}
    orderBy: D_TIMESTAMP_DESC
  ) {
    totalCount
    nodes {
      ...File
      userByDKdo {
        uJmeno
        uPrijmeni
      }
    }
  }
}
    ${FileFragmentDoc}`;
export const useFileListQuery = <
      TData = FileListQuery,
      TError = unknown
    >(
      variables?: FileListQueryVariables,
      options?: UseQueryOptions<FileListQuery, TError, TData>
    ) =>
    useQuery<FileListQuery, TError, TData>(
      variables === undefined ? ['FileList'] : ['FileList', variables],
      fetcher<FileListQuery, FileListQueryVariables>(FileListDocument, variables),
      options
    );

useFileListQuery.getKey = (variables?: FileListQueryVariables) => variables === undefined ? ['FileList'] : ['FileList', variables];
;

useFileListQuery.fetcher = (variables?: FileListQueryVariables, options?: RequestInit['headers']) => fetcher<FileListQuery, FileListQueryVariables>(FileListDocument, variables, options);
export const FileDocument = `
    query File($id: BigInt!) {
  dokumenty(dId: $id) {
    ...File
  }
}
    ${FileFragmentDoc}`;
export const useFileQuery = <
      TData = FileQuery,
      TError = unknown
    >(
      variables: FileQueryVariables,
      options?: UseQueryOptions<FileQuery, TError, TData>
    ) =>
    useQuery<FileQuery, TError, TData>(
      ['File', variables],
      fetcher<FileQuery, FileQueryVariables>(FileDocument, variables),
      options
    );

useFileQuery.getKey = (variables: FileQueryVariables) => ['File', variables];
;

useFileQuery.fetcher = (variables: FileQueryVariables, options?: RequestInit['headers']) => fetcher<FileQuery, FileQueryVariables>(FileDocument, variables, options);
export const CreateFileDocument = `
    mutation CreateFile($input: DokumentyInput!) {
  createDokumenty(input: {dokumenty: $input}) {
    __typename
  }
}
    `;
export const useCreateFileMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<CreateFileMutation, TError, CreateFileMutationVariables, TContext>) =>
    useMutation<CreateFileMutation, TError, CreateFileMutationVariables, TContext>(
      ['CreateFile'],
      (variables?: CreateFileMutationVariables) => fetcher<CreateFileMutation, CreateFileMutationVariables>(CreateFileDocument, variables)(),
      options
    );
useCreateFileMutation.getKey = () => ['CreateFile'];

useCreateFileMutation.fetcher = (variables: CreateFileMutationVariables, options?: RequestInit['headers']) => fetcher<CreateFileMutation, CreateFileMutationVariables>(CreateFileDocument, variables, options);
export const UpdateFileDocument = `
    mutation UpdateFile($id: BigInt!, $patch: DokumentyPatch!) {
  updateDokumenty(input: {dId: $id, patch: $patch}) {
    __typename
  }
}
    `;
export const useUpdateFileMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateFileMutation, TError, UpdateFileMutationVariables, TContext>) =>
    useMutation<UpdateFileMutation, TError, UpdateFileMutationVariables, TContext>(
      ['UpdateFile'],
      (variables?: UpdateFileMutationVariables) => fetcher<UpdateFileMutation, UpdateFileMutationVariables>(UpdateFileDocument, variables)(),
      options
    );
useUpdateFileMutation.getKey = () => ['UpdateFile'];

useUpdateFileMutation.fetcher = (variables: UpdateFileMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateFileMutation, UpdateFileMutationVariables>(UpdateFileDocument, variables, options);
export const DeleteFileDocument = `
    mutation DeleteFile($id: BigInt!) {
  deleteDokumenty(input: {dId: $id}) {
    __typename
  }
}
    `;
export const useDeleteFileMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteFileMutation, TError, DeleteFileMutationVariables, TContext>) =>
    useMutation<DeleteFileMutation, TError, DeleteFileMutationVariables, TContext>(
      ['DeleteFile'],
      (variables?: DeleteFileMutationVariables) => fetcher<DeleteFileMutation, DeleteFileMutationVariables>(DeleteFileDocument, variables)(),
      options
    );
useDeleteFileMutation.getKey = () => ['DeleteFile'];

useDeleteFileMutation.fetcher = (variables: DeleteFileMutationVariables, options?: RequestInit['headers']) => fetcher<DeleteFileMutation, DeleteFileMutationVariables>(DeleteFileDocument, variables, options);
export const EventParticipantsDocument = `
    query EventParticipants($id: BigInt!) {
  akce(aId: $id) {
    aJmeno
    akceItemsByAiIdRodic {
      nodes {
        ...EventItem
      }
    }
  }
}
    ${EventItemFragmentDoc}`;
export const useEventParticipantsQuery = <
      TData = EventParticipantsQuery,
      TError = unknown
    >(
      variables: EventParticipantsQueryVariables,
      options?: UseQueryOptions<EventParticipantsQuery, TError, TData>
    ) =>
    useQuery<EventParticipantsQuery, TError, TData>(
      ['EventParticipants', variables],
      fetcher<EventParticipantsQuery, EventParticipantsQueryVariables>(EventParticipantsDocument, variables),
      options
    );

useEventParticipantsQuery.getKey = (variables: EventParticipantsQueryVariables) => ['EventParticipants', variables];
;

useEventParticipantsQuery.fetcher = (variables: EventParticipantsQueryVariables, options?: RequestInit['headers']) => fetcher<EventParticipantsQuery, EventParticipantsQueryVariables>(EventParticipantsDocument, variables, options);
export const EventListDocument = `
    query EventList($limit: Int, $offset: Int, $visible: Boolean) {
  akces(
    first: $limit
    offset: $offset
    orderBy: [A_OD_DESC]
    condition: {aVisible: $visible}
  ) {
    totalCount
    nodes {
      ...EventWithItems
    }
  }
}
    ${EventWithItemsFragmentDoc}`;
export const useEventListQuery = <
      TData = EventListQuery,
      TError = unknown
    >(
      variables?: EventListQueryVariables,
      options?: UseQueryOptions<EventListQuery, TError, TData>
    ) =>
    useQuery<EventListQuery, TError, TData>(
      variables === undefined ? ['EventList'] : ['EventList', variables],
      fetcher<EventListQuery, EventListQueryVariables>(EventListDocument, variables),
      options
    );

useEventListQuery.getKey = (variables?: EventListQueryVariables) => variables === undefined ? ['EventList'] : ['EventList', variables];
;

useEventListQuery.fetcher = (variables?: EventListQueryVariables, options?: RequestInit['headers']) => fetcher<EventListQuery, EventListQueryVariables>(EventListDocument, variables, options);
export const EventDocument = `
    query Event($id: BigInt!) {
  akce(aId: $id) {
    ...Event
  }
}
    ${EventFragmentDoc}`;
export const useEventQuery = <
      TData = EventQuery,
      TError = unknown
    >(
      variables: EventQueryVariables,
      options?: UseQueryOptions<EventQuery, TError, TData>
    ) =>
    useQuery<EventQuery, TError, TData>(
      ['Event', variables],
      fetcher<EventQuery, EventQueryVariables>(EventDocument, variables),
      options
    );

useEventQuery.getKey = (variables: EventQueryVariables) => ['Event', variables];
;

useEventQuery.fetcher = (variables: EventQueryVariables, options?: RequestInit['headers']) => fetcher<EventQuery, EventQueryVariables>(EventDocument, variables, options);
export const ToggleEventVisibleDocument = `
    mutation ToggleEventVisible($id: BigInt!, $visible: Boolean!) {
  updateAkce(input: {aId: $id, patch: {aVisible: $visible}}) {
    akce {
      aId
    }
  }
}
    `;
export const useToggleEventVisibleMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<ToggleEventVisibleMutation, TError, ToggleEventVisibleMutationVariables, TContext>) =>
    useMutation<ToggleEventVisibleMutation, TError, ToggleEventVisibleMutationVariables, TContext>(
      ['ToggleEventVisible'],
      (variables?: ToggleEventVisibleMutationVariables) => fetcher<ToggleEventVisibleMutation, ToggleEventVisibleMutationVariables>(ToggleEventVisibleDocument, variables)(),
      options
    );
useToggleEventVisibleMutation.getKey = () => ['ToggleEventVisible'];

useToggleEventVisibleMutation.fetcher = (variables: ToggleEventVisibleMutationVariables, options?: RequestInit['headers']) => fetcher<ToggleEventVisibleMutation, ToggleEventVisibleMutationVariables>(ToggleEventVisibleDocument, variables, options);
export const CreateEventDocument = `
    mutation CreateEvent($input: AkceInput!) {
  createAkce(input: {akce: $input}) {
    __typename
  }
}
    `;
export const useCreateEventMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<CreateEventMutation, TError, CreateEventMutationVariables, TContext>) =>
    useMutation<CreateEventMutation, TError, CreateEventMutationVariables, TContext>(
      ['CreateEvent'],
      (variables?: CreateEventMutationVariables) => fetcher<CreateEventMutation, CreateEventMutationVariables>(CreateEventDocument, variables)(),
      options
    );
useCreateEventMutation.getKey = () => ['CreateEvent'];

useCreateEventMutation.fetcher = (variables: CreateEventMutationVariables, options?: RequestInit['headers']) => fetcher<CreateEventMutation, CreateEventMutationVariables>(CreateEventDocument, variables, options);
export const UpdateEventDocument = `
    mutation UpdateEvent($id: BigInt!, $patch: AkcePatch!) {
  updateAkce(input: {aId: $id, patch: $patch}) {
    __typename
  }
}
    `;
export const useUpdateEventMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateEventMutation, TError, UpdateEventMutationVariables, TContext>) =>
    useMutation<UpdateEventMutation, TError, UpdateEventMutationVariables, TContext>(
      ['UpdateEvent'],
      (variables?: UpdateEventMutationVariables) => fetcher<UpdateEventMutation, UpdateEventMutationVariables>(UpdateEventDocument, variables)(),
      options
    );
useUpdateEventMutation.getKey = () => ['UpdateEvent'];

useUpdateEventMutation.fetcher = (variables: UpdateEventMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateEventMutation, UpdateEventMutationVariables>(UpdateEventDocument, variables, options);
export const DeleteEventDocument = `
    mutation DeleteEvent($id: BigInt!) {
  deleteAkce(input: {aId: $id}) {
    __typename
  }
}
    `;
export const useDeleteEventMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteEventMutation, TError, DeleteEventMutationVariables, TContext>) =>
    useMutation<DeleteEventMutation, TError, DeleteEventMutationVariables, TContext>(
      ['DeleteEvent'],
      (variables?: DeleteEventMutationVariables) => fetcher<DeleteEventMutation, DeleteEventMutationVariables>(DeleteEventDocument, variables)(),
      options
    );
useDeleteEventMutation.getKey = () => ['DeleteEvent'];

useDeleteEventMutation.fetcher = (variables: DeleteEventMutationVariables, options?: RequestInit['headers']) => fetcher<DeleteEventMutation, DeleteEventMutationVariables>(DeleteEventDocument, variables, options);
export const GalleryDirDocument = `
    query GalleryDir($id: BigInt!) {
  galerieDir(gdId: $id) {
    ...GalleryDir
    galerieFotosByGfIdRodic(orderBy: [GF_NAME_ASC]) {
      nodes {
        ...GalleryPhoto
      }
    }
  }
  galerieDirs(condition: {gdIdRodic: $id, gdHidden: false}) {
    nodes {
      ...GalleryDir
      galerieFotosByGfIdRodic(orderBy: [GF_NAME_ASC], first: 1) {
        nodes {
          ...GalleryPhoto
        }
      }
    }
  }
}
    ${GalleryDirFragmentDoc}
${GalleryPhotoFragmentDoc}`;
export const useGalleryDirQuery = <
      TData = GalleryDirQuery,
      TError = unknown
    >(
      variables: GalleryDirQueryVariables,
      options?: UseQueryOptions<GalleryDirQuery, TError, TData>
    ) =>
    useQuery<GalleryDirQuery, TError, TData>(
      ['GalleryDir', variables],
      fetcher<GalleryDirQuery, GalleryDirQueryVariables>(GalleryDirDocument, variables),
      options
    );

useGalleryDirQuery.getKey = (variables: GalleryDirQueryVariables) => ['GalleryDir', variables];
;

useGalleryDirQuery.fetcher = (variables: GalleryDirQueryVariables, options?: RequestInit['headers']) => fetcher<GalleryDirQuery, GalleryDirQueryVariables>(GalleryDirDocument, variables, options);
export const GalleryDirListDocument = `
    query GalleryDirList($limit: Int, $offset: Int) {
  galerieDirs(first: $limit, offset: $offset, orderBy: [GD_NAME_ASC]) {
    totalCount
    nodes {
      ...GalleryDir
    }
  }
}
    ${GalleryDirFragmentDoc}`;
export const useGalleryDirListQuery = <
      TData = GalleryDirListQuery,
      TError = unknown
    >(
      variables?: GalleryDirListQueryVariables,
      options?: UseQueryOptions<GalleryDirListQuery, TError, TData>
    ) =>
    useQuery<GalleryDirListQuery, TError, TData>(
      variables === undefined ? ['GalleryDirList'] : ['GalleryDirList', variables],
      fetcher<GalleryDirListQuery, GalleryDirListQueryVariables>(GalleryDirListDocument, variables),
      options
    );

useGalleryDirListQuery.getKey = (variables?: GalleryDirListQueryVariables) => variables === undefined ? ['GalleryDirList'] : ['GalleryDirList', variables];
;

useGalleryDirListQuery.fetcher = (variables?: GalleryDirListQueryVariables, options?: RequestInit['headers']) => fetcher<GalleryDirListQuery, GalleryDirListQueryVariables>(GalleryDirListDocument, variables, options);
export const ToggleGalleryDirVisibleDocument = `
    mutation ToggleGalleryDirVisible($id: BigInt!, $visible: Boolean!) {
  updateGalerieDir(input: {gdId: $id, patch: {gdHidden: $visible}}) {
    galerieDir {
      gdId
    }
  }
}
    `;
export const useToggleGalleryDirVisibleMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<ToggleGalleryDirVisibleMutation, TError, ToggleGalleryDirVisibleMutationVariables, TContext>) =>
    useMutation<ToggleGalleryDirVisibleMutation, TError, ToggleGalleryDirVisibleMutationVariables, TContext>(
      ['ToggleGalleryDirVisible'],
      (variables?: ToggleGalleryDirVisibleMutationVariables) => fetcher<ToggleGalleryDirVisibleMutation, ToggleGalleryDirVisibleMutationVariables>(ToggleGalleryDirVisibleDocument, variables)(),
      options
    );
useToggleGalleryDirVisibleMutation.getKey = () => ['ToggleGalleryDirVisible'];

useToggleGalleryDirVisibleMutation.fetcher = (variables: ToggleGalleryDirVisibleMutationVariables, options?: RequestInit['headers']) => fetcher<ToggleGalleryDirVisibleMutation, ToggleGalleryDirVisibleMutationVariables>(ToggleGalleryDirVisibleDocument, variables, options);
export const CreateGalleryDirDocument = `
    mutation CreateGalleryDir($input: GalerieDirInput!) {
  createGalerieDir(input: {galerieDir: $input}) {
    __typename
  }
}
    `;
export const useCreateGalleryDirMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<CreateGalleryDirMutation, TError, CreateGalleryDirMutationVariables, TContext>) =>
    useMutation<CreateGalleryDirMutation, TError, CreateGalleryDirMutationVariables, TContext>(
      ['CreateGalleryDir'],
      (variables?: CreateGalleryDirMutationVariables) => fetcher<CreateGalleryDirMutation, CreateGalleryDirMutationVariables>(CreateGalleryDirDocument, variables)(),
      options
    );
useCreateGalleryDirMutation.getKey = () => ['CreateGalleryDir'];

useCreateGalleryDirMutation.fetcher = (variables: CreateGalleryDirMutationVariables, options?: RequestInit['headers']) => fetcher<CreateGalleryDirMutation, CreateGalleryDirMutationVariables>(CreateGalleryDirDocument, variables, options);
export const UpdateGalleryDirDocument = `
    mutation UpdateGalleryDir($id: BigInt!, $patch: GalerieDirPatch!) {
  updateGalerieDir(input: {gdId: $id, patch: $patch}) {
    __typename
  }
}
    `;
export const useUpdateGalleryDirMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateGalleryDirMutation, TError, UpdateGalleryDirMutationVariables, TContext>) =>
    useMutation<UpdateGalleryDirMutation, TError, UpdateGalleryDirMutationVariables, TContext>(
      ['UpdateGalleryDir'],
      (variables?: UpdateGalleryDirMutationVariables) => fetcher<UpdateGalleryDirMutation, UpdateGalleryDirMutationVariables>(UpdateGalleryDirDocument, variables)(),
      options
    );
useUpdateGalleryDirMutation.getKey = () => ['UpdateGalleryDir'];

useUpdateGalleryDirMutation.fetcher = (variables: UpdateGalleryDirMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateGalleryDirMutation, UpdateGalleryDirMutationVariables>(UpdateGalleryDirDocument, variables, options);
export const DeleteGalleryDirDocument = `
    mutation DeleteGalleryDir($id: BigInt!) {
  deleteGalerieDir(input: {gdId: $id}) {
    __typename
  }
}
    `;
export const useDeleteGalleryDirMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteGalleryDirMutation, TError, DeleteGalleryDirMutationVariables, TContext>) =>
    useMutation<DeleteGalleryDirMutation, TError, DeleteGalleryDirMutationVariables, TContext>(
      ['DeleteGalleryDir'],
      (variables?: DeleteGalleryDirMutationVariables) => fetcher<DeleteGalleryDirMutation, DeleteGalleryDirMutationVariables>(DeleteGalleryDirDocument, variables)(),
      options
    );
useDeleteGalleryDirMutation.getKey = () => ['DeleteGalleryDir'];

useDeleteGalleryDirMutation.fetcher = (variables: DeleteGalleryDirMutationVariables, options?: RequestInit['headers']) => fetcher<DeleteGalleryDirMutation, DeleteGalleryDirMutationVariables>(DeleteGalleryDirDocument, variables, options);
export const GalleryPhotoDocument = `
    query GalleryPhoto($id: BigInt!) {
  galerieFoto(gfId: $id) {
    ...GalleryPhoto
  }
}
    ${GalleryPhotoFragmentDoc}`;
export const useGalleryPhotoQuery = <
      TData = GalleryPhotoQuery,
      TError = unknown
    >(
      variables: GalleryPhotoQueryVariables,
      options?: UseQueryOptions<GalleryPhotoQuery, TError, TData>
    ) =>
    useQuery<GalleryPhotoQuery, TError, TData>(
      ['GalleryPhoto', variables],
      fetcher<GalleryPhotoQuery, GalleryPhotoQueryVariables>(GalleryPhotoDocument, variables),
      options
    );

useGalleryPhotoQuery.getKey = (variables: GalleryPhotoQueryVariables) => ['GalleryPhoto', variables];
;

useGalleryPhotoQuery.fetcher = (variables: GalleryPhotoQueryVariables, options?: RequestInit['headers']) => fetcher<GalleryPhotoQuery, GalleryPhotoQueryVariables>(GalleryPhotoDocument, variables, options);
export const CreateGalleryPhotoDocument = `
    mutation CreateGalleryPhoto($input: GalerieFotoInput!) {
  createGalerieFoto(input: {galerieFoto: $input}) {
    __typename
  }
}
    `;
export const useCreateGalleryPhotoMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<CreateGalleryPhotoMutation, TError, CreateGalleryPhotoMutationVariables, TContext>) =>
    useMutation<CreateGalleryPhotoMutation, TError, CreateGalleryPhotoMutationVariables, TContext>(
      ['CreateGalleryPhoto'],
      (variables?: CreateGalleryPhotoMutationVariables) => fetcher<CreateGalleryPhotoMutation, CreateGalleryPhotoMutationVariables>(CreateGalleryPhotoDocument, variables)(),
      options
    );
useCreateGalleryPhotoMutation.getKey = () => ['CreateGalleryPhoto'];

useCreateGalleryPhotoMutation.fetcher = (variables: CreateGalleryPhotoMutationVariables, options?: RequestInit['headers']) => fetcher<CreateGalleryPhotoMutation, CreateGalleryPhotoMutationVariables>(CreateGalleryPhotoDocument, variables, options);
export const UpdateGalleryPhotoDocument = `
    mutation UpdateGalleryPhoto($id: BigInt!, $patch: GalerieFotoPatch!) {
  updateGalerieFoto(input: {gfId: $id, patch: $patch}) {
    __typename
  }
}
    `;
export const useUpdateGalleryPhotoMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateGalleryPhotoMutation, TError, UpdateGalleryPhotoMutationVariables, TContext>) =>
    useMutation<UpdateGalleryPhotoMutation, TError, UpdateGalleryPhotoMutationVariables, TContext>(
      ['UpdateGalleryPhoto'],
      (variables?: UpdateGalleryPhotoMutationVariables) => fetcher<UpdateGalleryPhotoMutation, UpdateGalleryPhotoMutationVariables>(UpdateGalleryPhotoDocument, variables)(),
      options
    );
useUpdateGalleryPhotoMutation.getKey = () => ['UpdateGalleryPhoto'];

useUpdateGalleryPhotoMutation.fetcher = (variables: UpdateGalleryPhotoMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateGalleryPhotoMutation, UpdateGalleryPhotoMutationVariables>(UpdateGalleryPhotoDocument, variables, options);
export const DeleteGalleryPhotoDocument = `
    mutation DeleteGalleryPhoto($id: BigInt!) {
  deleteGalerieFoto(input: {gfId: $id}) {
    __typename
  }
}
    `;
export const useDeleteGalleryPhotoMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteGalleryPhotoMutation, TError, DeleteGalleryPhotoMutationVariables, TContext>) =>
    useMutation<DeleteGalleryPhotoMutation, TError, DeleteGalleryPhotoMutationVariables, TContext>(
      ['DeleteGalleryPhoto'],
      (variables?: DeleteGalleryPhotoMutationVariables) => fetcher<DeleteGalleryPhotoMutation, DeleteGalleryPhotoMutationVariables>(DeleteGalleryPhotoDocument, variables)(),
      options
    );
useDeleteGalleryPhotoMutation.getKey = () => ['DeleteGalleryPhoto'];

useDeleteGalleryPhotoMutation.fetcher = (variables: DeleteGalleryPhotoMutationVariables, options?: RequestInit['headers']) => fetcher<DeleteGalleryPhotoMutation, DeleteGalleryPhotoMutationVariables>(DeleteGalleryPhotoDocument, variables, options);
export const PageDocument = `
    query Page($url: String!) {
  pageByUrl(url: $url) {
    content
  }
}
    `;
export const usePageQuery = <
      TData = PageQuery,
      TError = unknown
    >(
      variables: PageQueryVariables,
      options?: UseQueryOptions<PageQuery, TError, TData>
    ) =>
    useQuery<PageQuery, TError, TData>(
      ['Page', variables],
      fetcher<PageQuery, PageQueryVariables>(PageDocument, variables),
      options
    );

usePageQuery.getKey = (variables: PageQueryVariables) => ['Page', variables];
;

usePageQuery.fetcher = (variables: PageQueryVariables, options?: RequestInit['headers']) => fetcher<PageQuery, PageQueryVariables>(PageDocument, variables, options);
export const PageListDocument = `
    query PageList {
  pages(orderBy: URL_ASC) {
    nodes {
      ...Page
    }
  }
}
    ${PageFragmentDoc}`;
export const usePageListQuery = <
      TData = PageListQuery,
      TError = unknown
    >(
      variables?: PageListQueryVariables,
      options?: UseQueryOptions<PageListQuery, TError, TData>
    ) =>
    useQuery<PageListQuery, TError, TData>(
      variables === undefined ? ['PageList'] : ['PageList', variables],
      fetcher<PageListQuery, PageListQueryVariables>(PageListDocument, variables),
      options
    );

usePageListQuery.getKey = (variables?: PageListQueryVariables) => variables === undefined ? ['PageList'] : ['PageList', variables];
;

usePageListQuery.fetcher = (variables?: PageListQueryVariables, options?: RequestInit['headers']) => fetcher<PageListQuery, PageListQueryVariables>(PageListDocument, variables, options);
export const PageRevisionsDocument = `
    query PageRevisions($id: Int!) {
  pageRevisions(condition: {id: $id}) {
    nodes {
      revNumber
      revOperation
      revTimestamp
      id
      url
      title
      content
      createdAt
      updatedAt
    }
  }
}
    `;
export const usePageRevisionsQuery = <
      TData = PageRevisionsQuery,
      TError = unknown
    >(
      variables: PageRevisionsQueryVariables,
      options?: UseQueryOptions<PageRevisionsQuery, TError, TData>
    ) =>
    useQuery<PageRevisionsQuery, TError, TData>(
      ['PageRevisions', variables],
      fetcher<PageRevisionsQuery, PageRevisionsQueryVariables>(PageRevisionsDocument, variables),
      options
    );

usePageRevisionsQuery.getKey = (variables: PageRevisionsQueryVariables) => ['PageRevisions', variables];
;

usePageRevisionsQuery.fetcher = (variables: PageRevisionsQueryVariables, options?: RequestInit['headers']) => fetcher<PageRevisionsQuery, PageRevisionsQueryVariables>(PageRevisionsDocument, variables, options);
export const CreatePageDocument = `
    mutation CreatePage($input: PageInput!) {
  createPage(input: {page: $input}) {
    page {
      ...Page
    }
  }
}
    ${PageFragmentDoc}`;
export const useCreatePageMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<CreatePageMutation, TError, CreatePageMutationVariables, TContext>) =>
    useMutation<CreatePageMutation, TError, CreatePageMutationVariables, TContext>(
      ['CreatePage'],
      (variables?: CreatePageMutationVariables) => fetcher<CreatePageMutation, CreatePageMutationVariables>(CreatePageDocument, variables)(),
      options
    );
useCreatePageMutation.getKey = () => ['CreatePage'];

useCreatePageMutation.fetcher = (variables: CreatePageMutationVariables, options?: RequestInit['headers']) => fetcher<CreatePageMutation, CreatePageMutationVariables>(CreatePageDocument, variables, options);
export const UpdatePageDocument = `
    mutation UpdatePage($id: Int!, $patch: PagePatch!) {
  updatePage(input: {id: $id, patch: $patch}) {
    page {
      ...Page
    }
  }
}
    ${PageFragmentDoc}`;
export const useUpdatePageMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<UpdatePageMutation, TError, UpdatePageMutationVariables, TContext>) =>
    useMutation<UpdatePageMutation, TError, UpdatePageMutationVariables, TContext>(
      ['UpdatePage'],
      (variables?: UpdatePageMutationVariables) => fetcher<UpdatePageMutation, UpdatePageMutationVariables>(UpdatePageDocument, variables)(),
      options
    );
useUpdatePageMutation.getKey = () => ['UpdatePage'];

useUpdatePageMutation.fetcher = (variables: UpdatePageMutationVariables, options?: RequestInit['headers']) => fetcher<UpdatePageMutation, UpdatePageMutationVariables>(UpdatePageDocument, variables, options);
export const MenuDocument = `
    query Menu {
  parameter(paName: "menu") {
    paValue
  }
}
    `;
export const useMenuQuery = <
      TData = MenuQuery,
      TError = unknown
    >(
      variables?: MenuQueryVariables,
      options?: UseQueryOptions<MenuQuery, TError, TData>
    ) =>
    useQuery<MenuQuery, TError, TData>(
      variables === undefined ? ['Menu'] : ['Menu', variables],
      fetcher<MenuQuery, MenuQueryVariables>(MenuDocument, variables),
      options
    );

useMenuQuery.getKey = (variables?: MenuQueryVariables) => variables === undefined ? ['Menu'] : ['Menu', variables];
;

useMenuQuery.fetcher = (variables?: MenuQueryVariables, options?: RequestInit['headers']) => fetcher<MenuQuery, MenuQueryVariables>(MenuDocument, variables, options);
export const ParameterListDocument = `
    query ParameterList {
  parameters {
    totalCount
    nodes {
      paName
      paValue
    }
  }
}
    `;
export const useParameterListQuery = <
      TData = ParameterListQuery,
      TError = unknown
    >(
      variables?: ParameterListQueryVariables,
      options?: UseQueryOptions<ParameterListQuery, TError, TData>
    ) =>
    useQuery<ParameterListQuery, TError, TData>(
      variables === undefined ? ['ParameterList'] : ['ParameterList', variables],
      fetcher<ParameterListQuery, ParameterListQueryVariables>(ParameterListDocument, variables),
      options
    );

useParameterListQuery.getKey = (variables?: ParameterListQueryVariables) => variables === undefined ? ['ParameterList'] : ['ParameterList', variables];
;

useParameterListQuery.fetcher = (variables?: ParameterListQueryVariables, options?: RequestInit['headers']) => fetcher<ParameterListQuery, ParameterListQueryVariables>(ParameterListDocument, variables, options);
export const CreateParameterDocument = `
    mutation CreateParameter($input: ParameterInput!) {
  createParameter(input: {parameter: $input}) {
    __typename
  }
}
    `;
export const useCreateParameterMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<CreateParameterMutation, TError, CreateParameterMutationVariables, TContext>) =>
    useMutation<CreateParameterMutation, TError, CreateParameterMutationVariables, TContext>(
      ['CreateParameter'],
      (variables?: CreateParameterMutationVariables) => fetcher<CreateParameterMutation, CreateParameterMutationVariables>(CreateParameterDocument, variables)(),
      options
    );
useCreateParameterMutation.getKey = () => ['CreateParameter'];

useCreateParameterMutation.fetcher = (variables: CreateParameterMutationVariables, options?: RequestInit['headers']) => fetcher<CreateParameterMutation, CreateParameterMutationVariables>(CreateParameterDocument, variables, options);
export const UpdateParameterDocument = `
    mutation UpdateParameter($id: String!, $value: String!) {
  updateParameter(input: {paName: $id, patch: {paValue: $value}}) {
    __typename
  }
}
    `;
export const useUpdateParameterMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateParameterMutation, TError, UpdateParameterMutationVariables, TContext>) =>
    useMutation<UpdateParameterMutation, TError, UpdateParameterMutationVariables, TContext>(
      ['UpdateParameter'],
      (variables?: UpdateParameterMutationVariables) => fetcher<UpdateParameterMutation, UpdateParameterMutationVariables>(UpdateParameterDocument, variables)(),
      options
    );
useUpdateParameterMutation.getKey = () => ['UpdateParameter'];

useUpdateParameterMutation.fetcher = (variables: UpdateParameterMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateParameterMutation, UpdateParameterMutationVariables>(UpdateParameterDocument, variables, options);
export const DeleteParameterDocument = `
    mutation DeleteParameter($id: String!) {
  deleteParameter(input: {paName: $id}) {
    __typename
  }
}
    `;
export const useDeleteParameterMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteParameterMutation, TError, DeleteParameterMutationVariables, TContext>) =>
    useMutation<DeleteParameterMutation, TError, DeleteParameterMutationVariables, TContext>(
      ['DeleteParameter'],
      (variables?: DeleteParameterMutationVariables) => fetcher<DeleteParameterMutation, DeleteParameterMutationVariables>(DeleteParameterDocument, variables)(),
      options
    );
useDeleteParameterMutation.getKey = () => ['DeleteParameter'];

useDeleteParameterMutation.fetcher = (variables: DeleteParameterMutationVariables, options?: RequestInit['headers']) => fetcher<DeleteParameterMutation, DeleteParameterMutationVariables>(DeleteParameterDocument, variables, options);
export const PaymentGroupListDocument = `
    query PaymentGroupList {
  platbyGroups {
    totalCount
    nodes {
      ...PaymentGroup
    }
  }
}
    ${PaymentGroupFragmentDoc}`;
export const usePaymentGroupListQuery = <
      TData = PaymentGroupListQuery,
      TError = unknown
    >(
      variables?: PaymentGroupListQueryVariables,
      options?: UseQueryOptions<PaymentGroupListQuery, TError, TData>
    ) =>
    useQuery<PaymentGroupListQuery, TError, TData>(
      variables === undefined ? ['PaymentGroupList'] : ['PaymentGroupList', variables],
      fetcher<PaymentGroupListQuery, PaymentGroupListQueryVariables>(PaymentGroupListDocument, variables),
      options
    );

usePaymentGroupListQuery.getKey = (variables?: PaymentGroupListQueryVariables) => variables === undefined ? ['PaymentGroupList'] : ['PaymentGroupList', variables];
;

usePaymentGroupListQuery.fetcher = (variables?: PaymentGroupListQueryVariables, options?: RequestInit['headers']) => fetcher<PaymentGroupListQuery, PaymentGroupListQueryVariables>(PaymentGroupListDocument, variables, options);
export const PaymentGroupDocument = `
    query PaymentGroup($id: BigInt!) {
  platbyGroup(pgId: $id) {
    ...PaymentGroup
  }
}
    ${PaymentGroupFragmentDoc}`;
export const usePaymentGroupQuery = <
      TData = PaymentGroupQuery,
      TError = unknown
    >(
      variables: PaymentGroupQueryVariables,
      options?: UseQueryOptions<PaymentGroupQuery, TError, TData>
    ) =>
    useQuery<PaymentGroupQuery, TError, TData>(
      ['PaymentGroup', variables],
      fetcher<PaymentGroupQuery, PaymentGroupQueryVariables>(PaymentGroupDocument, variables),
      options
    );

usePaymentGroupQuery.getKey = (variables: PaymentGroupQueryVariables) => ['PaymentGroup', variables];
;

usePaymentGroupQuery.fetcher = (variables: PaymentGroupQueryVariables, options?: RequestInit['headers']) => fetcher<PaymentGroupQuery, PaymentGroupQueryVariables>(PaymentGroupDocument, variables, options);
export const CreatePaymentGroupDocument = `
    mutation CreatePaymentGroup($input: PlatbyGroupInput!) {
  createPlatbyGroup(input: {platbyGroup: $input}) {
    __typename
  }
}
    `;
export const useCreatePaymentGroupMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<CreatePaymentGroupMutation, TError, CreatePaymentGroupMutationVariables, TContext>) =>
    useMutation<CreatePaymentGroupMutation, TError, CreatePaymentGroupMutationVariables, TContext>(
      ['CreatePaymentGroup'],
      (variables?: CreatePaymentGroupMutationVariables) => fetcher<CreatePaymentGroupMutation, CreatePaymentGroupMutationVariables>(CreatePaymentGroupDocument, variables)(),
      options
    );
useCreatePaymentGroupMutation.getKey = () => ['CreatePaymentGroup'];

useCreatePaymentGroupMutation.fetcher = (variables: CreatePaymentGroupMutationVariables, options?: RequestInit['headers']) => fetcher<CreatePaymentGroupMutation, CreatePaymentGroupMutationVariables>(CreatePaymentGroupDocument, variables, options);
export const UpdatePaymentGroupDocument = `
    mutation UpdatePaymentGroup($id: BigInt!, $patch: PlatbyGroupPatch!) {
  updatePlatbyGroup(input: {pgId: $id, patch: $patch}) {
    __typename
  }
}
    `;
export const useUpdatePaymentGroupMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<UpdatePaymentGroupMutation, TError, UpdatePaymentGroupMutationVariables, TContext>) =>
    useMutation<UpdatePaymentGroupMutation, TError, UpdatePaymentGroupMutationVariables, TContext>(
      ['UpdatePaymentGroup'],
      (variables?: UpdatePaymentGroupMutationVariables) => fetcher<UpdatePaymentGroupMutation, UpdatePaymentGroupMutationVariables>(UpdatePaymentGroupDocument, variables)(),
      options
    );
useUpdatePaymentGroupMutation.getKey = () => ['UpdatePaymentGroup'];

useUpdatePaymentGroupMutation.fetcher = (variables: UpdatePaymentGroupMutationVariables, options?: RequestInit['headers']) => fetcher<UpdatePaymentGroupMutation, UpdatePaymentGroupMutationVariables>(UpdatePaymentGroupDocument, variables, options);
export const DeletePaymentGroupDocument = `
    mutation DeletePaymentGroup($id: BigInt!) {
  deletePlatbyGroup(input: {pgId: $id}) {
    __typename
  }
}
    `;
export const useDeletePaymentGroupMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<DeletePaymentGroupMutation, TError, DeletePaymentGroupMutationVariables, TContext>) =>
    useMutation<DeletePaymentGroupMutation, TError, DeletePaymentGroupMutationVariables, TContext>(
      ['DeletePaymentGroup'],
      (variables?: DeletePaymentGroupMutationVariables) => fetcher<DeletePaymentGroupMutation, DeletePaymentGroupMutationVariables>(DeletePaymentGroupDocument, variables)(),
      options
    );
useDeletePaymentGroupMutation.getKey = () => ['DeletePaymentGroup'];

useDeletePaymentGroupMutation.fetcher = (variables: DeletePaymentGroupMutationVariables, options?: RequestInit['headers']) => fetcher<DeletePaymentGroupMutation, DeletePaymentGroupMutationVariables>(DeletePaymentGroupDocument, variables, options);
export const PaymentItemListDocument = `
    query PaymentItemList {
  platbyItems {
    totalCount
    nodes {
      ...PaymentItem
    }
  }
}
    ${PaymentItemFragmentDoc}`;
export const usePaymentItemListQuery = <
      TData = PaymentItemListQuery,
      TError = unknown
    >(
      variables?: PaymentItemListQueryVariables,
      options?: UseQueryOptions<PaymentItemListQuery, TError, TData>
    ) =>
    useQuery<PaymentItemListQuery, TError, TData>(
      variables === undefined ? ['PaymentItemList'] : ['PaymentItemList', variables],
      fetcher<PaymentItemListQuery, PaymentItemListQueryVariables>(PaymentItemListDocument, variables),
      options
    );

usePaymentItemListQuery.getKey = (variables?: PaymentItemListQueryVariables) => variables === undefined ? ['PaymentItemList'] : ['PaymentItemList', variables];
;

usePaymentItemListQuery.fetcher = (variables?: PaymentItemListQueryVariables, options?: RequestInit['headers']) => fetcher<PaymentItemListQuery, PaymentItemListQueryVariables>(PaymentItemListDocument, variables, options);
export const PaymentItemDocument = `
    query PaymentItem($id: BigInt!) {
  platbyItem(piId: $id) {
    ...PaymentItem
  }
}
    ${PaymentItemFragmentDoc}`;
export const usePaymentItemQuery = <
      TData = PaymentItemQuery,
      TError = unknown
    >(
      variables: PaymentItemQueryVariables,
      options?: UseQueryOptions<PaymentItemQuery, TError, TData>
    ) =>
    useQuery<PaymentItemQuery, TError, TData>(
      ['PaymentItem', variables],
      fetcher<PaymentItemQuery, PaymentItemQueryVariables>(PaymentItemDocument, variables),
      options
    );

usePaymentItemQuery.getKey = (variables: PaymentItemQueryVariables) => ['PaymentItem', variables];
;

usePaymentItemQuery.fetcher = (variables: PaymentItemQueryVariables, options?: RequestInit['headers']) => fetcher<PaymentItemQuery, PaymentItemQueryVariables>(PaymentItemDocument, variables, options);
export const CreatePaymentItemDocument = `
    mutation CreatePaymentItem($input: PlatbyItemInput!) {
  createPlatbyItem(input: {platbyItem: $input}) {
    __typename
  }
}
    `;
export const useCreatePaymentItemMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<CreatePaymentItemMutation, TError, CreatePaymentItemMutationVariables, TContext>) =>
    useMutation<CreatePaymentItemMutation, TError, CreatePaymentItemMutationVariables, TContext>(
      ['CreatePaymentItem'],
      (variables?: CreatePaymentItemMutationVariables) => fetcher<CreatePaymentItemMutation, CreatePaymentItemMutationVariables>(CreatePaymentItemDocument, variables)(),
      options
    );
useCreatePaymentItemMutation.getKey = () => ['CreatePaymentItem'];

useCreatePaymentItemMutation.fetcher = (variables: CreatePaymentItemMutationVariables, options?: RequestInit['headers']) => fetcher<CreatePaymentItemMutation, CreatePaymentItemMutationVariables>(CreatePaymentItemDocument, variables, options);
export const UpdatePaymentItemDocument = `
    mutation UpdatePaymentItem($id: BigInt!, $patch: PlatbyItemPatch!) {
  updatePlatbyItem(input: {piId: $id, patch: $patch}) {
    __typename
  }
}
    `;
export const useUpdatePaymentItemMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<UpdatePaymentItemMutation, TError, UpdatePaymentItemMutationVariables, TContext>) =>
    useMutation<UpdatePaymentItemMutation, TError, UpdatePaymentItemMutationVariables, TContext>(
      ['UpdatePaymentItem'],
      (variables?: UpdatePaymentItemMutationVariables) => fetcher<UpdatePaymentItemMutation, UpdatePaymentItemMutationVariables>(UpdatePaymentItemDocument, variables)(),
      options
    );
useUpdatePaymentItemMutation.getKey = () => ['UpdatePaymentItem'];

useUpdatePaymentItemMutation.fetcher = (variables: UpdatePaymentItemMutationVariables, options?: RequestInit['headers']) => fetcher<UpdatePaymentItemMutation, UpdatePaymentItemMutationVariables>(UpdatePaymentItemDocument, variables, options);
export const DeletePaymentItemDocument = `
    mutation DeletePaymentItem($id: BigInt!) {
  deletePlatbyItem(input: {piId: $id}) {
    __typename
  }
}
    `;
export const useDeletePaymentItemMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<DeletePaymentItemMutation, TError, DeletePaymentItemMutationVariables, TContext>) =>
    useMutation<DeletePaymentItemMutation, TError, DeletePaymentItemMutationVariables, TContext>(
      ['DeletePaymentItem'],
      (variables?: DeletePaymentItemMutationVariables) => fetcher<DeletePaymentItemMutation, DeletePaymentItemMutationVariables>(DeletePaymentItemDocument, variables)(),
      options
    );
useDeletePaymentItemMutation.getKey = () => ['DeletePaymentItem'];

useDeletePaymentItemMutation.fetcher = (variables: DeletePaymentItemMutationVariables, options?: RequestInit['headers']) => fetcher<DeletePaymentItemMutation, DeletePaymentItemMutationVariables>(DeletePaymentItemDocument, variables, options);
export const PaymentCategoryListDocument = `
    query PaymentCategoryList {
  platbyCategories {
    totalCount
    nodes {
      ...PaymentCategory
    }
  }
}
    ${PaymentCategoryFragmentDoc}`;
export const usePaymentCategoryListQuery = <
      TData = PaymentCategoryListQuery,
      TError = unknown
    >(
      variables?: PaymentCategoryListQueryVariables,
      options?: UseQueryOptions<PaymentCategoryListQuery, TError, TData>
    ) =>
    useQuery<PaymentCategoryListQuery, TError, TData>(
      variables === undefined ? ['PaymentCategoryList'] : ['PaymentCategoryList', variables],
      fetcher<PaymentCategoryListQuery, PaymentCategoryListQueryVariables>(PaymentCategoryListDocument, variables),
      options
    );

usePaymentCategoryListQuery.getKey = (variables?: PaymentCategoryListQueryVariables) => variables === undefined ? ['PaymentCategoryList'] : ['PaymentCategoryList', variables];
;

usePaymentCategoryListQuery.fetcher = (variables?: PaymentCategoryListQueryVariables, options?: RequestInit['headers']) => fetcher<PaymentCategoryListQuery, PaymentCategoryListQueryVariables>(PaymentCategoryListDocument, variables, options);
export const PaymentCategoryDocument = `
    query PaymentCategory($id: BigInt!) {
  platbyCategory(pcId: $id) {
    ...PaymentCategory
  }
}
    ${PaymentCategoryFragmentDoc}`;
export const usePaymentCategoryQuery = <
      TData = PaymentCategoryQuery,
      TError = unknown
    >(
      variables: PaymentCategoryQueryVariables,
      options?: UseQueryOptions<PaymentCategoryQuery, TError, TData>
    ) =>
    useQuery<PaymentCategoryQuery, TError, TData>(
      ['PaymentCategory', variables],
      fetcher<PaymentCategoryQuery, PaymentCategoryQueryVariables>(PaymentCategoryDocument, variables),
      options
    );

usePaymentCategoryQuery.getKey = (variables: PaymentCategoryQueryVariables) => ['PaymentCategory', variables];
;

usePaymentCategoryQuery.fetcher = (variables: PaymentCategoryQueryVariables, options?: RequestInit['headers']) => fetcher<PaymentCategoryQuery, PaymentCategoryQueryVariables>(PaymentCategoryDocument, variables, options);
export const CreatePaymentCategoryDocument = `
    mutation CreatePaymentCategory($input: PlatbyCategoryInput!) {
  createPlatbyCategory(input: {platbyCategory: $input}) {
    __typename
  }
}
    `;
export const useCreatePaymentCategoryMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<CreatePaymentCategoryMutation, TError, CreatePaymentCategoryMutationVariables, TContext>) =>
    useMutation<CreatePaymentCategoryMutation, TError, CreatePaymentCategoryMutationVariables, TContext>(
      ['CreatePaymentCategory'],
      (variables?: CreatePaymentCategoryMutationVariables) => fetcher<CreatePaymentCategoryMutation, CreatePaymentCategoryMutationVariables>(CreatePaymentCategoryDocument, variables)(),
      options
    );
useCreatePaymentCategoryMutation.getKey = () => ['CreatePaymentCategory'];

useCreatePaymentCategoryMutation.fetcher = (variables: CreatePaymentCategoryMutationVariables, options?: RequestInit['headers']) => fetcher<CreatePaymentCategoryMutation, CreatePaymentCategoryMutationVariables>(CreatePaymentCategoryDocument, variables, options);
export const UpdatePaymentCategoryDocument = `
    mutation UpdatePaymentCategory($id: BigInt!, $patch: PlatbyCategoryPatch!) {
  updatePlatbyCategory(input: {pcId: $id, patch: $patch}) {
    __typename
  }
}
    `;
export const useUpdatePaymentCategoryMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<UpdatePaymentCategoryMutation, TError, UpdatePaymentCategoryMutationVariables, TContext>) =>
    useMutation<UpdatePaymentCategoryMutation, TError, UpdatePaymentCategoryMutationVariables, TContext>(
      ['UpdatePaymentCategory'],
      (variables?: UpdatePaymentCategoryMutationVariables) => fetcher<UpdatePaymentCategoryMutation, UpdatePaymentCategoryMutationVariables>(UpdatePaymentCategoryDocument, variables)(),
      options
    );
useUpdatePaymentCategoryMutation.getKey = () => ['UpdatePaymentCategory'];

useUpdatePaymentCategoryMutation.fetcher = (variables: UpdatePaymentCategoryMutationVariables, options?: RequestInit['headers']) => fetcher<UpdatePaymentCategoryMutation, UpdatePaymentCategoryMutationVariables>(UpdatePaymentCategoryDocument, variables, options);
export const DeletePaymentCategoryDocument = `
    mutation DeletePaymentCategory($id: BigInt!) {
  deletePlatbyCategory(input: {pcId: $id}) {
    __typename
  }
}
    `;
export const useDeletePaymentCategoryMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<DeletePaymentCategoryMutation, TError, DeletePaymentCategoryMutationVariables, TContext>) =>
    useMutation<DeletePaymentCategoryMutation, TError, DeletePaymentCategoryMutationVariables, TContext>(
      ['DeletePaymentCategory'],
      (variables?: DeletePaymentCategoryMutationVariables) => fetcher<DeletePaymentCategoryMutation, DeletePaymentCategoryMutationVariables>(DeletePaymentCategoryDocument, variables)(),
      options
    );
useDeletePaymentCategoryMutation.getKey = () => ['DeletePaymentCategory'];

useDeletePaymentCategoryMutation.fetcher = (variables: DeletePaymentCategoryMutationVariables, options?: RequestInit['headers']) => fetcher<DeletePaymentCategoryMutation, DeletePaymentCategoryMutationVariables>(DeletePaymentCategoryDocument, variables, options);
export const ReservationListDocument = `
    query ReservationList($limit: Int, $offset: Int) {
  nabidkas(first: $limit, offset: $offset, orderBy: [N_OD_DESC]) {
    nodes {
      ...Reservation
    }
    totalCount
  }
}
    ${ReservationFragmentDoc}`;
export const useReservationListQuery = <
      TData = ReservationListQuery,
      TError = unknown
    >(
      variables?: ReservationListQueryVariables,
      options?: UseQueryOptions<ReservationListQuery, TError, TData>
    ) =>
    useQuery<ReservationListQuery, TError, TData>(
      variables === undefined ? ['ReservationList'] : ['ReservationList', variables],
      fetcher<ReservationListQuery, ReservationListQueryVariables>(ReservationListDocument, variables),
      options
    );

useReservationListQuery.getKey = (variables?: ReservationListQueryVariables) => variables === undefined ? ['ReservationList'] : ['ReservationList', variables];
;

useReservationListQuery.fetcher = (variables?: ReservationListQueryVariables, options?: RequestInit['headers']) => fetcher<ReservationListQuery, ReservationListQueryVariables>(ReservationListDocument, variables, options);
export const ReservationDocument = `
    query Reservation($id: BigInt!) {
  nabidka(nId: $id) {
    ...Reservation
  }
}
    ${ReservationFragmentDoc}`;
export const useReservationQuery = <
      TData = ReservationQuery,
      TError = unknown
    >(
      variables: ReservationQueryVariables,
      options?: UseQueryOptions<ReservationQuery, TError, TData>
    ) =>
    useQuery<ReservationQuery, TError, TData>(
      ['Reservation', variables],
      fetcher<ReservationQuery, ReservationQueryVariables>(ReservationDocument, variables),
      options
    );

useReservationQuery.getKey = (variables: ReservationQueryVariables) => ['Reservation', variables];
;

useReservationQuery.fetcher = (variables: ReservationQueryVariables, options?: RequestInit['headers']) => fetcher<ReservationQuery, ReservationQueryVariables>(ReservationDocument, variables, options);
export const ReservationRangeDocument = `
    query ReservationRange($startDate: Date!, $endDate: Date!) {
  reservationsForRange(startDate: $startDate, endDate: $endDate) {
    nodes {
      ...Reservation
    }
  }
}
    ${ReservationFragmentDoc}`;
export const useReservationRangeQuery = <
      TData = ReservationRangeQuery,
      TError = unknown
    >(
      variables: ReservationRangeQueryVariables,
      options?: UseQueryOptions<ReservationRangeQuery, TError, TData>
    ) =>
    useQuery<ReservationRangeQuery, TError, TData>(
      ['ReservationRange', variables],
      fetcher<ReservationRangeQuery, ReservationRangeQueryVariables>(ReservationRangeDocument, variables),
      options
    );

useReservationRangeQuery.getKey = (variables: ReservationRangeQueryVariables) => ['ReservationRange', variables];
;

useReservationRangeQuery.fetcher = (variables: ReservationRangeQueryVariables, options?: RequestInit['headers']) => fetcher<ReservationRangeQuery, ReservationRangeQueryVariables>(ReservationRangeDocument, variables, options);
export const ToggleReservationVisibleDocument = `
    mutation ToggleReservationVisible($id: BigInt!, $visible: Boolean!) {
  updateNabidka(input: {nId: $id, patch: {nVisible: $visible}}) {
    nabidka {
      nId
    }
  }
}
    `;
export const useToggleReservationVisibleMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<ToggleReservationVisibleMutation, TError, ToggleReservationVisibleMutationVariables, TContext>) =>
    useMutation<ToggleReservationVisibleMutation, TError, ToggleReservationVisibleMutationVariables, TContext>(
      ['ToggleReservationVisible'],
      (variables?: ToggleReservationVisibleMutationVariables) => fetcher<ToggleReservationVisibleMutation, ToggleReservationVisibleMutationVariables>(ToggleReservationVisibleDocument, variables)(),
      options
    );
useToggleReservationVisibleMutation.getKey = () => ['ToggleReservationVisible'];

useToggleReservationVisibleMutation.fetcher = (variables: ToggleReservationVisibleMutationVariables, options?: RequestInit['headers']) => fetcher<ToggleReservationVisibleMutation, ToggleReservationVisibleMutationVariables>(ToggleReservationVisibleDocument, variables, options);
export const CreateReservationDocument = `
    mutation CreateReservation($input: NabidkaInput!) {
  createNabidka(input: {nabidka: $input}) {
    __typename
  }
}
    `;
export const useCreateReservationMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<CreateReservationMutation, TError, CreateReservationMutationVariables, TContext>) =>
    useMutation<CreateReservationMutation, TError, CreateReservationMutationVariables, TContext>(
      ['CreateReservation'],
      (variables?: CreateReservationMutationVariables) => fetcher<CreateReservationMutation, CreateReservationMutationVariables>(CreateReservationDocument, variables)(),
      options
    );
useCreateReservationMutation.getKey = () => ['CreateReservation'];

useCreateReservationMutation.fetcher = (variables: CreateReservationMutationVariables, options?: RequestInit['headers']) => fetcher<CreateReservationMutation, CreateReservationMutationVariables>(CreateReservationDocument, variables, options);
export const UpdateReservationDocument = `
    mutation UpdateReservation($id: BigInt!, $patch: NabidkaPatch!) {
  updateNabidka(input: {nId: $id, patch: $patch}) {
    __typename
  }
}
    `;
export const useUpdateReservationMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateReservationMutation, TError, UpdateReservationMutationVariables, TContext>) =>
    useMutation<UpdateReservationMutation, TError, UpdateReservationMutationVariables, TContext>(
      ['UpdateReservation'],
      (variables?: UpdateReservationMutationVariables) => fetcher<UpdateReservationMutation, UpdateReservationMutationVariables>(UpdateReservationDocument, variables)(),
      options
    );
useUpdateReservationMutation.getKey = () => ['UpdateReservation'];

useUpdateReservationMutation.fetcher = (variables: UpdateReservationMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateReservationMutation, UpdateReservationMutationVariables>(UpdateReservationDocument, variables, options);
export const DeleteReservationDocument = `
    mutation DeleteReservation($id: BigInt!) {
  deleteNabidka(input: {nId: $id}) {
    __typename
  }
}
    `;
export const useDeleteReservationMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteReservationMutation, TError, DeleteReservationMutationVariables, TContext>) =>
    useMutation<DeleteReservationMutation, TError, DeleteReservationMutationVariables, TContext>(
      ['DeleteReservation'],
      (variables?: DeleteReservationMutationVariables) => fetcher<DeleteReservationMutation, DeleteReservationMutationVariables>(DeleteReservationDocument, variables)(),
      options
    );
useDeleteReservationMutation.getKey = () => ['DeleteReservation'];

useDeleteReservationMutation.fetcher = (variables: DeleteReservationMutationVariables, options?: RequestInit['headers']) => fetcher<DeleteReservationMutation, DeleteReservationMutationVariables>(DeleteReservationDocument, variables, options);
export const RoleListDocument = `
    query RoleList {
  permissions {
    totalCount
    nodes {
      ...Role
    }
  }
}
    ${RoleFragmentDoc}`;
export const useRoleListQuery = <
      TData = RoleListQuery,
      TError = unknown
    >(
      variables?: RoleListQueryVariables,
      options?: UseQueryOptions<RoleListQuery, TError, TData>
    ) =>
    useQuery<RoleListQuery, TError, TData>(
      variables === undefined ? ['RoleList'] : ['RoleList', variables],
      fetcher<RoleListQuery, RoleListQueryVariables>(RoleListDocument, variables),
      options
    );

useRoleListQuery.getKey = (variables?: RoleListQueryVariables) => variables === undefined ? ['RoleList'] : ['RoleList', variables];
;

useRoleListQuery.fetcher = (variables?: RoleListQueryVariables, options?: RequestInit['headers']) => fetcher<RoleListQuery, RoleListQueryVariables>(RoleListDocument, variables, options);
export const RoleDocument = `
    query Role($id: BigInt!) {
  permission(peId: $id) {
    ...Role
  }
}
    ${RoleFragmentDoc}`;
export const useRoleQuery = <
      TData = RoleQuery,
      TError = unknown
    >(
      variables: RoleQueryVariables,
      options?: UseQueryOptions<RoleQuery, TError, TData>
    ) =>
    useQuery<RoleQuery, TError, TData>(
      ['Role', variables],
      fetcher<RoleQuery, RoleQueryVariables>(RoleDocument, variables),
      options
    );

useRoleQuery.getKey = (variables: RoleQueryVariables) => ['Role', variables];
;

useRoleQuery.fetcher = (variables: RoleQueryVariables, options?: RequestInit['headers']) => fetcher<RoleQuery, RoleQueryVariables>(RoleDocument, variables, options);
export const CreateRoleDocument = `
    mutation CreateRole($input: PermissionInput!) {
  createPermission(input: {permission: $input}) {
    permission {
      peId
    }
  }
}
    `;
export const useCreateRoleMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<CreateRoleMutation, TError, CreateRoleMutationVariables, TContext>) =>
    useMutation<CreateRoleMutation, TError, CreateRoleMutationVariables, TContext>(
      ['CreateRole'],
      (variables?: CreateRoleMutationVariables) => fetcher<CreateRoleMutation, CreateRoleMutationVariables>(CreateRoleDocument, variables)(),
      options
    );
useCreateRoleMutation.getKey = () => ['CreateRole'];

useCreateRoleMutation.fetcher = (variables: CreateRoleMutationVariables, options?: RequestInit['headers']) => fetcher<CreateRoleMutation, CreateRoleMutationVariables>(CreateRoleDocument, variables, options);
export const UpdateRoleDocument = `
    mutation UpdateRole($id: BigInt!, $patch: PermissionPatch!) {
  updatePermission(input: {peId: $id, patch: $patch}) {
    __typename
  }
}
    `;
export const useUpdateRoleMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateRoleMutation, TError, UpdateRoleMutationVariables, TContext>) =>
    useMutation<UpdateRoleMutation, TError, UpdateRoleMutationVariables, TContext>(
      ['UpdateRole'],
      (variables?: UpdateRoleMutationVariables) => fetcher<UpdateRoleMutation, UpdateRoleMutationVariables>(UpdateRoleDocument, variables)(),
      options
    );
useUpdateRoleMutation.getKey = () => ['UpdateRole'];

useUpdateRoleMutation.fetcher = (variables: UpdateRoleMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateRoleMutation, UpdateRoleMutationVariables>(UpdateRoleDocument, variables, options);
export const DeleteRoleDocument = `
    mutation DeleteRole($id: BigInt!) {
  deletePermission(input: {peId: $id}) {
    __typename
  }
}
    `;
export const useDeleteRoleMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteRoleMutation, TError, DeleteRoleMutationVariables, TContext>) =>
    useMutation<DeleteRoleMutation, TError, DeleteRoleMutationVariables, TContext>(
      ['DeleteRole'],
      (variables?: DeleteRoleMutationVariables) => fetcher<DeleteRoleMutation, DeleteRoleMutationVariables>(DeleteRoleDocument, variables)(),
      options
    );
useDeleteRoleMutation.getKey = () => ['DeleteRole'];

useDeleteRoleMutation.fetcher = (variables: DeleteRoleMutationVariables, options?: RequestInit['headers']) => fetcher<DeleteRoleMutation, DeleteRoleMutationVariables>(DeleteRoleDocument, variables, options);
export const ScheduleRangeDocument = `
    query ScheduleRange($startDate: Date!, $endDate: Date!) {
  schedulesForRange(startDate: $startDate, endDate: $endDate) {
    nodes {
      ...Schedule
    }
  }
}
    ${ScheduleFragmentDoc}`;
export const useScheduleRangeQuery = <
      TData = ScheduleRangeQuery,
      TError = unknown
    >(
      variables: ScheduleRangeQueryVariables,
      options?: UseQueryOptions<ScheduleRangeQuery, TError, TData>
    ) =>
    useQuery<ScheduleRangeQuery, TError, TData>(
      ['ScheduleRange', variables],
      fetcher<ScheduleRangeQuery, ScheduleRangeQueryVariables>(ScheduleRangeDocument, variables),
      options
    );

useScheduleRangeQuery.getKey = (variables: ScheduleRangeQueryVariables) => ['ScheduleRange', variables];
;

useScheduleRangeQuery.fetcher = (variables: ScheduleRangeQueryVariables, options?: RequestInit['headers']) => fetcher<ScheduleRangeQuery, ScheduleRangeQueryVariables>(ScheduleRangeDocument, variables, options);
export const ScheduleListDocument = `
    query ScheduleList($limit: Int, $offset: Int) {
  rozpis(first: $limit, offset: $offset, orderBy: [R_DATUM_DESC]) {
    nodes {
      rDatum
      rId
      rKde
      rLock
      rTimestamp
      rTrener
      rVisible
      userByRTrener {
        uId
        uJmeno
        uPrijmeni
      }
      rozpisItemsByRiIdRodic {
        nodes {
          riDo
          riOd
          riId
          riPartner
        }
      }
    }
    totalCount
  }
}
    `;
export const useScheduleListQuery = <
      TData = ScheduleListQuery,
      TError = unknown
    >(
      variables?: ScheduleListQueryVariables,
      options?: UseQueryOptions<ScheduleListQuery, TError, TData>
    ) =>
    useQuery<ScheduleListQuery, TError, TData>(
      variables === undefined ? ['ScheduleList'] : ['ScheduleList', variables],
      fetcher<ScheduleListQuery, ScheduleListQueryVariables>(ScheduleListDocument, variables),
      options
    );

useScheduleListQuery.getKey = (variables?: ScheduleListQueryVariables) => variables === undefined ? ['ScheduleList'] : ['ScheduleList', variables];
;

useScheduleListQuery.fetcher = (variables?: ScheduleListQueryVariables, options?: RequestInit['headers']) => fetcher<ScheduleListQuery, ScheduleListQueryVariables>(ScheduleListDocument, variables, options);
export const MyLessonsDocument = `
    query MyLessons($startDate: Date, $endDate: Date) {
  currentCoupleIds {
    nodes
  }
  currentSessionId
  currentUserId
  myLessons(startDate: $startDate, endDate: $endDate) {
    nodes {
      ...Lesson
    }
  }
}
    ${LessonFragmentDoc}`;
export const useMyLessonsQuery = <
      TData = MyLessonsQuery,
      TError = unknown
    >(
      variables?: MyLessonsQueryVariables,
      options?: UseQueryOptions<MyLessonsQuery, TError, TData>
    ) =>
    useQuery<MyLessonsQuery, TError, TData>(
      variables === undefined ? ['MyLessons'] : ['MyLessons', variables],
      fetcher<MyLessonsQuery, MyLessonsQueryVariables>(MyLessonsDocument, variables),
      options
    );

useMyLessonsQuery.getKey = (variables?: MyLessonsQueryVariables) => variables === undefined ? ['MyLessons'] : ['MyLessons', variables];
;

useMyLessonsQuery.fetcher = (variables?: MyLessonsQueryVariables, options?: RequestInit['headers']) => fetcher<MyLessonsQuery, MyLessonsQueryVariables>(MyLessonsDocument, variables, options);
export const ScheduleDocument = `
    query Schedule($id: BigInt!) {
  rozpi(rId: $id) {
    ...Schedule
  }
}
    ${ScheduleFragmentDoc}`;
export const useScheduleQuery = <
      TData = ScheduleQuery,
      TError = unknown
    >(
      variables: ScheduleQueryVariables,
      options?: UseQueryOptions<ScheduleQuery, TError, TData>
    ) =>
    useQuery<ScheduleQuery, TError, TData>(
      ['Schedule', variables],
      fetcher<ScheduleQuery, ScheduleQueryVariables>(ScheduleDocument, variables),
      options
    );

useScheduleQuery.getKey = (variables: ScheduleQueryVariables) => ['Schedule', variables];
;

useScheduleQuery.fetcher = (variables: ScheduleQueryVariables, options?: RequestInit['headers']) => fetcher<ScheduleQuery, ScheduleQueryVariables>(ScheduleDocument, variables, options);
export const ToggleScheduleVisibleDocument = `
    mutation ToggleScheduleVisible($id: BigInt!, $visible: Boolean!) {
  updateRozpi(input: {rId: $id, patch: {rVisible: $visible}}) {
    rozpi {
      rId
    }
  }
}
    `;
export const useToggleScheduleVisibleMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<ToggleScheduleVisibleMutation, TError, ToggleScheduleVisibleMutationVariables, TContext>) =>
    useMutation<ToggleScheduleVisibleMutation, TError, ToggleScheduleVisibleMutationVariables, TContext>(
      ['ToggleScheduleVisible'],
      (variables?: ToggleScheduleVisibleMutationVariables) => fetcher<ToggleScheduleVisibleMutation, ToggleScheduleVisibleMutationVariables>(ToggleScheduleVisibleDocument, variables)(),
      options
    );
useToggleScheduleVisibleMutation.getKey = () => ['ToggleScheduleVisible'];

useToggleScheduleVisibleMutation.fetcher = (variables: ToggleScheduleVisibleMutationVariables, options?: RequestInit['headers']) => fetcher<ToggleScheduleVisibleMutation, ToggleScheduleVisibleMutationVariables>(ToggleScheduleVisibleDocument, variables, options);
export const CreateScheduleDocument = `
    mutation CreateSchedule($input: RozpiInput!) {
  createRozpi(input: {rozpi: $input}) {
    __typename
  }
}
    `;
export const useCreateScheduleMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<CreateScheduleMutation, TError, CreateScheduleMutationVariables, TContext>) =>
    useMutation<CreateScheduleMutation, TError, CreateScheduleMutationVariables, TContext>(
      ['CreateSchedule'],
      (variables?: CreateScheduleMutationVariables) => fetcher<CreateScheduleMutation, CreateScheduleMutationVariables>(CreateScheduleDocument, variables)(),
      options
    );
useCreateScheduleMutation.getKey = () => ['CreateSchedule'];

useCreateScheduleMutation.fetcher = (variables: CreateScheduleMutationVariables, options?: RequestInit['headers']) => fetcher<CreateScheduleMutation, CreateScheduleMutationVariables>(CreateScheduleDocument, variables, options);
export const UpdateScheduleDocument = `
    mutation UpdateSchedule($id: BigInt!, $patch: RozpiPatch!) {
  updateRozpi(input: {rId: $id, patch: $patch}) {
    __typename
  }
}
    `;
export const useUpdateScheduleMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateScheduleMutation, TError, UpdateScheduleMutationVariables, TContext>) =>
    useMutation<UpdateScheduleMutation, TError, UpdateScheduleMutationVariables, TContext>(
      ['UpdateSchedule'],
      (variables?: UpdateScheduleMutationVariables) => fetcher<UpdateScheduleMutation, UpdateScheduleMutationVariables>(UpdateScheduleDocument, variables)(),
      options
    );
useUpdateScheduleMutation.getKey = () => ['UpdateSchedule'];

useUpdateScheduleMutation.fetcher = (variables: UpdateScheduleMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateScheduleMutation, UpdateScheduleMutationVariables>(UpdateScheduleDocument, variables, options);
export const DeleteScheduleDocument = `
    mutation DeleteSchedule($id: BigInt!) {
  deleteRozpi(input: {rId: $id}) {
    __typename
  }
}
    `;
export const useDeleteScheduleMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteScheduleMutation, TError, DeleteScheduleMutationVariables, TContext>) =>
    useMutation<DeleteScheduleMutation, TError, DeleteScheduleMutationVariables, TContext>(
      ['DeleteSchedule'],
      (variables?: DeleteScheduleMutationVariables) => fetcher<DeleteScheduleMutation, DeleteScheduleMutationVariables>(DeleteScheduleDocument, variables)(),
      options
    );
useDeleteScheduleMutation.getKey = () => ['DeleteSchedule'];

useDeleteScheduleMutation.fetcher = (variables: DeleteScheduleMutationVariables, options?: RequestInit['headers']) => fetcher<DeleteScheduleMutation, DeleteScheduleMutationVariables>(DeleteScheduleDocument, variables, options);
export const UserDocument = `
    query User($id: BigInt!) {
  user(uId: $id) {
    ...User
  }
}
    ${UserFragmentDoc}`;
export const useUserQuery = <
      TData = UserQuery,
      TError = unknown
    >(
      variables: UserQueryVariables,
      options?: UseQueryOptions<UserQuery, TError, TData>
    ) =>
    useQuery<UserQuery, TError, TData>(
      ['User', variables],
      fetcher<UserQuery, UserQueryVariables>(UserDocument, variables),
      options
    );

useUserQuery.getKey = (variables: UserQueryVariables) => ['User', variables];
;

useUserQuery.fetcher = (variables: UserQueryVariables, options?: RequestInit['headers']) => fetcher<UserQuery, UserQueryVariables>(UserDocument, variables, options);
export const UserListDocument = `
    query UserList($confirmed: Boolean, $limit: Int, $offset: Int) {
  users(condition: {uConfirmed: $confirmed}, offset: $offset, first: $limit) {
    totalCount
    nodes {
      ...User
    }
  }
}
    ${UserFragmentDoc}`;
export const useUserListQuery = <
      TData = UserListQuery,
      TError = unknown
    >(
      variables?: UserListQueryVariables,
      options?: UseQueryOptions<UserListQuery, TError, TData>
    ) =>
    useQuery<UserListQuery, TError, TData>(
      variables === undefined ? ['UserList'] : ['UserList', variables],
      fetcher<UserListQuery, UserListQueryVariables>(UserListDocument, variables),
      options
    );

useUserListQuery.getKey = (variables?: UserListQueryVariables) => variables === undefined ? ['UserList'] : ['UserList', variables];
;

useUserListQuery.fetcher = (variables?: UserListQueryVariables, options?: RequestInit['headers']) => fetcher<UserListQuery, UserListQueryVariables>(UserListDocument, variables, options);
export const MemberListDocument = `
    query MemberList($cohortId: BigInt) {
  members(condition: {sId: $cohortId}) {
    totalCount
    nodes {
      uId
      uJmeno
      uPrijmeni
      uEmail
      uTelefon
      uRodneCislo
      sId
      sName
      sColorRgb
      sDescription
      sVisible
      paymentValid
    }
  }
}
    `;
export const useMemberListQuery = <
      TData = MemberListQuery,
      TError = unknown
    >(
      variables?: MemberListQueryVariables,
      options?: UseQueryOptions<MemberListQuery, TError, TData>
    ) =>
    useQuery<MemberListQuery, TError, TData>(
      variables === undefined ? ['MemberList'] : ['MemberList', variables],
      fetcher<MemberListQuery, MemberListQueryVariables>(MemberListDocument, variables),
      options
    );

useMemberListQuery.getKey = (variables?: MemberListQueryVariables) => variables === undefined ? ['MemberList'] : ['MemberList', variables];
;

useMemberListQuery.fetcher = (variables?: MemberListQueryVariables, options?: RequestInit['headers']) => fetcher<MemberListQuery, MemberListQueryVariables>(MemberListDocument, variables, options);
export const TrainerListDocument = `
    query TrainerList {
  trainers {
    totalCount
    nodes {
      ...User
    }
  }
}
    ${UserFragmentDoc}`;
export const useTrainerListQuery = <
      TData = TrainerListQuery,
      TError = unknown
    >(
      variables?: TrainerListQueryVariables,
      options?: UseQueryOptions<TrainerListQuery, TError, TData>
    ) =>
    useQuery<TrainerListQuery, TError, TData>(
      variables === undefined ? ['TrainerList'] : ['TrainerList', variables],
      fetcher<TrainerListQuery, TrainerListQueryVariables>(TrainerListDocument, variables),
      options
    );

useTrainerListQuery.getKey = (variables?: TrainerListQueryVariables) => variables === undefined ? ['TrainerList'] : ['TrainerList', variables];
;

useTrainerListQuery.fetcher = (variables?: TrainerListQueryVariables, options?: RequestInit['headers']) => fetcher<TrainerListQuery, TrainerListQueryVariables>(TrainerListDocument, variables, options);
export const ConfirmUserDocument = `
    mutation ConfirmUser($id: BigInt!, $role: BigInt!, $cohort: BigInt!) {
  confirmUser(input: {id: $id, grp: $role, cohort: $cohort}) {
    __typename
  }
}
    `;
export const useConfirmUserMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<ConfirmUserMutation, TError, ConfirmUserMutationVariables, TContext>) =>
    useMutation<ConfirmUserMutation, TError, ConfirmUserMutationVariables, TContext>(
      ['ConfirmUser'],
      (variables?: ConfirmUserMutationVariables) => fetcher<ConfirmUserMutation, ConfirmUserMutationVariables>(ConfirmUserDocument, variables)(),
      options
    );
useConfirmUserMutation.getKey = () => ['ConfirmUser'];

useConfirmUserMutation.fetcher = (variables: ConfirmUserMutationVariables, options?: RequestInit['headers']) => fetcher<ConfirmUserMutation, ConfirmUserMutationVariables>(ConfirmUserDocument, variables, options);
export const CreateUserDocument = `
    mutation CreateUser($input: UserInput!) {
  createUser(input: {user: $input}) {
    __typename
  }
}
    `;
export const useCreateUserMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<CreateUserMutation, TError, CreateUserMutationVariables, TContext>) =>
    useMutation<CreateUserMutation, TError, CreateUserMutationVariables, TContext>(
      ['CreateUser'],
      (variables?: CreateUserMutationVariables) => fetcher<CreateUserMutation, CreateUserMutationVariables>(CreateUserDocument, variables)(),
      options
    );
useCreateUserMutation.getKey = () => ['CreateUser'];

useCreateUserMutation.fetcher = (variables: CreateUserMutationVariables, options?: RequestInit['headers']) => fetcher<CreateUserMutation, CreateUserMutationVariables>(CreateUserDocument, variables, options);
export const UpdateUserDocument = `
    mutation UpdateUser($id: BigInt!, $patch: UserPatch!) {
  updateUser(input: {uId: $id, patch: $patch}) {
    __typename
  }
}
    `;
export const useUpdateUserMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateUserMutation, TError, UpdateUserMutationVariables, TContext>) =>
    useMutation<UpdateUserMutation, TError, UpdateUserMutationVariables, TContext>(
      ['UpdateUser'],
      (variables?: UpdateUserMutationVariables) => fetcher<UpdateUserMutation, UpdateUserMutationVariables>(UpdateUserDocument, variables)(),
      options
    );
useUpdateUserMutation.getKey = () => ['UpdateUser'];

useUpdateUserMutation.fetcher = (variables: UpdateUserMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateUserMutation, UpdateUserMutationVariables>(UpdateUserDocument, variables, options);
export const DeleteUserDocument = `
    mutation DeleteUser($id: BigInt!) {
  deleteUser(input: {uId: $id}) {
    __typename
  }
}
    `;
export const useDeleteUserMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteUserMutation, TError, DeleteUserMutationVariables, TContext>) =>
    useMutation<DeleteUserMutation, TError, DeleteUserMutationVariables, TContext>(
      ['DeleteUser'],
      (variables?: DeleteUserMutationVariables) => fetcher<DeleteUserMutation, DeleteUserMutationVariables>(DeleteUserDocument, variables)(),
      options
    );
useDeleteUserMutation.getKey = () => ['DeleteUser'];

useDeleteUserMutation.fetcher = (variables: DeleteUserMutationVariables, options?: RequestInit['headers']) => fetcher<DeleteUserMutation, DeleteUserMutationVariables>(DeleteUserDocument, variables, options);
export const TitleVideosDocument = `
    query TitleVideos {
  titleVideos {
    nodes {
      vTitle
      vUri
    }
  }
}
    `;
export const useTitleVideosQuery = <
      TData = TitleVideosQuery,
      TError = unknown
    >(
      variables?: TitleVideosQueryVariables,
      options?: UseQueryOptions<TitleVideosQuery, TError, TData>
    ) =>
    useQuery<TitleVideosQuery, TError, TData>(
      variables === undefined ? ['TitleVideos'] : ['TitleVideos', variables],
      fetcher<TitleVideosQuery, TitleVideosQueryVariables>(TitleVideosDocument, variables),
      options
    );

useTitleVideosQuery.getKey = (variables?: TitleVideosQueryVariables) => variables === undefined ? ['TitleVideos'] : ['TitleVideos', variables];
;

useTitleVideosQuery.fetcher = (variables?: TitleVideosQueryVariables, options?: RequestInit['headers']) => fetcher<TitleVideosQuery, TitleVideosQueryVariables>(TitleVideosDocument, variables, options);
export const VideoSourceDocument = `
    query VideoSource($id: BigInt!) {
  videoSource(vsId: $id) {
    ...VideoSource
  }
}
    ${VideoSourceFragmentDoc}`;
export const useVideoSourceQuery = <
      TData = VideoSourceQuery,
      TError = unknown
    >(
      variables: VideoSourceQueryVariables,
      options?: UseQueryOptions<VideoSourceQuery, TError, TData>
    ) =>
    useQuery<VideoSourceQuery, TError, TData>(
      ['VideoSource', variables],
      fetcher<VideoSourceQuery, VideoSourceQueryVariables>(VideoSourceDocument, variables),
      options
    );

useVideoSourceQuery.getKey = (variables: VideoSourceQueryVariables) => ['VideoSource', variables];
;

useVideoSourceQuery.fetcher = (variables: VideoSourceQueryVariables, options?: RequestInit['headers']) => fetcher<VideoSourceQuery, VideoSourceQueryVariables>(VideoSourceDocument, variables, options);
export const VideoSourceListDocument = `
    query VideoSourceList($limit: Int, $offset: Int) {
  videoSources(first: $limit, offset: $offset) {
    nodes {
      ...VideoSource
    }
  }
}
    ${VideoSourceFragmentDoc}`;
export const useVideoSourceListQuery = <
      TData = VideoSourceListQuery,
      TError = unknown
    >(
      variables?: VideoSourceListQueryVariables,
      options?: UseQueryOptions<VideoSourceListQuery, TError, TData>
    ) =>
    useQuery<VideoSourceListQuery, TError, TData>(
      variables === undefined ? ['VideoSourceList'] : ['VideoSourceList', variables],
      fetcher<VideoSourceListQuery, VideoSourceListQueryVariables>(VideoSourceListDocument, variables),
      options
    );

useVideoSourceListQuery.getKey = (variables?: VideoSourceListQueryVariables) => variables === undefined ? ['VideoSourceList'] : ['VideoSourceList', variables];
;

useVideoSourceListQuery.fetcher = (variables?: VideoSourceListQueryVariables, options?: RequestInit['headers']) => fetcher<VideoSourceListQuery, VideoSourceListQueryVariables>(VideoSourceListDocument, variables, options);
export const CreateVideoSourceDocument = `
    mutation CreateVideoSource($input: VideoSourceInput!) {
  createVideoSource(input: {videoSource: $input}) {
    __typename
  }
}
    `;
export const useCreateVideoSourceMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<CreateVideoSourceMutation, TError, CreateVideoSourceMutationVariables, TContext>) =>
    useMutation<CreateVideoSourceMutation, TError, CreateVideoSourceMutationVariables, TContext>(
      ['CreateVideoSource'],
      (variables?: CreateVideoSourceMutationVariables) => fetcher<CreateVideoSourceMutation, CreateVideoSourceMutationVariables>(CreateVideoSourceDocument, variables)(),
      options
    );
useCreateVideoSourceMutation.getKey = () => ['CreateVideoSource'];

useCreateVideoSourceMutation.fetcher = (variables: CreateVideoSourceMutationVariables, options?: RequestInit['headers']) => fetcher<CreateVideoSourceMutation, CreateVideoSourceMutationVariables>(CreateVideoSourceDocument, variables, options);
export const UpdateVideoSourceDocument = `
    mutation UpdateVideoSource($id: BigInt!, $patch: VideoSourcePatch!) {
  updateVideoSource(input: {vsId: $id, patch: $patch}) {
    __typename
  }
}
    `;
export const useUpdateVideoSourceMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateVideoSourceMutation, TError, UpdateVideoSourceMutationVariables, TContext>) =>
    useMutation<UpdateVideoSourceMutation, TError, UpdateVideoSourceMutationVariables, TContext>(
      ['UpdateVideoSource'],
      (variables?: UpdateVideoSourceMutationVariables) => fetcher<UpdateVideoSourceMutation, UpdateVideoSourceMutationVariables>(UpdateVideoSourceDocument, variables)(),
      options
    );
useUpdateVideoSourceMutation.getKey = () => ['UpdateVideoSource'];

useUpdateVideoSourceMutation.fetcher = (variables: UpdateVideoSourceMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateVideoSourceMutation, UpdateVideoSourceMutationVariables>(UpdateVideoSourceDocument, variables, options);
export const DeleteVideoSourceDocument = `
    mutation DeleteVideoSource($id: BigInt!) {
  deleteVideoSource(input: {vsId: $id}) {
    __typename
  }
}
    `;
export const useDeleteVideoSourceMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteVideoSourceMutation, TError, DeleteVideoSourceMutationVariables, TContext>) =>
    useMutation<DeleteVideoSourceMutation, TError, DeleteVideoSourceMutationVariables, TContext>(
      ['DeleteVideoSource'],
      (variables?: DeleteVideoSourceMutationVariables) => fetcher<DeleteVideoSourceMutation, DeleteVideoSourceMutationVariables>(DeleteVideoSourceDocument, variables)(),
      options
    );
useDeleteVideoSourceMutation.getKey = () => ['DeleteVideoSource'];

useDeleteVideoSourceMutation.fetcher = (variables: DeleteVideoSourceMutationVariables, options?: RequestInit['headers']) => fetcher<DeleteVideoSourceMutation, DeleteVideoSourceMutationVariables>(DeleteVideoSourceDocument, variables, options);
export const VideoDocument = `
    query Video($id: BigInt!) {
  video(vId: $id) {
    ...Video
  }
}
    ${VideoFragmentDoc}`;
export const useVideoQuery = <
      TData = VideoQuery,
      TError = unknown
    >(
      variables: VideoQueryVariables,
      options?: UseQueryOptions<VideoQuery, TError, TData>
    ) =>
    useQuery<VideoQuery, TError, TData>(
      ['Video', variables],
      fetcher<VideoQuery, VideoQueryVariables>(VideoDocument, variables),
      options
    );

useVideoQuery.getKey = (variables: VideoQueryVariables) => ['Video', variables];
;

useVideoQuery.fetcher = (variables: VideoQueryVariables, options?: RequestInit['headers']) => fetcher<VideoQuery, VideoQueryVariables>(VideoDocument, variables, options);
export const VideoListDocument = `
    query VideoList($limit: Int, $offset: Int) {
  videos(first: $limit, offset: $offset) {
    nodes {
      ...Video
    }
  }
}
    ${VideoFragmentDoc}`;
export const useVideoListQuery = <
      TData = VideoListQuery,
      TError = unknown
    >(
      variables?: VideoListQueryVariables,
      options?: UseQueryOptions<VideoListQuery, TError, TData>
    ) =>
    useQuery<VideoListQuery, TError, TData>(
      variables === undefined ? ['VideoList'] : ['VideoList', variables],
      fetcher<VideoListQuery, VideoListQueryVariables>(VideoListDocument, variables),
      options
    );

useVideoListQuery.getKey = (variables?: VideoListQueryVariables) => variables === undefined ? ['VideoList'] : ['VideoList', variables];
;

useVideoListQuery.fetcher = (variables?: VideoListQueryVariables, options?: RequestInit['headers']) => fetcher<VideoListQuery, VideoListQueryVariables>(VideoListDocument, variables, options);
export const CreateVideoDocument = `
    mutation CreateVideo($input: VideoInput!) {
  createVideo(input: {video: $input}) {
    __typename
  }
}
    `;
export const useCreateVideoMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<CreateVideoMutation, TError, CreateVideoMutationVariables, TContext>) =>
    useMutation<CreateVideoMutation, TError, CreateVideoMutationVariables, TContext>(
      ['CreateVideo'],
      (variables?: CreateVideoMutationVariables) => fetcher<CreateVideoMutation, CreateVideoMutationVariables>(CreateVideoDocument, variables)(),
      options
    );
useCreateVideoMutation.getKey = () => ['CreateVideo'];

useCreateVideoMutation.fetcher = (variables: CreateVideoMutationVariables, options?: RequestInit['headers']) => fetcher<CreateVideoMutation, CreateVideoMutationVariables>(CreateVideoDocument, variables, options);
export const UpdateVideoDocument = `
    mutation UpdateVideo($id: BigInt!, $patch: VideoPatch!) {
  updateVideo(input: {vId: $id, patch: $patch}) {
    __typename
  }
}
    `;
export const useUpdateVideoMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateVideoMutation, TError, UpdateVideoMutationVariables, TContext>) =>
    useMutation<UpdateVideoMutation, TError, UpdateVideoMutationVariables, TContext>(
      ['UpdateVideo'],
      (variables?: UpdateVideoMutationVariables) => fetcher<UpdateVideoMutation, UpdateVideoMutationVariables>(UpdateVideoDocument, variables)(),
      options
    );
useUpdateVideoMutation.getKey = () => ['UpdateVideo'];

useUpdateVideoMutation.fetcher = (variables: UpdateVideoMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateVideoMutation, UpdateVideoMutationVariables>(UpdateVideoDocument, variables, options);
export const DeleteVideoDocument = `
    mutation DeleteVideo($id: BigInt!) {
  deleteVideo(input: {vId: $id}) {
    __typename
  }
}
    `;
export const useDeleteVideoMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteVideoMutation, TError, DeleteVideoMutationVariables, TContext>) =>
    useMutation<DeleteVideoMutation, TError, DeleteVideoMutationVariables, TContext>(
      ['DeleteVideo'],
      (variables?: DeleteVideoMutationVariables) => fetcher<DeleteVideoMutation, DeleteVideoMutationVariables>(DeleteVideoDocument, variables)(),
      options
    );
useDeleteVideoMutation.getKey = () => ['DeleteVideo'];

useDeleteVideoMutation.fetcher = (variables: DeleteVideoMutationVariables, options?: RequestInit['headers']) => fetcher<DeleteVideoMutation, DeleteVideoMutationVariables>(DeleteVideoDocument, variables, options);