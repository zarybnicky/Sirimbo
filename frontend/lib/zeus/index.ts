//@ts-nocheck
/* eslint-disable */

import { AllTypesProps, ReturnTypes, Ops } from './const';
export const HOST = "http://localhost:3000/graphql"


export const HEADERS = {}
export const apiSubscription = (options: chainOptions) => (query: string) => {
  try {
    const queryString = options[0] + '?query=' + encodeURIComponent(query);
    const wsString = queryString.replace('http', 'ws');
    const host = (options.length > 1 && options[1]?.websocket?.[0]) || wsString;
    const webSocketOptions = options[1]?.websocket || [host];
    const ws = new WebSocket(...webSocketOptions);
    return {
      ws,
      on: (e: (args: any) => void) => {
        ws.onmessage = (event: any) => {
          if (event.data) {
            const parsed = JSON.parse(event.data);
            const data = parsed.data;
            return e(data);
          }
        };
      },
      off: (e: (args: any) => void) => {
        ws.onclose = e;
      },
      error: (e: (args: any) => void) => {
        ws.onerror = e;
      },
      open: (e: () => void) => {
        ws.onopen = e;
      },
    };
  } catch {
    throw new Error('No websockets implemented');
  }
};
const handleFetchResponse = (response: Response): Promise<GraphQLResponse> => {
  if (!response.ok) {
    return new Promise((_, reject) => {
      response
        .text()
        .then((text) => {
          try {
            reject(JSON.parse(text));
          } catch (err) {
            reject(text);
          }
        })
        .catch(reject);
    });
  }
  return response.json();
};

export const apiFetch =
  (options: fetchOptions) =>
  (query: string, variables: Record<string, unknown> = {}) => {
    const fetchOptions = options[1] || {};
    if (fetchOptions.method && fetchOptions.method === 'GET') {
      return fetch(`${options[0]}?query=${encodeURIComponent(query)}`, fetchOptions)
        .then(handleFetchResponse)
        .then((response: GraphQLResponse) => {
          if (response.errors) {
            throw new GraphQLError(response);
          }
          return response.data;
        });
    }
    return fetch(`${options[0]}`, {
      body: JSON.stringify({ query, variables }),
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      ...fetchOptions,
    })
      .then(handleFetchResponse)
      .then((response: GraphQLResponse) => {
        if (response.errors) {
          throw new GraphQLError(response);
        }
        return response.data;
      });
  };

export const InternalsBuildQuery = ({
  ops,
  props,
  returns,
  options,
  scalars,
}: {
  props: AllTypesPropsType;
  returns: ReturnTypesType;
  ops: Operations;
  options?: OperationOptions;
  scalars?: ScalarDefinition;
}) => {
  const ibb = (
    k: string,
    o: InputValueType | VType,
    p = '',
    root = true,
    vars: Array<{ name: string; graphQLType: string }> = [],
  ): string => {
    const keyForPath = purifyGraphQLKey(k);
    const newPath = [p, keyForPath].join(SEPARATOR);
    if (!o) {
      return '';
    }
    if (typeof o === 'boolean' || typeof o === 'number') {
      return k;
    }
    if (typeof o === 'string') {
      return `${k} ${o}`;
    }
    if (Array.isArray(o)) {
      const args = InternalArgsBuilt({
        props,
        returns,
        ops,
        scalars,
        vars,
      })(o[0], newPath);
      return `${ibb(args ? `${k}(${args})` : k, o[1], p, false, vars)}`;
    }
    if (k === '__alias') {
      return Object.entries(o)
        .map(([alias, objectUnderAlias]) => {
          if (typeof objectUnderAlias !== 'object' || Array.isArray(objectUnderAlias)) {
            throw new Error(
              'Invalid alias it should be __alias:{ YOUR_ALIAS_NAME: { OPERATION_NAME: { ...selectors }}}',
            );
          }
          const operationName = Object.keys(objectUnderAlias)[0];
          const operation = objectUnderAlias[operationName];
          return ibb(`${alias}:${operationName}`, operation, p, false, vars);
        })
        .join('\n');
    }
    const hasOperationName = root && options?.operationName ? ' ' + options.operationName : '';
    const keyForDirectives = o.__directives ?? '';
    const query = `{${Object.entries(o)
      .filter(([k]) => k !== '__directives')
      .map((e) => ibb(...e, [p, `field<>${keyForPath}`].join(SEPARATOR), false, vars))
      .join('\n')}}`;
    if (!root) {
      return `${k} ${keyForDirectives}${hasOperationName} ${query}`;
    }
    const varsString = vars.map((v) => `${v.name}: ${v.graphQLType}`).join(', ');
    return `${k} ${keyForDirectives}${hasOperationName}${varsString ? `(${varsString})` : ''} ${query}`;
  };
  return ibb;
};

export const Thunder =
  (fn: FetchFunction) =>
  <O extends keyof typeof Ops, SCLR extends ScalarDefinition, R extends keyof ValueTypes = GenericOperation<O>>(
    operation: O,
    graphqlOptions?: ThunderGraphQLOptions<SCLR>,
  ) =>
  <Z extends ValueTypes[R]>(o: Z | ValueTypes[R], ops?: OperationOptions & { variables?: Record<string, unknown> }) =>
    fn(
      Zeus(operation, o, {
        operationOptions: ops,
        scalars: graphqlOptions?.scalars,
      }),
      ops?.variables,
    ).then((data) => {
      if (graphqlOptions?.scalars) {
        return decodeScalarsInResponse({
          response: data,
          initialOp: operation,
          initialZeusQuery: o as VType,
          returns: ReturnTypes,
          scalars: graphqlOptions.scalars,
          ops: Ops,
        });
      }
      return data;
    }) as Promise<InputType<GraphQLTypes[R], Z, SCLR>>;

export const Chain = (...options: chainOptions) => Thunder(apiFetch(options));

export const SubscriptionThunder =
  (fn: SubscriptionFunction) =>
  <O extends keyof typeof Ops, SCLR extends ScalarDefinition, R extends keyof ValueTypes = GenericOperation<O>>(
    operation: O,
    graphqlOptions?: ThunderGraphQLOptions<SCLR>,
  ) =>
  <Z extends ValueTypes[R]>(o: Z | ValueTypes[R], ops?: OperationOptions & { variables?: ExtractVariables<Z> }) => {
    const returnedFunction = fn(
      Zeus(operation, o, {
        operationOptions: ops,
        scalars: graphqlOptions?.scalars,
      }),
    ) as SubscriptionToGraphQL<Z, GraphQLTypes[R], SCLR>;
    if (returnedFunction?.on && graphqlOptions?.scalars) {
      const wrapped = returnedFunction.on;
      returnedFunction.on = (fnToCall: (args: InputType<GraphQLTypes[R], Z, SCLR>) => void) =>
        wrapped((data: InputType<GraphQLTypes[R], Z, SCLR>) => {
          if (graphqlOptions?.scalars) {
            return fnToCall(
              decodeScalarsInResponse({
                response: data,
                initialOp: operation,
                initialZeusQuery: o as VType,
                returns: ReturnTypes,
                scalars: graphqlOptions.scalars,
                ops: Ops,
              }),
            );
          }
          return fnToCall(data);
        });
    }
    return returnedFunction;
  };

export const Subscription = (...options: chainOptions) => SubscriptionThunder(apiSubscription(options));
export const Zeus = <
  Z extends ValueTypes[R],
  O extends keyof typeof Ops,
  R extends keyof ValueTypes = GenericOperation<O>,
>(
  operation: O,
  o: Z | ValueTypes[R],
  ops?: {
    operationOptions?: OperationOptions;
    scalars?: ScalarDefinition;
  },
) =>
  InternalsBuildQuery({
    props: AllTypesProps,
    returns: ReturnTypes,
    ops: Ops,
    options: ops?.operationOptions,
    scalars: ops?.scalars,
  })(operation, o as VType);

export const ZeusSelect = <T>() => ((t: unknown) => t) as SelectionFunction<T>;

export const Selector = <T extends keyof ValueTypes>(key: T) => key && ZeusSelect<ValueTypes[T]>();

export const TypeFromSelector = <T extends keyof ValueTypes>(key: T) => key && ZeusSelect<ValueTypes[T]>();
export const Gql = Chain(HOST, {
  headers: {
    'Content-Type': 'application/json',
    ...HEADERS,
  },
});

export const ZeusScalars = ZeusSelect<ScalarCoders>();

export const decodeScalarsInResponse = <O extends Operations>({
  response,
  scalars,
  returns,
  ops,
  initialZeusQuery,
  initialOp,
}: {
  ops: O;
  response: any;
  returns: ReturnTypesType;
  scalars?: Record<string, ScalarResolver | undefined>;
  initialOp: keyof O;
  initialZeusQuery: InputValueType | VType;
}) => {
  if (!scalars) {
    return response;
  }
  const builder = PrepareScalarPaths({
    ops,
    returns,
  });

  const scalarPaths = builder(initialOp as string, ops[initialOp], initialZeusQuery);
  if (scalarPaths) {
    const r = traverseResponse({ scalarPaths, resolvers: scalars })(initialOp as string, response, [ops[initialOp]]);
    return r;
  }
  return response;
};

export const traverseResponse = ({
  resolvers,
  scalarPaths,
}: {
  scalarPaths: { [x: string]: `scalar.${string}` };
  resolvers: {
    [x: string]: ScalarResolver | undefined;
  };
}) => {
  const ibb = (k: string, o: InputValueType | VType, p: string[] = []): unknown => {
    if (Array.isArray(o)) {
      return o.map((eachO) => ibb(k, eachO, p));
    }
    if (o == null) {
      return o;
    }
    const scalarPathString = p.join(SEPARATOR);
    const currentScalarString = scalarPaths[scalarPathString];
    if (currentScalarString) {
      const currentDecoder = resolvers[currentScalarString.split('.')[1]]?.decode;
      if (currentDecoder) {
        return currentDecoder(o);
      }
    }
    if (typeof o === 'boolean' || typeof o === 'number' || typeof o === 'string' || !o) {
      return o;
    }
    return Object.fromEntries(Object.entries(o).map(([k, v]) => [k, ibb(k, v, [...p, purifyGraphQLKey(k)])]));
  };
  return ibb;
};

export type AllTypesPropsType = {
  [x: string]:
    | undefined
    | `scalar.${string}`
    | 'enum'
    | {
        [x: string]:
          | undefined
          | string
          | {
              [x: string]: string | undefined;
            };
      };
};

export type ReturnTypesType = {
  [x: string]:
    | {
        [x: string]: string | undefined;
      }
    | `scalar.${string}`
    | undefined;
};
export type InputValueType = {
  [x: string]: undefined | boolean | string | number | [any, undefined | boolean | InputValueType] | InputValueType;
};
export type VType =
  | undefined
  | boolean
  | string
  | number
  | [any, undefined | boolean | InputValueType]
  | InputValueType;

export type PlainType = boolean | number | string | null | undefined;
export type ZeusArgsType =
  | PlainType
  | {
      [x: string]: ZeusArgsType;
    }
  | Array<ZeusArgsType>;

export type Operations = Record<string, string>;

export type VariableDefinition = {
  [x: string]: unknown;
};

export const SEPARATOR = '|';

export type fetchOptions = Parameters<typeof fetch>;
type websocketOptions = typeof WebSocket extends new (...args: infer R) => WebSocket ? R : never;
export type chainOptions = [fetchOptions[0], fetchOptions[1] & { websocket?: websocketOptions }] | [fetchOptions[0]];
export type FetchFunction = (query: string, variables?: Record<string, unknown>) => Promise<any>;
export type SubscriptionFunction = (query: string) => any;
type NotUndefined<T> = T extends undefined ? never : T;
export type ResolverType<F> = NotUndefined<F extends [infer ARGS, any] ? ARGS : undefined>;

export type OperationOptions = {
  operationName?: string;
};

export type ScalarCoder = Record<string, (s: unknown) => string>;

export interface GraphQLResponse {
  data?: Record<string, any>;
  errors?: Array<{
    message: string;
  }>;
}
export class GraphQLError extends Error {
  constructor(public response: GraphQLResponse) {
    super('');
    console.error(response);
  }
  toString() {
    return 'GraphQL Response Error';
  }
}
export type GenericOperation<O> = O extends keyof typeof Ops ? typeof Ops[O] : never;
export type ThunderGraphQLOptions<SCLR extends ScalarDefinition> = {
  scalars?: SCLR | ScalarCoders;
};

const ExtractScalar = (mappedParts: string[], returns: ReturnTypesType): `scalar.${string}` | undefined => {
  if (mappedParts.length === 0) {
    return;
  }
  const oKey = mappedParts[0];
  const returnP1 = returns[oKey];
  if (typeof returnP1 === 'object') {
    const returnP2 = returnP1[mappedParts[1]];
    if (returnP2) {
      return ExtractScalar([returnP2, ...mappedParts.slice(2)], returns);
    }
    return undefined;
  }
  return returnP1 as `scalar.${string}` | undefined;
};

export const PrepareScalarPaths = ({ ops, returns }: { returns: ReturnTypesType; ops: Operations }) => {
  const ibb = (
    k: string,
    originalKey: string,
    o: InputValueType | VType,
    p: string[] = [],
    pOriginals: string[] = [],
    root = true,
  ): { [x: string]: `scalar.${string}` } | undefined => {
    if (!o) {
      return;
    }
    if (typeof o === 'boolean' || typeof o === 'number' || typeof o === 'string') {
      const extractionArray = [...pOriginals, originalKey];
      const isScalar = ExtractScalar(extractionArray, returns);
      if (isScalar?.startsWith('scalar')) {
        const partOfTree = {
          [[...p, k].join(SEPARATOR)]: isScalar,
        };
        return partOfTree;
      }
      return {};
    }
    if (Array.isArray(o)) {
      return ibb(k, k, o[1], p, pOriginals, false);
    }
    if (k === '__alias') {
      return Object.entries(o)
        .map(([alias, objectUnderAlias]) => {
          if (typeof objectUnderAlias !== 'object' || Array.isArray(objectUnderAlias)) {
            throw new Error(
              'Invalid alias it should be __alias:{ YOUR_ALIAS_NAME: { OPERATION_NAME: { ...selectors }}}',
            );
          }
          const operationName = Object.keys(objectUnderAlias)[0];
          const operation = objectUnderAlias[operationName];
          return ibb(alias, operationName, operation, p, pOriginals, false);
        })
        .reduce((a, b) => ({
          ...a,
          ...b,
        }));
    }
    const keyName = root ? ops[k] : k;
    return Object.entries(o)
      .filter(([k]) => k !== '__directives')
      .map(([k, v]) => {
        // Inline fragments shouldn't be added to the path as they aren't a field
        const isInlineFragment = originalKey.match(/^...\s*on/) != null;
        return ibb(
          k,
          k,
          v,
          isInlineFragment ? p : [...p, purifyGraphQLKey(keyName || k)],
          isInlineFragment ? pOriginals : [...pOriginals, purifyGraphQLKey(originalKey)],
          false,
        );
      })
      .reduce((a, b) => ({
        ...a,
        ...b,
      }));
  };
  return ibb;
};

export const purifyGraphQLKey = (k: string) => k.replace(/\([^)]*\)/g, '').replace(/^[^:]*\:/g, '');

const mapPart = (p: string) => {
  const [isArg, isField] = p.split('<>');
  if (isField) {
    return {
      v: isField,
      __type: 'field',
    } as const;
  }
  return {
    v: isArg,
    __type: 'arg',
  } as const;
};

type Part = ReturnType<typeof mapPart>;

export const ResolveFromPath = (props: AllTypesPropsType, returns: ReturnTypesType, ops: Operations) => {
  const ResolvePropsType = (mappedParts: Part[]) => {
    const oKey = ops[mappedParts[0].v];
    const propsP1 = oKey ? props[oKey] : props[mappedParts[0].v];
    if (propsP1 === 'enum' && mappedParts.length === 1) {
      return 'enum';
    }
    if (typeof propsP1 === 'string' && propsP1.startsWith('scalar.') && mappedParts.length === 1) {
      return propsP1;
    }
    if (typeof propsP1 === 'object') {
      if (mappedParts.length < 2) {
        return 'not';
      }
      const propsP2 = propsP1[mappedParts[1].v];
      if (typeof propsP2 === 'string') {
        return rpp(
          `${propsP2}${SEPARATOR}${mappedParts
            .slice(2)
            .map((mp) => mp.v)
            .join(SEPARATOR)}`,
        );
      }
      if (typeof propsP2 === 'object') {
        if (mappedParts.length < 3) {
          return 'not';
        }
        const propsP3 = propsP2[mappedParts[2].v];
        if (propsP3 && mappedParts[2].__type === 'arg') {
          return rpp(
            `${propsP3}${SEPARATOR}${mappedParts
              .slice(3)
              .map((mp) => mp.v)
              .join(SEPARATOR)}`,
          );
        }
      }
    }
  };
  const ResolveReturnType = (mappedParts: Part[]) => {
    if (mappedParts.length === 0) {
      return 'not';
    }
    const oKey = ops[mappedParts[0].v];
    const returnP1 = oKey ? returns[oKey] : returns[mappedParts[0].v];
    if (typeof returnP1 === 'object') {
      if (mappedParts.length < 2) return 'not';
      const returnP2 = returnP1[mappedParts[1].v];
      if (returnP2) {
        return rpp(
          `${returnP2}${SEPARATOR}${mappedParts
            .slice(2)
            .map((mp) => mp.v)
            .join(SEPARATOR)}`,
        );
      }
    }
  };
  const rpp = (path: string): 'enum' | 'not' | `scalar.${string}` => {
    const parts = path.split(SEPARATOR).filter((l) => l.length > 0);
    const mappedParts = parts.map(mapPart);
    const propsP1 = ResolvePropsType(mappedParts);
    if (propsP1) {
      return propsP1;
    }
    const returnP1 = ResolveReturnType(mappedParts);
    if (returnP1) {
      return returnP1;
    }
    return 'not';
  };
  return rpp;
};

export const InternalArgsBuilt = ({
  props,
  ops,
  returns,
  scalars,
  vars,
}: {
  props: AllTypesPropsType;
  returns: ReturnTypesType;
  ops: Operations;
  scalars?: ScalarDefinition;
  vars: Array<{ name: string; graphQLType: string }>;
}) => {
  const arb = (a: ZeusArgsType, p = '', root = true): string => {
    if (typeof a === 'string') {
      if (a.startsWith(START_VAR_NAME)) {
        const [varName, graphQLType] = a.replace(START_VAR_NAME, '$').split(GRAPHQL_TYPE_SEPARATOR);
        const v = vars.find((v) => v.name === varName);
        if (!v) {
          vars.push({
            name: varName,
            graphQLType,
          });
        } else {
          if (v.graphQLType !== graphQLType) {
            throw new Error(
              `Invalid variable exists with two different GraphQL Types, "${v.graphQLType}" and ${graphQLType}`,
            );
          }
        }
        return varName;
      }
    }
    const checkType = ResolveFromPath(props, returns, ops)(p);
    if (checkType.startsWith('scalar.')) {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      const [_, ...splittedScalar] = checkType.split('.');
      const scalarKey = splittedScalar.join('.');
      return (scalars?.[scalarKey]?.encode?.(a) as string) || JSON.stringify(a);
    }
    if (Array.isArray(a)) {
      return `[${a.map((arr) => arb(arr, p, false)).join(', ')}]`;
    }
    if (typeof a === 'string') {
      if (checkType === 'enum') {
        return a;
      }
      return `${JSON.stringify(a)}`;
    }
    if (typeof a === 'object') {
      if (a === null) {
        return `null`;
      }
      const returnedObjectString = Object.entries(a)
        .filter(([, v]) => typeof v !== 'undefined')
        .map(([k, v]) => `${k}: ${arb(v, [p, k].join(SEPARATOR), false)}`)
        .join(',\n');
      if (!root) {
        return `{${returnedObjectString}}`;
      }
      return returnedObjectString;
    }
    return `${a}`;
  };
  return arb;
};

export const resolverFor = <X, T extends keyof ResolverInputTypes, Z extends keyof ResolverInputTypes[T]>(
  type: T,
  field: Z,
  fn: (
    args: Required<ResolverInputTypes[T]>[Z] extends [infer Input, any] ? Input : any,
    source: any,
  ) => Z extends keyof ModelTypes[T] ? ModelTypes[T][Z] | Promise<ModelTypes[T][Z]> | X : any,
) => fn as (args?: any, source?: any) => any;

export type UnwrapPromise<T> = T extends Promise<infer R> ? R : T;
export type ZeusState<T extends (...args: any[]) => Promise<any>> = NonNullable<UnwrapPromise<ReturnType<T>>>;
export type ZeusHook<
  T extends (...args: any[]) => Record<string, (...args: any[]) => Promise<any>>,
  N extends keyof ReturnType<T>,
> = ZeusState<ReturnType<T>[N]>;

export type WithTypeNameValue<T> = T & {
  __typename?: boolean;
  __directives?: string;
};
export type AliasType<T> = WithTypeNameValue<T> & {
  __alias?: Record<string, WithTypeNameValue<T>>;
};
type DeepAnify<T> = {
  [P in keyof T]?: any;
};
type IsPayLoad<T> = T extends [any, infer PayLoad] ? PayLoad : T;
export type ScalarDefinition = Record<string, ScalarResolver>;

type IsScalar<S, SCLR extends ScalarDefinition> = S extends 'scalar' & { name: infer T }
  ? T extends keyof SCLR
    ? SCLR[T]['decode'] extends (s: unknown) => unknown
      ? ReturnType<SCLR[T]['decode']>
      : unknown
    : unknown
  : S;
type IsArray<T, U, SCLR extends ScalarDefinition> = T extends Array<infer R>
  ? InputType<R, U, SCLR>[]
  : InputType<T, U, SCLR>;
type FlattenArray<T> = T extends Array<infer R> ? R : T;
type BaseZeusResolver = boolean | 1 | string | Variable<any, string>;

type IsInterfaced<SRC extends DeepAnify<DST>, DST, SCLR extends ScalarDefinition> = FlattenArray<SRC> extends
  | ZEUS_INTERFACES
  | ZEUS_UNIONS
  ? {
      [P in keyof SRC]: SRC[P] extends '__union' & infer R
        ? P extends keyof DST
          ? IsArray<R, '__typename' extends keyof DST ? DST[P] & { __typename: true } : DST[P], SCLR>
          : Record<string, unknown>
        : never;
    }[keyof DST] & {
      [P in keyof Omit<
        Pick<
          SRC,
          {
            [P in keyof DST]: SRC[P] extends '__union' & infer R ? never : P;
          }[keyof DST]
        >,
        '__typename'
      >]: IsPayLoad<DST[P]> extends BaseZeusResolver ? IsScalar<SRC[P], SCLR> : IsArray<SRC[P], DST[P], SCLR>;
    }
  : {
      [P in keyof Pick<SRC, keyof DST>]: IsPayLoad<DST[P]> extends BaseZeusResolver
        ? IsScalar<SRC[P], SCLR>
        : IsArray<SRC[P], DST[P], SCLR>;
    };

export type MapType<SRC, DST, SCLR extends ScalarDefinition> = SRC extends DeepAnify<DST>
  ? IsInterfaced<SRC, DST, SCLR>
  : never;
// eslint-disable-next-line @typescript-eslint/ban-types
export type InputType<SRC, DST, SCLR extends ScalarDefinition = {}> = IsPayLoad<DST> extends { __alias: infer R }
  ? {
      [P in keyof R]: MapType<SRC, R[P], SCLR>[keyof MapType<SRC, R[P], SCLR>];
    } & MapType<SRC, Omit<IsPayLoad<DST>, '__alias'>, SCLR>
  : MapType<SRC, IsPayLoad<DST>, SCLR>;
export type SubscriptionToGraphQL<Z, T, SCLR extends ScalarDefinition> = {
  ws: WebSocket;
  on: (fn: (args: InputType<T, Z, SCLR>) => void) => void;
  off: (fn: (e: { data?: InputType<T, Z, SCLR>; code?: number; reason?: string; message?: string }) => void) => void;
  error: (fn: (e: { data?: InputType<T, Z, SCLR>; errors?: string[] }) => void) => void;
  open: () => void;
};

// eslint-disable-next-line @typescript-eslint/ban-types
export type FromSelector<SELECTOR, NAME extends keyof GraphQLTypes, SCLR extends ScalarDefinition = {}> = InputType<
  GraphQLTypes[NAME],
  SELECTOR,
  SCLR
>;

export type ScalarResolver = {
  encode?: (s: unknown) => string;
  decode?: (s: unknown) => unknown;
};

export type SelectionFunction<V> = <T>(t: T | V) => T;

type BuiltInVariableTypes = {
  ['String']: string;
  ['Int']: number;
  ['Float']: number;
  ['ID']: unknown;
  ['Boolean']: boolean;
};
type AllVariableTypes = keyof BuiltInVariableTypes | keyof ZEUS_VARIABLES;
type VariableRequired<T extends string> = `${T}!` | T | `[${T}]` | `[${T}]!` | `[${T}!]` | `[${T}!]!`;
type VR<T extends string> = VariableRequired<VariableRequired<T>>;

export type GraphQLVariableType = VR<AllVariableTypes>;

type ExtractVariableTypeString<T extends string> = T extends VR<infer R1>
  ? R1 extends VR<infer R2>
    ? R2 extends VR<infer R3>
      ? R3 extends VR<infer R4>
        ? R4 extends VR<infer R5>
          ? R5
          : R4
        : R3
      : R2
    : R1
  : T;

type DecomposeType<T, Type> = T extends `[${infer R}]`
  ? Array<DecomposeType<R, Type>> | undefined
  : T extends `${infer R}!`
  ? NonNullable<DecomposeType<R, Type>>
  : Type | undefined;

type ExtractTypeFromGraphQLType<T extends string> = T extends keyof ZEUS_VARIABLES
  ? ZEUS_VARIABLES[T]
  : T extends keyof BuiltInVariableTypes
  ? BuiltInVariableTypes[T]
  : any;

export type GetVariableType<T extends string> = DecomposeType<
  T,
  ExtractTypeFromGraphQLType<ExtractVariableTypeString<T>>
>;

type UndefinedKeys<T> = {
  [K in keyof T]-?: T[K] extends NonNullable<T[K]> ? never : K;
}[keyof T];

type WithNullableKeys<T> = Pick<T, UndefinedKeys<T>>;
type WithNonNullableKeys<T> = Omit<T, UndefinedKeys<T>>;

type OptionalKeys<T> = {
  [P in keyof T]?: T[P];
};

export type WithOptionalNullables<T> = OptionalKeys<WithNullableKeys<T>> & WithNonNullableKeys<T>;

export type Variable<T extends GraphQLVariableType, Name extends string> = {
  ' __zeus_name': Name;
  ' __zeus_type': T;
};

export type ExtractVariables<Query> = Query extends Variable<infer VType, infer VName>
  ? { [key in VName]: GetVariableType<VType> }
  : Query extends [infer Inputs, infer Outputs]
  ? ExtractVariables<Inputs> & ExtractVariables<Outputs>
  : Query extends string | number | boolean
  ? // eslint-disable-next-line @typescript-eslint/ban-types
    {}
  : UnionToIntersection<{ [K in keyof Query]: WithOptionalNullables<ExtractVariables<Query[K]>> }[keyof Query]>;

type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;

export const START_VAR_NAME = `$ZEUS_VAR`;
export const GRAPHQL_TYPE_SEPARATOR = `__$GRAPHQL__`;

export const $ = <Type extends GraphQLVariableType, Name extends string>(name: Name, graphqlType: Type) => {
  return (START_VAR_NAME + name + GRAPHQL_TYPE_SEPARATOR + graphqlType) as unknown as Variable<Type, Name>;
};
type ZEUS_INTERFACES = GraphQLTypes["Node"]
export type ScalarCoders = {
	BigInt?: ScalarResolver;
	Date?: ScalarResolver;
	Datetime?: ScalarResolver;
	Cursor?: ScalarResolver;
	BigFloat?: ScalarResolver;
	Time?: ScalarResolver;
	JSON?: ScalarResolver;
}
type ZEUS_UNIONS = never

export type ValueTypes = {
    /** The root query type which gives access points into the data universe. */
["Query"]: AliasType<{
	/** Exposes the root query type nested one level down. This is helpful for Relay 1
which can only query top level fields if they are in a particular form. */
	query?:ValueTypes["Query"],
	/** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
	nodeId?:boolean | `@${string}`,
node?: [{	/** The globally unique `ID`. */
	nodeId: string | Variable<any, string>},ValueTypes["Node"]],
akces?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `Akce`. */
	orderBy?: Array<ValueTypes["AkcesOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["AkceCondition"] | undefined | null | Variable<any, string>},ValueTypes["AkcesConnection"]],
akceItems?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `AkceItem`. */
	orderBy?: Array<ValueTypes["AkceItemsOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["AkceItemCondition"] | undefined | null | Variable<any, string>},ValueTypes["AkceItemsConnection"]],
aktualities?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `Aktuality`. */
	orderBy?: Array<ValueTypes["AktualitiesOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["AktualityCondition"] | undefined | null | Variable<any, string>},ValueTypes["AktualitiesConnection"]],
dokumenties?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `Dokumenty`. */
	orderBy?: Array<ValueTypes["DokumentiesOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["DokumentyCondition"] | undefined | null | Variable<any, string>},ValueTypes["DokumentiesConnection"]],
galerieDirs?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `GalerieDir`. */
	orderBy?: Array<ValueTypes["GalerieDirsOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["GalerieDirCondition"] | undefined | null | Variable<any, string>},ValueTypes["GalerieDirsConnection"]],
galerieFotos?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `GalerieFoto`. */
	orderBy?: Array<ValueTypes["GalerieFotosOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["GalerieFotoCondition"] | undefined | null | Variable<any, string>},ValueTypes["GalerieFotosConnection"]],
members?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `Member`. */
	orderBy?: Array<ValueTypes["MembersOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["MemberCondition"] | undefined | null | Variable<any, string>},ValueTypes["MembersConnection"]],
nabidkas?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `Nabidka`. */
	orderBy?: Array<ValueTypes["NabidkasOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["NabidkaCondition"] | undefined | null | Variable<any, string>},ValueTypes["NabidkasConnection"]],
nabidkaItems?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `NabidkaItem`. */
	orderBy?: Array<ValueTypes["NabidkaItemsOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["NabidkaItemCondition"] | undefined | null | Variable<any, string>},ValueTypes["NabidkaItemsConnection"]],
pages?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `Page`. */
	orderBy?: Array<ValueTypes["PagesOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["PageCondition"] | undefined | null | Variable<any, string>},ValueTypes["PagesConnection"]],
pageRevisions?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `PageRevision`. */
	orderBy?: Array<ValueTypes["PageRevisionsOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["PageRevisionCondition"] | undefined | null | Variable<any, string>},ValueTypes["PageRevisionsConnection"]],
parameters?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `Parameter`. */
	orderBy?: Array<ValueTypes["ParametersOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["ParameterCondition"] | undefined | null | Variable<any, string>},ValueTypes["ParametersConnection"]],
paries?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `Pary`. */
	orderBy?: Array<ValueTypes["PariesOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["ParyCondition"] | undefined | null | Variable<any, string>},ValueTypes["PariesConnection"]],
paryNavrhs?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `ParyNavrh`. */
	orderBy?: Array<ValueTypes["ParyNavrhsOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["ParyNavrhCondition"] | undefined | null | Variable<any, string>},ValueTypes["ParyNavrhsConnection"]],
permissions?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `Permission`. */
	orderBy?: Array<ValueTypes["PermissionsOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["PermissionCondition"] | undefined | null | Variable<any, string>},ValueTypes["PermissionsConnection"]],
platbyCategories?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `PlatbyCategory`. */
	orderBy?: Array<ValueTypes["PlatbyCategoriesOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["PlatbyCategoryCondition"] | undefined | null | Variable<any, string>},ValueTypes["PlatbyCategoriesConnection"]],
platbyCategoryGroups?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `PlatbyCategoryGroup`. */
	orderBy?: Array<ValueTypes["PlatbyCategoryGroupsOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["PlatbyCategoryGroupCondition"] | undefined | null | Variable<any, string>},ValueTypes["PlatbyCategoryGroupsConnection"]],
platbyGroups?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `PlatbyGroup`. */
	orderBy?: Array<ValueTypes["PlatbyGroupsOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["PlatbyGroupCondition"] | undefined | null | Variable<any, string>},ValueTypes["PlatbyGroupsConnection"]],
platbyGroupSkupinas?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `PlatbyGroupSkupina`. */
	orderBy?: Array<ValueTypes["PlatbyGroupSkupinasOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["PlatbyGroupSkupinaCondition"] | undefined | null | Variable<any, string>},ValueTypes["PlatbyGroupSkupinasConnection"]],
platbyItems?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `PlatbyItem`. */
	orderBy?: Array<ValueTypes["PlatbyItemsOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["PlatbyItemCondition"] | undefined | null | Variable<any, string>},ValueTypes["PlatbyItemsConnection"]],
platbyRaws?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `PlatbyRaw`. */
	orderBy?: Array<ValueTypes["PlatbyRawsOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["PlatbyRawCondition"] | undefined | null | Variable<any, string>},ValueTypes["PlatbyRawsConnection"]],
rozpis?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `Rozpi`. */
	orderBy?: Array<ValueTypes["RozpisOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["RozpiCondition"] | undefined | null | Variable<any, string>},ValueTypes["RozpisConnection"]],
rozpisItems?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `RozpisItem`. */
	orderBy?: Array<ValueTypes["RozpisItemsOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["RozpisItemCondition"] | undefined | null | Variable<any, string>},ValueTypes["RozpisItemsConnection"]],
sessions?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `Session`. */
	orderBy?: Array<ValueTypes["SessionsOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["SessionCondition"] | undefined | null | Variable<any, string>},ValueTypes["SessionsConnection"]],
skupinies?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `Skupiny`. */
	orderBy?: Array<ValueTypes["SkupiniesOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["SkupinyCondition"] | undefined | null | Variable<any, string>},ValueTypes["SkupiniesConnection"]],
upozornenis?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `Upozorneni`. */
	orderBy?: Array<ValueTypes["UpozornenisOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["UpozorneniCondition"] | undefined | null | Variable<any, string>},ValueTypes["UpozornenisConnection"]],
upozorneniSkupinies?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `UpozorneniSkupiny`. */
	orderBy?: Array<ValueTypes["UpozorneniSkupiniesOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["UpozorneniSkupinyCondition"] | undefined | null | Variable<any, string>},ValueTypes["UpozorneniSkupiniesConnection"]],
users?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `User`. */
	orderBy?: Array<ValueTypes["UsersOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["UserCondition"] | undefined | null | Variable<any, string>},ValueTypes["UsersConnection"]],
usersSkupinies?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `UsersSkupiny`. */
	orderBy?: Array<ValueTypes["UsersSkupiniesOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["UsersSkupinyCondition"] | undefined | null | Variable<any, string>},ValueTypes["UsersSkupiniesConnection"]],
videos?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `Video`. */
	orderBy?: Array<ValueTypes["VideosOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["VideoCondition"] | undefined | null | Variable<any, string>},ValueTypes["VideosConnection"]],
videoLists?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `VideoList`. */
	orderBy?: Array<ValueTypes["VideoListsOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["VideoListCondition"] | undefined | null | Variable<any, string>},ValueTypes["VideoListsConnection"]],
videoSources?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `VideoSource`. */
	orderBy?: Array<ValueTypes["VideoSourcesOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["VideoSourceCondition"] | undefined | null | Variable<any, string>},ValueTypes["VideoSourcesConnection"]],
akce?: [{	aId: ValueTypes["BigInt"] | Variable<any, string>},ValueTypes["Akce"]],
akceItem?: [{	aiId: ValueTypes["BigInt"] | Variable<any, string>},ValueTypes["AkceItem"]],
aktuality?: [{	atId: ValueTypes["BigInt"] | Variable<any, string>},ValueTypes["Aktuality"]],
dokumenty?: [{	dId: ValueTypes["BigInt"] | Variable<any, string>},ValueTypes["Dokumenty"]],
galerieDir?: [{	gdId: ValueTypes["BigInt"] | Variable<any, string>},ValueTypes["GalerieDir"]],
galerieFoto?: [{	gfId: ValueTypes["BigInt"] | Variable<any, string>},ValueTypes["GalerieFoto"]],
nabidka?: [{	nId: ValueTypes["BigInt"] | Variable<any, string>},ValueTypes["Nabidka"]],
nabidkaItem?: [{	niId: ValueTypes["BigInt"] | Variable<any, string>},ValueTypes["NabidkaItem"]],
page?: [{	id: number | Variable<any, string>},ValueTypes["Page"]],
pageByUrl?: [{	url: string | Variable<any, string>},ValueTypes["Page"]],
pageRevision?: [{	revNumber: number | Variable<any, string>,	id: number | Variable<any, string>},ValueTypes["PageRevision"]],
parameter?: [{	paName: string | Variable<any, string>},ValueTypes["Parameter"]],
pary?: [{	pId: ValueTypes["BigInt"] | Variable<any, string>},ValueTypes["Pary"]],
paryNavrh?: [{	pnId: ValueTypes["BigInt"] | Variable<any, string>},ValueTypes["ParyNavrh"]],
permission?: [{	peId: ValueTypes["BigInt"] | Variable<any, string>},ValueTypes["Permission"]],
platbyCategory?: [{	pcId: ValueTypes["BigInt"] | Variable<any, string>},ValueTypes["PlatbyCategory"]],
platbyCategoryGroup?: [{	pcgId: ValueTypes["BigInt"] | Variable<any, string>},ValueTypes["PlatbyCategoryGroup"]],
platbyGroup?: [{	pgId: ValueTypes["BigInt"] | Variable<any, string>},ValueTypes["PlatbyGroup"]],
platbyGroupSkupina?: [{	pgsId: ValueTypes["BigInt"] | Variable<any, string>},ValueTypes["PlatbyGroupSkupina"]],
platbyItem?: [{	piId: ValueTypes["BigInt"] | Variable<any, string>},ValueTypes["PlatbyItem"]],
platbyRaw?: [{	prId: ValueTypes["BigInt"] | Variable<any, string>},ValueTypes["PlatbyRaw"]],
rozpi?: [{	rId: ValueTypes["BigInt"] | Variable<any, string>},ValueTypes["Rozpi"]],
rozpisItem?: [{	riId: ValueTypes["BigInt"] | Variable<any, string>},ValueTypes["RozpisItem"]],
session?: [{	ssId: string | Variable<any, string>},ValueTypes["Session"]],
skupiny?: [{	sId: ValueTypes["BigInt"] | Variable<any, string>},ValueTypes["Skupiny"]],
upozorneni?: [{	upId: ValueTypes["BigInt"] | Variable<any, string>},ValueTypes["Upozorneni"]],
upozorneniSkupiny?: [{	upsId: ValueTypes["BigInt"] | Variable<any, string>},ValueTypes["UpozorneniSkupiny"]],
user?: [{	uId: ValueTypes["BigInt"] | Variable<any, string>},ValueTypes["User"]],
usersSkupiny?: [{	usId: ValueTypes["BigInt"] | Variable<any, string>},ValueTypes["UsersSkupiny"]],
video?: [{	vId: ValueTypes["BigInt"] | Variable<any, string>},ValueTypes["Video"]],
videoList?: [{	vlId: ValueTypes["BigInt"] | Variable<any, string>},ValueTypes["VideoList"]],
videoSource?: [{	vsId: ValueTypes["BigInt"] | Variable<any, string>},ValueTypes["VideoSource"]],
activeProspects?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>},ValueTypes["ActiveProspectsConnection"]],
cohortMembers?: [{	id?: number | undefined | null | Variable<any, string>,	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>},ValueTypes["MembersConnection"]],
currentCoupleIds?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>},ValueTypes["CurrentCoupleIdsConnection"]],
	currentSessionId?:boolean | `@${string}`,
	currentUserId?:boolean | `@${string}`,
	getCurrentUser?:ValueTypes["User"],
reservationsForRange?: [{	startDate?: ValueTypes["Date"] | undefined | null | Variable<any, string>,	endDate?: ValueTypes["Date"] | undefined | null | Variable<any, string>,	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>},ValueTypes["NabidkasConnection"]],
schedulesForRange?: [{	startDate?: ValueTypes["Date"] | undefined | null | Variable<any, string>,	endDate?: ValueTypes["Date"] | undefined | null | Variable<any, string>,	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>},ValueTypes["RozpisConnection"]],
titleVideos?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>},ValueTypes["VideosConnection"]],
akceByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `Akce`. */
	nodeId: string | Variable<any, string>},ValueTypes["Akce"]],
akceItemByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `AkceItem`. */
	nodeId: string | Variable<any, string>},ValueTypes["AkceItem"]],
aktualityByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `Aktuality`. */
	nodeId: string | Variable<any, string>},ValueTypes["Aktuality"]],
dokumentyByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `Dokumenty`. */
	nodeId: string | Variable<any, string>},ValueTypes["Dokumenty"]],
galerieDirByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `GalerieDir`. */
	nodeId: string | Variable<any, string>},ValueTypes["GalerieDir"]],
galerieFotoByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `GalerieFoto`. */
	nodeId: string | Variable<any, string>},ValueTypes["GalerieFoto"]],
nabidkaByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `Nabidka`. */
	nodeId: string | Variable<any, string>},ValueTypes["Nabidka"]],
nabidkaItemByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `NabidkaItem`. */
	nodeId: string | Variable<any, string>},ValueTypes["NabidkaItem"]],
pageByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `Page`. */
	nodeId: string | Variable<any, string>},ValueTypes["Page"]],
pageRevisionByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `PageRevision`. */
	nodeId: string | Variable<any, string>},ValueTypes["PageRevision"]],
parameterByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `Parameter`. */
	nodeId: string | Variable<any, string>},ValueTypes["Parameter"]],
paryByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `Pary`. */
	nodeId: string | Variable<any, string>},ValueTypes["Pary"]],
paryNavrhByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `ParyNavrh`. */
	nodeId: string | Variable<any, string>},ValueTypes["ParyNavrh"]],
permissionByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `Permission`. */
	nodeId: string | Variable<any, string>},ValueTypes["Permission"]],
platbyCategoryByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `PlatbyCategory`. */
	nodeId: string | Variable<any, string>},ValueTypes["PlatbyCategory"]],
platbyCategoryGroupByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `PlatbyCategoryGroup`. */
	nodeId: string | Variable<any, string>},ValueTypes["PlatbyCategoryGroup"]],
platbyGroupByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `PlatbyGroup`. */
	nodeId: string | Variable<any, string>},ValueTypes["PlatbyGroup"]],
platbyGroupSkupinaByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `PlatbyGroupSkupina`. */
	nodeId: string | Variable<any, string>},ValueTypes["PlatbyGroupSkupina"]],
platbyItemByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `PlatbyItem`. */
	nodeId: string | Variable<any, string>},ValueTypes["PlatbyItem"]],
platbyRawByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `PlatbyRaw`. */
	nodeId: string | Variable<any, string>},ValueTypes["PlatbyRaw"]],
rozpiByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `Rozpi`. */
	nodeId: string | Variable<any, string>},ValueTypes["Rozpi"]],
rozpisItemByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `RozpisItem`. */
	nodeId: string | Variable<any, string>},ValueTypes["RozpisItem"]],
sessionByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `Session`. */
	nodeId: string | Variable<any, string>},ValueTypes["Session"]],
skupinyByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `Skupiny`. */
	nodeId: string | Variable<any, string>},ValueTypes["Skupiny"]],
upozorneniByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `Upozorneni`. */
	nodeId: string | Variable<any, string>},ValueTypes["Upozorneni"]],
upozorneniSkupinyByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `UpozorneniSkupiny`. */
	nodeId: string | Variable<any, string>},ValueTypes["UpozorneniSkupiny"]],
userByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `User`. */
	nodeId: string | Variable<any, string>},ValueTypes["User"]],
usersSkupinyByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `UsersSkupiny`. */
	nodeId: string | Variable<any, string>},ValueTypes["UsersSkupiny"]],
videoByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `Video`. */
	nodeId: string | Variable<any, string>},ValueTypes["Video"]],
videoListByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `VideoList`. */
	nodeId: string | Variable<any, string>},ValueTypes["VideoList"]],
videoSourceByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `VideoSource`. */
	nodeId: string | Variable<any, string>},ValueTypes["VideoSource"]],
		__typename?: boolean | `@${string}`
}>;
	/** An object with a globally unique `ID`. */
["Node"]:AliasType<{
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`;
		['...on Query']?: Omit<ValueTypes["Query"],keyof ValueTypes["Node"]>;
		['...on Akce']?: Omit<ValueTypes["Akce"],keyof ValueTypes["Node"]>;
		['...on AkceItem']?: Omit<ValueTypes["AkceItem"],keyof ValueTypes["Node"]>;
		['...on User']?: Omit<ValueTypes["User"],keyof ValueTypes["Node"]>;
		['...on Permission']?: Omit<ValueTypes["Permission"],keyof ValueTypes["Node"]>;
		['...on Skupiny']?: Omit<ValueTypes["Skupiny"],keyof ValueTypes["Node"]>;
		['...on PlatbyGroupSkupina']?: Omit<ValueTypes["PlatbyGroupSkupina"],keyof ValueTypes["Node"]>;
		['...on PlatbyGroup']?: Omit<ValueTypes["PlatbyGroup"],keyof ValueTypes["Node"]>;
		['...on PlatbyCategoryGroup']?: Omit<ValueTypes["PlatbyCategoryGroup"],keyof ValueTypes["Node"]>;
		['...on PlatbyCategory']?: Omit<ValueTypes["PlatbyCategory"],keyof ValueTypes["Node"]>;
		['...on PlatbyItem']?: Omit<ValueTypes["PlatbyItem"],keyof ValueTypes["Node"]>;
		['...on PlatbyRaw']?: Omit<ValueTypes["PlatbyRaw"],keyof ValueTypes["Node"]>;
		['...on UpozorneniSkupiny']?: Omit<ValueTypes["UpozorneniSkupiny"],keyof ValueTypes["Node"]>;
		['...on Upozorneni']?: Omit<ValueTypes["Upozorneni"],keyof ValueTypes["Node"]>;
		['...on Aktuality']?: Omit<ValueTypes["Aktuality"],keyof ValueTypes["Node"]>;
		['...on GalerieFoto']?: Omit<ValueTypes["GalerieFoto"],keyof ValueTypes["Node"]>;
		['...on GalerieDir']?: Omit<ValueTypes["GalerieDir"],keyof ValueTypes["Node"]>;
		['...on Nabidka']?: Omit<ValueTypes["Nabidka"],keyof ValueTypes["Node"]>;
		['...on NabidkaItem']?: Omit<ValueTypes["NabidkaItem"],keyof ValueTypes["Node"]>;
		['...on Pary']?: Omit<ValueTypes["Pary"],keyof ValueTypes["Node"]>;
		['...on RozpisItem']?: Omit<ValueTypes["RozpisItem"],keyof ValueTypes["Node"]>;
		['...on Rozpi']?: Omit<ValueTypes["Rozpi"],keyof ValueTypes["Node"]>;
		['...on Session']?: Omit<ValueTypes["Session"],keyof ValueTypes["Node"]>;
		['...on Dokumenty']?: Omit<ValueTypes["Dokumenty"],keyof ValueTypes["Node"]>;
		['...on ParyNavrh']?: Omit<ValueTypes["ParyNavrh"],keyof ValueTypes["Node"]>;
		['...on Page']?: Omit<ValueTypes["Page"],keyof ValueTypes["Node"]>;
		['...on PageRevision']?: Omit<ValueTypes["PageRevision"],keyof ValueTypes["Node"]>;
		['...on Parameter']?: Omit<ValueTypes["Parameter"],keyof ValueTypes["Node"]>;
		['...on UsersSkupiny']?: Omit<ValueTypes["UsersSkupiny"],keyof ValueTypes["Node"]>;
		['...on Video']?: Omit<ValueTypes["Video"],keyof ValueTypes["Node"]>;
		['...on VideoList']?: Omit<ValueTypes["VideoList"],keyof ValueTypes["Node"]>;
		['...on VideoSource']?: Omit<ValueTypes["VideoSource"],keyof ValueTypes["Node"]>;
		__typename?: boolean | `@${string}`
}>;
	/** A connection to a list of `Akce` values. */
["AkcesConnection"]: AliasType<{
	/** A list of `Akce` objects. */
	nodes?:ValueTypes["Akce"],
	/** A list of edges which contains the `Akce` and cursor to aid in pagination. */
	edges?:ValueTypes["AkcesEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ValueTypes["PageInfo"],
	/** The count of *all* `Akce` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["Akce"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	aId?:boolean | `@${string}`,
	aJmeno?:boolean | `@${string}`,
	aKde?:boolean | `@${string}`,
	aInfo?:boolean | `@${string}`,
	aOd?:boolean | `@${string}`,
	aDo?:boolean | `@${string}`,
	aKapacita?:boolean | `@${string}`,
	aDokumenty?:boolean | `@${string}`,
	aTimestamp?:boolean | `@${string}`,
	aLock?:boolean | `@${string}`,
	aVisible?:boolean | `@${string}`,
akceItemsByAiIdRodic?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `AkceItem`. */
	orderBy?: Array<ValueTypes["AkceItemsOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["AkceItemCondition"] | undefined | null | Variable<any, string>},ValueTypes["AkceItemsConnection"]],
		__typename?: boolean | `@${string}`
}>;
	/** A signed eight-byte integer. The upper big integer values are greater than the
max value for a JavaScript number. Therefore all big integers will be output as
strings and not numbers. */
["BigInt"]:unknown;
	/** The day, does not include a time. */
["Date"]:unknown;
	/** A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone. */
["Datetime"]:unknown;
	/** A connection to a list of `AkceItem` values. */
["AkceItemsConnection"]: AliasType<{
	/** A list of `AkceItem` objects. */
	nodes?:ValueTypes["AkceItem"],
	/** A list of edges which contains the `AkceItem` and cursor to aid in pagination. */
	edges?:ValueTypes["AkceItemsEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ValueTypes["PageInfo"],
	/** The count of *all* `AkceItem` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["AkceItem"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	aiId?:boolean | `@${string}`,
	aiIdRodic?:boolean | `@${string}`,
	aiUser?:boolean | `@${string}`,
	aiRokNarozeni?:boolean | `@${string}`,
	/** Reads a single `Akce` that is related to this `AkceItem`. */
	akceByAiIdRodic?:ValueTypes["Akce"],
	/** Reads a single `User` that is related to this `AkceItem`. */
	userByAiUser?:ValueTypes["User"],
		__typename?: boolean | `@${string}`
}>;
	["User"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	uId?:boolean | `@${string}`,
	uLogin?:boolean | `@${string}`,
	uPass?:boolean | `@${string}`,
	uJmeno?:boolean | `@${string}`,
	uPrijmeni?:boolean | `@${string}`,
	uPohlavi?:boolean | `@${string}`,
	uEmail?:boolean | `@${string}`,
	uTelefon?:boolean | `@${string}`,
	uNarozeni?:boolean | `@${string}`,
	uRodneCislo?:boolean | `@${string}`,
	uPoznamky?:boolean | `@${string}`,
	uTimestamp?:boolean | `@${string}`,
	uLevel?:boolean | `@${string}`,
	uGroup?:boolean | `@${string}`,
	uSkupina?:boolean | `@${string}`,
	uDancer?:boolean | `@${string}`,
	uBan?:boolean | `@${string}`,
	uLock?:boolean | `@${string}`,
	uConfirmed?:boolean | `@${string}`,
	uSystem?:boolean | `@${string}`,
	uStreet?:boolean | `@${string}`,
	uConscriptionNumber?:boolean | `@${string}`,
	uOrientationNumber?:boolean | `@${string}`,
	uDistrict?:boolean | `@${string}`,
	uCity?:boolean | `@${string}`,
	uPostalCode?:boolean | `@${string}`,
	uNationality?:boolean | `@${string}`,
	uMemberSince?:boolean | `@${string}`,
	uMemberUntil?:boolean | `@${string}`,
	uCreatedAt?:boolean | `@${string}`,
	uTeacher?:boolean | `@${string}`,
	uGdprSignedAt?:boolean | `@${string}`,
	/** Reads a single `Permission` that is related to this `User`. */
	permissionByUGroup?:ValueTypes["Permission"],
	/** Reads a single `Skupiny` that is related to this `User`. */
	skupinyByUSkupina?:ValueTypes["Skupiny"],
aktualitiesByAtKdo?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `Aktuality`. */
	orderBy?: Array<ValueTypes["AktualitiesOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["AktualityCondition"] | undefined | null | Variable<any, string>},ValueTypes["AktualitiesConnection"]],
nabidkasByNTrener?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `Nabidka`. */
	orderBy?: Array<ValueTypes["NabidkasOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["NabidkaCondition"] | undefined | null | Variable<any, string>},ValueTypes["NabidkasConnection"]],
rozpisByRTrener?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `Rozpi`. */
	orderBy?: Array<ValueTypes["RozpisOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["RozpiCondition"] | undefined | null | Variable<any, string>},ValueTypes["RozpisConnection"]],
platbyItemsByPiIdUser?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `PlatbyItem`. */
	orderBy?: Array<ValueTypes["PlatbyItemsOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["PlatbyItemCondition"] | undefined | null | Variable<any, string>},ValueTypes["PlatbyItemsConnection"]],
pariesByPIdPartner?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `Pary`. */
	orderBy?: Array<ValueTypes["PariesOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["ParyCondition"] | undefined | null | Variable<any, string>},ValueTypes["PariesConnection"]],
sessionsBySsUser?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `Session`. */
	orderBy?: Array<ValueTypes["SessionsOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["SessionCondition"] | undefined | null | Variable<any, string>},ValueTypes["SessionsConnection"]],
akceItemsByAiUser?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `AkceItem`. */
	orderBy?: Array<ValueTypes["AkceItemsOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["AkceItemCondition"] | undefined | null | Variable<any, string>},ValueTypes["AkceItemsConnection"]],
dokumentiesByDKdo?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `Dokumenty`. */
	orderBy?: Array<ValueTypes["DokumentiesOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["DokumentyCondition"] | undefined | null | Variable<any, string>},ValueTypes["DokumentiesConnection"]],
galerieFotosByGfKdo?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `GalerieFoto`. */
	orderBy?: Array<ValueTypes["GalerieFotosOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["GalerieFotoCondition"] | undefined | null | Variable<any, string>},ValueTypes["GalerieFotosConnection"]],
paryNavrhsByPnNavrhl?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `ParyNavrh`. */
	orderBy?: Array<ValueTypes["ParyNavrhsOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["ParyNavrhCondition"] | undefined | null | Variable<any, string>},ValueTypes["ParyNavrhsConnection"]],
paryNavrhsByPnPartner?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `ParyNavrh`. */
	orderBy?: Array<ValueTypes["ParyNavrhsOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["ParyNavrhCondition"] | undefined | null | Variable<any, string>},ValueTypes["ParyNavrhsConnection"]],
paryNavrhsByPnPartnerka?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `ParyNavrh`. */
	orderBy?: Array<ValueTypes["ParyNavrhsOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["ParyNavrhCondition"] | undefined | null | Variable<any, string>},ValueTypes["ParyNavrhsConnection"]],
upozornenisByUpKdo?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `Upozorneni`. */
	orderBy?: Array<ValueTypes["UpozornenisOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["UpozorneniCondition"] | undefined | null | Variable<any, string>},ValueTypes["UpozornenisConnection"]],
		__typename?: boolean | `@${string}`
}>;
	["Permission"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	peId?:boolean | `@${string}`,
	peName?:boolean | `@${string}`,
	peDescription?:boolean | `@${string}`,
	peAkce?:boolean | `@${string}`,
	peAktuality?:boolean | `@${string}`,
	peAnkety?:boolean | `@${string}`,
	peDokumenty?:boolean | `@${string}`,
	peGalerie?:boolean | `@${string}`,
	peInzerce?:boolean | `@${string}`,
	peKonzole?:boolean | `@${string}`,
	peNabidka?:boolean | `@${string}`,
	peNastenka?:boolean | `@${string}`,
	peNovinky?:boolean | `@${string}`,
	pePary?:boolean | `@${string}`,
	pePlatby?:boolean | `@${string}`,
	pePermissions?:boolean | `@${string}`,
	peRozpis?:boolean | `@${string}`,
	peSkupiny?:boolean | `@${string}`,
	peUsers?:boolean | `@${string}`,
	peMain?:boolean | `@${string}`,
usersByUGroup?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `User`. */
	orderBy?: Array<ValueTypes["UsersOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["UserCondition"] | undefined | null | Variable<any, string>},ValueTypes["UsersConnection"]],
		__typename?: boolean | `@${string}`
}>;
	/** A connection to a list of `User` values. */
["UsersConnection"]: AliasType<{
	/** A list of `User` objects. */
	nodes?:ValueTypes["User"],
	/** A list of edges which contains the `User` and cursor to aid in pagination. */
	edges?:ValueTypes["UsersEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ValueTypes["PageInfo"],
	/** The count of *all* `User` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `User` edge in the connection. */
["UsersEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `User` at the end of the edge. */
	node?:ValueTypes["User"],
		__typename?: boolean | `@${string}`
}>;
	/** A location in a connection that can be used for resuming pagination. */
["Cursor"]:unknown;
	/** Information about pagination in a connection. */
["PageInfo"]: AliasType<{
	/** When paginating forwards, are there more items? */
	hasNextPage?:boolean | `@${string}`,
	/** When paginating backwards, are there more items? */
	hasPreviousPage?:boolean | `@${string}`,
	/** When paginating backwards, the cursor to continue. */
	startCursor?:boolean | `@${string}`,
	/** When paginating forwards, the cursor to continue. */
	endCursor?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `User`. */
["UsersOrderBy"]:UsersOrderBy;
	/** A condition to be used against `User` object types. All fields are tested for equality and combined with a logical and. */
["UserCondition"]: {
	/** Checks for equality with the objects `uId` field. */
	uId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uLogin` field. */
	uLogin?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uPass` field. */
	uPass?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uJmeno` field. */
	uJmeno?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uPrijmeni` field. */
	uPrijmeni?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uPohlavi` field. */
	uPohlavi?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uEmail` field. */
	uEmail?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uTelefon` field. */
	uTelefon?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uNarozeni` field. */
	uNarozeni?: ValueTypes["Date"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uRodneCislo` field. */
	uRodneCislo?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uPoznamky` field. */
	uPoznamky?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uTimestamp` field. */
	uTimestamp?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uLevel` field. */
	uLevel?: number | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uGroup` field. */
	uGroup?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uSkupina` field. */
	uSkupina?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uDancer` field. */
	uDancer?: boolean | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uBan` field. */
	uBan?: boolean | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uLock` field. */
	uLock?: boolean | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uConfirmed` field. */
	uConfirmed?: boolean | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uSystem` field. */
	uSystem?: boolean | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uStreet` field. */
	uStreet?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uConscriptionNumber` field. */
	uConscriptionNumber?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uOrientationNumber` field. */
	uOrientationNumber?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uDistrict` field. */
	uDistrict?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uCity` field. */
	uCity?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uPostalCode` field. */
	uPostalCode?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uNationality` field. */
	uNationality?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uMemberSince` field. */
	uMemberSince?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uMemberUntil` field. */
	uMemberUntil?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uCreatedAt` field. */
	uCreatedAt?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uTeacher` field. */
	uTeacher?: boolean | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uGdprSignedAt` field. */
	uGdprSignedAt?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	["Skupiny"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	sId?:boolean | `@${string}`,
	sName?:boolean | `@${string}`,
	sDescription?:boolean | `@${string}`,
	sColorRgb?:boolean | `@${string}`,
	sColorText?:boolean | `@${string}`,
	sLocation?:boolean | `@${string}`,
	sVisible?:boolean | `@${string}`,
usersByUSkupina?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `User`. */
	orderBy?: Array<ValueTypes["UsersOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["UserCondition"] | undefined | null | Variable<any, string>},ValueTypes["UsersConnection"]],
platbyGroupSkupinasByPgsIdSkupina?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `PlatbyGroupSkupina`. */
	orderBy?: Array<ValueTypes["PlatbyGroupSkupinasOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["PlatbyGroupSkupinaCondition"] | undefined | null | Variable<any, string>},ValueTypes["PlatbyGroupSkupinasConnection"]],
upozorneniSkupiniesByUpsIdSkupina?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `UpozorneniSkupiny`. */
	orderBy?: Array<ValueTypes["UpozorneniSkupiniesOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["UpozorneniSkupinyCondition"] | undefined | null | Variable<any, string>},ValueTypes["UpozorneniSkupiniesConnection"]],
		__typename?: boolean | `@${string}`
}>;
	/** A connection to a list of `PlatbyGroupSkupina` values. */
["PlatbyGroupSkupinasConnection"]: AliasType<{
	/** A list of `PlatbyGroupSkupina` objects. */
	nodes?:ValueTypes["PlatbyGroupSkupina"],
	/** A list of edges which contains the `PlatbyGroupSkupina` and cursor to aid in pagination. */
	edges?:ValueTypes["PlatbyGroupSkupinasEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ValueTypes["PageInfo"],
	/** The count of *all* `PlatbyGroupSkupina` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["PlatbyGroupSkupina"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	pgsId?:boolean | `@${string}`,
	pgsIdSkupina?:boolean | `@${string}`,
	pgsIdGroup?:boolean | `@${string}`,
	/** Reads a single `Skupiny` that is related to this `PlatbyGroupSkupina`. */
	skupinyByPgsIdSkupina?:ValueTypes["Skupiny"],
	/** Reads a single `PlatbyGroup` that is related to this `PlatbyGroupSkupina`. */
	platbyGroupByPgsIdGroup?:ValueTypes["PlatbyGroup"],
		__typename?: boolean | `@${string}`
}>;
	["PlatbyGroup"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	pgId?:boolean | `@${string}`,
	pgType?:boolean | `@${string}`,
	pgName?:boolean | `@${string}`,
	pgDescription?:boolean | `@${string}`,
	pgBase?:boolean | `@${string}`,
platbyCategoryGroupsByPcgIdGroup?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `PlatbyCategoryGroup`. */
	orderBy?: Array<ValueTypes["PlatbyCategoryGroupsOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["PlatbyCategoryGroupCondition"] | undefined | null | Variable<any, string>},ValueTypes["PlatbyCategoryGroupsConnection"]],
platbyGroupSkupinasByPgsIdGroup?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `PlatbyGroupSkupina`. */
	orderBy?: Array<ValueTypes["PlatbyGroupSkupinasOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["PlatbyGroupSkupinaCondition"] | undefined | null | Variable<any, string>},ValueTypes["PlatbyGroupSkupinasConnection"]],
		__typename?: boolean | `@${string}`
}>;
	/** A floating point number that requires more precision than IEEE 754 binary 64 */
["BigFloat"]:unknown;
	/** A connection to a list of `PlatbyCategoryGroup` values. */
["PlatbyCategoryGroupsConnection"]: AliasType<{
	/** A list of `PlatbyCategoryGroup` objects. */
	nodes?:ValueTypes["PlatbyCategoryGroup"],
	/** A list of edges which contains the `PlatbyCategoryGroup` and cursor to aid in pagination. */
	edges?:ValueTypes["PlatbyCategoryGroupsEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ValueTypes["PageInfo"],
	/** The count of *all* `PlatbyCategoryGroup` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["PlatbyCategoryGroup"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	pcgId?:boolean | `@${string}`,
	pcgIdGroup?:boolean | `@${string}`,
	pcgIdCategory?:boolean | `@${string}`,
	/** Reads a single `PlatbyGroup` that is related to this `PlatbyCategoryGroup`. */
	platbyGroupByPcgIdGroup?:ValueTypes["PlatbyGroup"],
	/** Reads a single `PlatbyCategory` that is related to this `PlatbyCategoryGroup`. */
	platbyCategoryByPcgIdCategory?:ValueTypes["PlatbyCategory"],
		__typename?: boolean | `@${string}`
}>;
	["PlatbyCategory"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	pcId?:boolean | `@${string}`,
	pcName?:boolean | `@${string}`,
	pcSymbol?:boolean | `@${string}`,
	pcAmount?:boolean | `@${string}`,
	pcDateDue?:boolean | `@${string}`,
	pcValidFrom?:boolean | `@${string}`,
	pcValidTo?:boolean | `@${string}`,
	pcUseBase?:boolean | `@${string}`,
	pcUsePrefix?:boolean | `@${string}`,
	pcArchive?:boolean | `@${string}`,
	pcVisible?:boolean | `@${string}`,
platbyCategoryGroupsByPcgIdCategory?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `PlatbyCategoryGroup`. */
	orderBy?: Array<ValueTypes["PlatbyCategoryGroupsOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["PlatbyCategoryGroupCondition"] | undefined | null | Variable<any, string>},ValueTypes["PlatbyCategoryGroupsConnection"]],
platbyItemsByPiIdCategory?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `PlatbyItem`. */
	orderBy?: Array<ValueTypes["PlatbyItemsOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["PlatbyItemCondition"] | undefined | null | Variable<any, string>},ValueTypes["PlatbyItemsConnection"]],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `PlatbyCategoryGroup`. */
["PlatbyCategoryGroupsOrderBy"]:PlatbyCategoryGroupsOrderBy;
	/** A condition to be used against `PlatbyCategoryGroup` object types. All fields
are tested for equality and combined with a logical and. */
["PlatbyCategoryGroupCondition"]: {
	/** Checks for equality with the objects `pcgId` field. */
	pcgId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pcgIdGroup` field. */
	pcgIdGroup?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pcgIdCategory` field. */
	pcgIdCategory?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>
};
	/** A connection to a list of `PlatbyItem` values. */
["PlatbyItemsConnection"]: AliasType<{
	/** A list of `PlatbyItem` objects. */
	nodes?:ValueTypes["PlatbyItem"],
	/** A list of edges which contains the `PlatbyItem` and cursor to aid in pagination. */
	edges?:ValueTypes["PlatbyItemsEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ValueTypes["PageInfo"],
	/** The count of *all* `PlatbyItem` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["PlatbyItem"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	piId?:boolean | `@${string}`,
	piIdUser?:boolean | `@${string}`,
	piIdCategory?:boolean | `@${string}`,
	piIdRaw?:boolean | `@${string}`,
	piAmount?:boolean | `@${string}`,
	piDate?:boolean | `@${string}`,
	piPrefix?:boolean | `@${string}`,
	/** Reads a single `User` that is related to this `PlatbyItem`. */
	userByPiIdUser?:ValueTypes["User"],
	/** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
	platbyCategoryByPiIdCategory?:ValueTypes["PlatbyCategory"],
	/** Reads a single `PlatbyRaw` that is related to this `PlatbyItem`. */
	platbyRawByPiIdRaw?:ValueTypes["PlatbyRaw"],
		__typename?: boolean | `@${string}`
}>;
	["PlatbyRaw"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	prId?:boolean | `@${string}`,
	prRaw?:boolean | `@${string}`,
	prHash?:boolean | `@${string}`,
	prSorted?:boolean | `@${string}`,
	prDiscarded?:boolean | `@${string}`,
platbyItemsByPiIdRaw?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `PlatbyItem`. */
	orderBy?: Array<ValueTypes["PlatbyItemsOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["PlatbyItemCondition"] | undefined | null | Variable<any, string>},ValueTypes["PlatbyItemsConnection"]],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `PlatbyItem`. */
["PlatbyItemsOrderBy"]:PlatbyItemsOrderBy;
	/** A condition to be used against `PlatbyItem` object types. All fields are tested
for equality and combined with a logical and. */
["PlatbyItemCondition"]: {
	/** Checks for equality with the objects `piId` field. */
	piId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `piIdUser` field. */
	piIdUser?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `piIdCategory` field. */
	piIdCategory?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `piIdRaw` field. */
	piIdRaw?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `piAmount` field. */
	piAmount?: ValueTypes["BigFloat"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `piDate` field. */
	piDate?: ValueTypes["Date"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `piPrefix` field. */
	piPrefix?: number | undefined | null | Variable<any, string>
};
	/** A `PlatbyItem` edge in the connection. */
["PlatbyItemsEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `PlatbyItem` at the end of the edge. */
	node?:ValueTypes["PlatbyItem"],
		__typename?: boolean | `@${string}`
}>;
	/** A `PlatbyCategoryGroup` edge in the connection. */
["PlatbyCategoryGroupsEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `PlatbyCategoryGroup` at the end of the edge. */
	node?:ValueTypes["PlatbyCategoryGroup"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `PlatbyGroupSkupina`. */
["PlatbyGroupSkupinasOrderBy"]:PlatbyGroupSkupinasOrderBy;
	/** A condition to be used against `PlatbyGroupSkupina` object types. All fields are
tested for equality and combined with a logical and. */
["PlatbyGroupSkupinaCondition"]: {
	/** Checks for equality with the objects `pgsId` field. */
	pgsId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pgsIdSkupina` field. */
	pgsIdSkupina?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pgsIdGroup` field. */
	pgsIdGroup?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>
};
	/** A `PlatbyGroupSkupina` edge in the connection. */
["PlatbyGroupSkupinasEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `PlatbyGroupSkupina` at the end of the edge. */
	node?:ValueTypes["PlatbyGroupSkupina"],
		__typename?: boolean | `@${string}`
}>;
	/** A connection to a list of `UpozorneniSkupiny` values. */
["UpozorneniSkupiniesConnection"]: AliasType<{
	/** A list of `UpozorneniSkupiny` objects. */
	nodes?:ValueTypes["UpozorneniSkupiny"],
	/** A list of edges which contains the `UpozorneniSkupiny` and cursor to aid in pagination. */
	edges?:ValueTypes["UpozorneniSkupiniesEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ValueTypes["PageInfo"],
	/** The count of *all* `UpozorneniSkupiny` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["UpozorneniSkupiny"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	upsId?:boolean | `@${string}`,
	upsIdRodic?:boolean | `@${string}`,
	upsIdSkupina?:boolean | `@${string}`,
	upsColor?:boolean | `@${string}`,
	upsPopis?:boolean | `@${string}`,
	/** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
	upozorneniByUpsIdRodic?:ValueTypes["Upozorneni"],
	/** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
	skupinyByUpsIdSkupina?:ValueTypes["Skupiny"],
		__typename?: boolean | `@${string}`
}>;
	["Upozorneni"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	upId?:boolean | `@${string}`,
	upKdo?:boolean | `@${string}`,
	upNadpis?:boolean | `@${string}`,
	upText?:boolean | `@${string}`,
	upBarvy?:boolean | `@${string}`,
	upLock?:boolean | `@${string}`,
	upTimestamp?:boolean | `@${string}`,
	upTimestampAdd?:boolean | `@${string}`,
	/** Reads a single `User` that is related to this `Upozorneni`. */
	userByUpKdo?:ValueTypes["User"],
upozorneniSkupiniesByUpsIdRodic?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `UpozorneniSkupiny`. */
	orderBy?: Array<ValueTypes["UpozorneniSkupiniesOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["UpozorneniSkupinyCondition"] | undefined | null | Variable<any, string>},ValueTypes["UpozorneniSkupiniesConnection"]],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `UpozorneniSkupiny`. */
["UpozorneniSkupiniesOrderBy"]:UpozorneniSkupiniesOrderBy;
	/** A condition to be used against `UpozorneniSkupiny` object types. All fields are
tested for equality and combined with a logical and. */
["UpozorneniSkupinyCondition"]: {
	/** Checks for equality with the objects `upsId` field. */
	upsId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `upsIdRodic` field. */
	upsIdRodic?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `upsIdSkupina` field. */
	upsIdSkupina?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `upsColor` field. */
	upsColor?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `upsPopis` field. */
	upsPopis?: string | undefined | null | Variable<any, string>
};
	/** A `UpozorneniSkupiny` edge in the connection. */
["UpozorneniSkupiniesEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `UpozorneniSkupiny` at the end of the edge. */
	node?:ValueTypes["UpozorneniSkupiny"],
		__typename?: boolean | `@${string}`
}>;
	/** A connection to a list of `Aktuality` values. */
["AktualitiesConnection"]: AliasType<{
	/** A list of `Aktuality` objects. */
	nodes?:ValueTypes["Aktuality"],
	/** A list of edges which contains the `Aktuality` and cursor to aid in pagination. */
	edges?:ValueTypes["AktualitiesEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ValueTypes["PageInfo"],
	/** The count of *all* `Aktuality` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["Aktuality"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	atId?:boolean | `@${string}`,
	atKdo?:boolean | `@${string}`,
	atKat?:boolean | `@${string}`,
	atJmeno?:boolean | `@${string}`,
	atText?:boolean | `@${string}`,
	atPreview?:boolean | `@${string}`,
	atFoto?:boolean | `@${string}`,
	atFotoMain?:boolean | `@${string}`,
	atTimestamp?:boolean | `@${string}`,
	atTimestampAdd?:boolean | `@${string}`,
	/** Reads a single `User` that is related to this `Aktuality`. */
	userByAtKdo?:ValueTypes["User"],
	/** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
	galerieFotoByAtFotoMain?:ValueTypes["GalerieFoto"],
		__typename?: boolean | `@${string}`
}>;
	["GalerieFoto"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	gfId?:boolean | `@${string}`,
	gfIdRodic?:boolean | `@${string}`,
	gfName?:boolean | `@${string}`,
	gfPath?:boolean | `@${string}`,
	gfKdo?:boolean | `@${string}`,
	gfTimestamp?:boolean | `@${string}`,
	/** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
	galerieDirByGfIdRodic?:ValueTypes["GalerieDir"],
	/** Reads a single `User` that is related to this `GalerieFoto`. */
	userByGfKdo?:ValueTypes["User"],
aktualitiesByAtFotoMain?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `Aktuality`. */
	orderBy?: Array<ValueTypes["AktualitiesOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["AktualityCondition"] | undefined | null | Variable<any, string>},ValueTypes["AktualitiesConnection"]],
		__typename?: boolean | `@${string}`
}>;
	["GalerieDir"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	gdId?:boolean | `@${string}`,
	gdIdRodic?:boolean | `@${string}`,
	gdName?:boolean | `@${string}`,
	gdLevel?:boolean | `@${string}`,
	gdPath?:boolean | `@${string}`,
	gdHidden?:boolean | `@${string}`,
galerieFotosByGfIdRodic?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `GalerieFoto`. */
	orderBy?: Array<ValueTypes["GalerieFotosOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["GalerieFotoCondition"] | undefined | null | Variable<any, string>},ValueTypes["GalerieFotosConnection"]],
		__typename?: boolean | `@${string}`
}>;
	/** A connection to a list of `GalerieFoto` values. */
["GalerieFotosConnection"]: AliasType<{
	/** A list of `GalerieFoto` objects. */
	nodes?:ValueTypes["GalerieFoto"],
	/** A list of edges which contains the `GalerieFoto` and cursor to aid in pagination. */
	edges?:ValueTypes["GalerieFotosEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ValueTypes["PageInfo"],
	/** The count of *all* `GalerieFoto` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `GalerieFoto` edge in the connection. */
["GalerieFotosEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `GalerieFoto` at the end of the edge. */
	node?:ValueTypes["GalerieFoto"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `GalerieFoto`. */
["GalerieFotosOrderBy"]:GalerieFotosOrderBy;
	/** A condition to be used against `GalerieFoto` object types. All fields are tested
for equality and combined with a logical and. */
["GalerieFotoCondition"]: {
	/** Checks for equality with the objects `gfId` field. */
	gfId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `gfIdRodic` field. */
	gfIdRodic?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `gfName` field. */
	gfName?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `gfPath` field. */
	gfPath?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `gfKdo` field. */
	gfKdo?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `gfTimestamp` field. */
	gfTimestamp?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	/** Methods to use when ordering `Aktuality`. */
["AktualitiesOrderBy"]:AktualitiesOrderBy;
	/** A condition to be used against `Aktuality` object types. All fields are tested
for equality and combined with a logical and. */
["AktualityCondition"]: {
	/** Checks for equality with the objects `atId` field. */
	atId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `atKdo` field. */
	atKdo?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `atKat` field. */
	atKat?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `atJmeno` field. */
	atJmeno?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `atText` field. */
	atText?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `atPreview` field. */
	atPreview?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `atFoto` field. */
	atFoto?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `atFotoMain` field. */
	atFotoMain?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `atTimestamp` field. */
	atTimestamp?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `atTimestampAdd` field. */
	atTimestampAdd?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	/** A `Aktuality` edge in the connection. */
["AktualitiesEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `Aktuality` at the end of the edge. */
	node?:ValueTypes["Aktuality"],
		__typename?: boolean | `@${string}`
}>;
	/** A connection to a list of `Nabidka` values. */
["NabidkasConnection"]: AliasType<{
	/** A list of `Nabidka` objects. */
	nodes?:ValueTypes["Nabidka"],
	/** A list of edges which contains the `Nabidka` and cursor to aid in pagination. */
	edges?:ValueTypes["NabidkasEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ValueTypes["PageInfo"],
	/** The count of *all* `Nabidka` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["Nabidka"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	nId?:boolean | `@${string}`,
	nTrener?:boolean | `@${string}`,
	nPocetHod?:boolean | `@${string}`,
	nMaxPocetHod?:boolean | `@${string}`,
	nOd?:boolean | `@${string}`,
	nDo?:boolean | `@${string}`,
	nVisible?:boolean | `@${string}`,
	nLock?:boolean | `@${string}`,
	nTimestamp?:boolean | `@${string}`,
	/** Reads a single `User` that is related to this `Nabidka`. */
	userByNTrener?:ValueTypes["User"],
nabidkaItemsByNiIdRodic?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `NabidkaItem`. */
	orderBy?: Array<ValueTypes["NabidkaItemsOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["NabidkaItemCondition"] | undefined | null | Variable<any, string>},ValueTypes["NabidkaItemsConnection"]],
		__typename?: boolean | `@${string}`
}>;
	/** A connection to a list of `NabidkaItem` values. */
["NabidkaItemsConnection"]: AliasType<{
	/** A list of `NabidkaItem` objects. */
	nodes?:ValueTypes["NabidkaItem"],
	/** A list of edges which contains the `NabidkaItem` and cursor to aid in pagination. */
	edges?:ValueTypes["NabidkaItemsEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ValueTypes["PageInfo"],
	/** The count of *all* `NabidkaItem` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["NabidkaItem"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	niId?:boolean | `@${string}`,
	niIdRodic?:boolean | `@${string}`,
	niPartner?:boolean | `@${string}`,
	niPocetHod?:boolean | `@${string}`,
	niLock?:boolean | `@${string}`,
	/** Reads a single `Nabidka` that is related to this `NabidkaItem`. */
	nabidkaByNiIdRodic?:ValueTypes["Nabidka"],
	/** Reads a single `Pary` that is related to this `NabidkaItem`. */
	paryByNiPartner?:ValueTypes["Pary"],
		__typename?: boolean | `@${string}`
}>;
	["Pary"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	pId?:boolean | `@${string}`,
	pIdPartner?:boolean | `@${string}`,
	pIdPartnerka?:boolean | `@${string}`,
	pSttTrida?:boolean | `@${string}`,
	pSttBody?:boolean | `@${string}`,
	pSttFinale?:boolean | `@${string}`,
	pLatTrida?:boolean | `@${string}`,
	pLatBody?:boolean | `@${string}`,
	pLatFinale?:boolean | `@${string}`,
	pHodnoceni?:boolean | `@${string}`,
	pArchiv?:boolean | `@${string}`,
	pTimestampAdd?:boolean | `@${string}`,
	pTimestampArchive?:boolean | `@${string}`,
	/** Reads a single `User` that is related to this `Pary`. */
	userByPIdPartner?:ValueTypes["User"],
nabidkaItemsByNiPartner?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `NabidkaItem`. */
	orderBy?: Array<ValueTypes["NabidkaItemsOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["NabidkaItemCondition"] | undefined | null | Variable<any, string>},ValueTypes["NabidkaItemsConnection"]],
rozpisItemsByRiPartner?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `RozpisItem`. */
	orderBy?: Array<ValueTypes["RozpisItemsOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["RozpisItemCondition"] | undefined | null | Variable<any, string>},ValueTypes["RozpisItemsConnection"]],
		__typename?: boolean | `@${string}`
}>;
	["ParyPSttTrida"]:ParyPSttTrida;
	["ParyPLatTrida"]:ParyPLatTrida;
	/** Methods to use when ordering `NabidkaItem`. */
["NabidkaItemsOrderBy"]:NabidkaItemsOrderBy;
	/** A condition to be used against `NabidkaItem` object types. All fields are tested
for equality and combined with a logical and. */
["NabidkaItemCondition"]: {
	/** Checks for equality with the objects `niId` field. */
	niId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `niIdRodic` field. */
	niIdRodic?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `niPartner` field. */
	niPartner?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `niPocetHod` field. */
	niPocetHod?: number | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `niLock` field. */
	niLock?: boolean | undefined | null | Variable<any, string>
};
	/** A connection to a list of `RozpisItem` values. */
["RozpisItemsConnection"]: AliasType<{
	/** A list of `RozpisItem` objects. */
	nodes?:ValueTypes["RozpisItem"],
	/** A list of edges which contains the `RozpisItem` and cursor to aid in pagination. */
	edges?:ValueTypes["RozpisItemsEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ValueTypes["PageInfo"],
	/** The count of *all* `RozpisItem` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["RozpisItem"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	riId?:boolean | `@${string}`,
	riIdRodic?:boolean | `@${string}`,
	riPartner?:boolean | `@${string}`,
	riOd?:boolean | `@${string}`,
	riDo?:boolean | `@${string}`,
	riLock?:boolean | `@${string}`,
	/** Reads a single `Rozpi` that is related to this `RozpisItem`. */
	rozpiByRiIdRodic?:ValueTypes["Rozpi"],
	/** Reads a single `Pary` that is related to this `RozpisItem`. */
	paryByRiPartner?:ValueTypes["Pary"],
		__typename?: boolean | `@${string}`
}>;
	/** The exact time of day, does not include the date. May or may not have a timezone offset. */
["Time"]:unknown;
	["Rozpi"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	rId?:boolean | `@${string}`,
	rTrener?:boolean | `@${string}`,
	rKde?:boolean | `@${string}`,
	rDatum?:boolean | `@${string}`,
	rVisible?:boolean | `@${string}`,
	rLock?:boolean | `@${string}`,
	rTimestamp?:boolean | `@${string}`,
	/** Reads a single `User` that is related to this `Rozpi`. */
	userByRTrener?:ValueTypes["User"],
rozpisItemsByRiIdRodic?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null | Variable<any, string>,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null | Variable<any, string>,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null | Variable<any, string>,	/** Read all values in the set before (above) this cursor. */
	before?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** Read all values in the set after (below) this cursor. */
	after?: ValueTypes["Cursor"] | undefined | null | Variable<any, string>,	/** The method to use when ordering `RozpisItem`. */
	orderBy?: Array<ValueTypes["RozpisItemsOrderBy"]> | undefined | null | Variable<any, string>,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ValueTypes["RozpisItemCondition"] | undefined | null | Variable<any, string>},ValueTypes["RozpisItemsConnection"]],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `RozpisItem`. */
["RozpisItemsOrderBy"]:RozpisItemsOrderBy;
	/** A condition to be used against `RozpisItem` object types. All fields are tested
for equality and combined with a logical and. */
["RozpisItemCondition"]: {
	/** Checks for equality with the objects `riId` field. */
	riId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `riIdRodic` field. */
	riIdRodic?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `riPartner` field. */
	riPartner?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `riOd` field. */
	riOd?: ValueTypes["Time"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `riDo` field. */
	riDo?: ValueTypes["Time"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `riLock` field. */
	riLock?: boolean | undefined | null | Variable<any, string>
};
	/** A `RozpisItem` edge in the connection. */
["RozpisItemsEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `RozpisItem` at the end of the edge. */
	node?:ValueTypes["RozpisItem"],
		__typename?: boolean | `@${string}`
}>;
	/** A `NabidkaItem` edge in the connection. */
["NabidkaItemsEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `NabidkaItem` at the end of the edge. */
	node?:ValueTypes["NabidkaItem"],
		__typename?: boolean | `@${string}`
}>;
	/** A `Nabidka` edge in the connection. */
["NabidkasEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `Nabidka` at the end of the edge. */
	node?:ValueTypes["Nabidka"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `Nabidka`. */
["NabidkasOrderBy"]:NabidkasOrderBy;
	/** A condition to be used against `Nabidka` object types. All fields are tested for equality and combined with a logical and. */
["NabidkaCondition"]: {
	/** Checks for equality with the objects `nId` field. */
	nId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `nTrener` field. */
	nTrener?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `nPocetHod` field. */
	nPocetHod?: number | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `nMaxPocetHod` field. */
	nMaxPocetHod?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `nOd` field. */
	nOd?: ValueTypes["Date"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `nDo` field. */
	nDo?: ValueTypes["Date"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `nVisible` field. */
	nVisible?: boolean | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `nLock` field. */
	nLock?: boolean | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `nTimestamp` field. */
	nTimestamp?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	/** A connection to a list of `Rozpi` values. */
["RozpisConnection"]: AliasType<{
	/** A list of `Rozpi` objects. */
	nodes?:ValueTypes["Rozpi"],
	/** A list of edges which contains the `Rozpi` and cursor to aid in pagination. */
	edges?:ValueTypes["RozpisEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ValueTypes["PageInfo"],
	/** The count of *all* `Rozpi` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `Rozpi` edge in the connection. */
["RozpisEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `Rozpi` at the end of the edge. */
	node?:ValueTypes["Rozpi"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `Rozpi`. */
["RozpisOrderBy"]:RozpisOrderBy;
	/** A condition to be used against `Rozpi` object types. All fields are tested for equality and combined with a logical and. */
["RozpiCondition"]: {
	/** Checks for equality with the objects `rId` field. */
	rId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `rTrener` field. */
	rTrener?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `rKde` field. */
	rKde?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `rDatum` field. */
	rDatum?: ValueTypes["Date"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `rVisible` field. */
	rVisible?: boolean | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `rLock` field. */
	rLock?: boolean | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `rTimestamp` field. */
	rTimestamp?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	/** A connection to a list of `Pary` values. */
["PariesConnection"]: AliasType<{
	/** A list of `Pary` objects. */
	nodes?:ValueTypes["Pary"],
	/** A list of edges which contains the `Pary` and cursor to aid in pagination. */
	edges?:ValueTypes["PariesEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ValueTypes["PageInfo"],
	/** The count of *all* `Pary` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `Pary` edge in the connection. */
["PariesEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `Pary` at the end of the edge. */
	node?:ValueTypes["Pary"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `Pary`. */
["PariesOrderBy"]:PariesOrderBy;
	/** A condition to be used against `Pary` object types. All fields are tested for equality and combined with a logical and. */
["ParyCondition"]: {
	/** Checks for equality with the objects `pId` field. */
	pId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pIdPartner` field. */
	pIdPartner?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pIdPartnerka` field. */
	pIdPartnerka?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pSttTrida` field. */
	pSttTrida?: ValueTypes["ParyPSttTrida"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pSttBody` field. */
	pSttBody?: number | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pSttFinale` field. */
	pSttFinale?: boolean | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pLatTrida` field. */
	pLatTrida?: ValueTypes["ParyPLatTrida"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pLatBody` field. */
	pLatBody?: number | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pLatFinale` field. */
	pLatFinale?: boolean | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pHodnoceni` field. */
	pHodnoceni?: number | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pArchiv` field. */
	pArchiv?: boolean | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pTimestampAdd` field. */
	pTimestampAdd?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pTimestampArchive` field. */
	pTimestampArchive?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	/** A connection to a list of `Session` values. */
["SessionsConnection"]: AliasType<{
	/** A list of `Session` objects. */
	nodes?:ValueTypes["Session"],
	/** A list of edges which contains the `Session` and cursor to aid in pagination. */
	edges?:ValueTypes["SessionsEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ValueTypes["PageInfo"],
	/** The count of *all* `Session` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["Session"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	ssId?:boolean | `@${string}`,
	ssData?:boolean | `@${string}`,
	ssUpdatedAt?:boolean | `@${string}`,
	ssLifetime?:boolean | `@${string}`,
	ssUser?:boolean | `@${string}`,
	/** Reads a single `User` that is related to this `Session`. */
	userBySsUser?:ValueTypes["User"],
		__typename?: boolean | `@${string}`
}>;
	/** A `Session` edge in the connection. */
["SessionsEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `Session` at the end of the edge. */
	node?:ValueTypes["Session"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `Session`. */
["SessionsOrderBy"]:SessionsOrderBy;
	/** A condition to be used against `Session` object types. All fields are tested for equality and combined with a logical and. */
["SessionCondition"]: {
	/** Checks for equality with the objects `ssId` field. */
	ssId?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `ssData` field. */
	ssData?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `ssUpdatedAt` field. */
	ssUpdatedAt?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `ssLifetime` field. */
	ssLifetime?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `ssUser` field. */
	ssUser?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>
};
	/** Methods to use when ordering `AkceItem`. */
["AkceItemsOrderBy"]:AkceItemsOrderBy;
	/** A condition to be used against `AkceItem` object types. All fields are tested
for equality and combined with a logical and. */
["AkceItemCondition"]: {
	/** Checks for equality with the objects `aiId` field. */
	aiId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `aiIdRodic` field. */
	aiIdRodic?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `aiUser` field. */
	aiUser?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `aiRokNarozeni` field. */
	aiRokNarozeni?: number | undefined | null | Variable<any, string>
};
	/** A connection to a list of `Dokumenty` values. */
["DokumentiesConnection"]: AliasType<{
	/** A list of `Dokumenty` objects. */
	nodes?:ValueTypes["Dokumenty"],
	/** A list of edges which contains the `Dokumenty` and cursor to aid in pagination. */
	edges?:ValueTypes["DokumentiesEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ValueTypes["PageInfo"],
	/** The count of *all* `Dokumenty` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["Dokumenty"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	dId?:boolean | `@${string}`,
	dPath?:boolean | `@${string}`,
	dName?:boolean | `@${string}`,
	dFilename?:boolean | `@${string}`,
	dKategorie?:boolean | `@${string}`,
	dKdo?:boolean | `@${string}`,
	dTimestamp?:boolean | `@${string}`,
	/** Reads a single `User` that is related to this `Dokumenty`. */
	userByDKdo?:ValueTypes["User"],
		__typename?: boolean | `@${string}`
}>;
	/** A `Dokumenty` edge in the connection. */
["DokumentiesEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `Dokumenty` at the end of the edge. */
	node?:ValueTypes["Dokumenty"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `Dokumenty`. */
["DokumentiesOrderBy"]:DokumentiesOrderBy;
	/** A condition to be used against `Dokumenty` object types. All fields are tested
for equality and combined with a logical and. */
["DokumentyCondition"]: {
	/** Checks for equality with the objects `dId` field. */
	dId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `dPath` field. */
	dPath?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `dName` field. */
	dName?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `dFilename` field. */
	dFilename?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `dKategorie` field. */
	dKategorie?: number | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `dKdo` field. */
	dKdo?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `dTimestamp` field. */
	dTimestamp?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	/** A connection to a list of `ParyNavrh` values. */
["ParyNavrhsConnection"]: AliasType<{
	/** A list of `ParyNavrh` objects. */
	nodes?:ValueTypes["ParyNavrh"],
	/** A list of edges which contains the `ParyNavrh` and cursor to aid in pagination. */
	edges?:ValueTypes["ParyNavrhsEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ValueTypes["PageInfo"],
	/** The count of *all* `ParyNavrh` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["ParyNavrh"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	pnId?:boolean | `@${string}`,
	pnNavrhl?:boolean | `@${string}`,
	pnPartner?:boolean | `@${string}`,
	pnPartnerka?:boolean | `@${string}`,
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnNavrhl?:ValueTypes["User"],
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnPartner?:ValueTypes["User"],
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnPartnerka?:ValueTypes["User"],
		__typename?: boolean | `@${string}`
}>;
	/** A `ParyNavrh` edge in the connection. */
["ParyNavrhsEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `ParyNavrh` at the end of the edge. */
	node?:ValueTypes["ParyNavrh"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `ParyNavrh`. */
["ParyNavrhsOrderBy"]:ParyNavrhsOrderBy;
	/** A condition to be used against `ParyNavrh` object types. All fields are tested
for equality and combined with a logical and. */
["ParyNavrhCondition"]: {
	/** Checks for equality with the objects `pnId` field. */
	pnId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pnNavrhl` field. */
	pnNavrhl?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pnPartner` field. */
	pnPartner?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pnPartnerka` field. */
	pnPartnerka?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>
};
	/** A connection to a list of `Upozorneni` values. */
["UpozornenisConnection"]: AliasType<{
	/** A list of `Upozorneni` objects. */
	nodes?:ValueTypes["Upozorneni"],
	/** A list of edges which contains the `Upozorneni` and cursor to aid in pagination. */
	edges?:ValueTypes["UpozornenisEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ValueTypes["PageInfo"],
	/** The count of *all* `Upozorneni` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `Upozorneni` edge in the connection. */
["UpozornenisEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `Upozorneni` at the end of the edge. */
	node?:ValueTypes["Upozorneni"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `Upozorneni`. */
["UpozornenisOrderBy"]:UpozornenisOrderBy;
	/** A condition to be used against `Upozorneni` object types. All fields are tested
for equality and combined with a logical and. */
["UpozorneniCondition"]: {
	/** Checks for equality with the objects `upId` field. */
	upId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `upKdo` field. */
	upKdo?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `upNadpis` field. */
	upNadpis?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `upText` field. */
	upText?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `upBarvy` field. */
	upBarvy?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `upLock` field. */
	upLock?: boolean | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `upTimestamp` field. */
	upTimestamp?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `upTimestampAdd` field. */
	upTimestampAdd?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	/** A `AkceItem` edge in the connection. */
["AkceItemsEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `AkceItem` at the end of the edge. */
	node?:ValueTypes["AkceItem"],
		__typename?: boolean | `@${string}`
}>;
	/** A `Akce` edge in the connection. */
["AkcesEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `Akce` at the end of the edge. */
	node?:ValueTypes["Akce"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `Akce`. */
["AkcesOrderBy"]:AkcesOrderBy;
	/** A condition to be used against `Akce` object types. All fields are tested for equality and combined with a logical and. */
["AkceCondition"]: {
	/** Checks for equality with the objects `aId` field. */
	aId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `aJmeno` field. */
	aJmeno?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `aKde` field. */
	aKde?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `aInfo` field. */
	aInfo?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `aOd` field. */
	aOd?: ValueTypes["Date"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `aDo` field. */
	aDo?: ValueTypes["Date"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `aKapacita` field. */
	aKapacita?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `aDokumenty` field. */
	aDokumenty?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `aTimestamp` field. */
	aTimestamp?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `aLock` field. */
	aLock?: boolean | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `aVisible` field. */
	aVisible?: boolean | undefined | null | Variable<any, string>
};
	/** A connection to a list of `GalerieDir` values. */
["GalerieDirsConnection"]: AliasType<{
	/** A list of `GalerieDir` objects. */
	nodes?:ValueTypes["GalerieDir"],
	/** A list of edges which contains the `GalerieDir` and cursor to aid in pagination. */
	edges?:ValueTypes["GalerieDirsEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ValueTypes["PageInfo"],
	/** The count of *all* `GalerieDir` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `GalerieDir` edge in the connection. */
["GalerieDirsEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `GalerieDir` at the end of the edge. */
	node?:ValueTypes["GalerieDir"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `GalerieDir`. */
["GalerieDirsOrderBy"]:GalerieDirsOrderBy;
	/** A condition to be used against `GalerieDir` object types. All fields are tested
for equality and combined with a logical and. */
["GalerieDirCondition"]: {
	/** Checks for equality with the objects `gdId` field. */
	gdId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `gdIdRodic` field. */
	gdIdRodic?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `gdName` field. */
	gdName?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `gdLevel` field. */
	gdLevel?: number | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `gdPath` field. */
	gdPath?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `gdHidden` field. */
	gdHidden?: boolean | undefined | null | Variable<any, string>
};
	/** A connection to a list of `Member` values. */
["MembersConnection"]: AliasType<{
	/** A list of `Member` objects. */
	nodes?:ValueTypes["Member"],
	/** A list of edges which contains the `Member` and cursor to aid in pagination. */
	edges?:ValueTypes["MembersEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ValueTypes["PageInfo"],
	/** The count of *all* `Member` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["Member"]: AliasType<{
	uId?:boolean | `@${string}`,
	uLogin?:boolean | `@${string}`,
	uPass?:boolean | `@${string}`,
	uJmeno?:boolean | `@${string}`,
	uPrijmeni?:boolean | `@${string}`,
	uPohlavi?:boolean | `@${string}`,
	uEmail?:boolean | `@${string}`,
	uTelefon?:boolean | `@${string}`,
	uNarozeni?:boolean | `@${string}`,
	uRodneCislo?:boolean | `@${string}`,
	uPoznamky?:boolean | `@${string}`,
	uTimestamp?:boolean | `@${string}`,
	uLevel?:boolean | `@${string}`,
	uGroup?:boolean | `@${string}`,
	uSkupina?:boolean | `@${string}`,
	uDancer?:boolean | `@${string}`,
	uBan?:boolean | `@${string}`,
	uLock?:boolean | `@${string}`,
	uConfirmed?:boolean | `@${string}`,
	uSystem?:boolean | `@${string}`,
	uStreet?:boolean | `@${string}`,
	uConscriptionNumber?:boolean | `@${string}`,
	uOrientationNumber?:boolean | `@${string}`,
	uDistrict?:boolean | `@${string}`,
	uCity?:boolean | `@${string}`,
	uPostalCode?:boolean | `@${string}`,
	uNationality?:boolean | `@${string}`,
	uMemberSince?:boolean | `@${string}`,
	uMemberUntil?:boolean | `@${string}`,
	uCreatedAt?:boolean | `@${string}`,
	uTeacher?:boolean | `@${string}`,
	uGdprSignedAt?:boolean | `@${string}`,
	sId?:boolean | `@${string}`,
	sName?:boolean | `@${string}`,
	paymentValid?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `Member` edge in the connection. */
["MembersEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `Member` at the end of the edge. */
	node?:ValueTypes["Member"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `Member`. */
["MembersOrderBy"]:MembersOrderBy;
	/** A condition to be used against `Member` object types. All fields are tested for equality and combined with a logical and. */
["MemberCondition"]: {
	/** Checks for equality with the objects `uId` field. */
	uId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uLogin` field. */
	uLogin?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uPass` field. */
	uPass?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uJmeno` field. */
	uJmeno?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uPrijmeni` field. */
	uPrijmeni?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uPohlavi` field. */
	uPohlavi?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uEmail` field. */
	uEmail?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uTelefon` field. */
	uTelefon?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uNarozeni` field. */
	uNarozeni?: ValueTypes["Date"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uRodneCislo` field. */
	uRodneCislo?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uPoznamky` field. */
	uPoznamky?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uTimestamp` field. */
	uTimestamp?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uLevel` field. */
	uLevel?: number | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uGroup` field. */
	uGroup?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uSkupina` field. */
	uSkupina?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uDancer` field. */
	uDancer?: boolean | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uBan` field. */
	uBan?: boolean | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uLock` field. */
	uLock?: boolean | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uConfirmed` field. */
	uConfirmed?: boolean | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uSystem` field. */
	uSystem?: boolean | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uStreet` field. */
	uStreet?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uConscriptionNumber` field. */
	uConscriptionNumber?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uOrientationNumber` field. */
	uOrientationNumber?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uDistrict` field. */
	uDistrict?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uCity` field. */
	uCity?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uPostalCode` field. */
	uPostalCode?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uNationality` field. */
	uNationality?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uMemberSince` field. */
	uMemberSince?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uMemberUntil` field. */
	uMemberUntil?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uCreatedAt` field. */
	uCreatedAt?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uTeacher` field. */
	uTeacher?: boolean | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `uGdprSignedAt` field. */
	uGdprSignedAt?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `sId` field. */
	sId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `sName` field. */
	sName?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `paymentValid` field. */
	paymentValid?: boolean | undefined | null | Variable<any, string>
};
	/** A connection to a list of `Page` values. */
["PagesConnection"]: AliasType<{
	/** A list of `Page` objects. */
	nodes?:ValueTypes["Page"],
	/** A list of edges which contains the `Page` and cursor to aid in pagination. */
	edges?:ValueTypes["PagesEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ValueTypes["PageInfo"],
	/** The count of *all* `Page` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["Page"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	id?:boolean | `@${string}`,
	url?:boolean | `@${string}`,
	content?:boolean | `@${string}`,
	createdAt?:boolean | `@${string}`,
	updatedAt?:boolean | `@${string}`,
	title?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
["JSON"]:unknown;
	/** A `Page` edge in the connection. */
["PagesEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `Page` at the end of the edge. */
	node?:ValueTypes["Page"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `Page`. */
["PagesOrderBy"]:PagesOrderBy;
	/** A condition to be used against `Page` object types. All fields are tested for equality and combined with a logical and. */
["PageCondition"]: {
	/** Checks for equality with the objects `id` field. */
	id?: number | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `url` field. */
	url?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `content` field. */
	content?: ValueTypes["JSON"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `createdAt` field. */
	createdAt?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `updatedAt` field. */
	updatedAt?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `title` field. */
	title?: string | undefined | null | Variable<any, string>
};
	/** A connection to a list of `PageRevision` values. */
["PageRevisionsConnection"]: AliasType<{
	/** A list of `PageRevision` objects. */
	nodes?:ValueTypes["PageRevision"],
	/** A list of edges which contains the `PageRevision` and cursor to aid in pagination. */
	edges?:ValueTypes["PageRevisionsEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ValueTypes["PageInfo"],
	/** The count of *all* `PageRevision` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["PageRevision"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	revNumber?:boolean | `@${string}`,
	revOperation?:boolean | `@${string}`,
	revTimestamp?:boolean | `@${string}`,
	id?:boolean | `@${string}`,
	url?:boolean | `@${string}`,
	content?:boolean | `@${string}`,
	createdAt?:boolean | `@${string}`,
	updatedAt?:boolean | `@${string}`,
	title?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `PageRevision` edge in the connection. */
["PageRevisionsEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `PageRevision` at the end of the edge. */
	node?:ValueTypes["PageRevision"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `PageRevision`. */
["PageRevisionsOrderBy"]:PageRevisionsOrderBy;
	/** A condition to be used against `PageRevision` object types. All fields are
tested for equality and combined with a logical and. */
["PageRevisionCondition"]: {
	/** Checks for equality with the objects `revNumber` field. */
	revNumber?: number | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `revOperation` field. */
	revOperation?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `revTimestamp` field. */
	revTimestamp?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `id` field. */
	id?: number | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `url` field. */
	url?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `content` field. */
	content?: ValueTypes["JSON"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `createdAt` field. */
	createdAt?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `updatedAt` field. */
	updatedAt?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `title` field. */
	title?: string | undefined | null | Variable<any, string>
};
	/** A connection to a list of `Parameter` values. */
["ParametersConnection"]: AliasType<{
	/** A list of `Parameter` objects. */
	nodes?:ValueTypes["Parameter"],
	/** A list of edges which contains the `Parameter` and cursor to aid in pagination. */
	edges?:ValueTypes["ParametersEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ValueTypes["PageInfo"],
	/** The count of *all* `Parameter` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["Parameter"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	paName?:boolean | `@${string}`,
	paValue?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `Parameter` edge in the connection. */
["ParametersEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `Parameter` at the end of the edge. */
	node?:ValueTypes["Parameter"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `Parameter`. */
["ParametersOrderBy"]:ParametersOrderBy;
	/** A condition to be used against `Parameter` object types. All fields are tested
for equality and combined with a logical and. */
["ParameterCondition"]: {
	/** Checks for equality with the objects `paName` field. */
	paName?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `paValue` field. */
	paValue?: string | undefined | null | Variable<any, string>
};
	/** A connection to a list of `Permission` values. */
["PermissionsConnection"]: AliasType<{
	/** A list of `Permission` objects. */
	nodes?:ValueTypes["Permission"],
	/** A list of edges which contains the `Permission` and cursor to aid in pagination. */
	edges?:ValueTypes["PermissionsEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ValueTypes["PageInfo"],
	/** The count of *all* `Permission` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `Permission` edge in the connection. */
["PermissionsEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `Permission` at the end of the edge. */
	node?:ValueTypes["Permission"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `Permission`. */
["PermissionsOrderBy"]:PermissionsOrderBy;
	/** A condition to be used against `Permission` object types. All fields are tested
for equality and combined with a logical and. */
["PermissionCondition"]: {
	/** Checks for equality with the objects `peId` field. */
	peId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `peName` field. */
	peName?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `peDescription` field. */
	peDescription?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `peAkce` field. */
	peAkce?: number | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `peAktuality` field. */
	peAktuality?: number | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `peAnkety` field. */
	peAnkety?: number | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `peDokumenty` field. */
	peDokumenty?: number | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `peGalerie` field. */
	peGalerie?: number | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `peInzerce` field. */
	peInzerce?: number | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `peKonzole` field. */
	peKonzole?: number | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `peNabidka` field. */
	peNabidka?: number | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `peNastenka` field. */
	peNastenka?: number | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `peNovinky` field. */
	peNovinky?: number | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pePary` field. */
	pePary?: number | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pePlatby` field. */
	pePlatby?: number | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pePermissions` field. */
	pePermissions?: number | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `peRozpis` field. */
	peRozpis?: number | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `peSkupiny` field. */
	peSkupiny?: number | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `peUsers` field. */
	peUsers?: number | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `peMain` field. */
	peMain?: number | undefined | null | Variable<any, string>
};
	/** A connection to a list of `PlatbyCategory` values. */
["PlatbyCategoriesConnection"]: AliasType<{
	/** A list of `PlatbyCategory` objects. */
	nodes?:ValueTypes["PlatbyCategory"],
	/** A list of edges which contains the `PlatbyCategory` and cursor to aid in pagination. */
	edges?:ValueTypes["PlatbyCategoriesEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ValueTypes["PageInfo"],
	/** The count of *all* `PlatbyCategory` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `PlatbyCategory` edge in the connection. */
["PlatbyCategoriesEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `PlatbyCategory` at the end of the edge. */
	node?:ValueTypes["PlatbyCategory"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `PlatbyCategory`. */
["PlatbyCategoriesOrderBy"]:PlatbyCategoriesOrderBy;
	/** A condition to be used against `PlatbyCategory` object types. All fields are
tested for equality and combined with a logical and. */
["PlatbyCategoryCondition"]: {
	/** Checks for equality with the objects `pcId` field. */
	pcId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pcName` field. */
	pcName?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pcSymbol` field. */
	pcSymbol?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pcAmount` field. */
	pcAmount?: ValueTypes["BigFloat"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pcDateDue` field. */
	pcDateDue?: ValueTypes["Date"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pcValidFrom` field. */
	pcValidFrom?: ValueTypes["Date"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pcValidTo` field. */
	pcValidTo?: ValueTypes["Date"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pcUseBase` field. */
	pcUseBase?: boolean | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pcUsePrefix` field. */
	pcUsePrefix?: boolean | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pcArchive` field. */
	pcArchive?: boolean | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pcVisible` field. */
	pcVisible?: boolean | undefined | null | Variable<any, string>
};
	/** A connection to a list of `PlatbyGroup` values. */
["PlatbyGroupsConnection"]: AliasType<{
	/** A list of `PlatbyGroup` objects. */
	nodes?:ValueTypes["PlatbyGroup"],
	/** A list of edges which contains the `PlatbyGroup` and cursor to aid in pagination. */
	edges?:ValueTypes["PlatbyGroupsEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ValueTypes["PageInfo"],
	/** The count of *all* `PlatbyGroup` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `PlatbyGroup` edge in the connection. */
["PlatbyGroupsEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `PlatbyGroup` at the end of the edge. */
	node?:ValueTypes["PlatbyGroup"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `PlatbyGroup`. */
["PlatbyGroupsOrderBy"]:PlatbyGroupsOrderBy;
	/** A condition to be used against `PlatbyGroup` object types. All fields are tested
for equality and combined with a logical and. */
["PlatbyGroupCondition"]: {
	/** Checks for equality with the objects `pgId` field. */
	pgId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pgType` field. */
	pgType?: ValueTypes["BigFloat"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pgName` field. */
	pgName?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pgDescription` field. */
	pgDescription?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `pgBase` field. */
	pgBase?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>
};
	/** A connection to a list of `PlatbyRaw` values. */
["PlatbyRawsConnection"]: AliasType<{
	/** A list of `PlatbyRaw` objects. */
	nodes?:ValueTypes["PlatbyRaw"],
	/** A list of edges which contains the `PlatbyRaw` and cursor to aid in pagination. */
	edges?:ValueTypes["PlatbyRawsEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ValueTypes["PageInfo"],
	/** The count of *all* `PlatbyRaw` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `PlatbyRaw` edge in the connection. */
["PlatbyRawsEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `PlatbyRaw` at the end of the edge. */
	node?:ValueTypes["PlatbyRaw"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `PlatbyRaw`. */
["PlatbyRawsOrderBy"]:PlatbyRawsOrderBy;
	/** A condition to be used against `PlatbyRaw` object types. All fields are tested
for equality and combined with a logical and. */
["PlatbyRawCondition"]: {
	/** Checks for equality with the objects `prId` field. */
	prId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `prRaw` field. */
	prRaw?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `prHash` field. */
	prHash?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `prSorted` field. */
	prSorted?: boolean | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `prDiscarded` field. */
	prDiscarded?: boolean | undefined | null | Variable<any, string>
};
	/** A connection to a list of `Skupiny` values. */
["SkupiniesConnection"]: AliasType<{
	/** A list of `Skupiny` objects. */
	nodes?:ValueTypes["Skupiny"],
	/** A list of edges which contains the `Skupiny` and cursor to aid in pagination. */
	edges?:ValueTypes["SkupiniesEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ValueTypes["PageInfo"],
	/** The count of *all* `Skupiny` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `Skupiny` edge in the connection. */
["SkupiniesEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `Skupiny` at the end of the edge. */
	node?:ValueTypes["Skupiny"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `Skupiny`. */
["SkupiniesOrderBy"]:SkupiniesOrderBy;
	/** A condition to be used against `Skupiny` object types. All fields are tested for equality and combined with a logical and. */
["SkupinyCondition"]: {
	/** Checks for equality with the objects `sId` field. */
	sId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `sName` field. */
	sName?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `sDescription` field. */
	sDescription?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `sColorRgb` field. */
	sColorRgb?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `sColorText` field. */
	sColorText?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `sLocation` field. */
	sLocation?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `sVisible` field. */
	sVisible?: boolean | undefined | null | Variable<any, string>
};
	/** A connection to a list of `UsersSkupiny` values. */
["UsersSkupiniesConnection"]: AliasType<{
	/** A list of `UsersSkupiny` objects. */
	nodes?:ValueTypes["UsersSkupiny"],
	/** A list of edges which contains the `UsersSkupiny` and cursor to aid in pagination. */
	edges?:ValueTypes["UsersSkupiniesEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ValueTypes["PageInfo"],
	/** The count of *all* `UsersSkupiny` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["UsersSkupiny"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	usId?:boolean | `@${string}`,
	usColor?:boolean | `@${string}`,
	usPlatbaMesic?:boolean | `@${string}`,
	usPlatbaCtvrtrok?:boolean | `@${string}`,
	usPlatbaPulrok?:boolean | `@${string}`,
	usPopis?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `UsersSkupiny` edge in the connection. */
["UsersSkupiniesEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `UsersSkupiny` at the end of the edge. */
	node?:ValueTypes["UsersSkupiny"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `UsersSkupiny`. */
["UsersSkupiniesOrderBy"]:UsersSkupiniesOrderBy;
	/** A condition to be used against `UsersSkupiny` object types. All fields are
tested for equality and combined with a logical and. */
["UsersSkupinyCondition"]: {
	/** Checks for equality with the objects `usId` field. */
	usId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `usColor` field. */
	usColor?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `usPlatbaMesic` field. */
	usPlatbaMesic?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `usPlatbaCtvrtrok` field. */
	usPlatbaCtvrtrok?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `usPlatbaPulrok` field. */
	usPlatbaPulrok?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `usPopis` field. */
	usPopis?: string | undefined | null | Variable<any, string>
};
	/** A connection to a list of `Video` values. */
["VideosConnection"]: AliasType<{
	/** A list of `Video` objects. */
	nodes?:ValueTypes["Video"],
	/** A list of edges which contains the `Video` and cursor to aid in pagination. */
	edges?:ValueTypes["VideosEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ValueTypes["PageInfo"],
	/** The count of *all* `Video` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["Video"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	vId?:boolean | `@${string}`,
	vUri?:boolean | `@${string}`,
	vTitle?:boolean | `@${string}`,
	vAuthor?:boolean | `@${string}`,
	vDescription?:boolean | `@${string}`,
	vPlaylist?:boolean | `@${string}`,
	vCreatedAt?:boolean | `@${string}`,
	vUpdatedAt?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `Video` edge in the connection. */
["VideosEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `Video` at the end of the edge. */
	node?:ValueTypes["Video"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `Video`. */
["VideosOrderBy"]:VideosOrderBy;
	/** A condition to be used against `Video` object types. All fields are tested for equality and combined with a logical and. */
["VideoCondition"]: {
	/** Checks for equality with the objects `vId` field. */
	vId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `vUri` field. */
	vUri?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `vTitle` field. */
	vTitle?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `vAuthor` field. */
	vAuthor?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `vDescription` field. */
	vDescription?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `vPlaylist` field. */
	vPlaylist?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `vCreatedAt` field. */
	vCreatedAt?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `vUpdatedAt` field. */
	vUpdatedAt?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	/** A connection to a list of `VideoList` values. */
["VideoListsConnection"]: AliasType<{
	/** A list of `VideoList` objects. */
	nodes?:ValueTypes["VideoList"],
	/** A list of edges which contains the `VideoList` and cursor to aid in pagination. */
	edges?:ValueTypes["VideoListsEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ValueTypes["PageInfo"],
	/** The count of *all* `VideoList` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["VideoList"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	vlId?:boolean | `@${string}`,
	vlUrl?:boolean | `@${string}`,
	vlTitle?:boolean | `@${string}`,
	vlDescription?:boolean | `@${string}`,
	vlCount?:boolean | `@${string}`,
	vlCreatedAt?:boolean | `@${string}`,
	vlLastChecked?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `VideoList` edge in the connection. */
["VideoListsEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `VideoList` at the end of the edge. */
	node?:ValueTypes["VideoList"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `VideoList`. */
["VideoListsOrderBy"]:VideoListsOrderBy;
	/** A condition to be used against `VideoList` object types. All fields are tested
for equality and combined with a logical and. */
["VideoListCondition"]: {
	/** Checks for equality with the objects `vlId` field. */
	vlId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `vlUrl` field. */
	vlUrl?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `vlTitle` field. */
	vlTitle?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `vlDescription` field. */
	vlDescription?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `vlCount` field. */
	vlCount?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `vlCreatedAt` field. */
	vlCreatedAt?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `vlLastChecked` field. */
	vlLastChecked?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	/** A connection to a list of `VideoSource` values. */
["VideoSourcesConnection"]: AliasType<{
	/** A list of `VideoSource` objects. */
	nodes?:ValueTypes["VideoSource"],
	/** A list of edges which contains the `VideoSource` and cursor to aid in pagination. */
	edges?:ValueTypes["VideoSourcesEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ValueTypes["PageInfo"],
	/** The count of *all* `VideoSource` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["VideoSource"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	vsId?:boolean | `@${string}`,
	vsUrl?:boolean | `@${string}`,
	vsTitle?:boolean | `@${string}`,
	vsDescription?:boolean | `@${string}`,
	vsCreatedAt?:boolean | `@${string}`,
	vsLastChecked?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `VideoSource` edge in the connection. */
["VideoSourcesEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `VideoSource` at the end of the edge. */
	node?:ValueTypes["VideoSource"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `VideoSource`. */
["VideoSourcesOrderBy"]:VideoSourcesOrderBy;
	/** A condition to be used against `VideoSource` object types. All fields are tested
for equality and combined with a logical and. */
["VideoSourceCondition"]: {
	/** Checks for equality with the objects `vsId` field. */
	vsId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `vsUrl` field. */
	vsUrl?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `vsTitle` field. */
	vsTitle?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `vsDescription` field. */
	vsDescription?: string | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `vsCreatedAt` field. */
	vsCreatedAt?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	/** Checks for equality with the objects `vsLastChecked` field. */
	vsLastChecked?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	/** A connection to a list of `ActiveProspectsRecord` values. */
["ActiveProspectsConnection"]: AliasType<{
	/** A list of `ActiveProspectsRecord` objects. */
	nodes?:ValueTypes["ActiveProspectsRecord"],
	/** A list of edges which contains the `ActiveProspectsRecord` and cursor to aid in pagination. */
	edges?:ValueTypes["ActiveProspectEdge"],
	/** The count of *all* `ActiveProspectsRecord` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** The return type of our `activeProspects` query. */
["ActiveProspectsRecord"]: AliasType<{
	id?:boolean | `@${string}`,
	data?:ValueTypes["ProspectDatum"],
	cohort?:boolean | `@${string}`,
	updatedAt?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["ProspectDatum"]: AliasType<{
	name?:boolean | `@${string}`,
	surname?:boolean | `@${string}`,
	email?:boolean | `@${string}`,
	phone?:boolean | `@${string}`,
	yearofbirth?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["CrmCohort"]:CrmCohort;
	/** A `ActiveProspectsRecord` edge in the connection. */
["ActiveProspectEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `ActiveProspectsRecord` at the end of the edge. */
	node?:ValueTypes["ActiveProspectsRecord"],
		__typename?: boolean | `@${string}`
}>;
	/** A connection to a list of `BigInt` values. */
["CurrentCoupleIdsConnection"]: AliasType<{
	/** A list of `BigInt` objects. */
	nodes?:boolean | `@${string}`,
	/** A list of edges which contains the `BigInt` and cursor to aid in pagination. */
	edges?:ValueTypes["CurrentCoupleIdEdge"],
	/** The count of *all* `BigInt` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `BigInt` edge in the connection. */
["CurrentCoupleIdEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `BigInt` at the end of the edge. */
	node?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** The root mutation type which contains root level fields which mutate data. */
["Mutation"]: AliasType<{
createAkce?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["CreateAkceInput"] | Variable<any, string>},ValueTypes["CreateAkcePayload"]],
createAkceItem?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["CreateAkceItemInput"] | Variable<any, string>},ValueTypes["CreateAkceItemPayload"]],
createAktuality?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["CreateAktualityInput"] | Variable<any, string>},ValueTypes["CreateAktualityPayload"]],
createDokumenty?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["CreateDokumentyInput"] | Variable<any, string>},ValueTypes["CreateDokumentyPayload"]],
createGalerieDir?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["CreateGalerieDirInput"] | Variable<any, string>},ValueTypes["CreateGalerieDirPayload"]],
createGalerieFoto?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["CreateGalerieFotoInput"] | Variable<any, string>},ValueTypes["CreateGalerieFotoPayload"]],
createNabidka?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["CreateNabidkaInput"] | Variable<any, string>},ValueTypes["CreateNabidkaPayload"]],
createNabidkaItem?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["CreateNabidkaItemInput"] | Variable<any, string>},ValueTypes["CreateNabidkaItemPayload"]],
createPage?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["CreatePageInput"] | Variable<any, string>},ValueTypes["CreatePagePayload"]],
createParameter?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["CreateParameterInput"] | Variable<any, string>},ValueTypes["CreateParameterPayload"]],
createPary?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["CreateParyInput"] | Variable<any, string>},ValueTypes["CreateParyPayload"]],
createParyNavrh?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["CreateParyNavrhInput"] | Variable<any, string>},ValueTypes["CreateParyNavrhPayload"]],
createPermission?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["CreatePermissionInput"] | Variable<any, string>},ValueTypes["CreatePermissionPayload"]],
createPlatbyCategory?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["CreatePlatbyCategoryInput"] | Variable<any, string>},ValueTypes["CreatePlatbyCategoryPayload"]],
createPlatbyCategoryGroup?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["CreatePlatbyCategoryGroupInput"] | Variable<any, string>},ValueTypes["CreatePlatbyCategoryGroupPayload"]],
createPlatbyGroup?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["CreatePlatbyGroupInput"] | Variable<any, string>},ValueTypes["CreatePlatbyGroupPayload"]],
createPlatbyGroupSkupina?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["CreatePlatbyGroupSkupinaInput"] | Variable<any, string>},ValueTypes["CreatePlatbyGroupSkupinaPayload"]],
createPlatbyItem?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["CreatePlatbyItemInput"] | Variable<any, string>},ValueTypes["CreatePlatbyItemPayload"]],
createPlatbyRaw?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["CreatePlatbyRawInput"] | Variable<any, string>},ValueTypes["CreatePlatbyRawPayload"]],
createRozpi?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["CreateRozpiInput"] | Variable<any, string>},ValueTypes["CreateRozpiPayload"]],
createRozpisItem?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["CreateRozpisItemInput"] | Variable<any, string>},ValueTypes["CreateRozpisItemPayload"]],
createSession?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["CreateSessionInput"] | Variable<any, string>},ValueTypes["CreateSessionPayload"]],
createSkupiny?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["CreateSkupinyInput"] | Variable<any, string>},ValueTypes["CreateSkupinyPayload"]],
createUpozorneni?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["CreateUpozorneniInput"] | Variable<any, string>},ValueTypes["CreateUpozorneniPayload"]],
createUpozorneniSkupiny?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["CreateUpozorneniSkupinyInput"] | Variable<any, string>},ValueTypes["CreateUpozorneniSkupinyPayload"]],
createUser?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["CreateUserInput"] | Variable<any, string>},ValueTypes["CreateUserPayload"]],
createUsersSkupiny?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["CreateUsersSkupinyInput"] | Variable<any, string>},ValueTypes["CreateUsersSkupinyPayload"]],
createVideo?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["CreateVideoInput"] | Variable<any, string>},ValueTypes["CreateVideoPayload"]],
createVideoList?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["CreateVideoListInput"] | Variable<any, string>},ValueTypes["CreateVideoListPayload"]],
createVideoSource?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["CreateVideoSourceInput"] | Variable<any, string>},ValueTypes["CreateVideoSourcePayload"]],
updateAkceByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateAkceByNodeIdInput"] | Variable<any, string>},ValueTypes["UpdateAkcePayload"]],
updateAkce?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateAkceInput"] | Variable<any, string>},ValueTypes["UpdateAkcePayload"]],
updateAkceItemByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateAkceItemByNodeIdInput"] | Variable<any, string>},ValueTypes["UpdateAkceItemPayload"]],
updateAkceItem?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateAkceItemInput"] | Variable<any, string>},ValueTypes["UpdateAkceItemPayload"]],
updateAktualityByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateAktualityByNodeIdInput"] | Variable<any, string>},ValueTypes["UpdateAktualityPayload"]],
updateAktuality?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateAktualityInput"] | Variable<any, string>},ValueTypes["UpdateAktualityPayload"]],
updateDokumentyByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateDokumentyByNodeIdInput"] | Variable<any, string>},ValueTypes["UpdateDokumentyPayload"]],
updateDokumenty?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateDokumentyInput"] | Variable<any, string>},ValueTypes["UpdateDokumentyPayload"]],
updateGalerieDirByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateGalerieDirByNodeIdInput"] | Variable<any, string>},ValueTypes["UpdateGalerieDirPayload"]],
updateGalerieDir?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateGalerieDirInput"] | Variable<any, string>},ValueTypes["UpdateGalerieDirPayload"]],
updateGalerieFotoByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateGalerieFotoByNodeIdInput"] | Variable<any, string>},ValueTypes["UpdateGalerieFotoPayload"]],
updateGalerieFoto?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateGalerieFotoInput"] | Variable<any, string>},ValueTypes["UpdateGalerieFotoPayload"]],
updateNabidkaByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateNabidkaByNodeIdInput"] | Variable<any, string>},ValueTypes["UpdateNabidkaPayload"]],
updateNabidka?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateNabidkaInput"] | Variable<any, string>},ValueTypes["UpdateNabidkaPayload"]],
updateNabidkaItemByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateNabidkaItemByNodeIdInput"] | Variable<any, string>},ValueTypes["UpdateNabidkaItemPayload"]],
updateNabidkaItem?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateNabidkaItemInput"] | Variable<any, string>},ValueTypes["UpdateNabidkaItemPayload"]],
updatePageByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdatePageByNodeIdInput"] | Variable<any, string>},ValueTypes["UpdatePagePayload"]],
updatePage?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdatePageInput"] | Variable<any, string>},ValueTypes["UpdatePagePayload"]],
updatePageByUrl?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdatePageByUrlInput"] | Variable<any, string>},ValueTypes["UpdatePagePayload"]],
updateParameterByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateParameterByNodeIdInput"] | Variable<any, string>},ValueTypes["UpdateParameterPayload"]],
updateParameter?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateParameterInput"] | Variable<any, string>},ValueTypes["UpdateParameterPayload"]],
updateParyByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateParyByNodeIdInput"] | Variable<any, string>},ValueTypes["UpdateParyPayload"]],
updatePary?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateParyInput"] | Variable<any, string>},ValueTypes["UpdateParyPayload"]],
updateParyNavrhByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateParyNavrhByNodeIdInput"] | Variable<any, string>},ValueTypes["UpdateParyNavrhPayload"]],
updateParyNavrh?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateParyNavrhInput"] | Variable<any, string>},ValueTypes["UpdateParyNavrhPayload"]],
updatePermissionByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdatePermissionByNodeIdInput"] | Variable<any, string>},ValueTypes["UpdatePermissionPayload"]],
updatePermission?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdatePermissionInput"] | Variable<any, string>},ValueTypes["UpdatePermissionPayload"]],
updatePlatbyCategoryByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdatePlatbyCategoryByNodeIdInput"] | Variable<any, string>},ValueTypes["UpdatePlatbyCategoryPayload"]],
updatePlatbyCategory?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdatePlatbyCategoryInput"] | Variable<any, string>},ValueTypes["UpdatePlatbyCategoryPayload"]],
updatePlatbyCategoryGroupByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdatePlatbyCategoryGroupByNodeIdInput"] | Variable<any, string>},ValueTypes["UpdatePlatbyCategoryGroupPayload"]],
updatePlatbyCategoryGroup?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdatePlatbyCategoryGroupInput"] | Variable<any, string>},ValueTypes["UpdatePlatbyCategoryGroupPayload"]],
updatePlatbyGroupByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdatePlatbyGroupByNodeIdInput"] | Variable<any, string>},ValueTypes["UpdatePlatbyGroupPayload"]],
updatePlatbyGroup?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdatePlatbyGroupInput"] | Variable<any, string>},ValueTypes["UpdatePlatbyGroupPayload"]],
updatePlatbyGroupSkupinaByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdatePlatbyGroupSkupinaByNodeIdInput"] | Variable<any, string>},ValueTypes["UpdatePlatbyGroupSkupinaPayload"]],
updatePlatbyGroupSkupina?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdatePlatbyGroupSkupinaInput"] | Variable<any, string>},ValueTypes["UpdatePlatbyGroupSkupinaPayload"]],
updatePlatbyItemByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdatePlatbyItemByNodeIdInput"] | Variable<any, string>},ValueTypes["UpdatePlatbyItemPayload"]],
updatePlatbyItem?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdatePlatbyItemInput"] | Variable<any, string>},ValueTypes["UpdatePlatbyItemPayload"]],
updatePlatbyRawByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdatePlatbyRawByNodeIdInput"] | Variable<any, string>},ValueTypes["UpdatePlatbyRawPayload"]],
updatePlatbyRaw?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdatePlatbyRawInput"] | Variable<any, string>},ValueTypes["UpdatePlatbyRawPayload"]],
updateRozpiByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateRozpiByNodeIdInput"] | Variable<any, string>},ValueTypes["UpdateRozpiPayload"]],
updateRozpi?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateRozpiInput"] | Variable<any, string>},ValueTypes["UpdateRozpiPayload"]],
updateRozpisItemByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateRozpisItemByNodeIdInput"] | Variable<any, string>},ValueTypes["UpdateRozpisItemPayload"]],
updateRozpisItem?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateRozpisItemInput"] | Variable<any, string>},ValueTypes["UpdateRozpisItemPayload"]],
updateSessionByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateSessionByNodeIdInput"] | Variable<any, string>},ValueTypes["UpdateSessionPayload"]],
updateSession?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateSessionInput"] | Variable<any, string>},ValueTypes["UpdateSessionPayload"]],
updateSkupinyByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateSkupinyByNodeIdInput"] | Variable<any, string>},ValueTypes["UpdateSkupinyPayload"]],
updateSkupiny?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateSkupinyInput"] | Variable<any, string>},ValueTypes["UpdateSkupinyPayload"]],
updateUpozorneniByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateUpozorneniByNodeIdInput"] | Variable<any, string>},ValueTypes["UpdateUpozorneniPayload"]],
updateUpozorneni?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateUpozorneniInput"] | Variable<any, string>},ValueTypes["UpdateUpozorneniPayload"]],
updateUpozorneniSkupinyByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateUpozorneniSkupinyByNodeIdInput"] | Variable<any, string>},ValueTypes["UpdateUpozorneniSkupinyPayload"]],
updateUpozorneniSkupiny?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateUpozorneniSkupinyInput"] | Variable<any, string>},ValueTypes["UpdateUpozorneniSkupinyPayload"]],
updateUserByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateUserByNodeIdInput"] | Variable<any, string>},ValueTypes["UpdateUserPayload"]],
updateUser?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateUserInput"] | Variable<any, string>},ValueTypes["UpdateUserPayload"]],
updateUsersSkupinyByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateUsersSkupinyByNodeIdInput"] | Variable<any, string>},ValueTypes["UpdateUsersSkupinyPayload"]],
updateUsersSkupiny?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateUsersSkupinyInput"] | Variable<any, string>},ValueTypes["UpdateUsersSkupinyPayload"]],
updateVideoByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateVideoByNodeIdInput"] | Variable<any, string>},ValueTypes["UpdateVideoPayload"]],
updateVideo?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateVideoInput"] | Variable<any, string>},ValueTypes["UpdateVideoPayload"]],
updateVideoListByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateVideoListByNodeIdInput"] | Variable<any, string>},ValueTypes["UpdateVideoListPayload"]],
updateVideoList?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateVideoListInput"] | Variable<any, string>},ValueTypes["UpdateVideoListPayload"]],
updateVideoSourceByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateVideoSourceByNodeIdInput"] | Variable<any, string>},ValueTypes["UpdateVideoSourcePayload"]],
updateVideoSource?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UpdateVideoSourceInput"] | Variable<any, string>},ValueTypes["UpdateVideoSourcePayload"]],
deleteAkceByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteAkceByNodeIdInput"] | Variable<any, string>},ValueTypes["DeleteAkcePayload"]],
deleteAkce?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteAkceInput"] | Variable<any, string>},ValueTypes["DeleteAkcePayload"]],
deleteAkceItemByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteAkceItemByNodeIdInput"] | Variable<any, string>},ValueTypes["DeleteAkceItemPayload"]],
deleteAkceItem?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteAkceItemInput"] | Variable<any, string>},ValueTypes["DeleteAkceItemPayload"]],
deleteAktualityByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteAktualityByNodeIdInput"] | Variable<any, string>},ValueTypes["DeleteAktualityPayload"]],
deleteAktuality?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteAktualityInput"] | Variable<any, string>},ValueTypes["DeleteAktualityPayload"]],
deleteDokumentyByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteDokumentyByNodeIdInput"] | Variable<any, string>},ValueTypes["DeleteDokumentyPayload"]],
deleteDokumenty?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteDokumentyInput"] | Variable<any, string>},ValueTypes["DeleteDokumentyPayload"]],
deleteGalerieDirByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteGalerieDirByNodeIdInput"] | Variable<any, string>},ValueTypes["DeleteGalerieDirPayload"]],
deleteGalerieDir?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteGalerieDirInput"] | Variable<any, string>},ValueTypes["DeleteGalerieDirPayload"]],
deleteGalerieFotoByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteGalerieFotoByNodeIdInput"] | Variable<any, string>},ValueTypes["DeleteGalerieFotoPayload"]],
deleteGalerieFoto?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteGalerieFotoInput"] | Variable<any, string>},ValueTypes["DeleteGalerieFotoPayload"]],
deleteNabidkaByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteNabidkaByNodeIdInput"] | Variable<any, string>},ValueTypes["DeleteNabidkaPayload"]],
deleteNabidka?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteNabidkaInput"] | Variable<any, string>},ValueTypes["DeleteNabidkaPayload"]],
deleteNabidkaItemByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteNabidkaItemByNodeIdInput"] | Variable<any, string>},ValueTypes["DeleteNabidkaItemPayload"]],
deleteNabidkaItem?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteNabidkaItemInput"] | Variable<any, string>},ValueTypes["DeleteNabidkaItemPayload"]],
deleteParameterByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteParameterByNodeIdInput"] | Variable<any, string>},ValueTypes["DeleteParameterPayload"]],
deleteParameter?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteParameterInput"] | Variable<any, string>},ValueTypes["DeleteParameterPayload"]],
deleteParyByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteParyByNodeIdInput"] | Variable<any, string>},ValueTypes["DeleteParyPayload"]],
deletePary?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteParyInput"] | Variable<any, string>},ValueTypes["DeleteParyPayload"]],
deleteParyNavrhByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteParyNavrhByNodeIdInput"] | Variable<any, string>},ValueTypes["DeleteParyNavrhPayload"]],
deleteParyNavrh?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteParyNavrhInput"] | Variable<any, string>},ValueTypes["DeleteParyNavrhPayload"]],
deletePermissionByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeletePermissionByNodeIdInput"] | Variable<any, string>},ValueTypes["DeletePermissionPayload"]],
deletePermission?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeletePermissionInput"] | Variable<any, string>},ValueTypes["DeletePermissionPayload"]],
deletePlatbyCategoryByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeletePlatbyCategoryByNodeIdInput"] | Variable<any, string>},ValueTypes["DeletePlatbyCategoryPayload"]],
deletePlatbyCategory?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeletePlatbyCategoryInput"] | Variable<any, string>},ValueTypes["DeletePlatbyCategoryPayload"]],
deletePlatbyCategoryGroupByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeletePlatbyCategoryGroupByNodeIdInput"] | Variable<any, string>},ValueTypes["DeletePlatbyCategoryGroupPayload"]],
deletePlatbyCategoryGroup?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeletePlatbyCategoryGroupInput"] | Variable<any, string>},ValueTypes["DeletePlatbyCategoryGroupPayload"]],
deletePlatbyGroupByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeletePlatbyGroupByNodeIdInput"] | Variable<any, string>},ValueTypes["DeletePlatbyGroupPayload"]],
deletePlatbyGroup?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeletePlatbyGroupInput"] | Variable<any, string>},ValueTypes["DeletePlatbyGroupPayload"]],
deletePlatbyGroupSkupinaByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeletePlatbyGroupSkupinaByNodeIdInput"] | Variable<any, string>},ValueTypes["DeletePlatbyGroupSkupinaPayload"]],
deletePlatbyGroupSkupina?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeletePlatbyGroupSkupinaInput"] | Variable<any, string>},ValueTypes["DeletePlatbyGroupSkupinaPayload"]],
deletePlatbyItemByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeletePlatbyItemByNodeIdInput"] | Variable<any, string>},ValueTypes["DeletePlatbyItemPayload"]],
deletePlatbyItem?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeletePlatbyItemInput"] | Variable<any, string>},ValueTypes["DeletePlatbyItemPayload"]],
deletePlatbyRawByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeletePlatbyRawByNodeIdInput"] | Variable<any, string>},ValueTypes["DeletePlatbyRawPayload"]],
deletePlatbyRaw?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeletePlatbyRawInput"] | Variable<any, string>},ValueTypes["DeletePlatbyRawPayload"]],
deleteRozpiByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteRozpiByNodeIdInput"] | Variable<any, string>},ValueTypes["DeleteRozpiPayload"]],
deleteRozpi?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteRozpiInput"] | Variable<any, string>},ValueTypes["DeleteRozpiPayload"]],
deleteRozpisItemByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteRozpisItemByNodeIdInput"] | Variable<any, string>},ValueTypes["DeleteRozpisItemPayload"]],
deleteRozpisItem?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteRozpisItemInput"] | Variable<any, string>},ValueTypes["DeleteRozpisItemPayload"]],
deleteSessionByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteSessionByNodeIdInput"] | Variable<any, string>},ValueTypes["DeleteSessionPayload"]],
deleteSession?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteSessionInput"] | Variable<any, string>},ValueTypes["DeleteSessionPayload"]],
deleteSkupinyByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteSkupinyByNodeIdInput"] | Variable<any, string>},ValueTypes["DeleteSkupinyPayload"]],
deleteSkupiny?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteSkupinyInput"] | Variable<any, string>},ValueTypes["DeleteSkupinyPayload"]],
deleteUpozorneniByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteUpozorneniByNodeIdInput"] | Variable<any, string>},ValueTypes["DeleteUpozorneniPayload"]],
deleteUpozorneni?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteUpozorneniInput"] | Variable<any, string>},ValueTypes["DeleteUpozorneniPayload"]],
deleteUpozorneniSkupinyByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteUpozorneniSkupinyByNodeIdInput"] | Variable<any, string>},ValueTypes["DeleteUpozorneniSkupinyPayload"]],
deleteUpozorneniSkupiny?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteUpozorneniSkupinyInput"] | Variable<any, string>},ValueTypes["DeleteUpozorneniSkupinyPayload"]],
deleteUserByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteUserByNodeIdInput"] | Variable<any, string>},ValueTypes["DeleteUserPayload"]],
deleteUser?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteUserInput"] | Variable<any, string>},ValueTypes["DeleteUserPayload"]],
deleteUsersSkupinyByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteUsersSkupinyByNodeIdInput"] | Variable<any, string>},ValueTypes["DeleteUsersSkupinyPayload"]],
deleteUsersSkupiny?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteUsersSkupinyInput"] | Variable<any, string>},ValueTypes["DeleteUsersSkupinyPayload"]],
deleteVideoByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteVideoByNodeIdInput"] | Variable<any, string>},ValueTypes["DeleteVideoPayload"]],
deleteVideo?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteVideoInput"] | Variable<any, string>},ValueTypes["DeleteVideoPayload"]],
deleteVideoListByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteVideoListByNodeIdInput"] | Variable<any, string>},ValueTypes["DeleteVideoListPayload"]],
deleteVideoList?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteVideoListInput"] | Variable<any, string>},ValueTypes["DeleteVideoListPayload"]],
deleteVideoSourceByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteVideoSourceByNodeIdInput"] | Variable<any, string>},ValueTypes["DeleteVideoSourcePayload"]],
deleteVideoSource?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["DeleteVideoSourceInput"] | Variable<any, string>},ValueTypes["DeleteVideoSourcePayload"]],
login?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["LoginInput"] | Variable<any, string>},ValueTypes["LoginPayload"]],
logout?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["LogoutInput"] | Variable<any, string>},ValueTypes["LogoutPayload"]],
prospectFormDancer?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["ProspectFormDancerInput"] | Variable<any, string>},ValueTypes["ProspectFormDancerPayload"]],
uploadFile?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ValueTypes["UploadInput"] | Variable<any, string>},ValueTypes["Upload"]],
		__typename?: boolean | `@${string}`
}>;
	/** The output of our create `Akce` mutation. */
["CreateAkcePayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Akce` that was created by this mutation. */
	akce?:ValueTypes["Akce"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
akceEdge?: [{	/** The method to use when ordering `Akce`. */
	orderBy?: Array<ValueTypes["AkcesOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["AkcesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `Akce` mutation. */
["CreateAkceInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The `Akce` to be created by this mutation. */
	akce: ValueTypes["AkceInput"] | Variable<any, string>
};
	/** An input for mutations affecting `Akce` */
["AkceInput"]: {
	aId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	aJmeno: string | Variable<any, string>,
	aKde: string | Variable<any, string>,
	aInfo: string | Variable<any, string>,
	aOd: ValueTypes["Date"] | Variable<any, string>,
	aDo: ValueTypes["Date"] | Variable<any, string>,
	aKapacita?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	aDokumenty: string | Variable<any, string>,
	aTimestamp?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	aLock?: boolean | undefined | null | Variable<any, string>,
	aVisible?: boolean | undefined | null | Variable<any, string>
};
	/** The output of our create `AkceItem` mutation. */
["CreateAkceItemPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `AkceItem` that was created by this mutation. */
	akceItem?:ValueTypes["AkceItem"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `Akce` that is related to this `AkceItem`. */
	akceByAiIdRodic?:ValueTypes["Akce"],
	/** Reads a single `User` that is related to this `AkceItem`. */
	userByAiUser?:ValueTypes["User"],
akceItemEdge?: [{	/** The method to use when ordering `AkceItem`. */
	orderBy?: Array<ValueTypes["AkceItemsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["AkceItemsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `AkceItem` mutation. */
["CreateAkceItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The `AkceItem` to be created by this mutation. */
	akceItem: ValueTypes["AkceItemInput"] | Variable<any, string>
};
	/** An input for mutations affecting `AkceItem` */
["AkceItemInput"]: {
	aiId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	aiIdRodic: ValueTypes["BigInt"] | Variable<any, string>,
	aiUser: ValueTypes["BigInt"] | Variable<any, string>,
	aiRokNarozeni: number | Variable<any, string>
};
	/** The output of our create `Aktuality` mutation. */
["CreateAktualityPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Aktuality` that was created by this mutation. */
	aktuality?:ValueTypes["Aktuality"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `User` that is related to this `Aktuality`. */
	userByAtKdo?:ValueTypes["User"],
	/** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
	galerieFotoByAtFotoMain?:ValueTypes["GalerieFoto"],
aktualityEdge?: [{	/** The method to use when ordering `Aktuality`. */
	orderBy?: Array<ValueTypes["AktualitiesOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["AktualitiesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `Aktuality` mutation. */
["CreateAktualityInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The `Aktuality` to be created by this mutation. */
	aktuality: ValueTypes["AktualityInput"] | Variable<any, string>
};
	/** An input for mutations affecting `Aktuality` */
["AktualityInput"]: {
	atId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	atKdo: ValueTypes["BigInt"] | Variable<any, string>,
	atKat: string | Variable<any, string>,
	atJmeno: string | Variable<any, string>,
	atText: string | Variable<any, string>,
	atPreview: string | Variable<any, string>,
	atFoto?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	atFotoMain?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	atTimestamp?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	atTimestampAdd?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	/** The output of our create `Dokumenty` mutation. */
["CreateDokumentyPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Dokumenty` that was created by this mutation. */
	dokumenty?:ValueTypes["Dokumenty"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `User` that is related to this `Dokumenty`. */
	userByDKdo?:ValueTypes["User"],
dokumentyEdge?: [{	/** The method to use when ordering `Dokumenty`. */
	orderBy?: Array<ValueTypes["DokumentiesOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["DokumentiesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `Dokumenty` mutation. */
["CreateDokumentyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The `Dokumenty` to be created by this mutation. */
	dokumenty: ValueTypes["DokumentyInput"] | Variable<any, string>
};
	/** An input for mutations affecting `Dokumenty` */
["DokumentyInput"]: {
	dId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	dPath: string | Variable<any, string>,
	dName: string | Variable<any, string>,
	dFilename: string | Variable<any, string>,
	dKategorie: number | Variable<any, string>,
	dKdo: ValueTypes["BigInt"] | Variable<any, string>,
	dTimestamp?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	/** The output of our create `GalerieDir` mutation. */
["CreateGalerieDirPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `GalerieDir` that was created by this mutation. */
	galerieDir?:ValueTypes["GalerieDir"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
galerieDirEdge?: [{	/** The method to use when ordering `GalerieDir`. */
	orderBy?: Array<ValueTypes["GalerieDirsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["GalerieDirsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `GalerieDir` mutation. */
["CreateGalerieDirInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The `GalerieDir` to be created by this mutation. */
	galerieDir: ValueTypes["GalerieDirInput"] | Variable<any, string>
};
	/** An input for mutations affecting `GalerieDir` */
["GalerieDirInput"]: {
	gdId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	gdIdRodic: ValueTypes["BigInt"] | Variable<any, string>,
	gdName: string | Variable<any, string>,
	gdLevel?: number | undefined | null | Variable<any, string>,
	gdPath: string | Variable<any, string>,
	gdHidden?: boolean | undefined | null | Variable<any, string>
};
	/** The output of our create `GalerieFoto` mutation. */
["CreateGalerieFotoPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `GalerieFoto` that was created by this mutation. */
	galerieFoto?:ValueTypes["GalerieFoto"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
	galerieDirByGfIdRodic?:ValueTypes["GalerieDir"],
	/** Reads a single `User` that is related to this `GalerieFoto`. */
	userByGfKdo?:ValueTypes["User"],
galerieFotoEdge?: [{	/** The method to use when ordering `GalerieFoto`. */
	orderBy?: Array<ValueTypes["GalerieFotosOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["GalerieFotosEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `GalerieFoto` mutation. */
["CreateGalerieFotoInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The `GalerieFoto` to be created by this mutation. */
	galerieFoto: ValueTypes["GalerieFotoInput"] | Variable<any, string>
};
	/** An input for mutations affecting `GalerieFoto` */
["GalerieFotoInput"]: {
	gfId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	gfIdRodic: ValueTypes["BigInt"] | Variable<any, string>,
	gfName: string | Variable<any, string>,
	gfPath: string | Variable<any, string>,
	gfKdo: ValueTypes["BigInt"] | Variable<any, string>,
	gfTimestamp?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	/** The output of our create `Nabidka` mutation. */
["CreateNabidkaPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Nabidka` that was created by this mutation. */
	nabidka?:ValueTypes["Nabidka"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `User` that is related to this `Nabidka`. */
	userByNTrener?:ValueTypes["User"],
nabidkaEdge?: [{	/** The method to use when ordering `Nabidka`. */
	orderBy?: Array<ValueTypes["NabidkasOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["NabidkasEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `Nabidka` mutation. */
["CreateNabidkaInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The `Nabidka` to be created by this mutation. */
	nabidka: ValueTypes["NabidkaInput"] | Variable<any, string>
};
	/** An input for mutations affecting `Nabidka` */
["NabidkaInput"]: {
	nId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	nTrener: ValueTypes["BigInt"] | Variable<any, string>,
	nPocetHod?: number | undefined | null | Variable<any, string>,
	nMaxPocetHod?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	nOd: ValueTypes["Date"] | Variable<any, string>,
	nDo: ValueTypes["Date"] | Variable<any, string>,
	nVisible?: boolean | undefined | null | Variable<any, string>,
	nLock?: boolean | undefined | null | Variable<any, string>,
	nTimestamp?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	/** The output of our create `NabidkaItem` mutation. */
["CreateNabidkaItemPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `NabidkaItem` that was created by this mutation. */
	nabidkaItem?:ValueTypes["NabidkaItem"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `Nabidka` that is related to this `NabidkaItem`. */
	nabidkaByNiIdRodic?:ValueTypes["Nabidka"],
	/** Reads a single `Pary` that is related to this `NabidkaItem`. */
	paryByNiPartner?:ValueTypes["Pary"],
nabidkaItemEdge?: [{	/** The method to use when ordering `NabidkaItem`. */
	orderBy?: Array<ValueTypes["NabidkaItemsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["NabidkaItemsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `NabidkaItem` mutation. */
["CreateNabidkaItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The `NabidkaItem` to be created by this mutation. */
	nabidkaItem: ValueTypes["NabidkaItemInput"] | Variable<any, string>
};
	/** An input for mutations affecting `NabidkaItem` */
["NabidkaItemInput"]: {
	niId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	niIdRodic: ValueTypes["BigInt"] | Variable<any, string>,
	niPartner: ValueTypes["BigInt"] | Variable<any, string>,
	niPocetHod?: number | undefined | null | Variable<any, string>,
	niLock?: boolean | undefined | null | Variable<any, string>
};
	/** The output of our create `Page` mutation. */
["CreatePagePayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Page` that was created by this mutation. */
	page?:ValueTypes["Page"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
pageEdge?: [{	/** The method to use when ordering `Page`. */
	orderBy?: Array<ValueTypes["PagesOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["PagesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `Page` mutation. */
["CreatePageInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The `Page` to be created by this mutation. */
	page: ValueTypes["PageInput"] | Variable<any, string>
};
	/** An input for mutations affecting `Page` */
["PageInput"]: {
	id?: number | undefined | null | Variable<any, string>,
	url: string | Variable<any, string>,
	content: ValueTypes["JSON"] | Variable<any, string>,
	createdAt?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	updatedAt?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	title?: string | undefined | null | Variable<any, string>
};
	/** The output of our create `Parameter` mutation. */
["CreateParameterPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Parameter` that was created by this mutation. */
	parameter?:ValueTypes["Parameter"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
parameterEdge?: [{	/** The method to use when ordering `Parameter`. */
	orderBy?: Array<ValueTypes["ParametersOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["ParametersEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `Parameter` mutation. */
["CreateParameterInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The `Parameter` to be created by this mutation. */
	parameter: ValueTypes["ParameterInput"] | Variable<any, string>
};
	/** An input for mutations affecting `Parameter` */
["ParameterInput"]: {
	paName: string | Variable<any, string>,
	paValue: string | Variable<any, string>
};
	/** The output of our create `Pary` mutation. */
["CreateParyPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Pary` that was created by this mutation. */
	pary?:ValueTypes["Pary"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `User` that is related to this `Pary`. */
	userByPIdPartner?:ValueTypes["User"],
paryEdge?: [{	/** The method to use when ordering `Pary`. */
	orderBy?: Array<ValueTypes["PariesOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["PariesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `Pary` mutation. */
["CreateParyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The `Pary` to be created by this mutation. */
	pary: ValueTypes["ParyInput"] | Variable<any, string>
};
	/** An input for mutations affecting `Pary` */
["ParyInput"]: {
	pId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	pIdPartner: ValueTypes["BigInt"] | Variable<any, string>,
	pIdPartnerka?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	pSttTrida?: ValueTypes["ParyPSttTrida"] | undefined | null | Variable<any, string>,
	pSttBody?: number | undefined | null | Variable<any, string>,
	pSttFinale?: boolean | undefined | null | Variable<any, string>,
	pLatTrida?: ValueTypes["ParyPLatTrida"] | undefined | null | Variable<any, string>,
	pLatBody?: number | undefined | null | Variable<any, string>,
	pLatFinale?: boolean | undefined | null | Variable<any, string>,
	pHodnoceni?: number | undefined | null | Variable<any, string>,
	pArchiv?: boolean | undefined | null | Variable<any, string>,
	pTimestampAdd?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	pTimestampArchive?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	/** The output of our create `ParyNavrh` mutation. */
["CreateParyNavrhPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `ParyNavrh` that was created by this mutation. */
	paryNavrh?:ValueTypes["ParyNavrh"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnNavrhl?:ValueTypes["User"],
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnPartner?:ValueTypes["User"],
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnPartnerka?:ValueTypes["User"],
paryNavrhEdge?: [{	/** The method to use when ordering `ParyNavrh`. */
	orderBy?: Array<ValueTypes["ParyNavrhsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["ParyNavrhsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `ParyNavrh` mutation. */
["CreateParyNavrhInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The `ParyNavrh` to be created by this mutation. */
	paryNavrh: ValueTypes["ParyNavrhInput"] | Variable<any, string>
};
	/** An input for mutations affecting `ParyNavrh` */
["ParyNavrhInput"]: {
	pnId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	pnNavrhl: ValueTypes["BigInt"] | Variable<any, string>,
	pnPartner: ValueTypes["BigInt"] | Variable<any, string>,
	pnPartnerka: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our create `Permission` mutation. */
["CreatePermissionPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Permission` that was created by this mutation. */
	permission?:ValueTypes["Permission"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
permissionEdge?: [{	/** The method to use when ordering `Permission`. */
	orderBy?: Array<ValueTypes["PermissionsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["PermissionsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `Permission` mutation. */
["CreatePermissionInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The `Permission` to be created by this mutation. */
	permission: ValueTypes["PermissionInput"] | Variable<any, string>
};
	/** An input for mutations affecting `Permission` */
["PermissionInput"]: {
	peId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	peName: string | Variable<any, string>,
	peDescription: string | Variable<any, string>,
	peAkce: number | Variable<any, string>,
	peAktuality: number | Variable<any, string>,
	peAnkety: number | Variable<any, string>,
	peDokumenty: number | Variable<any, string>,
	peGalerie: number | Variable<any, string>,
	peInzerce: number | Variable<any, string>,
	peKonzole: number | Variable<any, string>,
	peNabidka: number | Variable<any, string>,
	peNastenka: number | Variable<any, string>,
	peNovinky: number | Variable<any, string>,
	pePary: number | Variable<any, string>,
	pePlatby: number | Variable<any, string>,
	pePermissions: number | Variable<any, string>,
	peRozpis: number | Variable<any, string>,
	peSkupiny: number | Variable<any, string>,
	peUsers: number | Variable<any, string>,
	peMain: number | Variable<any, string>
};
	/** The output of our create `PlatbyCategory` mutation. */
["CreatePlatbyCategoryPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyCategory` that was created by this mutation. */
	platbyCategory?:ValueTypes["PlatbyCategory"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
platbyCategoryEdge?: [{	/** The method to use when ordering `PlatbyCategory`. */
	orderBy?: Array<ValueTypes["PlatbyCategoriesOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["PlatbyCategoriesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `PlatbyCategory` mutation. */
["CreatePlatbyCategoryInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The `PlatbyCategory` to be created by this mutation. */
	platbyCategory: ValueTypes["PlatbyCategoryInput"] | Variable<any, string>
};
	/** An input for mutations affecting `PlatbyCategory` */
["PlatbyCategoryInput"]: {
	pcId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	pcName: string | Variable<any, string>,
	pcSymbol: ValueTypes["BigInt"] | Variable<any, string>,
	pcAmount: ValueTypes["BigFloat"] | Variable<any, string>,
	pcDateDue: ValueTypes["Date"] | Variable<any, string>,
	pcValidFrom: ValueTypes["Date"] | Variable<any, string>,
	pcValidTo: ValueTypes["Date"] | Variable<any, string>,
	pcUseBase?: boolean | undefined | null | Variable<any, string>,
	pcUsePrefix?: boolean | undefined | null | Variable<any, string>,
	pcArchive?: boolean | undefined | null | Variable<any, string>,
	pcVisible?: boolean | undefined | null | Variable<any, string>
};
	/** The output of our create `PlatbyCategoryGroup` mutation. */
["CreatePlatbyCategoryGroupPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyCategoryGroup` that was created by this mutation. */
	platbyCategoryGroup?:ValueTypes["PlatbyCategoryGroup"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `PlatbyGroup` that is related to this `PlatbyCategoryGroup`. */
	platbyGroupByPcgIdGroup?:ValueTypes["PlatbyGroup"],
	/** Reads a single `PlatbyCategory` that is related to this `PlatbyCategoryGroup`. */
	platbyCategoryByPcgIdCategory?:ValueTypes["PlatbyCategory"],
platbyCategoryGroupEdge?: [{	/** The method to use when ordering `PlatbyCategoryGroup`. */
	orderBy?: Array<ValueTypes["PlatbyCategoryGroupsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["PlatbyCategoryGroupsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `PlatbyCategoryGroup` mutation. */
["CreatePlatbyCategoryGroupInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The `PlatbyCategoryGroup` to be created by this mutation. */
	platbyCategoryGroup: ValueTypes["PlatbyCategoryGroupInput"] | Variable<any, string>
};
	/** An input for mutations affecting `PlatbyCategoryGroup` */
["PlatbyCategoryGroupInput"]: {
	pcgId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	pcgIdGroup: ValueTypes["BigInt"] | Variable<any, string>,
	pcgIdCategory: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our create `PlatbyGroup` mutation. */
["CreatePlatbyGroupPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyGroup` that was created by this mutation. */
	platbyGroup?:ValueTypes["PlatbyGroup"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
platbyGroupEdge?: [{	/** The method to use when ordering `PlatbyGroup`. */
	orderBy?: Array<ValueTypes["PlatbyGroupsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["PlatbyGroupsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `PlatbyGroup` mutation. */
["CreatePlatbyGroupInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The `PlatbyGroup` to be created by this mutation. */
	platbyGroup: ValueTypes["PlatbyGroupInput"] | Variable<any, string>
};
	/** An input for mutations affecting `PlatbyGroup` */
["PlatbyGroupInput"]: {
	pgId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	pgType?: ValueTypes["BigFloat"] | undefined | null | Variable<any, string>,
	pgName: string | Variable<any, string>,
	pgDescription: string | Variable<any, string>,
	pgBase?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>
};
	/** The output of our create `PlatbyGroupSkupina` mutation. */
["CreatePlatbyGroupSkupinaPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyGroupSkupina` that was created by this mutation. */
	platbyGroupSkupina?:ValueTypes["PlatbyGroupSkupina"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `Skupiny` that is related to this `PlatbyGroupSkupina`. */
	skupinyByPgsIdSkupina?:ValueTypes["Skupiny"],
	/** Reads a single `PlatbyGroup` that is related to this `PlatbyGroupSkupina`. */
	platbyGroupByPgsIdGroup?:ValueTypes["PlatbyGroup"],
platbyGroupSkupinaEdge?: [{	/** The method to use when ordering `PlatbyGroupSkupina`. */
	orderBy?: Array<ValueTypes["PlatbyGroupSkupinasOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["PlatbyGroupSkupinasEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `PlatbyGroupSkupina` mutation. */
["CreatePlatbyGroupSkupinaInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The `PlatbyGroupSkupina` to be created by this mutation. */
	platbyGroupSkupina: ValueTypes["PlatbyGroupSkupinaInput"] | Variable<any, string>
};
	/** An input for mutations affecting `PlatbyGroupSkupina` */
["PlatbyGroupSkupinaInput"]: {
	pgsId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	pgsIdSkupina: ValueTypes["BigInt"] | Variable<any, string>,
	pgsIdGroup: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our create `PlatbyItem` mutation. */
["CreatePlatbyItemPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyItem` that was created by this mutation. */
	platbyItem?:ValueTypes["PlatbyItem"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `User` that is related to this `PlatbyItem`. */
	userByPiIdUser?:ValueTypes["User"],
	/** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
	platbyCategoryByPiIdCategory?:ValueTypes["PlatbyCategory"],
	/** Reads a single `PlatbyRaw` that is related to this `PlatbyItem`. */
	platbyRawByPiIdRaw?:ValueTypes["PlatbyRaw"],
platbyItemEdge?: [{	/** The method to use when ordering `PlatbyItem`. */
	orderBy?: Array<ValueTypes["PlatbyItemsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["PlatbyItemsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `PlatbyItem` mutation. */
["CreatePlatbyItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The `PlatbyItem` to be created by this mutation. */
	platbyItem: ValueTypes["PlatbyItemInput"] | Variable<any, string>
};
	/** An input for mutations affecting `PlatbyItem` */
["PlatbyItemInput"]: {
	piId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	piIdUser?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	piIdCategory: ValueTypes["BigInt"] | Variable<any, string>,
	piIdRaw?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	piAmount: ValueTypes["BigFloat"] | Variable<any, string>,
	piDate: ValueTypes["Date"] | Variable<any, string>,
	piPrefix?: number | undefined | null | Variable<any, string>
};
	/** The output of our create `PlatbyRaw` mutation. */
["CreatePlatbyRawPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyRaw` that was created by this mutation. */
	platbyRaw?:ValueTypes["PlatbyRaw"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
platbyRawEdge?: [{	/** The method to use when ordering `PlatbyRaw`. */
	orderBy?: Array<ValueTypes["PlatbyRawsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["PlatbyRawsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `PlatbyRaw` mutation. */
["CreatePlatbyRawInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The `PlatbyRaw` to be created by this mutation. */
	platbyRaw: ValueTypes["PlatbyRawInput"] | Variable<any, string>
};
	/** An input for mutations affecting `PlatbyRaw` */
["PlatbyRawInput"]: {
	prId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	prRaw: string | Variable<any, string>,
	prHash: string | Variable<any, string>,
	prSorted?: boolean | undefined | null | Variable<any, string>,
	prDiscarded?: boolean | undefined | null | Variable<any, string>
};
	/** The output of our create `Rozpi` mutation. */
["CreateRozpiPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Rozpi` that was created by this mutation. */
	rozpi?:ValueTypes["Rozpi"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `User` that is related to this `Rozpi`. */
	userByRTrener?:ValueTypes["User"],
rozpiEdge?: [{	/** The method to use when ordering `Rozpi`. */
	orderBy?: Array<ValueTypes["RozpisOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["RozpisEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `Rozpi` mutation. */
["CreateRozpiInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The `Rozpi` to be created by this mutation. */
	rozpi: ValueTypes["RozpiInput"] | Variable<any, string>
};
	/** An input for mutations affecting `Rozpi` */
["RozpiInput"]: {
	rId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	rTrener: ValueTypes["BigInt"] | Variable<any, string>,
	rKde: string | Variable<any, string>,
	rDatum: ValueTypes["Date"] | Variable<any, string>,
	rVisible?: boolean | undefined | null | Variable<any, string>,
	rLock?: boolean | undefined | null | Variable<any, string>,
	rTimestamp?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	/** The output of our create `RozpisItem` mutation. */
["CreateRozpisItemPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `RozpisItem` that was created by this mutation. */
	rozpisItem?:ValueTypes["RozpisItem"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `Rozpi` that is related to this `RozpisItem`. */
	rozpiByRiIdRodic?:ValueTypes["Rozpi"],
	/** Reads a single `Pary` that is related to this `RozpisItem`. */
	paryByRiPartner?:ValueTypes["Pary"],
rozpisItemEdge?: [{	/** The method to use when ordering `RozpisItem`. */
	orderBy?: Array<ValueTypes["RozpisItemsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["RozpisItemsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `RozpisItem` mutation. */
["CreateRozpisItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The `RozpisItem` to be created by this mutation. */
	rozpisItem: ValueTypes["RozpisItemInput"] | Variable<any, string>
};
	/** An input for mutations affecting `RozpisItem` */
["RozpisItemInput"]: {
	riId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	riIdRodic: ValueTypes["BigInt"] | Variable<any, string>,
	riPartner?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	riOd: ValueTypes["Time"] | Variable<any, string>,
	riDo: ValueTypes["Time"] | Variable<any, string>,
	riLock?: boolean | undefined | null | Variable<any, string>
};
	/** The output of our create `Session` mutation. */
["CreateSessionPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Session` that was created by this mutation. */
	session?:ValueTypes["Session"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `User` that is related to this `Session`. */
	userBySsUser?:ValueTypes["User"],
sessionEdge?: [{	/** The method to use when ordering `Session`. */
	orderBy?: Array<ValueTypes["SessionsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["SessionsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `Session` mutation. */
["CreateSessionInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The `Session` to be created by this mutation. */
	session: ValueTypes["SessionInput"] | Variable<any, string>
};
	/** An input for mutations affecting `Session` */
["SessionInput"]: {
	ssId: string | Variable<any, string>,
	ssData: string | Variable<any, string>,
	ssUpdatedAt?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	ssLifetime: ValueTypes["BigInt"] | Variable<any, string>,
	ssUser?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>
};
	/** The output of our create `Skupiny` mutation. */
["CreateSkupinyPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Skupiny` that was created by this mutation. */
	skupiny?:ValueTypes["Skupiny"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
skupinyEdge?: [{	/** The method to use when ordering `Skupiny`. */
	orderBy?: Array<ValueTypes["SkupiniesOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["SkupiniesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `Skupiny` mutation. */
["CreateSkupinyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The `Skupiny` to be created by this mutation. */
	skupiny: ValueTypes["SkupinyInput"] | Variable<any, string>
};
	/** An input for mutations affecting `Skupiny` */
["SkupinyInput"]: {
	sId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	sName: string | Variable<any, string>,
	sDescription: string | Variable<any, string>,
	sColorRgb: string | Variable<any, string>,
	sColorText: string | Variable<any, string>,
	sLocation?: string | undefined | null | Variable<any, string>,
	sVisible?: boolean | undefined | null | Variable<any, string>
};
	/** The output of our create `Upozorneni` mutation. */
["CreateUpozorneniPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Upozorneni` that was created by this mutation. */
	upozorneni?:ValueTypes["Upozorneni"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `User` that is related to this `Upozorneni`. */
	userByUpKdo?:ValueTypes["User"],
upozorneniEdge?: [{	/** The method to use when ordering `Upozorneni`. */
	orderBy?: Array<ValueTypes["UpozornenisOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["UpozornenisEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `Upozorneni` mutation. */
["CreateUpozorneniInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The `Upozorneni` to be created by this mutation. */
	upozorneni: ValueTypes["UpozorneniInput"] | Variable<any, string>
};
	/** An input for mutations affecting `Upozorneni` */
["UpozorneniInput"]: {
	upId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	upKdo: ValueTypes["BigInt"] | Variable<any, string>,
	upNadpis: string | Variable<any, string>,
	upText: string | Variable<any, string>,
	upBarvy?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	upLock?: boolean | undefined | null | Variable<any, string>,
	upTimestamp?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	upTimestampAdd?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	/** The output of our create `UpozorneniSkupiny` mutation. */
["CreateUpozorneniSkupinyPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `UpozorneniSkupiny` that was created by this mutation. */
	upozorneniSkupiny?:ValueTypes["UpozorneniSkupiny"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
	upozorneniByUpsIdRodic?:ValueTypes["Upozorneni"],
	/** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
	skupinyByUpsIdSkupina?:ValueTypes["Skupiny"],
upozorneniSkupinyEdge?: [{	/** The method to use when ordering `UpozorneniSkupiny`. */
	orderBy?: Array<ValueTypes["UpozorneniSkupiniesOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["UpozorneniSkupiniesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `UpozorneniSkupiny` mutation. */
["CreateUpozorneniSkupinyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The `UpozorneniSkupiny` to be created by this mutation. */
	upozorneniSkupiny: ValueTypes["UpozorneniSkupinyInput"] | Variable<any, string>
};
	/** An input for mutations affecting `UpozorneniSkupiny` */
["UpozorneniSkupinyInput"]: {
	upsId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	upsIdRodic: ValueTypes["BigInt"] | Variable<any, string>,
	upsIdSkupina: ValueTypes["BigInt"] | Variable<any, string>,
	upsColor: string | Variable<any, string>,
	upsPopis: string | Variable<any, string>
};
	/** The output of our create `User` mutation. */
["CreateUserPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `User` that was created by this mutation. */
	user?:ValueTypes["User"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `Permission` that is related to this `User`. */
	permissionByUGroup?:ValueTypes["Permission"],
	/** Reads a single `Skupiny` that is related to this `User`. */
	skupinyByUSkupina?:ValueTypes["Skupiny"],
userEdge?: [{	/** The method to use when ordering `User`. */
	orderBy?: Array<ValueTypes["UsersOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["UsersEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `User` mutation. */
["CreateUserInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The `User` to be created by this mutation. */
	user: ValueTypes["UserInput"] | Variable<any, string>
};
	/** An input for mutations affecting `User` */
["UserInput"]: {
	uId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	uLogin: string | Variable<any, string>,
	uPass: string | Variable<any, string>,
	uJmeno: string | Variable<any, string>,
	uPrijmeni: string | Variable<any, string>,
	uPohlavi: string | Variable<any, string>,
	uEmail: string | Variable<any, string>,
	uTelefon: string | Variable<any, string>,
	uNarozeni: ValueTypes["Date"] | Variable<any, string>,
	uRodneCislo?: string | undefined | null | Variable<any, string>,
	uPoznamky?: string | undefined | null | Variable<any, string>,
	uTimestamp?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	uLevel?: number | undefined | null | Variable<any, string>,
	uGroup: ValueTypes["BigInt"] | Variable<any, string>,
	uSkupina?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	uDancer?: boolean | undefined | null | Variable<any, string>,
	uBan?: boolean | undefined | null | Variable<any, string>,
	uLock?: boolean | undefined | null | Variable<any, string>,
	uConfirmed?: boolean | undefined | null | Variable<any, string>,
	uSystem?: boolean | undefined | null | Variable<any, string>,
	uStreet: string | Variable<any, string>,
	uConscriptionNumber?: string | undefined | null | Variable<any, string>,
	uOrientationNumber?: string | undefined | null | Variable<any, string>,
	uDistrict?: string | undefined | null | Variable<any, string>,
	uCity: string | Variable<any, string>,
	uPostalCode: string | Variable<any, string>,
	uNationality: string | Variable<any, string>,
	uMemberSince?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	uMemberUntil?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	uCreatedAt?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	uTeacher?: boolean | undefined | null | Variable<any, string>,
	uGdprSignedAt?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	/** The output of our create `UsersSkupiny` mutation. */
["CreateUsersSkupinyPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `UsersSkupiny` that was created by this mutation. */
	usersSkupiny?:ValueTypes["UsersSkupiny"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
usersSkupinyEdge?: [{	/** The method to use when ordering `UsersSkupiny`. */
	orderBy?: Array<ValueTypes["UsersSkupiniesOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["UsersSkupiniesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `UsersSkupiny` mutation. */
["CreateUsersSkupinyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The `UsersSkupiny` to be created by this mutation. */
	usersSkupiny: ValueTypes["UsersSkupinyInput"] | Variable<any, string>
};
	/** An input for mutations affecting `UsersSkupiny` */
["UsersSkupinyInput"]: {
	usId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	usColor?: string | undefined | null | Variable<any, string>,
	usPlatbaMesic?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	usPlatbaCtvrtrok?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	usPlatbaPulrok?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	usPopis: string | Variable<any, string>
};
	/** The output of our create `Video` mutation. */
["CreateVideoPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Video` that was created by this mutation. */
	video?:ValueTypes["Video"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
videoEdge?: [{	/** The method to use when ordering `Video`. */
	orderBy?: Array<ValueTypes["VideosOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["VideosEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `Video` mutation. */
["CreateVideoInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The `Video` to be created by this mutation. */
	video: ValueTypes["VideoInput"] | Variable<any, string>
};
	/** An input for mutations affecting `Video` */
["VideoInput"]: {
	vId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	vUri: string | Variable<any, string>,
	vTitle: string | Variable<any, string>,
	vAuthor: string | Variable<any, string>,
	vDescription: string | Variable<any, string>,
	vPlaylist?: string | undefined | null | Variable<any, string>,
	vCreatedAt: ValueTypes["Datetime"] | Variable<any, string>,
	vUpdatedAt?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	/** The output of our create `VideoList` mutation. */
["CreateVideoListPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `VideoList` that was created by this mutation. */
	videoList?:ValueTypes["VideoList"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
videoListEdge?: [{	/** The method to use when ordering `VideoList`. */
	orderBy?: Array<ValueTypes["VideoListsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["VideoListsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `VideoList` mutation. */
["CreateVideoListInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The `VideoList` to be created by this mutation. */
	videoList: ValueTypes["VideoListInput"] | Variable<any, string>
};
	/** An input for mutations affecting `VideoList` */
["VideoListInput"]: {
	vlId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	vlUrl: string | Variable<any, string>,
	vlTitle: string | Variable<any, string>,
	vlDescription: string | Variable<any, string>,
	vlCount: ValueTypes["BigInt"] | Variable<any, string>,
	vlCreatedAt: ValueTypes["Datetime"] | Variable<any, string>,
	vlLastChecked?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	/** The output of our create `VideoSource` mutation. */
["CreateVideoSourcePayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `VideoSource` that was created by this mutation. */
	videoSource?:ValueTypes["VideoSource"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
videoSourceEdge?: [{	/** The method to use when ordering `VideoSource`. */
	orderBy?: Array<ValueTypes["VideoSourcesOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["VideoSourcesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `VideoSource` mutation. */
["CreateVideoSourceInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The `VideoSource` to be created by this mutation. */
	videoSource: ValueTypes["VideoSourceInput"] | Variable<any, string>
};
	/** An input for mutations affecting `VideoSource` */
["VideoSourceInput"]: {
	vsId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	vsUrl: string | Variable<any, string>,
	vsTitle?: string | undefined | null | Variable<any, string>,
	vsDescription?: string | undefined | null | Variable<any, string>,
	vsCreatedAt?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	vsLastChecked?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	/** The output of our update `Akce` mutation. */
["UpdateAkcePayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Akce` that was updated by this mutation. */
	akce?:ValueTypes["Akce"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
akceEdge?: [{	/** The method to use when ordering `Akce`. */
	orderBy?: Array<ValueTypes["AkcesOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["AkcesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateAkceByNodeId` mutation. */
["UpdateAkceByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `Akce` to be updated. */
	nodeId: string | Variable<any, string>,
	/** An object where the defined keys will be set on the `Akce` being updated. */
	patch: ValueTypes["AkcePatch"] | Variable<any, string>
};
	/** Represents an update to a `Akce`. Fields that are set will be updated. */
["AkcePatch"]: {
	aId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	aJmeno?: string | undefined | null | Variable<any, string>,
	aKde?: string | undefined | null | Variable<any, string>,
	aInfo?: string | undefined | null | Variable<any, string>,
	aOd?: ValueTypes["Date"] | undefined | null | Variable<any, string>,
	aDo?: ValueTypes["Date"] | undefined | null | Variable<any, string>,
	aKapacita?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	aDokumenty?: string | undefined | null | Variable<any, string>,
	aTimestamp?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	aLock?: boolean | undefined | null | Variable<any, string>,
	aVisible?: boolean | undefined | null | Variable<any, string>
};
	/** All input for the `updateAkce` mutation. */
["UpdateAkceInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** An object where the defined keys will be set on the `Akce` being updated. */
	patch: ValueTypes["AkcePatch"] | Variable<any, string>,
	aId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our update `AkceItem` mutation. */
["UpdateAkceItemPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `AkceItem` that was updated by this mutation. */
	akceItem?:ValueTypes["AkceItem"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `Akce` that is related to this `AkceItem`. */
	akceByAiIdRodic?:ValueTypes["Akce"],
	/** Reads a single `User` that is related to this `AkceItem`. */
	userByAiUser?:ValueTypes["User"],
akceItemEdge?: [{	/** The method to use when ordering `AkceItem`. */
	orderBy?: Array<ValueTypes["AkceItemsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["AkceItemsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateAkceItemByNodeId` mutation. */
["UpdateAkceItemByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `AkceItem` to be updated. */
	nodeId: string | Variable<any, string>,
	/** An object where the defined keys will be set on the `AkceItem` being updated. */
	patch: ValueTypes["AkceItemPatch"] | Variable<any, string>
};
	/** Represents an update to a `AkceItem`. Fields that are set will be updated. */
["AkceItemPatch"]: {
	aiId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	aiIdRodic?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	aiUser?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	aiRokNarozeni?: number | undefined | null | Variable<any, string>
};
	/** All input for the `updateAkceItem` mutation. */
["UpdateAkceItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** An object where the defined keys will be set on the `AkceItem` being updated. */
	patch: ValueTypes["AkceItemPatch"] | Variable<any, string>,
	aiId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our update `Aktuality` mutation. */
["UpdateAktualityPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Aktuality` that was updated by this mutation. */
	aktuality?:ValueTypes["Aktuality"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `User` that is related to this `Aktuality`. */
	userByAtKdo?:ValueTypes["User"],
	/** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
	galerieFotoByAtFotoMain?:ValueTypes["GalerieFoto"],
aktualityEdge?: [{	/** The method to use when ordering `Aktuality`. */
	orderBy?: Array<ValueTypes["AktualitiesOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["AktualitiesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateAktualityByNodeId` mutation. */
["UpdateAktualityByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `Aktuality` to be updated. */
	nodeId: string | Variable<any, string>,
	/** An object where the defined keys will be set on the `Aktuality` being updated. */
	patch: ValueTypes["AktualityPatch"] | Variable<any, string>
};
	/** Represents an update to a `Aktuality`. Fields that are set will be updated. */
["AktualityPatch"]: {
	atId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	atKdo?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	atKat?: string | undefined | null | Variable<any, string>,
	atJmeno?: string | undefined | null | Variable<any, string>,
	atText?: string | undefined | null | Variable<any, string>,
	atPreview?: string | undefined | null | Variable<any, string>,
	atFoto?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	atFotoMain?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	atTimestamp?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	atTimestampAdd?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	/** All input for the `updateAktuality` mutation. */
["UpdateAktualityInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** An object where the defined keys will be set on the `Aktuality` being updated. */
	patch: ValueTypes["AktualityPatch"] | Variable<any, string>,
	atId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our update `Dokumenty` mutation. */
["UpdateDokumentyPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Dokumenty` that was updated by this mutation. */
	dokumenty?:ValueTypes["Dokumenty"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `User` that is related to this `Dokumenty`. */
	userByDKdo?:ValueTypes["User"],
dokumentyEdge?: [{	/** The method to use when ordering `Dokumenty`. */
	orderBy?: Array<ValueTypes["DokumentiesOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["DokumentiesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateDokumentyByNodeId` mutation. */
["UpdateDokumentyByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `Dokumenty` to be updated. */
	nodeId: string | Variable<any, string>,
	/** An object where the defined keys will be set on the `Dokumenty` being updated. */
	patch: ValueTypes["DokumentyPatch"] | Variable<any, string>
};
	/** Represents an update to a `Dokumenty`. Fields that are set will be updated. */
["DokumentyPatch"]: {
	dId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	dPath?: string | undefined | null | Variable<any, string>,
	dName?: string | undefined | null | Variable<any, string>,
	dFilename?: string | undefined | null | Variable<any, string>,
	dKategorie?: number | undefined | null | Variable<any, string>,
	dKdo?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	dTimestamp?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	/** All input for the `updateDokumenty` mutation. */
["UpdateDokumentyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** An object where the defined keys will be set on the `Dokumenty` being updated. */
	patch: ValueTypes["DokumentyPatch"] | Variable<any, string>,
	dId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our update `GalerieDir` mutation. */
["UpdateGalerieDirPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `GalerieDir` that was updated by this mutation. */
	galerieDir?:ValueTypes["GalerieDir"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
galerieDirEdge?: [{	/** The method to use when ordering `GalerieDir`. */
	orderBy?: Array<ValueTypes["GalerieDirsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["GalerieDirsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateGalerieDirByNodeId` mutation. */
["UpdateGalerieDirByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `GalerieDir` to be updated. */
	nodeId: string | Variable<any, string>,
	/** An object where the defined keys will be set on the `GalerieDir` being updated. */
	patch: ValueTypes["GalerieDirPatch"] | Variable<any, string>
};
	/** Represents an update to a `GalerieDir`. Fields that are set will be updated. */
["GalerieDirPatch"]: {
	gdId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	gdIdRodic?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	gdName?: string | undefined | null | Variable<any, string>,
	gdLevel?: number | undefined | null | Variable<any, string>,
	gdPath?: string | undefined | null | Variable<any, string>,
	gdHidden?: boolean | undefined | null | Variable<any, string>
};
	/** All input for the `updateGalerieDir` mutation. */
["UpdateGalerieDirInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** An object where the defined keys will be set on the `GalerieDir` being updated. */
	patch: ValueTypes["GalerieDirPatch"] | Variable<any, string>,
	gdId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our update `GalerieFoto` mutation. */
["UpdateGalerieFotoPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `GalerieFoto` that was updated by this mutation. */
	galerieFoto?:ValueTypes["GalerieFoto"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
	galerieDirByGfIdRodic?:ValueTypes["GalerieDir"],
	/** Reads a single `User` that is related to this `GalerieFoto`. */
	userByGfKdo?:ValueTypes["User"],
galerieFotoEdge?: [{	/** The method to use when ordering `GalerieFoto`. */
	orderBy?: Array<ValueTypes["GalerieFotosOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["GalerieFotosEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateGalerieFotoByNodeId` mutation. */
["UpdateGalerieFotoByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `GalerieFoto` to be updated. */
	nodeId: string | Variable<any, string>,
	/** An object where the defined keys will be set on the `GalerieFoto` being updated. */
	patch: ValueTypes["GalerieFotoPatch"] | Variable<any, string>
};
	/** Represents an update to a `GalerieFoto`. Fields that are set will be updated. */
["GalerieFotoPatch"]: {
	gfId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	gfIdRodic?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	gfName?: string | undefined | null | Variable<any, string>,
	gfPath?: string | undefined | null | Variable<any, string>,
	gfKdo?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	gfTimestamp?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	/** All input for the `updateGalerieFoto` mutation. */
["UpdateGalerieFotoInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** An object where the defined keys will be set on the `GalerieFoto` being updated. */
	patch: ValueTypes["GalerieFotoPatch"] | Variable<any, string>,
	gfId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our update `Nabidka` mutation. */
["UpdateNabidkaPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Nabidka` that was updated by this mutation. */
	nabidka?:ValueTypes["Nabidka"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `User` that is related to this `Nabidka`. */
	userByNTrener?:ValueTypes["User"],
nabidkaEdge?: [{	/** The method to use when ordering `Nabidka`. */
	orderBy?: Array<ValueTypes["NabidkasOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["NabidkasEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateNabidkaByNodeId` mutation. */
["UpdateNabidkaByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `Nabidka` to be updated. */
	nodeId: string | Variable<any, string>,
	/** An object where the defined keys will be set on the `Nabidka` being updated. */
	patch: ValueTypes["NabidkaPatch"] | Variable<any, string>
};
	/** Represents an update to a `Nabidka`. Fields that are set will be updated. */
["NabidkaPatch"]: {
	nId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	nTrener?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	nPocetHod?: number | undefined | null | Variable<any, string>,
	nMaxPocetHod?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	nOd?: ValueTypes["Date"] | undefined | null | Variable<any, string>,
	nDo?: ValueTypes["Date"] | undefined | null | Variable<any, string>,
	nVisible?: boolean | undefined | null | Variable<any, string>,
	nLock?: boolean | undefined | null | Variable<any, string>,
	nTimestamp?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	/** All input for the `updateNabidka` mutation. */
["UpdateNabidkaInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** An object where the defined keys will be set on the `Nabidka` being updated. */
	patch: ValueTypes["NabidkaPatch"] | Variable<any, string>,
	nId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our update `NabidkaItem` mutation. */
["UpdateNabidkaItemPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `NabidkaItem` that was updated by this mutation. */
	nabidkaItem?:ValueTypes["NabidkaItem"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `Nabidka` that is related to this `NabidkaItem`. */
	nabidkaByNiIdRodic?:ValueTypes["Nabidka"],
	/** Reads a single `Pary` that is related to this `NabidkaItem`. */
	paryByNiPartner?:ValueTypes["Pary"],
nabidkaItemEdge?: [{	/** The method to use when ordering `NabidkaItem`. */
	orderBy?: Array<ValueTypes["NabidkaItemsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["NabidkaItemsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateNabidkaItemByNodeId` mutation. */
["UpdateNabidkaItemByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `NabidkaItem` to be updated. */
	nodeId: string | Variable<any, string>,
	/** An object where the defined keys will be set on the `NabidkaItem` being updated. */
	patch: ValueTypes["NabidkaItemPatch"] | Variable<any, string>
};
	/** Represents an update to a `NabidkaItem`. Fields that are set will be updated. */
["NabidkaItemPatch"]: {
	niId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	niIdRodic?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	niPartner?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	niPocetHod?: number | undefined | null | Variable<any, string>,
	niLock?: boolean | undefined | null | Variable<any, string>
};
	/** All input for the `updateNabidkaItem` mutation. */
["UpdateNabidkaItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** An object where the defined keys will be set on the `NabidkaItem` being updated. */
	patch: ValueTypes["NabidkaItemPatch"] | Variable<any, string>,
	niId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our update `Page` mutation. */
["UpdatePagePayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Page` that was updated by this mutation. */
	page?:ValueTypes["Page"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
pageEdge?: [{	/** The method to use when ordering `Page`. */
	orderBy?: Array<ValueTypes["PagesOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["PagesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updatePageByNodeId` mutation. */
["UpdatePageByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `Page` to be updated. */
	nodeId: string | Variable<any, string>,
	/** An object where the defined keys will be set on the `Page` being updated. */
	patch: ValueTypes["PagePatch"] | Variable<any, string>
};
	/** Represents an update to a `Page`. Fields that are set will be updated. */
["PagePatch"]: {
	id?: number | undefined | null | Variable<any, string>,
	url?: string | undefined | null | Variable<any, string>,
	content?: ValueTypes["JSON"] | undefined | null | Variable<any, string>,
	createdAt?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	updatedAt?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	title?: string | undefined | null | Variable<any, string>
};
	/** All input for the `updatePage` mutation. */
["UpdatePageInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** An object where the defined keys will be set on the `Page` being updated. */
	patch: ValueTypes["PagePatch"] | Variable<any, string>,
	id: number | Variable<any, string>
};
	/** All input for the `updatePageByUrl` mutation. */
["UpdatePageByUrlInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** An object where the defined keys will be set on the `Page` being updated. */
	patch: ValueTypes["PagePatch"] | Variable<any, string>,
	url: string | Variable<any, string>
};
	/** The output of our update `Parameter` mutation. */
["UpdateParameterPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Parameter` that was updated by this mutation. */
	parameter?:ValueTypes["Parameter"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
parameterEdge?: [{	/** The method to use when ordering `Parameter`. */
	orderBy?: Array<ValueTypes["ParametersOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["ParametersEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateParameterByNodeId` mutation. */
["UpdateParameterByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `Parameter` to be updated. */
	nodeId: string | Variable<any, string>,
	/** An object where the defined keys will be set on the `Parameter` being updated. */
	patch: ValueTypes["ParameterPatch"] | Variable<any, string>
};
	/** Represents an update to a `Parameter`. Fields that are set will be updated. */
["ParameterPatch"]: {
	paName?: string | undefined | null | Variable<any, string>,
	paValue?: string | undefined | null | Variable<any, string>
};
	/** All input for the `updateParameter` mutation. */
["UpdateParameterInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** An object where the defined keys will be set on the `Parameter` being updated. */
	patch: ValueTypes["ParameterPatch"] | Variable<any, string>,
	paName: string | Variable<any, string>
};
	/** The output of our update `Pary` mutation. */
["UpdateParyPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Pary` that was updated by this mutation. */
	pary?:ValueTypes["Pary"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `User` that is related to this `Pary`. */
	userByPIdPartner?:ValueTypes["User"],
paryEdge?: [{	/** The method to use when ordering `Pary`. */
	orderBy?: Array<ValueTypes["PariesOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["PariesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateParyByNodeId` mutation. */
["UpdateParyByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `Pary` to be updated. */
	nodeId: string | Variable<any, string>,
	/** An object where the defined keys will be set on the `Pary` being updated. */
	patch: ValueTypes["ParyPatch"] | Variable<any, string>
};
	/** Represents an update to a `Pary`. Fields that are set will be updated. */
["ParyPatch"]: {
	pId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	pIdPartner?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	pIdPartnerka?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	pSttTrida?: ValueTypes["ParyPSttTrida"] | undefined | null | Variable<any, string>,
	pSttBody?: number | undefined | null | Variable<any, string>,
	pSttFinale?: boolean | undefined | null | Variable<any, string>,
	pLatTrida?: ValueTypes["ParyPLatTrida"] | undefined | null | Variable<any, string>,
	pLatBody?: number | undefined | null | Variable<any, string>,
	pLatFinale?: boolean | undefined | null | Variable<any, string>,
	pHodnoceni?: number | undefined | null | Variable<any, string>,
	pArchiv?: boolean | undefined | null | Variable<any, string>,
	pTimestampAdd?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	pTimestampArchive?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	/** All input for the `updatePary` mutation. */
["UpdateParyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** An object where the defined keys will be set on the `Pary` being updated. */
	patch: ValueTypes["ParyPatch"] | Variable<any, string>,
	pId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our update `ParyNavrh` mutation. */
["UpdateParyNavrhPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `ParyNavrh` that was updated by this mutation. */
	paryNavrh?:ValueTypes["ParyNavrh"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnNavrhl?:ValueTypes["User"],
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnPartner?:ValueTypes["User"],
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnPartnerka?:ValueTypes["User"],
paryNavrhEdge?: [{	/** The method to use when ordering `ParyNavrh`. */
	orderBy?: Array<ValueTypes["ParyNavrhsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["ParyNavrhsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateParyNavrhByNodeId` mutation. */
["UpdateParyNavrhByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `ParyNavrh` to be updated. */
	nodeId: string | Variable<any, string>,
	/** An object where the defined keys will be set on the `ParyNavrh` being updated. */
	patch: ValueTypes["ParyNavrhPatch"] | Variable<any, string>
};
	/** Represents an update to a `ParyNavrh`. Fields that are set will be updated. */
["ParyNavrhPatch"]: {
	pnId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	pnNavrhl?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	pnPartner?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	pnPartnerka?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>
};
	/** All input for the `updateParyNavrh` mutation. */
["UpdateParyNavrhInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** An object where the defined keys will be set on the `ParyNavrh` being updated. */
	patch: ValueTypes["ParyNavrhPatch"] | Variable<any, string>,
	pnId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our update `Permission` mutation. */
["UpdatePermissionPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Permission` that was updated by this mutation. */
	permission?:ValueTypes["Permission"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
permissionEdge?: [{	/** The method to use when ordering `Permission`. */
	orderBy?: Array<ValueTypes["PermissionsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["PermissionsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updatePermissionByNodeId` mutation. */
["UpdatePermissionByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `Permission` to be updated. */
	nodeId: string | Variable<any, string>,
	/** An object where the defined keys will be set on the `Permission` being updated. */
	patch: ValueTypes["PermissionPatch"] | Variable<any, string>
};
	/** Represents an update to a `Permission`. Fields that are set will be updated. */
["PermissionPatch"]: {
	peId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	peName?: string | undefined | null | Variable<any, string>,
	peDescription?: string | undefined | null | Variable<any, string>,
	peAkce?: number | undefined | null | Variable<any, string>,
	peAktuality?: number | undefined | null | Variable<any, string>,
	peAnkety?: number | undefined | null | Variable<any, string>,
	peDokumenty?: number | undefined | null | Variable<any, string>,
	peGalerie?: number | undefined | null | Variable<any, string>,
	peInzerce?: number | undefined | null | Variable<any, string>,
	peKonzole?: number | undefined | null | Variable<any, string>,
	peNabidka?: number | undefined | null | Variable<any, string>,
	peNastenka?: number | undefined | null | Variable<any, string>,
	peNovinky?: number | undefined | null | Variable<any, string>,
	pePary?: number | undefined | null | Variable<any, string>,
	pePlatby?: number | undefined | null | Variable<any, string>,
	pePermissions?: number | undefined | null | Variable<any, string>,
	peRozpis?: number | undefined | null | Variable<any, string>,
	peSkupiny?: number | undefined | null | Variable<any, string>,
	peUsers?: number | undefined | null | Variable<any, string>,
	peMain?: number | undefined | null | Variable<any, string>
};
	/** All input for the `updatePermission` mutation. */
["UpdatePermissionInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** An object where the defined keys will be set on the `Permission` being updated. */
	patch: ValueTypes["PermissionPatch"] | Variable<any, string>,
	peId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our update `PlatbyCategory` mutation. */
["UpdatePlatbyCategoryPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyCategory` that was updated by this mutation. */
	platbyCategory?:ValueTypes["PlatbyCategory"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
platbyCategoryEdge?: [{	/** The method to use when ordering `PlatbyCategory`. */
	orderBy?: Array<ValueTypes["PlatbyCategoriesOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["PlatbyCategoriesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updatePlatbyCategoryByNodeId` mutation. */
["UpdatePlatbyCategoryByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `PlatbyCategory` to be updated. */
	nodeId: string | Variable<any, string>,
	/** An object where the defined keys will be set on the `PlatbyCategory` being updated. */
	patch: ValueTypes["PlatbyCategoryPatch"] | Variable<any, string>
};
	/** Represents an update to a `PlatbyCategory`. Fields that are set will be updated. */
["PlatbyCategoryPatch"]: {
	pcId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	pcName?: string | undefined | null | Variable<any, string>,
	pcSymbol?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	pcAmount?: ValueTypes["BigFloat"] | undefined | null | Variable<any, string>,
	pcDateDue?: ValueTypes["Date"] | undefined | null | Variable<any, string>,
	pcValidFrom?: ValueTypes["Date"] | undefined | null | Variable<any, string>,
	pcValidTo?: ValueTypes["Date"] | undefined | null | Variable<any, string>,
	pcUseBase?: boolean | undefined | null | Variable<any, string>,
	pcUsePrefix?: boolean | undefined | null | Variable<any, string>,
	pcArchive?: boolean | undefined | null | Variable<any, string>,
	pcVisible?: boolean | undefined | null | Variable<any, string>
};
	/** All input for the `updatePlatbyCategory` mutation. */
["UpdatePlatbyCategoryInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** An object where the defined keys will be set on the `PlatbyCategory` being updated. */
	patch: ValueTypes["PlatbyCategoryPatch"] | Variable<any, string>,
	pcId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our update `PlatbyCategoryGroup` mutation. */
["UpdatePlatbyCategoryGroupPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyCategoryGroup` that was updated by this mutation. */
	platbyCategoryGroup?:ValueTypes["PlatbyCategoryGroup"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `PlatbyGroup` that is related to this `PlatbyCategoryGroup`. */
	platbyGroupByPcgIdGroup?:ValueTypes["PlatbyGroup"],
	/** Reads a single `PlatbyCategory` that is related to this `PlatbyCategoryGroup`. */
	platbyCategoryByPcgIdCategory?:ValueTypes["PlatbyCategory"],
platbyCategoryGroupEdge?: [{	/** The method to use when ordering `PlatbyCategoryGroup`. */
	orderBy?: Array<ValueTypes["PlatbyCategoryGroupsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["PlatbyCategoryGroupsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updatePlatbyCategoryGroupByNodeId` mutation. */
["UpdatePlatbyCategoryGroupByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `PlatbyCategoryGroup` to be updated. */
	nodeId: string | Variable<any, string>,
	/** An object where the defined keys will be set on the `PlatbyCategoryGroup` being updated. */
	patch: ValueTypes["PlatbyCategoryGroupPatch"] | Variable<any, string>
};
	/** Represents an update to a `PlatbyCategoryGroup`. Fields that are set will be updated. */
["PlatbyCategoryGroupPatch"]: {
	pcgId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	pcgIdGroup?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	pcgIdCategory?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>
};
	/** All input for the `updatePlatbyCategoryGroup` mutation. */
["UpdatePlatbyCategoryGroupInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** An object where the defined keys will be set on the `PlatbyCategoryGroup` being updated. */
	patch: ValueTypes["PlatbyCategoryGroupPatch"] | Variable<any, string>,
	pcgId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our update `PlatbyGroup` mutation. */
["UpdatePlatbyGroupPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyGroup` that was updated by this mutation. */
	platbyGroup?:ValueTypes["PlatbyGroup"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
platbyGroupEdge?: [{	/** The method to use when ordering `PlatbyGroup`. */
	orderBy?: Array<ValueTypes["PlatbyGroupsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["PlatbyGroupsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updatePlatbyGroupByNodeId` mutation. */
["UpdatePlatbyGroupByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `PlatbyGroup` to be updated. */
	nodeId: string | Variable<any, string>,
	/** An object where the defined keys will be set on the `PlatbyGroup` being updated. */
	patch: ValueTypes["PlatbyGroupPatch"] | Variable<any, string>
};
	/** Represents an update to a `PlatbyGroup`. Fields that are set will be updated. */
["PlatbyGroupPatch"]: {
	pgId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	pgType?: ValueTypes["BigFloat"] | undefined | null | Variable<any, string>,
	pgName?: string | undefined | null | Variable<any, string>,
	pgDescription?: string | undefined | null | Variable<any, string>,
	pgBase?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>
};
	/** All input for the `updatePlatbyGroup` mutation. */
["UpdatePlatbyGroupInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** An object where the defined keys will be set on the `PlatbyGroup` being updated. */
	patch: ValueTypes["PlatbyGroupPatch"] | Variable<any, string>,
	pgId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our update `PlatbyGroupSkupina` mutation. */
["UpdatePlatbyGroupSkupinaPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyGroupSkupina` that was updated by this mutation. */
	platbyGroupSkupina?:ValueTypes["PlatbyGroupSkupina"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `Skupiny` that is related to this `PlatbyGroupSkupina`. */
	skupinyByPgsIdSkupina?:ValueTypes["Skupiny"],
	/** Reads a single `PlatbyGroup` that is related to this `PlatbyGroupSkupina`. */
	platbyGroupByPgsIdGroup?:ValueTypes["PlatbyGroup"],
platbyGroupSkupinaEdge?: [{	/** The method to use when ordering `PlatbyGroupSkupina`. */
	orderBy?: Array<ValueTypes["PlatbyGroupSkupinasOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["PlatbyGroupSkupinasEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updatePlatbyGroupSkupinaByNodeId` mutation. */
["UpdatePlatbyGroupSkupinaByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `PlatbyGroupSkupina` to be updated. */
	nodeId: string | Variable<any, string>,
	/** An object where the defined keys will be set on the `PlatbyGroupSkupina` being updated. */
	patch: ValueTypes["PlatbyGroupSkupinaPatch"] | Variable<any, string>
};
	/** Represents an update to a `PlatbyGroupSkupina`. Fields that are set will be updated. */
["PlatbyGroupSkupinaPatch"]: {
	pgsId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	pgsIdSkupina?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	pgsIdGroup?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>
};
	/** All input for the `updatePlatbyGroupSkupina` mutation. */
["UpdatePlatbyGroupSkupinaInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** An object where the defined keys will be set on the `PlatbyGroupSkupina` being updated. */
	patch: ValueTypes["PlatbyGroupSkupinaPatch"] | Variable<any, string>,
	pgsId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our update `PlatbyItem` mutation. */
["UpdatePlatbyItemPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyItem` that was updated by this mutation. */
	platbyItem?:ValueTypes["PlatbyItem"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `User` that is related to this `PlatbyItem`. */
	userByPiIdUser?:ValueTypes["User"],
	/** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
	platbyCategoryByPiIdCategory?:ValueTypes["PlatbyCategory"],
	/** Reads a single `PlatbyRaw` that is related to this `PlatbyItem`. */
	platbyRawByPiIdRaw?:ValueTypes["PlatbyRaw"],
platbyItemEdge?: [{	/** The method to use when ordering `PlatbyItem`. */
	orderBy?: Array<ValueTypes["PlatbyItemsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["PlatbyItemsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updatePlatbyItemByNodeId` mutation. */
["UpdatePlatbyItemByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `PlatbyItem` to be updated. */
	nodeId: string | Variable<any, string>,
	/** An object where the defined keys will be set on the `PlatbyItem` being updated. */
	patch: ValueTypes["PlatbyItemPatch"] | Variable<any, string>
};
	/** Represents an update to a `PlatbyItem`. Fields that are set will be updated. */
["PlatbyItemPatch"]: {
	piId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	piIdUser?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	piIdCategory?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	piIdRaw?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	piAmount?: ValueTypes["BigFloat"] | undefined | null | Variable<any, string>,
	piDate?: ValueTypes["Date"] | undefined | null | Variable<any, string>,
	piPrefix?: number | undefined | null | Variable<any, string>
};
	/** All input for the `updatePlatbyItem` mutation. */
["UpdatePlatbyItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** An object where the defined keys will be set on the `PlatbyItem` being updated. */
	patch: ValueTypes["PlatbyItemPatch"] | Variable<any, string>,
	piId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our update `PlatbyRaw` mutation. */
["UpdatePlatbyRawPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyRaw` that was updated by this mutation. */
	platbyRaw?:ValueTypes["PlatbyRaw"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
platbyRawEdge?: [{	/** The method to use when ordering `PlatbyRaw`. */
	orderBy?: Array<ValueTypes["PlatbyRawsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["PlatbyRawsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updatePlatbyRawByNodeId` mutation. */
["UpdatePlatbyRawByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `PlatbyRaw` to be updated. */
	nodeId: string | Variable<any, string>,
	/** An object where the defined keys will be set on the `PlatbyRaw` being updated. */
	patch: ValueTypes["PlatbyRawPatch"] | Variable<any, string>
};
	/** Represents an update to a `PlatbyRaw`. Fields that are set will be updated. */
["PlatbyRawPatch"]: {
	prId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	prRaw?: string | undefined | null | Variable<any, string>,
	prHash?: string | undefined | null | Variable<any, string>,
	prSorted?: boolean | undefined | null | Variable<any, string>,
	prDiscarded?: boolean | undefined | null | Variable<any, string>
};
	/** All input for the `updatePlatbyRaw` mutation. */
["UpdatePlatbyRawInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** An object where the defined keys will be set on the `PlatbyRaw` being updated. */
	patch: ValueTypes["PlatbyRawPatch"] | Variable<any, string>,
	prId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our update `Rozpi` mutation. */
["UpdateRozpiPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Rozpi` that was updated by this mutation. */
	rozpi?:ValueTypes["Rozpi"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `User` that is related to this `Rozpi`. */
	userByRTrener?:ValueTypes["User"],
rozpiEdge?: [{	/** The method to use when ordering `Rozpi`. */
	orderBy?: Array<ValueTypes["RozpisOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["RozpisEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateRozpiByNodeId` mutation. */
["UpdateRozpiByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `Rozpi` to be updated. */
	nodeId: string | Variable<any, string>,
	/** An object where the defined keys will be set on the `Rozpi` being updated. */
	patch: ValueTypes["RozpiPatch"] | Variable<any, string>
};
	/** Represents an update to a `Rozpi`. Fields that are set will be updated. */
["RozpiPatch"]: {
	rId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	rTrener?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	rKde?: string | undefined | null | Variable<any, string>,
	rDatum?: ValueTypes["Date"] | undefined | null | Variable<any, string>,
	rVisible?: boolean | undefined | null | Variable<any, string>,
	rLock?: boolean | undefined | null | Variable<any, string>,
	rTimestamp?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	/** All input for the `updateRozpi` mutation. */
["UpdateRozpiInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** An object where the defined keys will be set on the `Rozpi` being updated. */
	patch: ValueTypes["RozpiPatch"] | Variable<any, string>,
	rId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our update `RozpisItem` mutation. */
["UpdateRozpisItemPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `RozpisItem` that was updated by this mutation. */
	rozpisItem?:ValueTypes["RozpisItem"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `Rozpi` that is related to this `RozpisItem`. */
	rozpiByRiIdRodic?:ValueTypes["Rozpi"],
	/** Reads a single `Pary` that is related to this `RozpisItem`. */
	paryByRiPartner?:ValueTypes["Pary"],
rozpisItemEdge?: [{	/** The method to use when ordering `RozpisItem`. */
	orderBy?: Array<ValueTypes["RozpisItemsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["RozpisItemsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateRozpisItemByNodeId` mutation. */
["UpdateRozpisItemByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `RozpisItem` to be updated. */
	nodeId: string | Variable<any, string>,
	/** An object where the defined keys will be set on the `RozpisItem` being updated. */
	patch: ValueTypes["RozpisItemPatch"] | Variable<any, string>
};
	/** Represents an update to a `RozpisItem`. Fields that are set will be updated. */
["RozpisItemPatch"]: {
	riId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	riIdRodic?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	riPartner?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	riOd?: ValueTypes["Time"] | undefined | null | Variable<any, string>,
	riDo?: ValueTypes["Time"] | undefined | null | Variable<any, string>,
	riLock?: boolean | undefined | null | Variable<any, string>
};
	/** All input for the `updateRozpisItem` mutation. */
["UpdateRozpisItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** An object where the defined keys will be set on the `RozpisItem` being updated. */
	patch: ValueTypes["RozpisItemPatch"] | Variable<any, string>,
	riId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our update `Session` mutation. */
["UpdateSessionPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Session` that was updated by this mutation. */
	session?:ValueTypes["Session"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `User` that is related to this `Session`. */
	userBySsUser?:ValueTypes["User"],
sessionEdge?: [{	/** The method to use when ordering `Session`. */
	orderBy?: Array<ValueTypes["SessionsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["SessionsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateSessionByNodeId` mutation. */
["UpdateSessionByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `Session` to be updated. */
	nodeId: string | Variable<any, string>,
	/** An object where the defined keys will be set on the `Session` being updated. */
	patch: ValueTypes["SessionPatch"] | Variable<any, string>
};
	/** Represents an update to a `Session`. Fields that are set will be updated. */
["SessionPatch"]: {
	ssId?: string | undefined | null | Variable<any, string>,
	ssData?: string | undefined | null | Variable<any, string>,
	ssUpdatedAt?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	ssLifetime?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	ssUser?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>
};
	/** All input for the `updateSession` mutation. */
["UpdateSessionInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** An object where the defined keys will be set on the `Session` being updated. */
	patch: ValueTypes["SessionPatch"] | Variable<any, string>,
	ssId: string | Variable<any, string>
};
	/** The output of our update `Skupiny` mutation. */
["UpdateSkupinyPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Skupiny` that was updated by this mutation. */
	skupiny?:ValueTypes["Skupiny"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
skupinyEdge?: [{	/** The method to use when ordering `Skupiny`. */
	orderBy?: Array<ValueTypes["SkupiniesOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["SkupiniesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateSkupinyByNodeId` mutation. */
["UpdateSkupinyByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `Skupiny` to be updated. */
	nodeId: string | Variable<any, string>,
	/** An object where the defined keys will be set on the `Skupiny` being updated. */
	patch: ValueTypes["SkupinyPatch"] | Variable<any, string>
};
	/** Represents an update to a `Skupiny`. Fields that are set will be updated. */
["SkupinyPatch"]: {
	sId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	sName?: string | undefined | null | Variable<any, string>,
	sDescription?: string | undefined | null | Variable<any, string>,
	sColorRgb?: string | undefined | null | Variable<any, string>,
	sColorText?: string | undefined | null | Variable<any, string>,
	sLocation?: string | undefined | null | Variable<any, string>,
	sVisible?: boolean | undefined | null | Variable<any, string>
};
	/** All input for the `updateSkupiny` mutation. */
["UpdateSkupinyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** An object where the defined keys will be set on the `Skupiny` being updated. */
	patch: ValueTypes["SkupinyPatch"] | Variable<any, string>,
	sId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our update `Upozorneni` mutation. */
["UpdateUpozorneniPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Upozorneni` that was updated by this mutation. */
	upozorneni?:ValueTypes["Upozorneni"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `User` that is related to this `Upozorneni`. */
	userByUpKdo?:ValueTypes["User"],
upozorneniEdge?: [{	/** The method to use when ordering `Upozorneni`. */
	orderBy?: Array<ValueTypes["UpozornenisOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["UpozornenisEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateUpozorneniByNodeId` mutation. */
["UpdateUpozorneniByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `Upozorneni` to be updated. */
	nodeId: string | Variable<any, string>,
	/** An object where the defined keys will be set on the `Upozorneni` being updated. */
	patch: ValueTypes["UpozorneniPatch"] | Variable<any, string>
};
	/** Represents an update to a `Upozorneni`. Fields that are set will be updated. */
["UpozorneniPatch"]: {
	upId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	upKdo?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	upNadpis?: string | undefined | null | Variable<any, string>,
	upText?: string | undefined | null | Variable<any, string>,
	upBarvy?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	upLock?: boolean | undefined | null | Variable<any, string>,
	upTimestamp?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	upTimestampAdd?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	/** All input for the `updateUpozorneni` mutation. */
["UpdateUpozorneniInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** An object where the defined keys will be set on the `Upozorneni` being updated. */
	patch: ValueTypes["UpozorneniPatch"] | Variable<any, string>,
	upId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our update `UpozorneniSkupiny` mutation. */
["UpdateUpozorneniSkupinyPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `UpozorneniSkupiny` that was updated by this mutation. */
	upozorneniSkupiny?:ValueTypes["UpozorneniSkupiny"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
	upozorneniByUpsIdRodic?:ValueTypes["Upozorneni"],
	/** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
	skupinyByUpsIdSkupina?:ValueTypes["Skupiny"],
upozorneniSkupinyEdge?: [{	/** The method to use when ordering `UpozorneniSkupiny`. */
	orderBy?: Array<ValueTypes["UpozorneniSkupiniesOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["UpozorneniSkupiniesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateUpozorneniSkupinyByNodeId` mutation. */
["UpdateUpozorneniSkupinyByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `UpozorneniSkupiny` to be updated. */
	nodeId: string | Variable<any, string>,
	/** An object where the defined keys will be set on the `UpozorneniSkupiny` being updated. */
	patch: ValueTypes["UpozorneniSkupinyPatch"] | Variable<any, string>
};
	/** Represents an update to a `UpozorneniSkupiny`. Fields that are set will be updated. */
["UpozorneniSkupinyPatch"]: {
	upsId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	upsIdRodic?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	upsIdSkupina?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	upsColor?: string | undefined | null | Variable<any, string>,
	upsPopis?: string | undefined | null | Variable<any, string>
};
	/** All input for the `updateUpozorneniSkupiny` mutation. */
["UpdateUpozorneniSkupinyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** An object where the defined keys will be set on the `UpozorneniSkupiny` being updated. */
	patch: ValueTypes["UpozorneniSkupinyPatch"] | Variable<any, string>,
	upsId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our update `User` mutation. */
["UpdateUserPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `User` that was updated by this mutation. */
	user?:ValueTypes["User"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `Permission` that is related to this `User`. */
	permissionByUGroup?:ValueTypes["Permission"],
	/** Reads a single `Skupiny` that is related to this `User`. */
	skupinyByUSkupina?:ValueTypes["Skupiny"],
userEdge?: [{	/** The method to use when ordering `User`. */
	orderBy?: Array<ValueTypes["UsersOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["UsersEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateUserByNodeId` mutation. */
["UpdateUserByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `User` to be updated. */
	nodeId: string | Variable<any, string>,
	/** An object where the defined keys will be set on the `User` being updated. */
	patch: ValueTypes["UserPatch"] | Variable<any, string>
};
	/** Represents an update to a `User`. Fields that are set will be updated. */
["UserPatch"]: {
	uId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	uLogin?: string | undefined | null | Variable<any, string>,
	uPass?: string | undefined | null | Variable<any, string>,
	uJmeno?: string | undefined | null | Variable<any, string>,
	uPrijmeni?: string | undefined | null | Variable<any, string>,
	uPohlavi?: string | undefined | null | Variable<any, string>,
	uEmail?: string | undefined | null | Variable<any, string>,
	uTelefon?: string | undefined | null | Variable<any, string>,
	uNarozeni?: ValueTypes["Date"] | undefined | null | Variable<any, string>,
	uRodneCislo?: string | undefined | null | Variable<any, string>,
	uPoznamky?: string | undefined | null | Variable<any, string>,
	uTimestamp?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	uLevel?: number | undefined | null | Variable<any, string>,
	uGroup?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	uSkupina?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	uDancer?: boolean | undefined | null | Variable<any, string>,
	uBan?: boolean | undefined | null | Variable<any, string>,
	uLock?: boolean | undefined | null | Variable<any, string>,
	uConfirmed?: boolean | undefined | null | Variable<any, string>,
	uSystem?: boolean | undefined | null | Variable<any, string>,
	uStreet?: string | undefined | null | Variable<any, string>,
	uConscriptionNumber?: string | undefined | null | Variable<any, string>,
	uOrientationNumber?: string | undefined | null | Variable<any, string>,
	uDistrict?: string | undefined | null | Variable<any, string>,
	uCity?: string | undefined | null | Variable<any, string>,
	uPostalCode?: string | undefined | null | Variable<any, string>,
	uNationality?: string | undefined | null | Variable<any, string>,
	uMemberSince?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	uMemberUntil?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	uCreatedAt?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	uTeacher?: boolean | undefined | null | Variable<any, string>,
	uGdprSignedAt?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	/** All input for the `updateUser` mutation. */
["UpdateUserInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** An object where the defined keys will be set on the `User` being updated. */
	patch: ValueTypes["UserPatch"] | Variable<any, string>,
	uId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our update `UsersSkupiny` mutation. */
["UpdateUsersSkupinyPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `UsersSkupiny` that was updated by this mutation. */
	usersSkupiny?:ValueTypes["UsersSkupiny"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
usersSkupinyEdge?: [{	/** The method to use when ordering `UsersSkupiny`. */
	orderBy?: Array<ValueTypes["UsersSkupiniesOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["UsersSkupiniesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateUsersSkupinyByNodeId` mutation. */
["UpdateUsersSkupinyByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `UsersSkupiny` to be updated. */
	nodeId: string | Variable<any, string>,
	/** An object where the defined keys will be set on the `UsersSkupiny` being updated. */
	patch: ValueTypes["UsersSkupinyPatch"] | Variable<any, string>
};
	/** Represents an update to a `UsersSkupiny`. Fields that are set will be updated. */
["UsersSkupinyPatch"]: {
	usId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	usColor?: string | undefined | null | Variable<any, string>,
	usPlatbaMesic?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	usPlatbaCtvrtrok?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	usPlatbaPulrok?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	usPopis?: string | undefined | null | Variable<any, string>
};
	/** All input for the `updateUsersSkupiny` mutation. */
["UpdateUsersSkupinyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** An object where the defined keys will be set on the `UsersSkupiny` being updated. */
	patch: ValueTypes["UsersSkupinyPatch"] | Variable<any, string>,
	usId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our update `Video` mutation. */
["UpdateVideoPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Video` that was updated by this mutation. */
	video?:ValueTypes["Video"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
videoEdge?: [{	/** The method to use when ordering `Video`. */
	orderBy?: Array<ValueTypes["VideosOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["VideosEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateVideoByNodeId` mutation. */
["UpdateVideoByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `Video` to be updated. */
	nodeId: string | Variable<any, string>,
	/** An object where the defined keys will be set on the `Video` being updated. */
	patch: ValueTypes["VideoPatch"] | Variable<any, string>
};
	/** Represents an update to a `Video`. Fields that are set will be updated. */
["VideoPatch"]: {
	vId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	vUri?: string | undefined | null | Variable<any, string>,
	vTitle?: string | undefined | null | Variable<any, string>,
	vAuthor?: string | undefined | null | Variable<any, string>,
	vDescription?: string | undefined | null | Variable<any, string>,
	vPlaylist?: string | undefined | null | Variable<any, string>,
	vCreatedAt?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	vUpdatedAt?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	/** All input for the `updateVideo` mutation. */
["UpdateVideoInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** An object where the defined keys will be set on the `Video` being updated. */
	patch: ValueTypes["VideoPatch"] | Variable<any, string>,
	vId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our update `VideoList` mutation. */
["UpdateVideoListPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `VideoList` that was updated by this mutation. */
	videoList?:ValueTypes["VideoList"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
videoListEdge?: [{	/** The method to use when ordering `VideoList`. */
	orderBy?: Array<ValueTypes["VideoListsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["VideoListsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateVideoListByNodeId` mutation. */
["UpdateVideoListByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `VideoList` to be updated. */
	nodeId: string | Variable<any, string>,
	/** An object where the defined keys will be set on the `VideoList` being updated. */
	patch: ValueTypes["VideoListPatch"] | Variable<any, string>
};
	/** Represents an update to a `VideoList`. Fields that are set will be updated. */
["VideoListPatch"]: {
	vlId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	vlUrl?: string | undefined | null | Variable<any, string>,
	vlTitle?: string | undefined | null | Variable<any, string>,
	vlDescription?: string | undefined | null | Variable<any, string>,
	vlCount?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	vlCreatedAt?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	vlLastChecked?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	/** All input for the `updateVideoList` mutation. */
["UpdateVideoListInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** An object where the defined keys will be set on the `VideoList` being updated. */
	patch: ValueTypes["VideoListPatch"] | Variable<any, string>,
	vlId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our update `VideoSource` mutation. */
["UpdateVideoSourcePayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `VideoSource` that was updated by this mutation. */
	videoSource?:ValueTypes["VideoSource"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
videoSourceEdge?: [{	/** The method to use when ordering `VideoSource`. */
	orderBy?: Array<ValueTypes["VideoSourcesOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["VideoSourcesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateVideoSourceByNodeId` mutation. */
["UpdateVideoSourceByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `VideoSource` to be updated. */
	nodeId: string | Variable<any, string>,
	/** An object where the defined keys will be set on the `VideoSource` being updated. */
	patch: ValueTypes["VideoSourcePatch"] | Variable<any, string>
};
	/** Represents an update to a `VideoSource`. Fields that are set will be updated. */
["VideoSourcePatch"]: {
	vsId?: ValueTypes["BigInt"] | undefined | null | Variable<any, string>,
	vsUrl?: string | undefined | null | Variable<any, string>,
	vsTitle?: string | undefined | null | Variable<any, string>,
	vsDescription?: string | undefined | null | Variable<any, string>,
	vsCreatedAt?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>,
	vsLastChecked?: ValueTypes["Datetime"] | undefined | null | Variable<any, string>
};
	/** All input for the `updateVideoSource` mutation. */
["UpdateVideoSourceInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** An object where the defined keys will be set on the `VideoSource` being updated. */
	patch: ValueTypes["VideoSourcePatch"] | Variable<any, string>,
	vsId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our delete `Akce` mutation. */
["DeleteAkcePayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Akce` that was deleted by this mutation. */
	akce?:ValueTypes["Akce"],
	deletedAkceNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
akceEdge?: [{	/** The method to use when ordering `Akce`. */
	orderBy?: Array<ValueTypes["AkcesOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["AkcesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteAkceByNodeId` mutation. */
["DeleteAkceByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `Akce` to be deleted. */
	nodeId: string | Variable<any, string>
};
	/** All input for the `deleteAkce` mutation. */
["DeleteAkceInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	aId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our delete `AkceItem` mutation. */
["DeleteAkceItemPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `AkceItem` that was deleted by this mutation. */
	akceItem?:ValueTypes["AkceItem"],
	deletedAkceItemNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `Akce` that is related to this `AkceItem`. */
	akceByAiIdRodic?:ValueTypes["Akce"],
	/** Reads a single `User` that is related to this `AkceItem`. */
	userByAiUser?:ValueTypes["User"],
akceItemEdge?: [{	/** The method to use when ordering `AkceItem`. */
	orderBy?: Array<ValueTypes["AkceItemsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["AkceItemsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteAkceItemByNodeId` mutation. */
["DeleteAkceItemByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `AkceItem` to be deleted. */
	nodeId: string | Variable<any, string>
};
	/** All input for the `deleteAkceItem` mutation. */
["DeleteAkceItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	aiId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our delete `Aktuality` mutation. */
["DeleteAktualityPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Aktuality` that was deleted by this mutation. */
	aktuality?:ValueTypes["Aktuality"],
	deletedAktualityNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `User` that is related to this `Aktuality`. */
	userByAtKdo?:ValueTypes["User"],
	/** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
	galerieFotoByAtFotoMain?:ValueTypes["GalerieFoto"],
aktualityEdge?: [{	/** The method to use when ordering `Aktuality`. */
	orderBy?: Array<ValueTypes["AktualitiesOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["AktualitiesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteAktualityByNodeId` mutation. */
["DeleteAktualityByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `Aktuality` to be deleted. */
	nodeId: string | Variable<any, string>
};
	/** All input for the `deleteAktuality` mutation. */
["DeleteAktualityInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	atId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our delete `Dokumenty` mutation. */
["DeleteDokumentyPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Dokumenty` that was deleted by this mutation. */
	dokumenty?:ValueTypes["Dokumenty"],
	deletedDokumentyNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `User` that is related to this `Dokumenty`. */
	userByDKdo?:ValueTypes["User"],
dokumentyEdge?: [{	/** The method to use when ordering `Dokumenty`. */
	orderBy?: Array<ValueTypes["DokumentiesOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["DokumentiesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteDokumentyByNodeId` mutation. */
["DeleteDokumentyByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `Dokumenty` to be deleted. */
	nodeId: string | Variable<any, string>
};
	/** All input for the `deleteDokumenty` mutation. */
["DeleteDokumentyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	dId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our delete `GalerieDir` mutation. */
["DeleteGalerieDirPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `GalerieDir` that was deleted by this mutation. */
	galerieDir?:ValueTypes["GalerieDir"],
	deletedGalerieDirNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
galerieDirEdge?: [{	/** The method to use when ordering `GalerieDir`. */
	orderBy?: Array<ValueTypes["GalerieDirsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["GalerieDirsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteGalerieDirByNodeId` mutation. */
["DeleteGalerieDirByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `GalerieDir` to be deleted. */
	nodeId: string | Variable<any, string>
};
	/** All input for the `deleteGalerieDir` mutation. */
["DeleteGalerieDirInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	gdId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our delete `GalerieFoto` mutation. */
["DeleteGalerieFotoPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `GalerieFoto` that was deleted by this mutation. */
	galerieFoto?:ValueTypes["GalerieFoto"],
	deletedGalerieFotoNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
	galerieDirByGfIdRodic?:ValueTypes["GalerieDir"],
	/** Reads a single `User` that is related to this `GalerieFoto`. */
	userByGfKdo?:ValueTypes["User"],
galerieFotoEdge?: [{	/** The method to use when ordering `GalerieFoto`. */
	orderBy?: Array<ValueTypes["GalerieFotosOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["GalerieFotosEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteGalerieFotoByNodeId` mutation. */
["DeleteGalerieFotoByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `GalerieFoto` to be deleted. */
	nodeId: string | Variable<any, string>
};
	/** All input for the `deleteGalerieFoto` mutation. */
["DeleteGalerieFotoInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	gfId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our delete `Nabidka` mutation. */
["DeleteNabidkaPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Nabidka` that was deleted by this mutation. */
	nabidka?:ValueTypes["Nabidka"],
	deletedNabidkaNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `User` that is related to this `Nabidka`. */
	userByNTrener?:ValueTypes["User"],
nabidkaEdge?: [{	/** The method to use when ordering `Nabidka`. */
	orderBy?: Array<ValueTypes["NabidkasOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["NabidkasEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteNabidkaByNodeId` mutation. */
["DeleteNabidkaByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `Nabidka` to be deleted. */
	nodeId: string | Variable<any, string>
};
	/** All input for the `deleteNabidka` mutation. */
["DeleteNabidkaInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	nId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our delete `NabidkaItem` mutation. */
["DeleteNabidkaItemPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `NabidkaItem` that was deleted by this mutation. */
	nabidkaItem?:ValueTypes["NabidkaItem"],
	deletedNabidkaItemNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `Nabidka` that is related to this `NabidkaItem`. */
	nabidkaByNiIdRodic?:ValueTypes["Nabidka"],
	/** Reads a single `Pary` that is related to this `NabidkaItem`. */
	paryByNiPartner?:ValueTypes["Pary"],
nabidkaItemEdge?: [{	/** The method to use when ordering `NabidkaItem`. */
	orderBy?: Array<ValueTypes["NabidkaItemsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["NabidkaItemsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteNabidkaItemByNodeId` mutation. */
["DeleteNabidkaItemByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `NabidkaItem` to be deleted. */
	nodeId: string | Variable<any, string>
};
	/** All input for the `deleteNabidkaItem` mutation. */
["DeleteNabidkaItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	niId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our delete `Parameter` mutation. */
["DeleteParameterPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Parameter` that was deleted by this mutation. */
	parameter?:ValueTypes["Parameter"],
	deletedParameterNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
parameterEdge?: [{	/** The method to use when ordering `Parameter`. */
	orderBy?: Array<ValueTypes["ParametersOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["ParametersEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteParameterByNodeId` mutation. */
["DeleteParameterByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `Parameter` to be deleted. */
	nodeId: string | Variable<any, string>
};
	/** All input for the `deleteParameter` mutation. */
["DeleteParameterInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	paName: string | Variable<any, string>
};
	/** The output of our delete `Pary` mutation. */
["DeleteParyPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Pary` that was deleted by this mutation. */
	pary?:ValueTypes["Pary"],
	deletedParyNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `User` that is related to this `Pary`. */
	userByPIdPartner?:ValueTypes["User"],
paryEdge?: [{	/** The method to use when ordering `Pary`. */
	orderBy?: Array<ValueTypes["PariesOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["PariesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteParyByNodeId` mutation. */
["DeleteParyByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `Pary` to be deleted. */
	nodeId: string | Variable<any, string>
};
	/** All input for the `deletePary` mutation. */
["DeleteParyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	pId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our delete `ParyNavrh` mutation. */
["DeleteParyNavrhPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `ParyNavrh` that was deleted by this mutation. */
	paryNavrh?:ValueTypes["ParyNavrh"],
	deletedParyNavrhNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnNavrhl?:ValueTypes["User"],
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnPartner?:ValueTypes["User"],
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnPartnerka?:ValueTypes["User"],
paryNavrhEdge?: [{	/** The method to use when ordering `ParyNavrh`. */
	orderBy?: Array<ValueTypes["ParyNavrhsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["ParyNavrhsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteParyNavrhByNodeId` mutation. */
["DeleteParyNavrhByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `ParyNavrh` to be deleted. */
	nodeId: string | Variable<any, string>
};
	/** All input for the `deleteParyNavrh` mutation. */
["DeleteParyNavrhInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	pnId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our delete `Permission` mutation. */
["DeletePermissionPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Permission` that was deleted by this mutation. */
	permission?:ValueTypes["Permission"],
	deletedPermissionNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
permissionEdge?: [{	/** The method to use when ordering `Permission`. */
	orderBy?: Array<ValueTypes["PermissionsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["PermissionsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deletePermissionByNodeId` mutation. */
["DeletePermissionByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `Permission` to be deleted. */
	nodeId: string | Variable<any, string>
};
	/** All input for the `deletePermission` mutation. */
["DeletePermissionInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	peId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our delete `PlatbyCategory` mutation. */
["DeletePlatbyCategoryPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyCategory` that was deleted by this mutation. */
	platbyCategory?:ValueTypes["PlatbyCategory"],
	deletedPlatbyCategoryNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
platbyCategoryEdge?: [{	/** The method to use when ordering `PlatbyCategory`. */
	orderBy?: Array<ValueTypes["PlatbyCategoriesOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["PlatbyCategoriesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deletePlatbyCategoryByNodeId` mutation. */
["DeletePlatbyCategoryByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `PlatbyCategory` to be deleted. */
	nodeId: string | Variable<any, string>
};
	/** All input for the `deletePlatbyCategory` mutation. */
["DeletePlatbyCategoryInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	pcId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our delete `PlatbyCategoryGroup` mutation. */
["DeletePlatbyCategoryGroupPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyCategoryGroup` that was deleted by this mutation. */
	platbyCategoryGroup?:ValueTypes["PlatbyCategoryGroup"],
	deletedPlatbyCategoryGroupNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `PlatbyGroup` that is related to this `PlatbyCategoryGroup`. */
	platbyGroupByPcgIdGroup?:ValueTypes["PlatbyGroup"],
	/** Reads a single `PlatbyCategory` that is related to this `PlatbyCategoryGroup`. */
	platbyCategoryByPcgIdCategory?:ValueTypes["PlatbyCategory"],
platbyCategoryGroupEdge?: [{	/** The method to use when ordering `PlatbyCategoryGroup`. */
	orderBy?: Array<ValueTypes["PlatbyCategoryGroupsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["PlatbyCategoryGroupsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deletePlatbyCategoryGroupByNodeId` mutation. */
["DeletePlatbyCategoryGroupByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `PlatbyCategoryGroup` to be deleted. */
	nodeId: string | Variable<any, string>
};
	/** All input for the `deletePlatbyCategoryGroup` mutation. */
["DeletePlatbyCategoryGroupInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	pcgId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our delete `PlatbyGroup` mutation. */
["DeletePlatbyGroupPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyGroup` that was deleted by this mutation. */
	platbyGroup?:ValueTypes["PlatbyGroup"],
	deletedPlatbyGroupNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
platbyGroupEdge?: [{	/** The method to use when ordering `PlatbyGroup`. */
	orderBy?: Array<ValueTypes["PlatbyGroupsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["PlatbyGroupsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deletePlatbyGroupByNodeId` mutation. */
["DeletePlatbyGroupByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `PlatbyGroup` to be deleted. */
	nodeId: string | Variable<any, string>
};
	/** All input for the `deletePlatbyGroup` mutation. */
["DeletePlatbyGroupInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	pgId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our delete `PlatbyGroupSkupina` mutation. */
["DeletePlatbyGroupSkupinaPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyGroupSkupina` that was deleted by this mutation. */
	platbyGroupSkupina?:ValueTypes["PlatbyGroupSkupina"],
	deletedPlatbyGroupSkupinaNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `Skupiny` that is related to this `PlatbyGroupSkupina`. */
	skupinyByPgsIdSkupina?:ValueTypes["Skupiny"],
	/** Reads a single `PlatbyGroup` that is related to this `PlatbyGroupSkupina`. */
	platbyGroupByPgsIdGroup?:ValueTypes["PlatbyGroup"],
platbyGroupSkupinaEdge?: [{	/** The method to use when ordering `PlatbyGroupSkupina`. */
	orderBy?: Array<ValueTypes["PlatbyGroupSkupinasOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["PlatbyGroupSkupinasEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deletePlatbyGroupSkupinaByNodeId` mutation. */
["DeletePlatbyGroupSkupinaByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `PlatbyGroupSkupina` to be deleted. */
	nodeId: string | Variable<any, string>
};
	/** All input for the `deletePlatbyGroupSkupina` mutation. */
["DeletePlatbyGroupSkupinaInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	pgsId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our delete `PlatbyItem` mutation. */
["DeletePlatbyItemPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyItem` that was deleted by this mutation. */
	platbyItem?:ValueTypes["PlatbyItem"],
	deletedPlatbyItemNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `User` that is related to this `PlatbyItem`. */
	userByPiIdUser?:ValueTypes["User"],
	/** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
	platbyCategoryByPiIdCategory?:ValueTypes["PlatbyCategory"],
	/** Reads a single `PlatbyRaw` that is related to this `PlatbyItem`. */
	platbyRawByPiIdRaw?:ValueTypes["PlatbyRaw"],
platbyItemEdge?: [{	/** The method to use when ordering `PlatbyItem`. */
	orderBy?: Array<ValueTypes["PlatbyItemsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["PlatbyItemsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deletePlatbyItemByNodeId` mutation. */
["DeletePlatbyItemByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `PlatbyItem` to be deleted. */
	nodeId: string | Variable<any, string>
};
	/** All input for the `deletePlatbyItem` mutation. */
["DeletePlatbyItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	piId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our delete `PlatbyRaw` mutation. */
["DeletePlatbyRawPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyRaw` that was deleted by this mutation. */
	platbyRaw?:ValueTypes["PlatbyRaw"],
	deletedPlatbyRawNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
platbyRawEdge?: [{	/** The method to use when ordering `PlatbyRaw`. */
	orderBy?: Array<ValueTypes["PlatbyRawsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["PlatbyRawsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deletePlatbyRawByNodeId` mutation. */
["DeletePlatbyRawByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `PlatbyRaw` to be deleted. */
	nodeId: string | Variable<any, string>
};
	/** All input for the `deletePlatbyRaw` mutation. */
["DeletePlatbyRawInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	prId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our delete `Rozpi` mutation. */
["DeleteRozpiPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Rozpi` that was deleted by this mutation. */
	rozpi?:ValueTypes["Rozpi"],
	deletedRozpiNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `User` that is related to this `Rozpi`. */
	userByRTrener?:ValueTypes["User"],
rozpiEdge?: [{	/** The method to use when ordering `Rozpi`. */
	orderBy?: Array<ValueTypes["RozpisOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["RozpisEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteRozpiByNodeId` mutation. */
["DeleteRozpiByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `Rozpi` to be deleted. */
	nodeId: string | Variable<any, string>
};
	/** All input for the `deleteRozpi` mutation. */
["DeleteRozpiInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	rId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our delete `RozpisItem` mutation. */
["DeleteRozpisItemPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `RozpisItem` that was deleted by this mutation. */
	rozpisItem?:ValueTypes["RozpisItem"],
	deletedRozpisItemNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `Rozpi` that is related to this `RozpisItem`. */
	rozpiByRiIdRodic?:ValueTypes["Rozpi"],
	/** Reads a single `Pary` that is related to this `RozpisItem`. */
	paryByRiPartner?:ValueTypes["Pary"],
rozpisItemEdge?: [{	/** The method to use when ordering `RozpisItem`. */
	orderBy?: Array<ValueTypes["RozpisItemsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["RozpisItemsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteRozpisItemByNodeId` mutation. */
["DeleteRozpisItemByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `RozpisItem` to be deleted. */
	nodeId: string | Variable<any, string>
};
	/** All input for the `deleteRozpisItem` mutation. */
["DeleteRozpisItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	riId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our delete `Session` mutation. */
["DeleteSessionPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Session` that was deleted by this mutation. */
	session?:ValueTypes["Session"],
	deletedSessionNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `User` that is related to this `Session`. */
	userBySsUser?:ValueTypes["User"],
sessionEdge?: [{	/** The method to use when ordering `Session`. */
	orderBy?: Array<ValueTypes["SessionsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["SessionsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteSessionByNodeId` mutation. */
["DeleteSessionByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `Session` to be deleted. */
	nodeId: string | Variable<any, string>
};
	/** All input for the `deleteSession` mutation. */
["DeleteSessionInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	ssId: string | Variable<any, string>
};
	/** The output of our delete `Skupiny` mutation. */
["DeleteSkupinyPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Skupiny` that was deleted by this mutation. */
	skupiny?:ValueTypes["Skupiny"],
	deletedSkupinyNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
skupinyEdge?: [{	/** The method to use when ordering `Skupiny`. */
	orderBy?: Array<ValueTypes["SkupiniesOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["SkupiniesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteSkupinyByNodeId` mutation. */
["DeleteSkupinyByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `Skupiny` to be deleted. */
	nodeId: string | Variable<any, string>
};
	/** All input for the `deleteSkupiny` mutation. */
["DeleteSkupinyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	sId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our delete `Upozorneni` mutation. */
["DeleteUpozorneniPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Upozorneni` that was deleted by this mutation. */
	upozorneni?:ValueTypes["Upozorneni"],
	deletedUpozorneniNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `User` that is related to this `Upozorneni`. */
	userByUpKdo?:ValueTypes["User"],
upozorneniEdge?: [{	/** The method to use when ordering `Upozorneni`. */
	orderBy?: Array<ValueTypes["UpozornenisOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["UpozornenisEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteUpozorneniByNodeId` mutation. */
["DeleteUpozorneniByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `Upozorneni` to be deleted. */
	nodeId: string | Variable<any, string>
};
	/** All input for the `deleteUpozorneni` mutation. */
["DeleteUpozorneniInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	upId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our delete `UpozorneniSkupiny` mutation. */
["DeleteUpozorneniSkupinyPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `UpozorneniSkupiny` that was deleted by this mutation. */
	upozorneniSkupiny?:ValueTypes["UpozorneniSkupiny"],
	deletedUpozorneniSkupinyNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
	upozorneniByUpsIdRodic?:ValueTypes["Upozorneni"],
	/** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
	skupinyByUpsIdSkupina?:ValueTypes["Skupiny"],
upozorneniSkupinyEdge?: [{	/** The method to use when ordering `UpozorneniSkupiny`. */
	orderBy?: Array<ValueTypes["UpozorneniSkupiniesOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["UpozorneniSkupiniesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteUpozorneniSkupinyByNodeId` mutation. */
["DeleteUpozorneniSkupinyByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `UpozorneniSkupiny` to be deleted. */
	nodeId: string | Variable<any, string>
};
	/** All input for the `deleteUpozorneniSkupiny` mutation. */
["DeleteUpozorneniSkupinyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	upsId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our delete `User` mutation. */
["DeleteUserPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `User` that was deleted by this mutation. */
	user?:ValueTypes["User"],
	deletedUserNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
	/** Reads a single `Permission` that is related to this `User`. */
	permissionByUGroup?:ValueTypes["Permission"],
	/** Reads a single `Skupiny` that is related to this `User`. */
	skupinyByUSkupina?:ValueTypes["Skupiny"],
userEdge?: [{	/** The method to use when ordering `User`. */
	orderBy?: Array<ValueTypes["UsersOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["UsersEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteUserByNodeId` mutation. */
["DeleteUserByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `User` to be deleted. */
	nodeId: string | Variable<any, string>
};
	/** All input for the `deleteUser` mutation. */
["DeleteUserInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	uId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our delete `UsersSkupiny` mutation. */
["DeleteUsersSkupinyPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `UsersSkupiny` that was deleted by this mutation. */
	usersSkupiny?:ValueTypes["UsersSkupiny"],
	deletedUsersSkupinyNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
usersSkupinyEdge?: [{	/** The method to use when ordering `UsersSkupiny`. */
	orderBy?: Array<ValueTypes["UsersSkupiniesOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["UsersSkupiniesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteUsersSkupinyByNodeId` mutation. */
["DeleteUsersSkupinyByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `UsersSkupiny` to be deleted. */
	nodeId: string | Variable<any, string>
};
	/** All input for the `deleteUsersSkupiny` mutation. */
["DeleteUsersSkupinyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	usId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our delete `Video` mutation. */
["DeleteVideoPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Video` that was deleted by this mutation. */
	video?:ValueTypes["Video"],
	deletedVideoNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
videoEdge?: [{	/** The method to use when ordering `Video`. */
	orderBy?: Array<ValueTypes["VideosOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["VideosEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteVideoByNodeId` mutation. */
["DeleteVideoByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `Video` to be deleted. */
	nodeId: string | Variable<any, string>
};
	/** All input for the `deleteVideo` mutation. */
["DeleteVideoInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	vId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our delete `VideoList` mutation. */
["DeleteVideoListPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `VideoList` that was deleted by this mutation. */
	videoList?:ValueTypes["VideoList"],
	deletedVideoListNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
videoListEdge?: [{	/** The method to use when ordering `VideoList`. */
	orderBy?: Array<ValueTypes["VideoListsOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["VideoListsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteVideoListByNodeId` mutation. */
["DeleteVideoListByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `VideoList` to be deleted. */
	nodeId: string | Variable<any, string>
};
	/** All input for the `deleteVideoList` mutation. */
["DeleteVideoListInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	vlId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our delete `VideoSource` mutation. */
["DeleteVideoSourcePayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `VideoSource` that was deleted by this mutation. */
	videoSource?:ValueTypes["VideoSource"],
	deletedVideoSourceNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
videoSourceEdge?: [{	/** The method to use when ordering `VideoSource`. */
	orderBy?: Array<ValueTypes["VideoSourcesOrderBy"]> | undefined | null | Variable<any, string>},ValueTypes["VideoSourcesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteVideoSourceByNodeId` mutation. */
["DeleteVideoSourceByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	/** The globally unique `ID` which will identify a single `VideoSource` to be deleted. */
	nodeId: string | Variable<any, string>
};
	/** All input for the `deleteVideoSource` mutation. */
["DeleteVideoSourceInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	vsId: ValueTypes["BigInt"] | Variable<any, string>
};
	/** The output of our `login` mutation. */
["LoginPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	result?:ValueTypes["LoginRecord"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
		__typename?: boolean | `@${string}`
}>;
	/** The return type of our `login` mutation. */
["LoginRecord"]: AliasType<{
	couple?:ValueTypes["Pary"],
	sess?:ValueTypes["Session"],
	usr?:ValueTypes["User"],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `login` mutation. */
["LoginInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	login: string | Variable<any, string>,
	passwd: string | Variable<any, string>
};
	/** The output of our `logout` mutation. */
["LogoutPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `logout` mutation. */
["LogoutInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>
};
	/** The output of our `prospectFormDancer` mutation. */
["ProspectFormDancerPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ValueTypes["Query"],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `prospectFormDancer` mutation. */
["ProspectFormDancerInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null | Variable<any, string>,
	cohort: ValueTypes["CrmCohort"] | Variable<any, string>,
	prospectData: ValueTypes["ProspectDatumInput"] | Variable<any, string>,
	origin: string | Variable<any, string>,
	note: string | Variable<any, string>
};
	/** An input for mutations affecting `ProspectDatum` */
["ProspectDatumInput"]: {
	name?: string | undefined | null | Variable<any, string>,
	surname?: string | undefined | null | Variable<any, string>,
	email?: string | undefined | null | Variable<any, string>,
	phone?: string | undefined | null | Variable<any, string>,
	yearofbirth?: string | undefined | null | Variable<any, string>
};
	["Upload"]: AliasType<{
	uploadUrl?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["UploadInput"]: {
	directory?: string | undefined | null | Variable<any, string>,
	filename: string | Variable<any, string>
}
  }

export type ResolverInputTypes = {
    /** The root query type which gives access points into the data universe. */
["Query"]: AliasType<{
	/** Exposes the root query type nested one level down. This is helpful for Relay 1
which can only query top level fields if they are in a particular form. */
	query?:ResolverInputTypes["Query"],
	/** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
	nodeId?:boolean | `@${string}`,
node?: [{	/** The globally unique `ID`. */
	nodeId: string},ResolverInputTypes["Node"]],
akces?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `Akce`. */
	orderBy?: Array<ResolverInputTypes["AkcesOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["AkceCondition"] | undefined | null},ResolverInputTypes["AkcesConnection"]],
akceItems?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `AkceItem`. */
	orderBy?: Array<ResolverInputTypes["AkceItemsOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["AkceItemCondition"] | undefined | null},ResolverInputTypes["AkceItemsConnection"]],
aktualities?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `Aktuality`. */
	orderBy?: Array<ResolverInputTypes["AktualitiesOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["AktualityCondition"] | undefined | null},ResolverInputTypes["AktualitiesConnection"]],
dokumenties?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `Dokumenty`. */
	orderBy?: Array<ResolverInputTypes["DokumentiesOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["DokumentyCondition"] | undefined | null},ResolverInputTypes["DokumentiesConnection"]],
galerieDirs?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `GalerieDir`. */
	orderBy?: Array<ResolverInputTypes["GalerieDirsOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["GalerieDirCondition"] | undefined | null},ResolverInputTypes["GalerieDirsConnection"]],
galerieFotos?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `GalerieFoto`. */
	orderBy?: Array<ResolverInputTypes["GalerieFotosOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["GalerieFotoCondition"] | undefined | null},ResolverInputTypes["GalerieFotosConnection"]],
members?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `Member`. */
	orderBy?: Array<ResolverInputTypes["MembersOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["MemberCondition"] | undefined | null},ResolverInputTypes["MembersConnection"]],
nabidkas?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `Nabidka`. */
	orderBy?: Array<ResolverInputTypes["NabidkasOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["NabidkaCondition"] | undefined | null},ResolverInputTypes["NabidkasConnection"]],
nabidkaItems?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `NabidkaItem`. */
	orderBy?: Array<ResolverInputTypes["NabidkaItemsOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["NabidkaItemCondition"] | undefined | null},ResolverInputTypes["NabidkaItemsConnection"]],
pages?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `Page`. */
	orderBy?: Array<ResolverInputTypes["PagesOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["PageCondition"] | undefined | null},ResolverInputTypes["PagesConnection"]],
pageRevisions?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `PageRevision`. */
	orderBy?: Array<ResolverInputTypes["PageRevisionsOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["PageRevisionCondition"] | undefined | null},ResolverInputTypes["PageRevisionsConnection"]],
parameters?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `Parameter`. */
	orderBy?: Array<ResolverInputTypes["ParametersOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["ParameterCondition"] | undefined | null},ResolverInputTypes["ParametersConnection"]],
paries?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `Pary`. */
	orderBy?: Array<ResolverInputTypes["PariesOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["ParyCondition"] | undefined | null},ResolverInputTypes["PariesConnection"]],
paryNavrhs?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `ParyNavrh`. */
	orderBy?: Array<ResolverInputTypes["ParyNavrhsOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["ParyNavrhCondition"] | undefined | null},ResolverInputTypes["ParyNavrhsConnection"]],
permissions?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `Permission`. */
	orderBy?: Array<ResolverInputTypes["PermissionsOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["PermissionCondition"] | undefined | null},ResolverInputTypes["PermissionsConnection"]],
platbyCategories?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `PlatbyCategory`. */
	orderBy?: Array<ResolverInputTypes["PlatbyCategoriesOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["PlatbyCategoryCondition"] | undefined | null},ResolverInputTypes["PlatbyCategoriesConnection"]],
platbyCategoryGroups?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `PlatbyCategoryGroup`. */
	orderBy?: Array<ResolverInputTypes["PlatbyCategoryGroupsOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["PlatbyCategoryGroupCondition"] | undefined | null},ResolverInputTypes["PlatbyCategoryGroupsConnection"]],
platbyGroups?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `PlatbyGroup`. */
	orderBy?: Array<ResolverInputTypes["PlatbyGroupsOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["PlatbyGroupCondition"] | undefined | null},ResolverInputTypes["PlatbyGroupsConnection"]],
platbyGroupSkupinas?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `PlatbyGroupSkupina`. */
	orderBy?: Array<ResolverInputTypes["PlatbyGroupSkupinasOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["PlatbyGroupSkupinaCondition"] | undefined | null},ResolverInputTypes["PlatbyGroupSkupinasConnection"]],
platbyItems?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `PlatbyItem`. */
	orderBy?: Array<ResolverInputTypes["PlatbyItemsOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["PlatbyItemCondition"] | undefined | null},ResolverInputTypes["PlatbyItemsConnection"]],
platbyRaws?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `PlatbyRaw`. */
	orderBy?: Array<ResolverInputTypes["PlatbyRawsOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["PlatbyRawCondition"] | undefined | null},ResolverInputTypes["PlatbyRawsConnection"]],
rozpis?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `Rozpi`. */
	orderBy?: Array<ResolverInputTypes["RozpisOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["RozpiCondition"] | undefined | null},ResolverInputTypes["RozpisConnection"]],
rozpisItems?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `RozpisItem`. */
	orderBy?: Array<ResolverInputTypes["RozpisItemsOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["RozpisItemCondition"] | undefined | null},ResolverInputTypes["RozpisItemsConnection"]],
sessions?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `Session`. */
	orderBy?: Array<ResolverInputTypes["SessionsOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["SessionCondition"] | undefined | null},ResolverInputTypes["SessionsConnection"]],
skupinies?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `Skupiny`. */
	orderBy?: Array<ResolverInputTypes["SkupiniesOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["SkupinyCondition"] | undefined | null},ResolverInputTypes["SkupiniesConnection"]],
upozornenis?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `Upozorneni`. */
	orderBy?: Array<ResolverInputTypes["UpozornenisOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["UpozorneniCondition"] | undefined | null},ResolverInputTypes["UpozornenisConnection"]],
upozorneniSkupinies?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `UpozorneniSkupiny`. */
	orderBy?: Array<ResolverInputTypes["UpozorneniSkupiniesOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["UpozorneniSkupinyCondition"] | undefined | null},ResolverInputTypes["UpozorneniSkupiniesConnection"]],
users?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `User`. */
	orderBy?: Array<ResolverInputTypes["UsersOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["UserCondition"] | undefined | null},ResolverInputTypes["UsersConnection"]],
usersSkupinies?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `UsersSkupiny`. */
	orderBy?: Array<ResolverInputTypes["UsersSkupiniesOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["UsersSkupinyCondition"] | undefined | null},ResolverInputTypes["UsersSkupiniesConnection"]],
videos?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `Video`. */
	orderBy?: Array<ResolverInputTypes["VideosOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["VideoCondition"] | undefined | null},ResolverInputTypes["VideosConnection"]],
videoLists?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `VideoList`. */
	orderBy?: Array<ResolverInputTypes["VideoListsOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["VideoListCondition"] | undefined | null},ResolverInputTypes["VideoListsConnection"]],
videoSources?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `VideoSource`. */
	orderBy?: Array<ResolverInputTypes["VideoSourcesOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["VideoSourceCondition"] | undefined | null},ResolverInputTypes["VideoSourcesConnection"]],
akce?: [{	aId: ResolverInputTypes["BigInt"]},ResolverInputTypes["Akce"]],
akceItem?: [{	aiId: ResolverInputTypes["BigInt"]},ResolverInputTypes["AkceItem"]],
aktuality?: [{	atId: ResolverInputTypes["BigInt"]},ResolverInputTypes["Aktuality"]],
dokumenty?: [{	dId: ResolverInputTypes["BigInt"]},ResolverInputTypes["Dokumenty"]],
galerieDir?: [{	gdId: ResolverInputTypes["BigInt"]},ResolverInputTypes["GalerieDir"]],
galerieFoto?: [{	gfId: ResolverInputTypes["BigInt"]},ResolverInputTypes["GalerieFoto"]],
nabidka?: [{	nId: ResolverInputTypes["BigInt"]},ResolverInputTypes["Nabidka"]],
nabidkaItem?: [{	niId: ResolverInputTypes["BigInt"]},ResolverInputTypes["NabidkaItem"]],
page?: [{	id: number},ResolverInputTypes["Page"]],
pageByUrl?: [{	url: string},ResolverInputTypes["Page"]],
pageRevision?: [{	revNumber: number,	id: number},ResolverInputTypes["PageRevision"]],
parameter?: [{	paName: string},ResolverInputTypes["Parameter"]],
pary?: [{	pId: ResolverInputTypes["BigInt"]},ResolverInputTypes["Pary"]],
paryNavrh?: [{	pnId: ResolverInputTypes["BigInt"]},ResolverInputTypes["ParyNavrh"]],
permission?: [{	peId: ResolverInputTypes["BigInt"]},ResolverInputTypes["Permission"]],
platbyCategory?: [{	pcId: ResolverInputTypes["BigInt"]},ResolverInputTypes["PlatbyCategory"]],
platbyCategoryGroup?: [{	pcgId: ResolverInputTypes["BigInt"]},ResolverInputTypes["PlatbyCategoryGroup"]],
platbyGroup?: [{	pgId: ResolverInputTypes["BigInt"]},ResolverInputTypes["PlatbyGroup"]],
platbyGroupSkupina?: [{	pgsId: ResolverInputTypes["BigInt"]},ResolverInputTypes["PlatbyGroupSkupina"]],
platbyItem?: [{	piId: ResolverInputTypes["BigInt"]},ResolverInputTypes["PlatbyItem"]],
platbyRaw?: [{	prId: ResolverInputTypes["BigInt"]},ResolverInputTypes["PlatbyRaw"]],
rozpi?: [{	rId: ResolverInputTypes["BigInt"]},ResolverInputTypes["Rozpi"]],
rozpisItem?: [{	riId: ResolverInputTypes["BigInt"]},ResolverInputTypes["RozpisItem"]],
session?: [{	ssId: string},ResolverInputTypes["Session"]],
skupiny?: [{	sId: ResolverInputTypes["BigInt"]},ResolverInputTypes["Skupiny"]],
upozorneni?: [{	upId: ResolverInputTypes["BigInt"]},ResolverInputTypes["Upozorneni"]],
upozorneniSkupiny?: [{	upsId: ResolverInputTypes["BigInt"]},ResolverInputTypes["UpozorneniSkupiny"]],
user?: [{	uId: ResolverInputTypes["BigInt"]},ResolverInputTypes["User"]],
usersSkupiny?: [{	usId: ResolverInputTypes["BigInt"]},ResolverInputTypes["UsersSkupiny"]],
video?: [{	vId: ResolverInputTypes["BigInt"]},ResolverInputTypes["Video"]],
videoList?: [{	vlId: ResolverInputTypes["BigInt"]},ResolverInputTypes["VideoList"]],
videoSource?: [{	vsId: ResolverInputTypes["BigInt"]},ResolverInputTypes["VideoSource"]],
activeProspects?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null},ResolverInputTypes["ActiveProspectsConnection"]],
cohortMembers?: [{	id?: number | undefined | null,	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null},ResolverInputTypes["MembersConnection"]],
currentCoupleIds?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null},ResolverInputTypes["CurrentCoupleIdsConnection"]],
	currentSessionId?:boolean | `@${string}`,
	currentUserId?:boolean | `@${string}`,
	getCurrentUser?:ResolverInputTypes["User"],
reservationsForRange?: [{	startDate?: ResolverInputTypes["Date"] | undefined | null,	endDate?: ResolverInputTypes["Date"] | undefined | null,	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null},ResolverInputTypes["NabidkasConnection"]],
schedulesForRange?: [{	startDate?: ResolverInputTypes["Date"] | undefined | null,	endDate?: ResolverInputTypes["Date"] | undefined | null,	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null},ResolverInputTypes["RozpisConnection"]],
titleVideos?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null},ResolverInputTypes["VideosConnection"]],
akceByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `Akce`. */
	nodeId: string},ResolverInputTypes["Akce"]],
akceItemByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `AkceItem`. */
	nodeId: string},ResolverInputTypes["AkceItem"]],
aktualityByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `Aktuality`. */
	nodeId: string},ResolverInputTypes["Aktuality"]],
dokumentyByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `Dokumenty`. */
	nodeId: string},ResolverInputTypes["Dokumenty"]],
galerieDirByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `GalerieDir`. */
	nodeId: string},ResolverInputTypes["GalerieDir"]],
galerieFotoByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `GalerieFoto`. */
	nodeId: string},ResolverInputTypes["GalerieFoto"]],
nabidkaByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `Nabidka`. */
	nodeId: string},ResolverInputTypes["Nabidka"]],
nabidkaItemByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `NabidkaItem`. */
	nodeId: string},ResolverInputTypes["NabidkaItem"]],
pageByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `Page`. */
	nodeId: string},ResolverInputTypes["Page"]],
pageRevisionByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `PageRevision`. */
	nodeId: string},ResolverInputTypes["PageRevision"]],
parameterByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `Parameter`. */
	nodeId: string},ResolverInputTypes["Parameter"]],
paryByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `Pary`. */
	nodeId: string},ResolverInputTypes["Pary"]],
paryNavrhByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `ParyNavrh`. */
	nodeId: string},ResolverInputTypes["ParyNavrh"]],
permissionByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `Permission`. */
	nodeId: string},ResolverInputTypes["Permission"]],
platbyCategoryByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `PlatbyCategory`. */
	nodeId: string},ResolverInputTypes["PlatbyCategory"]],
platbyCategoryGroupByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `PlatbyCategoryGroup`. */
	nodeId: string},ResolverInputTypes["PlatbyCategoryGroup"]],
platbyGroupByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `PlatbyGroup`. */
	nodeId: string},ResolverInputTypes["PlatbyGroup"]],
platbyGroupSkupinaByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `PlatbyGroupSkupina`. */
	nodeId: string},ResolverInputTypes["PlatbyGroupSkupina"]],
platbyItemByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `PlatbyItem`. */
	nodeId: string},ResolverInputTypes["PlatbyItem"]],
platbyRawByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `PlatbyRaw`. */
	nodeId: string},ResolverInputTypes["PlatbyRaw"]],
rozpiByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `Rozpi`. */
	nodeId: string},ResolverInputTypes["Rozpi"]],
rozpisItemByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `RozpisItem`. */
	nodeId: string},ResolverInputTypes["RozpisItem"]],
sessionByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `Session`. */
	nodeId: string},ResolverInputTypes["Session"]],
skupinyByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `Skupiny`. */
	nodeId: string},ResolverInputTypes["Skupiny"]],
upozorneniByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `Upozorneni`. */
	nodeId: string},ResolverInputTypes["Upozorneni"]],
upozorneniSkupinyByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `UpozorneniSkupiny`. */
	nodeId: string},ResolverInputTypes["UpozorneniSkupiny"]],
userByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `User`. */
	nodeId: string},ResolverInputTypes["User"]],
usersSkupinyByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `UsersSkupiny`. */
	nodeId: string},ResolverInputTypes["UsersSkupiny"]],
videoByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `Video`. */
	nodeId: string},ResolverInputTypes["Video"]],
videoListByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `VideoList`. */
	nodeId: string},ResolverInputTypes["VideoList"]],
videoSourceByNodeId?: [{	/** The globally unique `ID` to be used in selecting a single `VideoSource`. */
	nodeId: string},ResolverInputTypes["VideoSource"]],
		__typename?: boolean | `@${string}`
}>;
	/** An object with a globally unique `ID`. */
["Node"]:AliasType<{
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`;
		['...on Query']?: Omit<ResolverInputTypes["Query"],keyof ResolverInputTypes["Node"]>;
		['...on Akce']?: Omit<ResolverInputTypes["Akce"],keyof ResolverInputTypes["Node"]>;
		['...on AkceItem']?: Omit<ResolverInputTypes["AkceItem"],keyof ResolverInputTypes["Node"]>;
		['...on User']?: Omit<ResolverInputTypes["User"],keyof ResolverInputTypes["Node"]>;
		['...on Permission']?: Omit<ResolverInputTypes["Permission"],keyof ResolverInputTypes["Node"]>;
		['...on Skupiny']?: Omit<ResolverInputTypes["Skupiny"],keyof ResolverInputTypes["Node"]>;
		['...on PlatbyGroupSkupina']?: Omit<ResolverInputTypes["PlatbyGroupSkupina"],keyof ResolverInputTypes["Node"]>;
		['...on PlatbyGroup']?: Omit<ResolverInputTypes["PlatbyGroup"],keyof ResolverInputTypes["Node"]>;
		['...on PlatbyCategoryGroup']?: Omit<ResolverInputTypes["PlatbyCategoryGroup"],keyof ResolverInputTypes["Node"]>;
		['...on PlatbyCategory']?: Omit<ResolverInputTypes["PlatbyCategory"],keyof ResolverInputTypes["Node"]>;
		['...on PlatbyItem']?: Omit<ResolverInputTypes["PlatbyItem"],keyof ResolverInputTypes["Node"]>;
		['...on PlatbyRaw']?: Omit<ResolverInputTypes["PlatbyRaw"],keyof ResolverInputTypes["Node"]>;
		['...on UpozorneniSkupiny']?: Omit<ResolverInputTypes["UpozorneniSkupiny"],keyof ResolverInputTypes["Node"]>;
		['...on Upozorneni']?: Omit<ResolverInputTypes["Upozorneni"],keyof ResolverInputTypes["Node"]>;
		['...on Aktuality']?: Omit<ResolverInputTypes["Aktuality"],keyof ResolverInputTypes["Node"]>;
		['...on GalerieFoto']?: Omit<ResolverInputTypes["GalerieFoto"],keyof ResolverInputTypes["Node"]>;
		['...on GalerieDir']?: Omit<ResolverInputTypes["GalerieDir"],keyof ResolverInputTypes["Node"]>;
		['...on Nabidka']?: Omit<ResolverInputTypes["Nabidka"],keyof ResolverInputTypes["Node"]>;
		['...on NabidkaItem']?: Omit<ResolverInputTypes["NabidkaItem"],keyof ResolverInputTypes["Node"]>;
		['...on Pary']?: Omit<ResolverInputTypes["Pary"],keyof ResolverInputTypes["Node"]>;
		['...on RozpisItem']?: Omit<ResolverInputTypes["RozpisItem"],keyof ResolverInputTypes["Node"]>;
		['...on Rozpi']?: Omit<ResolverInputTypes["Rozpi"],keyof ResolverInputTypes["Node"]>;
		['...on Session']?: Omit<ResolverInputTypes["Session"],keyof ResolverInputTypes["Node"]>;
		['...on Dokumenty']?: Omit<ResolverInputTypes["Dokumenty"],keyof ResolverInputTypes["Node"]>;
		['...on ParyNavrh']?: Omit<ResolverInputTypes["ParyNavrh"],keyof ResolverInputTypes["Node"]>;
		['...on Page']?: Omit<ResolverInputTypes["Page"],keyof ResolverInputTypes["Node"]>;
		['...on PageRevision']?: Omit<ResolverInputTypes["PageRevision"],keyof ResolverInputTypes["Node"]>;
		['...on Parameter']?: Omit<ResolverInputTypes["Parameter"],keyof ResolverInputTypes["Node"]>;
		['...on UsersSkupiny']?: Omit<ResolverInputTypes["UsersSkupiny"],keyof ResolverInputTypes["Node"]>;
		['...on Video']?: Omit<ResolverInputTypes["Video"],keyof ResolverInputTypes["Node"]>;
		['...on VideoList']?: Omit<ResolverInputTypes["VideoList"],keyof ResolverInputTypes["Node"]>;
		['...on VideoSource']?: Omit<ResolverInputTypes["VideoSource"],keyof ResolverInputTypes["Node"]>;
		__typename?: boolean | `@${string}`
}>;
	/** A connection to a list of `Akce` values. */
["AkcesConnection"]: AliasType<{
	/** A list of `Akce` objects. */
	nodes?:ResolverInputTypes["Akce"],
	/** A list of edges which contains the `Akce` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["AkcesEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ResolverInputTypes["PageInfo"],
	/** The count of *all* `Akce` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["Akce"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	aId?:boolean | `@${string}`,
	aJmeno?:boolean | `@${string}`,
	aKde?:boolean | `@${string}`,
	aInfo?:boolean | `@${string}`,
	aOd?:boolean | `@${string}`,
	aDo?:boolean | `@${string}`,
	aKapacita?:boolean | `@${string}`,
	aDokumenty?:boolean | `@${string}`,
	aTimestamp?:boolean | `@${string}`,
	aLock?:boolean | `@${string}`,
	aVisible?:boolean | `@${string}`,
akceItemsByAiIdRodic?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `AkceItem`. */
	orderBy?: Array<ResolverInputTypes["AkceItemsOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["AkceItemCondition"] | undefined | null},ResolverInputTypes["AkceItemsConnection"]],
		__typename?: boolean | `@${string}`
}>;
	/** A signed eight-byte integer. The upper big integer values are greater than the
max value for a JavaScript number. Therefore all big integers will be output as
strings and not numbers. */
["BigInt"]:unknown;
	/** The day, does not include a time. */
["Date"]:unknown;
	/** A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone. */
["Datetime"]:unknown;
	/** A connection to a list of `AkceItem` values. */
["AkceItemsConnection"]: AliasType<{
	/** A list of `AkceItem` objects. */
	nodes?:ResolverInputTypes["AkceItem"],
	/** A list of edges which contains the `AkceItem` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["AkceItemsEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ResolverInputTypes["PageInfo"],
	/** The count of *all* `AkceItem` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["AkceItem"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	aiId?:boolean | `@${string}`,
	aiIdRodic?:boolean | `@${string}`,
	aiUser?:boolean | `@${string}`,
	aiRokNarozeni?:boolean | `@${string}`,
	/** Reads a single `Akce` that is related to this `AkceItem`. */
	akceByAiIdRodic?:ResolverInputTypes["Akce"],
	/** Reads a single `User` that is related to this `AkceItem`. */
	userByAiUser?:ResolverInputTypes["User"],
		__typename?: boolean | `@${string}`
}>;
	["User"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	uId?:boolean | `@${string}`,
	uLogin?:boolean | `@${string}`,
	uPass?:boolean | `@${string}`,
	uJmeno?:boolean | `@${string}`,
	uPrijmeni?:boolean | `@${string}`,
	uPohlavi?:boolean | `@${string}`,
	uEmail?:boolean | `@${string}`,
	uTelefon?:boolean | `@${string}`,
	uNarozeni?:boolean | `@${string}`,
	uRodneCislo?:boolean | `@${string}`,
	uPoznamky?:boolean | `@${string}`,
	uTimestamp?:boolean | `@${string}`,
	uLevel?:boolean | `@${string}`,
	uGroup?:boolean | `@${string}`,
	uSkupina?:boolean | `@${string}`,
	uDancer?:boolean | `@${string}`,
	uBan?:boolean | `@${string}`,
	uLock?:boolean | `@${string}`,
	uConfirmed?:boolean | `@${string}`,
	uSystem?:boolean | `@${string}`,
	uStreet?:boolean | `@${string}`,
	uConscriptionNumber?:boolean | `@${string}`,
	uOrientationNumber?:boolean | `@${string}`,
	uDistrict?:boolean | `@${string}`,
	uCity?:boolean | `@${string}`,
	uPostalCode?:boolean | `@${string}`,
	uNationality?:boolean | `@${string}`,
	uMemberSince?:boolean | `@${string}`,
	uMemberUntil?:boolean | `@${string}`,
	uCreatedAt?:boolean | `@${string}`,
	uTeacher?:boolean | `@${string}`,
	uGdprSignedAt?:boolean | `@${string}`,
	/** Reads a single `Permission` that is related to this `User`. */
	permissionByUGroup?:ResolverInputTypes["Permission"],
	/** Reads a single `Skupiny` that is related to this `User`. */
	skupinyByUSkupina?:ResolverInputTypes["Skupiny"],
aktualitiesByAtKdo?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `Aktuality`. */
	orderBy?: Array<ResolverInputTypes["AktualitiesOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["AktualityCondition"] | undefined | null},ResolverInputTypes["AktualitiesConnection"]],
nabidkasByNTrener?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `Nabidka`. */
	orderBy?: Array<ResolverInputTypes["NabidkasOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["NabidkaCondition"] | undefined | null},ResolverInputTypes["NabidkasConnection"]],
rozpisByRTrener?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `Rozpi`. */
	orderBy?: Array<ResolverInputTypes["RozpisOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["RozpiCondition"] | undefined | null},ResolverInputTypes["RozpisConnection"]],
platbyItemsByPiIdUser?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `PlatbyItem`. */
	orderBy?: Array<ResolverInputTypes["PlatbyItemsOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["PlatbyItemCondition"] | undefined | null},ResolverInputTypes["PlatbyItemsConnection"]],
pariesByPIdPartner?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `Pary`. */
	orderBy?: Array<ResolverInputTypes["PariesOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["ParyCondition"] | undefined | null},ResolverInputTypes["PariesConnection"]],
sessionsBySsUser?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `Session`. */
	orderBy?: Array<ResolverInputTypes["SessionsOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["SessionCondition"] | undefined | null},ResolverInputTypes["SessionsConnection"]],
akceItemsByAiUser?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `AkceItem`. */
	orderBy?: Array<ResolverInputTypes["AkceItemsOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["AkceItemCondition"] | undefined | null},ResolverInputTypes["AkceItemsConnection"]],
dokumentiesByDKdo?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `Dokumenty`. */
	orderBy?: Array<ResolverInputTypes["DokumentiesOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["DokumentyCondition"] | undefined | null},ResolverInputTypes["DokumentiesConnection"]],
galerieFotosByGfKdo?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `GalerieFoto`. */
	orderBy?: Array<ResolverInputTypes["GalerieFotosOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["GalerieFotoCondition"] | undefined | null},ResolverInputTypes["GalerieFotosConnection"]],
paryNavrhsByPnNavrhl?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `ParyNavrh`. */
	orderBy?: Array<ResolverInputTypes["ParyNavrhsOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["ParyNavrhCondition"] | undefined | null},ResolverInputTypes["ParyNavrhsConnection"]],
paryNavrhsByPnPartner?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `ParyNavrh`. */
	orderBy?: Array<ResolverInputTypes["ParyNavrhsOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["ParyNavrhCondition"] | undefined | null},ResolverInputTypes["ParyNavrhsConnection"]],
paryNavrhsByPnPartnerka?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `ParyNavrh`. */
	orderBy?: Array<ResolverInputTypes["ParyNavrhsOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["ParyNavrhCondition"] | undefined | null},ResolverInputTypes["ParyNavrhsConnection"]],
upozornenisByUpKdo?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `Upozorneni`. */
	orderBy?: Array<ResolverInputTypes["UpozornenisOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["UpozorneniCondition"] | undefined | null},ResolverInputTypes["UpozornenisConnection"]],
		__typename?: boolean | `@${string}`
}>;
	["Permission"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	peId?:boolean | `@${string}`,
	peName?:boolean | `@${string}`,
	peDescription?:boolean | `@${string}`,
	peAkce?:boolean | `@${string}`,
	peAktuality?:boolean | `@${string}`,
	peAnkety?:boolean | `@${string}`,
	peDokumenty?:boolean | `@${string}`,
	peGalerie?:boolean | `@${string}`,
	peInzerce?:boolean | `@${string}`,
	peKonzole?:boolean | `@${string}`,
	peNabidka?:boolean | `@${string}`,
	peNastenka?:boolean | `@${string}`,
	peNovinky?:boolean | `@${string}`,
	pePary?:boolean | `@${string}`,
	pePlatby?:boolean | `@${string}`,
	pePermissions?:boolean | `@${string}`,
	peRozpis?:boolean | `@${string}`,
	peSkupiny?:boolean | `@${string}`,
	peUsers?:boolean | `@${string}`,
	peMain?:boolean | `@${string}`,
usersByUGroup?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `User`. */
	orderBy?: Array<ResolverInputTypes["UsersOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["UserCondition"] | undefined | null},ResolverInputTypes["UsersConnection"]],
		__typename?: boolean | `@${string}`
}>;
	/** A connection to a list of `User` values. */
["UsersConnection"]: AliasType<{
	/** A list of `User` objects. */
	nodes?:ResolverInputTypes["User"],
	/** A list of edges which contains the `User` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["UsersEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ResolverInputTypes["PageInfo"],
	/** The count of *all* `User` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `User` edge in the connection. */
["UsersEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `User` at the end of the edge. */
	node?:ResolverInputTypes["User"],
		__typename?: boolean | `@${string}`
}>;
	/** A location in a connection that can be used for resuming pagination. */
["Cursor"]:unknown;
	/** Information about pagination in a connection. */
["PageInfo"]: AliasType<{
	/** When paginating forwards, are there more items? */
	hasNextPage?:boolean | `@${string}`,
	/** When paginating backwards, are there more items? */
	hasPreviousPage?:boolean | `@${string}`,
	/** When paginating backwards, the cursor to continue. */
	startCursor?:boolean | `@${string}`,
	/** When paginating forwards, the cursor to continue. */
	endCursor?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `User`. */
["UsersOrderBy"]:UsersOrderBy;
	/** A condition to be used against `User` object types. All fields are tested for equality and combined with a logical and. */
["UserCondition"]: {
	/** Checks for equality with the objects `uId` field. */
	uId?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `uLogin` field. */
	uLogin?: string | undefined | null,
	/** Checks for equality with the objects `uPass` field. */
	uPass?: string | undefined | null,
	/** Checks for equality with the objects `uJmeno` field. */
	uJmeno?: string | undefined | null,
	/** Checks for equality with the objects `uPrijmeni` field. */
	uPrijmeni?: string | undefined | null,
	/** Checks for equality with the objects `uPohlavi` field. */
	uPohlavi?: string | undefined | null,
	/** Checks for equality with the objects `uEmail` field. */
	uEmail?: string | undefined | null,
	/** Checks for equality with the objects `uTelefon` field. */
	uTelefon?: string | undefined | null,
	/** Checks for equality with the objects `uNarozeni` field. */
	uNarozeni?: ResolverInputTypes["Date"] | undefined | null,
	/** Checks for equality with the objects `uRodneCislo` field. */
	uRodneCislo?: string | undefined | null,
	/** Checks for equality with the objects `uPoznamky` field. */
	uPoznamky?: string | undefined | null,
	/** Checks for equality with the objects `uTimestamp` field. */
	uTimestamp?: ResolverInputTypes["Datetime"] | undefined | null,
	/** Checks for equality with the objects `uLevel` field. */
	uLevel?: number | undefined | null,
	/** Checks for equality with the objects `uGroup` field. */
	uGroup?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `uSkupina` field. */
	uSkupina?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `uDancer` field. */
	uDancer?: boolean | undefined | null,
	/** Checks for equality with the objects `uBan` field. */
	uBan?: boolean | undefined | null,
	/** Checks for equality with the objects `uLock` field. */
	uLock?: boolean | undefined | null,
	/** Checks for equality with the objects `uConfirmed` field. */
	uConfirmed?: boolean | undefined | null,
	/** Checks for equality with the objects `uSystem` field. */
	uSystem?: boolean | undefined | null,
	/** Checks for equality with the objects `uStreet` field. */
	uStreet?: string | undefined | null,
	/** Checks for equality with the objects `uConscriptionNumber` field. */
	uConscriptionNumber?: string | undefined | null,
	/** Checks for equality with the objects `uOrientationNumber` field. */
	uOrientationNumber?: string | undefined | null,
	/** Checks for equality with the objects `uDistrict` field. */
	uDistrict?: string | undefined | null,
	/** Checks for equality with the objects `uCity` field. */
	uCity?: string | undefined | null,
	/** Checks for equality with the objects `uPostalCode` field. */
	uPostalCode?: string | undefined | null,
	/** Checks for equality with the objects `uNationality` field. */
	uNationality?: string | undefined | null,
	/** Checks for equality with the objects `uMemberSince` field. */
	uMemberSince?: ResolverInputTypes["Datetime"] | undefined | null,
	/** Checks for equality with the objects `uMemberUntil` field. */
	uMemberUntil?: ResolverInputTypes["Datetime"] | undefined | null,
	/** Checks for equality with the objects `uCreatedAt` field. */
	uCreatedAt?: ResolverInputTypes["Datetime"] | undefined | null,
	/** Checks for equality with the objects `uTeacher` field. */
	uTeacher?: boolean | undefined | null,
	/** Checks for equality with the objects `uGdprSignedAt` field. */
	uGdprSignedAt?: ResolverInputTypes["Datetime"] | undefined | null
};
	["Skupiny"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	sId?:boolean | `@${string}`,
	sName?:boolean | `@${string}`,
	sDescription?:boolean | `@${string}`,
	sColorRgb?:boolean | `@${string}`,
	sColorText?:boolean | `@${string}`,
	sLocation?:boolean | `@${string}`,
	sVisible?:boolean | `@${string}`,
usersByUSkupina?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `User`. */
	orderBy?: Array<ResolverInputTypes["UsersOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["UserCondition"] | undefined | null},ResolverInputTypes["UsersConnection"]],
platbyGroupSkupinasByPgsIdSkupina?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `PlatbyGroupSkupina`. */
	orderBy?: Array<ResolverInputTypes["PlatbyGroupSkupinasOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["PlatbyGroupSkupinaCondition"] | undefined | null},ResolverInputTypes["PlatbyGroupSkupinasConnection"]],
upozorneniSkupiniesByUpsIdSkupina?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `UpozorneniSkupiny`. */
	orderBy?: Array<ResolverInputTypes["UpozorneniSkupiniesOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["UpozorneniSkupinyCondition"] | undefined | null},ResolverInputTypes["UpozorneniSkupiniesConnection"]],
		__typename?: boolean | `@${string}`
}>;
	/** A connection to a list of `PlatbyGroupSkupina` values. */
["PlatbyGroupSkupinasConnection"]: AliasType<{
	/** A list of `PlatbyGroupSkupina` objects. */
	nodes?:ResolverInputTypes["PlatbyGroupSkupina"],
	/** A list of edges which contains the `PlatbyGroupSkupina` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["PlatbyGroupSkupinasEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ResolverInputTypes["PageInfo"],
	/** The count of *all* `PlatbyGroupSkupina` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["PlatbyGroupSkupina"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	pgsId?:boolean | `@${string}`,
	pgsIdSkupina?:boolean | `@${string}`,
	pgsIdGroup?:boolean | `@${string}`,
	/** Reads a single `Skupiny` that is related to this `PlatbyGroupSkupina`. */
	skupinyByPgsIdSkupina?:ResolverInputTypes["Skupiny"],
	/** Reads a single `PlatbyGroup` that is related to this `PlatbyGroupSkupina`. */
	platbyGroupByPgsIdGroup?:ResolverInputTypes["PlatbyGroup"],
		__typename?: boolean | `@${string}`
}>;
	["PlatbyGroup"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	pgId?:boolean | `@${string}`,
	pgType?:boolean | `@${string}`,
	pgName?:boolean | `@${string}`,
	pgDescription?:boolean | `@${string}`,
	pgBase?:boolean | `@${string}`,
platbyCategoryGroupsByPcgIdGroup?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `PlatbyCategoryGroup`. */
	orderBy?: Array<ResolverInputTypes["PlatbyCategoryGroupsOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["PlatbyCategoryGroupCondition"] | undefined | null},ResolverInputTypes["PlatbyCategoryGroupsConnection"]],
platbyGroupSkupinasByPgsIdGroup?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `PlatbyGroupSkupina`. */
	orderBy?: Array<ResolverInputTypes["PlatbyGroupSkupinasOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["PlatbyGroupSkupinaCondition"] | undefined | null},ResolverInputTypes["PlatbyGroupSkupinasConnection"]],
		__typename?: boolean | `@${string}`
}>;
	/** A floating point number that requires more precision than IEEE 754 binary 64 */
["BigFloat"]:unknown;
	/** A connection to a list of `PlatbyCategoryGroup` values. */
["PlatbyCategoryGroupsConnection"]: AliasType<{
	/** A list of `PlatbyCategoryGroup` objects. */
	nodes?:ResolverInputTypes["PlatbyCategoryGroup"],
	/** A list of edges which contains the `PlatbyCategoryGroup` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["PlatbyCategoryGroupsEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ResolverInputTypes["PageInfo"],
	/** The count of *all* `PlatbyCategoryGroup` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["PlatbyCategoryGroup"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	pcgId?:boolean | `@${string}`,
	pcgIdGroup?:boolean | `@${string}`,
	pcgIdCategory?:boolean | `@${string}`,
	/** Reads a single `PlatbyGroup` that is related to this `PlatbyCategoryGroup`. */
	platbyGroupByPcgIdGroup?:ResolverInputTypes["PlatbyGroup"],
	/** Reads a single `PlatbyCategory` that is related to this `PlatbyCategoryGroup`. */
	platbyCategoryByPcgIdCategory?:ResolverInputTypes["PlatbyCategory"],
		__typename?: boolean | `@${string}`
}>;
	["PlatbyCategory"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	pcId?:boolean | `@${string}`,
	pcName?:boolean | `@${string}`,
	pcSymbol?:boolean | `@${string}`,
	pcAmount?:boolean | `@${string}`,
	pcDateDue?:boolean | `@${string}`,
	pcValidFrom?:boolean | `@${string}`,
	pcValidTo?:boolean | `@${string}`,
	pcUseBase?:boolean | `@${string}`,
	pcUsePrefix?:boolean | `@${string}`,
	pcArchive?:boolean | `@${string}`,
	pcVisible?:boolean | `@${string}`,
platbyCategoryGroupsByPcgIdCategory?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `PlatbyCategoryGroup`. */
	orderBy?: Array<ResolverInputTypes["PlatbyCategoryGroupsOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["PlatbyCategoryGroupCondition"] | undefined | null},ResolverInputTypes["PlatbyCategoryGroupsConnection"]],
platbyItemsByPiIdCategory?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `PlatbyItem`. */
	orderBy?: Array<ResolverInputTypes["PlatbyItemsOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["PlatbyItemCondition"] | undefined | null},ResolverInputTypes["PlatbyItemsConnection"]],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `PlatbyCategoryGroup`. */
["PlatbyCategoryGroupsOrderBy"]:PlatbyCategoryGroupsOrderBy;
	/** A condition to be used against `PlatbyCategoryGroup` object types. All fields
are tested for equality and combined with a logical and. */
["PlatbyCategoryGroupCondition"]: {
	/** Checks for equality with the objects `pcgId` field. */
	pcgId?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `pcgIdGroup` field. */
	pcgIdGroup?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `pcgIdCategory` field. */
	pcgIdCategory?: ResolverInputTypes["BigInt"] | undefined | null
};
	/** A connection to a list of `PlatbyItem` values. */
["PlatbyItemsConnection"]: AliasType<{
	/** A list of `PlatbyItem` objects. */
	nodes?:ResolverInputTypes["PlatbyItem"],
	/** A list of edges which contains the `PlatbyItem` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["PlatbyItemsEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ResolverInputTypes["PageInfo"],
	/** The count of *all* `PlatbyItem` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["PlatbyItem"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	piId?:boolean | `@${string}`,
	piIdUser?:boolean | `@${string}`,
	piIdCategory?:boolean | `@${string}`,
	piIdRaw?:boolean | `@${string}`,
	piAmount?:boolean | `@${string}`,
	piDate?:boolean | `@${string}`,
	piPrefix?:boolean | `@${string}`,
	/** Reads a single `User` that is related to this `PlatbyItem`. */
	userByPiIdUser?:ResolverInputTypes["User"],
	/** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
	platbyCategoryByPiIdCategory?:ResolverInputTypes["PlatbyCategory"],
	/** Reads a single `PlatbyRaw` that is related to this `PlatbyItem`. */
	platbyRawByPiIdRaw?:ResolverInputTypes["PlatbyRaw"],
		__typename?: boolean | `@${string}`
}>;
	["PlatbyRaw"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	prId?:boolean | `@${string}`,
	prRaw?:boolean | `@${string}`,
	prHash?:boolean | `@${string}`,
	prSorted?:boolean | `@${string}`,
	prDiscarded?:boolean | `@${string}`,
platbyItemsByPiIdRaw?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `PlatbyItem`. */
	orderBy?: Array<ResolverInputTypes["PlatbyItemsOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["PlatbyItemCondition"] | undefined | null},ResolverInputTypes["PlatbyItemsConnection"]],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `PlatbyItem`. */
["PlatbyItemsOrderBy"]:PlatbyItemsOrderBy;
	/** A condition to be used against `PlatbyItem` object types. All fields are tested
for equality and combined with a logical and. */
["PlatbyItemCondition"]: {
	/** Checks for equality with the objects `piId` field. */
	piId?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `piIdUser` field. */
	piIdUser?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `piIdCategory` field. */
	piIdCategory?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `piIdRaw` field. */
	piIdRaw?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `piAmount` field. */
	piAmount?: ResolverInputTypes["BigFloat"] | undefined | null,
	/** Checks for equality with the objects `piDate` field. */
	piDate?: ResolverInputTypes["Date"] | undefined | null,
	/** Checks for equality with the objects `piPrefix` field. */
	piPrefix?: number | undefined | null
};
	/** A `PlatbyItem` edge in the connection. */
["PlatbyItemsEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `PlatbyItem` at the end of the edge. */
	node?:ResolverInputTypes["PlatbyItem"],
		__typename?: boolean | `@${string}`
}>;
	/** A `PlatbyCategoryGroup` edge in the connection. */
["PlatbyCategoryGroupsEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `PlatbyCategoryGroup` at the end of the edge. */
	node?:ResolverInputTypes["PlatbyCategoryGroup"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `PlatbyGroupSkupina`. */
["PlatbyGroupSkupinasOrderBy"]:PlatbyGroupSkupinasOrderBy;
	/** A condition to be used against `PlatbyGroupSkupina` object types. All fields are
tested for equality and combined with a logical and. */
["PlatbyGroupSkupinaCondition"]: {
	/** Checks for equality with the objects `pgsId` field. */
	pgsId?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `pgsIdSkupina` field. */
	pgsIdSkupina?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `pgsIdGroup` field. */
	pgsIdGroup?: ResolverInputTypes["BigInt"] | undefined | null
};
	/** A `PlatbyGroupSkupina` edge in the connection. */
["PlatbyGroupSkupinasEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `PlatbyGroupSkupina` at the end of the edge. */
	node?:ResolverInputTypes["PlatbyGroupSkupina"],
		__typename?: boolean | `@${string}`
}>;
	/** A connection to a list of `UpozorneniSkupiny` values. */
["UpozorneniSkupiniesConnection"]: AliasType<{
	/** A list of `UpozorneniSkupiny` objects. */
	nodes?:ResolverInputTypes["UpozorneniSkupiny"],
	/** A list of edges which contains the `UpozorneniSkupiny` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["UpozorneniSkupiniesEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ResolverInputTypes["PageInfo"],
	/** The count of *all* `UpozorneniSkupiny` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["UpozorneniSkupiny"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	upsId?:boolean | `@${string}`,
	upsIdRodic?:boolean | `@${string}`,
	upsIdSkupina?:boolean | `@${string}`,
	upsColor?:boolean | `@${string}`,
	upsPopis?:boolean | `@${string}`,
	/** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
	upozorneniByUpsIdRodic?:ResolverInputTypes["Upozorneni"],
	/** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
	skupinyByUpsIdSkupina?:ResolverInputTypes["Skupiny"],
		__typename?: boolean | `@${string}`
}>;
	["Upozorneni"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	upId?:boolean | `@${string}`,
	upKdo?:boolean | `@${string}`,
	upNadpis?:boolean | `@${string}`,
	upText?:boolean | `@${string}`,
	upBarvy?:boolean | `@${string}`,
	upLock?:boolean | `@${string}`,
	upTimestamp?:boolean | `@${string}`,
	upTimestampAdd?:boolean | `@${string}`,
	/** Reads a single `User` that is related to this `Upozorneni`. */
	userByUpKdo?:ResolverInputTypes["User"],
upozorneniSkupiniesByUpsIdRodic?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `UpozorneniSkupiny`. */
	orderBy?: Array<ResolverInputTypes["UpozorneniSkupiniesOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["UpozorneniSkupinyCondition"] | undefined | null},ResolverInputTypes["UpozorneniSkupiniesConnection"]],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `UpozorneniSkupiny`. */
["UpozorneniSkupiniesOrderBy"]:UpozorneniSkupiniesOrderBy;
	/** A condition to be used against `UpozorneniSkupiny` object types. All fields are
tested for equality and combined with a logical and. */
["UpozorneniSkupinyCondition"]: {
	/** Checks for equality with the objects `upsId` field. */
	upsId?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `upsIdRodic` field. */
	upsIdRodic?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `upsIdSkupina` field. */
	upsIdSkupina?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `upsColor` field. */
	upsColor?: string | undefined | null,
	/** Checks for equality with the objects `upsPopis` field. */
	upsPopis?: string | undefined | null
};
	/** A `UpozorneniSkupiny` edge in the connection. */
["UpozorneniSkupiniesEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `UpozorneniSkupiny` at the end of the edge. */
	node?:ResolverInputTypes["UpozorneniSkupiny"],
		__typename?: boolean | `@${string}`
}>;
	/** A connection to a list of `Aktuality` values. */
["AktualitiesConnection"]: AliasType<{
	/** A list of `Aktuality` objects. */
	nodes?:ResolverInputTypes["Aktuality"],
	/** A list of edges which contains the `Aktuality` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["AktualitiesEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ResolverInputTypes["PageInfo"],
	/** The count of *all* `Aktuality` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["Aktuality"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	atId?:boolean | `@${string}`,
	atKdo?:boolean | `@${string}`,
	atKat?:boolean | `@${string}`,
	atJmeno?:boolean | `@${string}`,
	atText?:boolean | `@${string}`,
	atPreview?:boolean | `@${string}`,
	atFoto?:boolean | `@${string}`,
	atFotoMain?:boolean | `@${string}`,
	atTimestamp?:boolean | `@${string}`,
	atTimestampAdd?:boolean | `@${string}`,
	/** Reads a single `User` that is related to this `Aktuality`. */
	userByAtKdo?:ResolverInputTypes["User"],
	/** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
	galerieFotoByAtFotoMain?:ResolverInputTypes["GalerieFoto"],
		__typename?: boolean | `@${string}`
}>;
	["GalerieFoto"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	gfId?:boolean | `@${string}`,
	gfIdRodic?:boolean | `@${string}`,
	gfName?:boolean | `@${string}`,
	gfPath?:boolean | `@${string}`,
	gfKdo?:boolean | `@${string}`,
	gfTimestamp?:boolean | `@${string}`,
	/** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
	galerieDirByGfIdRodic?:ResolverInputTypes["GalerieDir"],
	/** Reads a single `User` that is related to this `GalerieFoto`. */
	userByGfKdo?:ResolverInputTypes["User"],
aktualitiesByAtFotoMain?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `Aktuality`. */
	orderBy?: Array<ResolverInputTypes["AktualitiesOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["AktualityCondition"] | undefined | null},ResolverInputTypes["AktualitiesConnection"]],
		__typename?: boolean | `@${string}`
}>;
	["GalerieDir"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	gdId?:boolean | `@${string}`,
	gdIdRodic?:boolean | `@${string}`,
	gdName?:boolean | `@${string}`,
	gdLevel?:boolean | `@${string}`,
	gdPath?:boolean | `@${string}`,
	gdHidden?:boolean | `@${string}`,
galerieFotosByGfIdRodic?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `GalerieFoto`. */
	orderBy?: Array<ResolverInputTypes["GalerieFotosOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["GalerieFotoCondition"] | undefined | null},ResolverInputTypes["GalerieFotosConnection"]],
		__typename?: boolean | `@${string}`
}>;
	/** A connection to a list of `GalerieFoto` values. */
["GalerieFotosConnection"]: AliasType<{
	/** A list of `GalerieFoto` objects. */
	nodes?:ResolverInputTypes["GalerieFoto"],
	/** A list of edges which contains the `GalerieFoto` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["GalerieFotosEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ResolverInputTypes["PageInfo"],
	/** The count of *all* `GalerieFoto` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `GalerieFoto` edge in the connection. */
["GalerieFotosEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `GalerieFoto` at the end of the edge. */
	node?:ResolverInputTypes["GalerieFoto"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `GalerieFoto`. */
["GalerieFotosOrderBy"]:GalerieFotosOrderBy;
	/** A condition to be used against `GalerieFoto` object types. All fields are tested
for equality and combined with a logical and. */
["GalerieFotoCondition"]: {
	/** Checks for equality with the objects `gfId` field. */
	gfId?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `gfIdRodic` field. */
	gfIdRodic?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `gfName` field. */
	gfName?: string | undefined | null,
	/** Checks for equality with the objects `gfPath` field. */
	gfPath?: string | undefined | null,
	/** Checks for equality with the objects `gfKdo` field. */
	gfKdo?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `gfTimestamp` field. */
	gfTimestamp?: ResolverInputTypes["Datetime"] | undefined | null
};
	/** Methods to use when ordering `Aktuality`. */
["AktualitiesOrderBy"]:AktualitiesOrderBy;
	/** A condition to be used against `Aktuality` object types. All fields are tested
for equality and combined with a logical and. */
["AktualityCondition"]: {
	/** Checks for equality with the objects `atId` field. */
	atId?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `atKdo` field. */
	atKdo?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `atKat` field. */
	atKat?: string | undefined | null,
	/** Checks for equality with the objects `atJmeno` field. */
	atJmeno?: string | undefined | null,
	/** Checks for equality with the objects `atText` field. */
	atText?: string | undefined | null,
	/** Checks for equality with the objects `atPreview` field. */
	atPreview?: string | undefined | null,
	/** Checks for equality with the objects `atFoto` field. */
	atFoto?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `atFotoMain` field. */
	atFotoMain?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `atTimestamp` field. */
	atTimestamp?: ResolverInputTypes["Datetime"] | undefined | null,
	/** Checks for equality with the objects `atTimestampAdd` field. */
	atTimestampAdd?: ResolverInputTypes["Datetime"] | undefined | null
};
	/** A `Aktuality` edge in the connection. */
["AktualitiesEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `Aktuality` at the end of the edge. */
	node?:ResolverInputTypes["Aktuality"],
		__typename?: boolean | `@${string}`
}>;
	/** A connection to a list of `Nabidka` values. */
["NabidkasConnection"]: AliasType<{
	/** A list of `Nabidka` objects. */
	nodes?:ResolverInputTypes["Nabidka"],
	/** A list of edges which contains the `Nabidka` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["NabidkasEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ResolverInputTypes["PageInfo"],
	/** The count of *all* `Nabidka` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["Nabidka"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	nId?:boolean | `@${string}`,
	nTrener?:boolean | `@${string}`,
	nPocetHod?:boolean | `@${string}`,
	nMaxPocetHod?:boolean | `@${string}`,
	nOd?:boolean | `@${string}`,
	nDo?:boolean | `@${string}`,
	nVisible?:boolean | `@${string}`,
	nLock?:boolean | `@${string}`,
	nTimestamp?:boolean | `@${string}`,
	/** Reads a single `User` that is related to this `Nabidka`. */
	userByNTrener?:ResolverInputTypes["User"],
nabidkaItemsByNiIdRodic?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `NabidkaItem`. */
	orderBy?: Array<ResolverInputTypes["NabidkaItemsOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["NabidkaItemCondition"] | undefined | null},ResolverInputTypes["NabidkaItemsConnection"]],
		__typename?: boolean | `@${string}`
}>;
	/** A connection to a list of `NabidkaItem` values. */
["NabidkaItemsConnection"]: AliasType<{
	/** A list of `NabidkaItem` objects. */
	nodes?:ResolverInputTypes["NabidkaItem"],
	/** A list of edges which contains the `NabidkaItem` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["NabidkaItemsEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ResolverInputTypes["PageInfo"],
	/** The count of *all* `NabidkaItem` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["NabidkaItem"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	niId?:boolean | `@${string}`,
	niIdRodic?:boolean | `@${string}`,
	niPartner?:boolean | `@${string}`,
	niPocetHod?:boolean | `@${string}`,
	niLock?:boolean | `@${string}`,
	/** Reads a single `Nabidka` that is related to this `NabidkaItem`. */
	nabidkaByNiIdRodic?:ResolverInputTypes["Nabidka"],
	/** Reads a single `Pary` that is related to this `NabidkaItem`. */
	paryByNiPartner?:ResolverInputTypes["Pary"],
		__typename?: boolean | `@${string}`
}>;
	["Pary"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	pId?:boolean | `@${string}`,
	pIdPartner?:boolean | `@${string}`,
	pIdPartnerka?:boolean | `@${string}`,
	pSttTrida?:boolean | `@${string}`,
	pSttBody?:boolean | `@${string}`,
	pSttFinale?:boolean | `@${string}`,
	pLatTrida?:boolean | `@${string}`,
	pLatBody?:boolean | `@${string}`,
	pLatFinale?:boolean | `@${string}`,
	pHodnoceni?:boolean | `@${string}`,
	pArchiv?:boolean | `@${string}`,
	pTimestampAdd?:boolean | `@${string}`,
	pTimestampArchive?:boolean | `@${string}`,
	/** Reads a single `User` that is related to this `Pary`. */
	userByPIdPartner?:ResolverInputTypes["User"],
nabidkaItemsByNiPartner?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `NabidkaItem`. */
	orderBy?: Array<ResolverInputTypes["NabidkaItemsOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["NabidkaItemCondition"] | undefined | null},ResolverInputTypes["NabidkaItemsConnection"]],
rozpisItemsByRiPartner?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `RozpisItem`. */
	orderBy?: Array<ResolverInputTypes["RozpisItemsOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["RozpisItemCondition"] | undefined | null},ResolverInputTypes["RozpisItemsConnection"]],
		__typename?: boolean | `@${string}`
}>;
	["ParyPSttTrida"]:ParyPSttTrida;
	["ParyPLatTrida"]:ParyPLatTrida;
	/** Methods to use when ordering `NabidkaItem`. */
["NabidkaItemsOrderBy"]:NabidkaItemsOrderBy;
	/** A condition to be used against `NabidkaItem` object types. All fields are tested
for equality and combined with a logical and. */
["NabidkaItemCondition"]: {
	/** Checks for equality with the objects `niId` field. */
	niId?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `niIdRodic` field. */
	niIdRodic?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `niPartner` field. */
	niPartner?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `niPocetHod` field. */
	niPocetHod?: number | undefined | null,
	/** Checks for equality with the objects `niLock` field. */
	niLock?: boolean | undefined | null
};
	/** A connection to a list of `RozpisItem` values. */
["RozpisItemsConnection"]: AliasType<{
	/** A list of `RozpisItem` objects. */
	nodes?:ResolverInputTypes["RozpisItem"],
	/** A list of edges which contains the `RozpisItem` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["RozpisItemsEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ResolverInputTypes["PageInfo"],
	/** The count of *all* `RozpisItem` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["RozpisItem"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	riId?:boolean | `@${string}`,
	riIdRodic?:boolean | `@${string}`,
	riPartner?:boolean | `@${string}`,
	riOd?:boolean | `@${string}`,
	riDo?:boolean | `@${string}`,
	riLock?:boolean | `@${string}`,
	/** Reads a single `Rozpi` that is related to this `RozpisItem`. */
	rozpiByRiIdRodic?:ResolverInputTypes["Rozpi"],
	/** Reads a single `Pary` that is related to this `RozpisItem`. */
	paryByRiPartner?:ResolverInputTypes["Pary"],
		__typename?: boolean | `@${string}`
}>;
	/** The exact time of day, does not include the date. May or may not have a timezone offset. */
["Time"]:unknown;
	["Rozpi"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	rId?:boolean | `@${string}`,
	rTrener?:boolean | `@${string}`,
	rKde?:boolean | `@${string}`,
	rDatum?:boolean | `@${string}`,
	rVisible?:boolean | `@${string}`,
	rLock?:boolean | `@${string}`,
	rTimestamp?:boolean | `@${string}`,
	/** Reads a single `User` that is related to this `Rozpi`. */
	userByRTrener?:ResolverInputTypes["User"],
rozpisItemsByRiIdRodic?: [{	/** Only read the first `n` values of the set. */
	first?: number | undefined | null,	/** Only read the last `n` values of the set. */
	last?: number | undefined | null,	/** Skip the first `n` values from our `after` cursor, an alternative to cursor
based pagination. May not be used with `last`. */
	offset?: number | undefined | null,	/** Read all values in the set before (above) this cursor. */
	before?: ResolverInputTypes["Cursor"] | undefined | null,	/** Read all values in the set after (below) this cursor. */
	after?: ResolverInputTypes["Cursor"] | undefined | null,	/** The method to use when ordering `RozpisItem`. */
	orderBy?: Array<ResolverInputTypes["RozpisItemsOrderBy"]> | undefined | null,	/** A condition to be used in determining which values should be returned by the collection. */
	condition?: ResolverInputTypes["RozpisItemCondition"] | undefined | null},ResolverInputTypes["RozpisItemsConnection"]],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `RozpisItem`. */
["RozpisItemsOrderBy"]:RozpisItemsOrderBy;
	/** A condition to be used against `RozpisItem` object types. All fields are tested
for equality and combined with a logical and. */
["RozpisItemCondition"]: {
	/** Checks for equality with the objects `riId` field. */
	riId?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `riIdRodic` field. */
	riIdRodic?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `riPartner` field. */
	riPartner?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `riOd` field. */
	riOd?: ResolverInputTypes["Time"] | undefined | null,
	/** Checks for equality with the objects `riDo` field. */
	riDo?: ResolverInputTypes["Time"] | undefined | null,
	/** Checks for equality with the objects `riLock` field. */
	riLock?: boolean | undefined | null
};
	/** A `RozpisItem` edge in the connection. */
["RozpisItemsEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `RozpisItem` at the end of the edge. */
	node?:ResolverInputTypes["RozpisItem"],
		__typename?: boolean | `@${string}`
}>;
	/** A `NabidkaItem` edge in the connection. */
["NabidkaItemsEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `NabidkaItem` at the end of the edge. */
	node?:ResolverInputTypes["NabidkaItem"],
		__typename?: boolean | `@${string}`
}>;
	/** A `Nabidka` edge in the connection. */
["NabidkasEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `Nabidka` at the end of the edge. */
	node?:ResolverInputTypes["Nabidka"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `Nabidka`. */
["NabidkasOrderBy"]:NabidkasOrderBy;
	/** A condition to be used against `Nabidka` object types. All fields are tested for equality and combined with a logical and. */
["NabidkaCondition"]: {
	/** Checks for equality with the objects `nId` field. */
	nId?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `nTrener` field. */
	nTrener?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `nPocetHod` field. */
	nPocetHod?: number | undefined | null,
	/** Checks for equality with the objects `nMaxPocetHod` field. */
	nMaxPocetHod?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `nOd` field. */
	nOd?: ResolverInputTypes["Date"] | undefined | null,
	/** Checks for equality with the objects `nDo` field. */
	nDo?: ResolverInputTypes["Date"] | undefined | null,
	/** Checks for equality with the objects `nVisible` field. */
	nVisible?: boolean | undefined | null,
	/** Checks for equality with the objects `nLock` field. */
	nLock?: boolean | undefined | null,
	/** Checks for equality with the objects `nTimestamp` field. */
	nTimestamp?: ResolverInputTypes["Datetime"] | undefined | null
};
	/** A connection to a list of `Rozpi` values. */
["RozpisConnection"]: AliasType<{
	/** A list of `Rozpi` objects. */
	nodes?:ResolverInputTypes["Rozpi"],
	/** A list of edges which contains the `Rozpi` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["RozpisEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ResolverInputTypes["PageInfo"],
	/** The count of *all* `Rozpi` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `Rozpi` edge in the connection. */
["RozpisEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `Rozpi` at the end of the edge. */
	node?:ResolverInputTypes["Rozpi"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `Rozpi`. */
["RozpisOrderBy"]:RozpisOrderBy;
	/** A condition to be used against `Rozpi` object types. All fields are tested for equality and combined with a logical and. */
["RozpiCondition"]: {
	/** Checks for equality with the objects `rId` field. */
	rId?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `rTrener` field. */
	rTrener?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `rKde` field. */
	rKde?: string | undefined | null,
	/** Checks for equality with the objects `rDatum` field. */
	rDatum?: ResolverInputTypes["Date"] | undefined | null,
	/** Checks for equality with the objects `rVisible` field. */
	rVisible?: boolean | undefined | null,
	/** Checks for equality with the objects `rLock` field. */
	rLock?: boolean | undefined | null,
	/** Checks for equality with the objects `rTimestamp` field. */
	rTimestamp?: ResolverInputTypes["Datetime"] | undefined | null
};
	/** A connection to a list of `Pary` values. */
["PariesConnection"]: AliasType<{
	/** A list of `Pary` objects. */
	nodes?:ResolverInputTypes["Pary"],
	/** A list of edges which contains the `Pary` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["PariesEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ResolverInputTypes["PageInfo"],
	/** The count of *all* `Pary` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `Pary` edge in the connection. */
["PariesEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `Pary` at the end of the edge. */
	node?:ResolverInputTypes["Pary"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `Pary`. */
["PariesOrderBy"]:PariesOrderBy;
	/** A condition to be used against `Pary` object types. All fields are tested for equality and combined with a logical and. */
["ParyCondition"]: {
	/** Checks for equality with the objects `pId` field. */
	pId?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `pIdPartner` field. */
	pIdPartner?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `pIdPartnerka` field. */
	pIdPartnerka?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `pSttTrida` field. */
	pSttTrida?: ResolverInputTypes["ParyPSttTrida"] | undefined | null,
	/** Checks for equality with the objects `pSttBody` field. */
	pSttBody?: number | undefined | null,
	/** Checks for equality with the objects `pSttFinale` field. */
	pSttFinale?: boolean | undefined | null,
	/** Checks for equality with the objects `pLatTrida` field. */
	pLatTrida?: ResolverInputTypes["ParyPLatTrida"] | undefined | null,
	/** Checks for equality with the objects `pLatBody` field. */
	pLatBody?: number | undefined | null,
	/** Checks for equality with the objects `pLatFinale` field. */
	pLatFinale?: boolean | undefined | null,
	/** Checks for equality with the objects `pHodnoceni` field. */
	pHodnoceni?: number | undefined | null,
	/** Checks for equality with the objects `pArchiv` field. */
	pArchiv?: boolean | undefined | null,
	/** Checks for equality with the objects `pTimestampAdd` field. */
	pTimestampAdd?: ResolverInputTypes["Datetime"] | undefined | null,
	/** Checks for equality with the objects `pTimestampArchive` field. */
	pTimestampArchive?: ResolverInputTypes["Datetime"] | undefined | null
};
	/** A connection to a list of `Session` values. */
["SessionsConnection"]: AliasType<{
	/** A list of `Session` objects. */
	nodes?:ResolverInputTypes["Session"],
	/** A list of edges which contains the `Session` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["SessionsEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ResolverInputTypes["PageInfo"],
	/** The count of *all* `Session` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["Session"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	ssId?:boolean | `@${string}`,
	ssData?:boolean | `@${string}`,
	ssUpdatedAt?:boolean | `@${string}`,
	ssLifetime?:boolean | `@${string}`,
	ssUser?:boolean | `@${string}`,
	/** Reads a single `User` that is related to this `Session`. */
	userBySsUser?:ResolverInputTypes["User"],
		__typename?: boolean | `@${string}`
}>;
	/** A `Session` edge in the connection. */
["SessionsEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `Session` at the end of the edge. */
	node?:ResolverInputTypes["Session"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `Session`. */
["SessionsOrderBy"]:SessionsOrderBy;
	/** A condition to be used against `Session` object types. All fields are tested for equality and combined with a logical and. */
["SessionCondition"]: {
	/** Checks for equality with the objects `ssId` field. */
	ssId?: string | undefined | null,
	/** Checks for equality with the objects `ssData` field. */
	ssData?: string | undefined | null,
	/** Checks for equality with the objects `ssUpdatedAt` field. */
	ssUpdatedAt?: ResolverInputTypes["Datetime"] | undefined | null,
	/** Checks for equality with the objects `ssLifetime` field. */
	ssLifetime?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `ssUser` field. */
	ssUser?: ResolverInputTypes["BigInt"] | undefined | null
};
	/** Methods to use when ordering `AkceItem`. */
["AkceItemsOrderBy"]:AkceItemsOrderBy;
	/** A condition to be used against `AkceItem` object types. All fields are tested
for equality and combined with a logical and. */
["AkceItemCondition"]: {
	/** Checks for equality with the objects `aiId` field. */
	aiId?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `aiIdRodic` field. */
	aiIdRodic?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `aiUser` field. */
	aiUser?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `aiRokNarozeni` field. */
	aiRokNarozeni?: number | undefined | null
};
	/** A connection to a list of `Dokumenty` values. */
["DokumentiesConnection"]: AliasType<{
	/** A list of `Dokumenty` objects. */
	nodes?:ResolverInputTypes["Dokumenty"],
	/** A list of edges which contains the `Dokumenty` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["DokumentiesEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ResolverInputTypes["PageInfo"],
	/** The count of *all* `Dokumenty` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["Dokumenty"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	dId?:boolean | `@${string}`,
	dPath?:boolean | `@${string}`,
	dName?:boolean | `@${string}`,
	dFilename?:boolean | `@${string}`,
	dKategorie?:boolean | `@${string}`,
	dKdo?:boolean | `@${string}`,
	dTimestamp?:boolean | `@${string}`,
	/** Reads a single `User` that is related to this `Dokumenty`. */
	userByDKdo?:ResolverInputTypes["User"],
		__typename?: boolean | `@${string}`
}>;
	/** A `Dokumenty` edge in the connection. */
["DokumentiesEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `Dokumenty` at the end of the edge. */
	node?:ResolverInputTypes["Dokumenty"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `Dokumenty`. */
["DokumentiesOrderBy"]:DokumentiesOrderBy;
	/** A condition to be used against `Dokumenty` object types. All fields are tested
for equality and combined with a logical and. */
["DokumentyCondition"]: {
	/** Checks for equality with the objects `dId` field. */
	dId?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `dPath` field. */
	dPath?: string | undefined | null,
	/** Checks for equality with the objects `dName` field. */
	dName?: string | undefined | null,
	/** Checks for equality with the objects `dFilename` field. */
	dFilename?: string | undefined | null,
	/** Checks for equality with the objects `dKategorie` field. */
	dKategorie?: number | undefined | null,
	/** Checks for equality with the objects `dKdo` field. */
	dKdo?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `dTimestamp` field. */
	dTimestamp?: ResolverInputTypes["Datetime"] | undefined | null
};
	/** A connection to a list of `ParyNavrh` values. */
["ParyNavrhsConnection"]: AliasType<{
	/** A list of `ParyNavrh` objects. */
	nodes?:ResolverInputTypes["ParyNavrh"],
	/** A list of edges which contains the `ParyNavrh` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["ParyNavrhsEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ResolverInputTypes["PageInfo"],
	/** The count of *all* `ParyNavrh` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["ParyNavrh"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	pnId?:boolean | `@${string}`,
	pnNavrhl?:boolean | `@${string}`,
	pnPartner?:boolean | `@${string}`,
	pnPartnerka?:boolean | `@${string}`,
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnNavrhl?:ResolverInputTypes["User"],
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnPartner?:ResolverInputTypes["User"],
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnPartnerka?:ResolverInputTypes["User"],
		__typename?: boolean | `@${string}`
}>;
	/** A `ParyNavrh` edge in the connection. */
["ParyNavrhsEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `ParyNavrh` at the end of the edge. */
	node?:ResolverInputTypes["ParyNavrh"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `ParyNavrh`. */
["ParyNavrhsOrderBy"]:ParyNavrhsOrderBy;
	/** A condition to be used against `ParyNavrh` object types. All fields are tested
for equality and combined with a logical and. */
["ParyNavrhCondition"]: {
	/** Checks for equality with the objects `pnId` field. */
	pnId?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `pnNavrhl` field. */
	pnNavrhl?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `pnPartner` field. */
	pnPartner?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `pnPartnerka` field. */
	pnPartnerka?: ResolverInputTypes["BigInt"] | undefined | null
};
	/** A connection to a list of `Upozorneni` values. */
["UpozornenisConnection"]: AliasType<{
	/** A list of `Upozorneni` objects. */
	nodes?:ResolverInputTypes["Upozorneni"],
	/** A list of edges which contains the `Upozorneni` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["UpozornenisEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ResolverInputTypes["PageInfo"],
	/** The count of *all* `Upozorneni` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `Upozorneni` edge in the connection. */
["UpozornenisEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `Upozorneni` at the end of the edge. */
	node?:ResolverInputTypes["Upozorneni"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `Upozorneni`. */
["UpozornenisOrderBy"]:UpozornenisOrderBy;
	/** A condition to be used against `Upozorneni` object types. All fields are tested
for equality and combined with a logical and. */
["UpozorneniCondition"]: {
	/** Checks for equality with the objects `upId` field. */
	upId?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `upKdo` field. */
	upKdo?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `upNadpis` field. */
	upNadpis?: string | undefined | null,
	/** Checks for equality with the objects `upText` field. */
	upText?: string | undefined | null,
	/** Checks for equality with the objects `upBarvy` field. */
	upBarvy?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `upLock` field. */
	upLock?: boolean | undefined | null,
	/** Checks for equality with the objects `upTimestamp` field. */
	upTimestamp?: ResolverInputTypes["Datetime"] | undefined | null,
	/** Checks for equality with the objects `upTimestampAdd` field. */
	upTimestampAdd?: ResolverInputTypes["Datetime"] | undefined | null
};
	/** A `AkceItem` edge in the connection. */
["AkceItemsEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `AkceItem` at the end of the edge. */
	node?:ResolverInputTypes["AkceItem"],
		__typename?: boolean | `@${string}`
}>;
	/** A `Akce` edge in the connection. */
["AkcesEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `Akce` at the end of the edge. */
	node?:ResolverInputTypes["Akce"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `Akce`. */
["AkcesOrderBy"]:AkcesOrderBy;
	/** A condition to be used against `Akce` object types. All fields are tested for equality and combined with a logical and. */
["AkceCondition"]: {
	/** Checks for equality with the objects `aId` field. */
	aId?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `aJmeno` field. */
	aJmeno?: string | undefined | null,
	/** Checks for equality with the objects `aKde` field. */
	aKde?: string | undefined | null,
	/** Checks for equality with the objects `aInfo` field. */
	aInfo?: string | undefined | null,
	/** Checks for equality with the objects `aOd` field. */
	aOd?: ResolverInputTypes["Date"] | undefined | null,
	/** Checks for equality with the objects `aDo` field. */
	aDo?: ResolverInputTypes["Date"] | undefined | null,
	/** Checks for equality with the objects `aKapacita` field. */
	aKapacita?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `aDokumenty` field. */
	aDokumenty?: string | undefined | null,
	/** Checks for equality with the objects `aTimestamp` field. */
	aTimestamp?: ResolverInputTypes["Datetime"] | undefined | null,
	/** Checks for equality with the objects `aLock` field. */
	aLock?: boolean | undefined | null,
	/** Checks for equality with the objects `aVisible` field. */
	aVisible?: boolean | undefined | null
};
	/** A connection to a list of `GalerieDir` values. */
["GalerieDirsConnection"]: AliasType<{
	/** A list of `GalerieDir` objects. */
	nodes?:ResolverInputTypes["GalerieDir"],
	/** A list of edges which contains the `GalerieDir` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["GalerieDirsEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ResolverInputTypes["PageInfo"],
	/** The count of *all* `GalerieDir` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `GalerieDir` edge in the connection. */
["GalerieDirsEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `GalerieDir` at the end of the edge. */
	node?:ResolverInputTypes["GalerieDir"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `GalerieDir`. */
["GalerieDirsOrderBy"]:GalerieDirsOrderBy;
	/** A condition to be used against `GalerieDir` object types. All fields are tested
for equality and combined with a logical and. */
["GalerieDirCondition"]: {
	/** Checks for equality with the objects `gdId` field. */
	gdId?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `gdIdRodic` field. */
	gdIdRodic?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `gdName` field. */
	gdName?: string | undefined | null,
	/** Checks for equality with the objects `gdLevel` field. */
	gdLevel?: number | undefined | null,
	/** Checks for equality with the objects `gdPath` field. */
	gdPath?: string | undefined | null,
	/** Checks for equality with the objects `gdHidden` field. */
	gdHidden?: boolean | undefined | null
};
	/** A connection to a list of `Member` values. */
["MembersConnection"]: AliasType<{
	/** A list of `Member` objects. */
	nodes?:ResolverInputTypes["Member"],
	/** A list of edges which contains the `Member` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["MembersEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ResolverInputTypes["PageInfo"],
	/** The count of *all* `Member` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["Member"]: AliasType<{
	uId?:boolean | `@${string}`,
	uLogin?:boolean | `@${string}`,
	uPass?:boolean | `@${string}`,
	uJmeno?:boolean | `@${string}`,
	uPrijmeni?:boolean | `@${string}`,
	uPohlavi?:boolean | `@${string}`,
	uEmail?:boolean | `@${string}`,
	uTelefon?:boolean | `@${string}`,
	uNarozeni?:boolean | `@${string}`,
	uRodneCislo?:boolean | `@${string}`,
	uPoznamky?:boolean | `@${string}`,
	uTimestamp?:boolean | `@${string}`,
	uLevel?:boolean | `@${string}`,
	uGroup?:boolean | `@${string}`,
	uSkupina?:boolean | `@${string}`,
	uDancer?:boolean | `@${string}`,
	uBan?:boolean | `@${string}`,
	uLock?:boolean | `@${string}`,
	uConfirmed?:boolean | `@${string}`,
	uSystem?:boolean | `@${string}`,
	uStreet?:boolean | `@${string}`,
	uConscriptionNumber?:boolean | `@${string}`,
	uOrientationNumber?:boolean | `@${string}`,
	uDistrict?:boolean | `@${string}`,
	uCity?:boolean | `@${string}`,
	uPostalCode?:boolean | `@${string}`,
	uNationality?:boolean | `@${string}`,
	uMemberSince?:boolean | `@${string}`,
	uMemberUntil?:boolean | `@${string}`,
	uCreatedAt?:boolean | `@${string}`,
	uTeacher?:boolean | `@${string}`,
	uGdprSignedAt?:boolean | `@${string}`,
	sId?:boolean | `@${string}`,
	sName?:boolean | `@${string}`,
	paymentValid?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `Member` edge in the connection. */
["MembersEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `Member` at the end of the edge. */
	node?:ResolverInputTypes["Member"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `Member`. */
["MembersOrderBy"]:MembersOrderBy;
	/** A condition to be used against `Member` object types. All fields are tested for equality and combined with a logical and. */
["MemberCondition"]: {
	/** Checks for equality with the objects `uId` field. */
	uId?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `uLogin` field. */
	uLogin?: string | undefined | null,
	/** Checks for equality with the objects `uPass` field. */
	uPass?: string | undefined | null,
	/** Checks for equality with the objects `uJmeno` field. */
	uJmeno?: string | undefined | null,
	/** Checks for equality with the objects `uPrijmeni` field. */
	uPrijmeni?: string | undefined | null,
	/** Checks for equality with the objects `uPohlavi` field. */
	uPohlavi?: string | undefined | null,
	/** Checks for equality with the objects `uEmail` field. */
	uEmail?: string | undefined | null,
	/** Checks for equality with the objects `uTelefon` field. */
	uTelefon?: string | undefined | null,
	/** Checks for equality with the objects `uNarozeni` field. */
	uNarozeni?: ResolverInputTypes["Date"] | undefined | null,
	/** Checks for equality with the objects `uRodneCislo` field. */
	uRodneCislo?: string | undefined | null,
	/** Checks for equality with the objects `uPoznamky` field. */
	uPoznamky?: string | undefined | null,
	/** Checks for equality with the objects `uTimestamp` field. */
	uTimestamp?: ResolverInputTypes["Datetime"] | undefined | null,
	/** Checks for equality with the objects `uLevel` field. */
	uLevel?: number | undefined | null,
	/** Checks for equality with the objects `uGroup` field. */
	uGroup?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `uSkupina` field. */
	uSkupina?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `uDancer` field. */
	uDancer?: boolean | undefined | null,
	/** Checks for equality with the objects `uBan` field. */
	uBan?: boolean | undefined | null,
	/** Checks for equality with the objects `uLock` field. */
	uLock?: boolean | undefined | null,
	/** Checks for equality with the objects `uConfirmed` field. */
	uConfirmed?: boolean | undefined | null,
	/** Checks for equality with the objects `uSystem` field. */
	uSystem?: boolean | undefined | null,
	/** Checks for equality with the objects `uStreet` field. */
	uStreet?: string | undefined | null,
	/** Checks for equality with the objects `uConscriptionNumber` field. */
	uConscriptionNumber?: string | undefined | null,
	/** Checks for equality with the objects `uOrientationNumber` field. */
	uOrientationNumber?: string | undefined | null,
	/** Checks for equality with the objects `uDistrict` field. */
	uDistrict?: string | undefined | null,
	/** Checks for equality with the objects `uCity` field. */
	uCity?: string | undefined | null,
	/** Checks for equality with the objects `uPostalCode` field. */
	uPostalCode?: string | undefined | null,
	/** Checks for equality with the objects `uNationality` field. */
	uNationality?: string | undefined | null,
	/** Checks for equality with the objects `uMemberSince` field. */
	uMemberSince?: ResolverInputTypes["Datetime"] | undefined | null,
	/** Checks for equality with the objects `uMemberUntil` field. */
	uMemberUntil?: ResolverInputTypes["Datetime"] | undefined | null,
	/** Checks for equality with the objects `uCreatedAt` field. */
	uCreatedAt?: ResolverInputTypes["Datetime"] | undefined | null,
	/** Checks for equality with the objects `uTeacher` field. */
	uTeacher?: boolean | undefined | null,
	/** Checks for equality with the objects `uGdprSignedAt` field. */
	uGdprSignedAt?: ResolverInputTypes["Datetime"] | undefined | null,
	/** Checks for equality with the objects `sId` field. */
	sId?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `sName` field. */
	sName?: string | undefined | null,
	/** Checks for equality with the objects `paymentValid` field. */
	paymentValid?: boolean | undefined | null
};
	/** A connection to a list of `Page` values. */
["PagesConnection"]: AliasType<{
	/** A list of `Page` objects. */
	nodes?:ResolverInputTypes["Page"],
	/** A list of edges which contains the `Page` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["PagesEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ResolverInputTypes["PageInfo"],
	/** The count of *all* `Page` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["Page"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	id?:boolean | `@${string}`,
	url?:boolean | `@${string}`,
	content?:boolean | `@${string}`,
	createdAt?:boolean | `@${string}`,
	updatedAt?:boolean | `@${string}`,
	title?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
["JSON"]:unknown;
	/** A `Page` edge in the connection. */
["PagesEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `Page` at the end of the edge. */
	node?:ResolverInputTypes["Page"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `Page`. */
["PagesOrderBy"]:PagesOrderBy;
	/** A condition to be used against `Page` object types. All fields are tested for equality and combined with a logical and. */
["PageCondition"]: {
	/** Checks for equality with the objects `id` field. */
	id?: number | undefined | null,
	/** Checks for equality with the objects `url` field. */
	url?: string | undefined | null,
	/** Checks for equality with the objects `content` field. */
	content?: ResolverInputTypes["JSON"] | undefined | null,
	/** Checks for equality with the objects `createdAt` field. */
	createdAt?: ResolverInputTypes["Datetime"] | undefined | null,
	/** Checks for equality with the objects `updatedAt` field. */
	updatedAt?: ResolverInputTypes["Datetime"] | undefined | null,
	/** Checks for equality with the objects `title` field. */
	title?: string | undefined | null
};
	/** A connection to a list of `PageRevision` values. */
["PageRevisionsConnection"]: AliasType<{
	/** A list of `PageRevision` objects. */
	nodes?:ResolverInputTypes["PageRevision"],
	/** A list of edges which contains the `PageRevision` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["PageRevisionsEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ResolverInputTypes["PageInfo"],
	/** The count of *all* `PageRevision` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["PageRevision"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	revNumber?:boolean | `@${string}`,
	revOperation?:boolean | `@${string}`,
	revTimestamp?:boolean | `@${string}`,
	id?:boolean | `@${string}`,
	url?:boolean | `@${string}`,
	content?:boolean | `@${string}`,
	createdAt?:boolean | `@${string}`,
	updatedAt?:boolean | `@${string}`,
	title?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `PageRevision` edge in the connection. */
["PageRevisionsEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `PageRevision` at the end of the edge. */
	node?:ResolverInputTypes["PageRevision"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `PageRevision`. */
["PageRevisionsOrderBy"]:PageRevisionsOrderBy;
	/** A condition to be used against `PageRevision` object types. All fields are
tested for equality and combined with a logical and. */
["PageRevisionCondition"]: {
	/** Checks for equality with the objects `revNumber` field. */
	revNumber?: number | undefined | null,
	/** Checks for equality with the objects `revOperation` field. */
	revOperation?: string | undefined | null,
	/** Checks for equality with the objects `revTimestamp` field. */
	revTimestamp?: ResolverInputTypes["Datetime"] | undefined | null,
	/** Checks for equality with the objects `id` field. */
	id?: number | undefined | null,
	/** Checks for equality with the objects `url` field. */
	url?: string | undefined | null,
	/** Checks for equality with the objects `content` field. */
	content?: ResolverInputTypes["JSON"] | undefined | null,
	/** Checks for equality with the objects `createdAt` field. */
	createdAt?: ResolverInputTypes["Datetime"] | undefined | null,
	/** Checks for equality with the objects `updatedAt` field. */
	updatedAt?: ResolverInputTypes["Datetime"] | undefined | null,
	/** Checks for equality with the objects `title` field. */
	title?: string | undefined | null
};
	/** A connection to a list of `Parameter` values. */
["ParametersConnection"]: AliasType<{
	/** A list of `Parameter` objects. */
	nodes?:ResolverInputTypes["Parameter"],
	/** A list of edges which contains the `Parameter` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["ParametersEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ResolverInputTypes["PageInfo"],
	/** The count of *all* `Parameter` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["Parameter"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	paName?:boolean | `@${string}`,
	paValue?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `Parameter` edge in the connection. */
["ParametersEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `Parameter` at the end of the edge. */
	node?:ResolverInputTypes["Parameter"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `Parameter`. */
["ParametersOrderBy"]:ParametersOrderBy;
	/** A condition to be used against `Parameter` object types. All fields are tested
for equality and combined with a logical and. */
["ParameterCondition"]: {
	/** Checks for equality with the objects `paName` field. */
	paName?: string | undefined | null,
	/** Checks for equality with the objects `paValue` field. */
	paValue?: string | undefined | null
};
	/** A connection to a list of `Permission` values. */
["PermissionsConnection"]: AliasType<{
	/** A list of `Permission` objects. */
	nodes?:ResolverInputTypes["Permission"],
	/** A list of edges which contains the `Permission` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["PermissionsEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ResolverInputTypes["PageInfo"],
	/** The count of *all* `Permission` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `Permission` edge in the connection. */
["PermissionsEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `Permission` at the end of the edge. */
	node?:ResolverInputTypes["Permission"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `Permission`. */
["PermissionsOrderBy"]:PermissionsOrderBy;
	/** A condition to be used against `Permission` object types. All fields are tested
for equality and combined with a logical and. */
["PermissionCondition"]: {
	/** Checks for equality with the objects `peId` field. */
	peId?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `peName` field. */
	peName?: string | undefined | null,
	/** Checks for equality with the objects `peDescription` field. */
	peDescription?: string | undefined | null,
	/** Checks for equality with the objects `peAkce` field. */
	peAkce?: number | undefined | null,
	/** Checks for equality with the objects `peAktuality` field. */
	peAktuality?: number | undefined | null,
	/** Checks for equality with the objects `peAnkety` field. */
	peAnkety?: number | undefined | null,
	/** Checks for equality with the objects `peDokumenty` field. */
	peDokumenty?: number | undefined | null,
	/** Checks for equality with the objects `peGalerie` field. */
	peGalerie?: number | undefined | null,
	/** Checks for equality with the objects `peInzerce` field. */
	peInzerce?: number | undefined | null,
	/** Checks for equality with the objects `peKonzole` field. */
	peKonzole?: number | undefined | null,
	/** Checks for equality with the objects `peNabidka` field. */
	peNabidka?: number | undefined | null,
	/** Checks for equality with the objects `peNastenka` field. */
	peNastenka?: number | undefined | null,
	/** Checks for equality with the objects `peNovinky` field. */
	peNovinky?: number | undefined | null,
	/** Checks for equality with the objects `pePary` field. */
	pePary?: number | undefined | null,
	/** Checks for equality with the objects `pePlatby` field. */
	pePlatby?: number | undefined | null,
	/** Checks for equality with the objects `pePermissions` field. */
	pePermissions?: number | undefined | null,
	/** Checks for equality with the objects `peRozpis` field. */
	peRozpis?: number | undefined | null,
	/** Checks for equality with the objects `peSkupiny` field. */
	peSkupiny?: number | undefined | null,
	/** Checks for equality with the objects `peUsers` field. */
	peUsers?: number | undefined | null,
	/** Checks for equality with the objects `peMain` field. */
	peMain?: number | undefined | null
};
	/** A connection to a list of `PlatbyCategory` values. */
["PlatbyCategoriesConnection"]: AliasType<{
	/** A list of `PlatbyCategory` objects. */
	nodes?:ResolverInputTypes["PlatbyCategory"],
	/** A list of edges which contains the `PlatbyCategory` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["PlatbyCategoriesEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ResolverInputTypes["PageInfo"],
	/** The count of *all* `PlatbyCategory` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `PlatbyCategory` edge in the connection. */
["PlatbyCategoriesEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `PlatbyCategory` at the end of the edge. */
	node?:ResolverInputTypes["PlatbyCategory"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `PlatbyCategory`. */
["PlatbyCategoriesOrderBy"]:PlatbyCategoriesOrderBy;
	/** A condition to be used against `PlatbyCategory` object types. All fields are
tested for equality and combined with a logical and. */
["PlatbyCategoryCondition"]: {
	/** Checks for equality with the objects `pcId` field. */
	pcId?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `pcName` field. */
	pcName?: string | undefined | null,
	/** Checks for equality with the objects `pcSymbol` field. */
	pcSymbol?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `pcAmount` field. */
	pcAmount?: ResolverInputTypes["BigFloat"] | undefined | null,
	/** Checks for equality with the objects `pcDateDue` field. */
	pcDateDue?: ResolverInputTypes["Date"] | undefined | null,
	/** Checks for equality with the objects `pcValidFrom` field. */
	pcValidFrom?: ResolverInputTypes["Date"] | undefined | null,
	/** Checks for equality with the objects `pcValidTo` field. */
	pcValidTo?: ResolverInputTypes["Date"] | undefined | null,
	/** Checks for equality with the objects `pcUseBase` field. */
	pcUseBase?: boolean | undefined | null,
	/** Checks for equality with the objects `pcUsePrefix` field. */
	pcUsePrefix?: boolean | undefined | null,
	/** Checks for equality with the objects `pcArchive` field. */
	pcArchive?: boolean | undefined | null,
	/** Checks for equality with the objects `pcVisible` field. */
	pcVisible?: boolean | undefined | null
};
	/** A connection to a list of `PlatbyGroup` values. */
["PlatbyGroupsConnection"]: AliasType<{
	/** A list of `PlatbyGroup` objects. */
	nodes?:ResolverInputTypes["PlatbyGroup"],
	/** A list of edges which contains the `PlatbyGroup` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["PlatbyGroupsEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ResolverInputTypes["PageInfo"],
	/** The count of *all* `PlatbyGroup` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `PlatbyGroup` edge in the connection. */
["PlatbyGroupsEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `PlatbyGroup` at the end of the edge. */
	node?:ResolverInputTypes["PlatbyGroup"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `PlatbyGroup`. */
["PlatbyGroupsOrderBy"]:PlatbyGroupsOrderBy;
	/** A condition to be used against `PlatbyGroup` object types. All fields are tested
for equality and combined with a logical and. */
["PlatbyGroupCondition"]: {
	/** Checks for equality with the objects `pgId` field. */
	pgId?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `pgType` field. */
	pgType?: ResolverInputTypes["BigFloat"] | undefined | null,
	/** Checks for equality with the objects `pgName` field. */
	pgName?: string | undefined | null,
	/** Checks for equality with the objects `pgDescription` field. */
	pgDescription?: string | undefined | null,
	/** Checks for equality with the objects `pgBase` field. */
	pgBase?: ResolverInputTypes["BigInt"] | undefined | null
};
	/** A connection to a list of `PlatbyRaw` values. */
["PlatbyRawsConnection"]: AliasType<{
	/** A list of `PlatbyRaw` objects. */
	nodes?:ResolverInputTypes["PlatbyRaw"],
	/** A list of edges which contains the `PlatbyRaw` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["PlatbyRawsEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ResolverInputTypes["PageInfo"],
	/** The count of *all* `PlatbyRaw` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `PlatbyRaw` edge in the connection. */
["PlatbyRawsEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `PlatbyRaw` at the end of the edge. */
	node?:ResolverInputTypes["PlatbyRaw"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `PlatbyRaw`. */
["PlatbyRawsOrderBy"]:PlatbyRawsOrderBy;
	/** A condition to be used against `PlatbyRaw` object types. All fields are tested
for equality and combined with a logical and. */
["PlatbyRawCondition"]: {
	/** Checks for equality with the objects `prId` field. */
	prId?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `prRaw` field. */
	prRaw?: string | undefined | null,
	/** Checks for equality with the objects `prHash` field. */
	prHash?: string | undefined | null,
	/** Checks for equality with the objects `prSorted` field. */
	prSorted?: boolean | undefined | null,
	/** Checks for equality with the objects `prDiscarded` field. */
	prDiscarded?: boolean | undefined | null
};
	/** A connection to a list of `Skupiny` values. */
["SkupiniesConnection"]: AliasType<{
	/** A list of `Skupiny` objects. */
	nodes?:ResolverInputTypes["Skupiny"],
	/** A list of edges which contains the `Skupiny` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["SkupiniesEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ResolverInputTypes["PageInfo"],
	/** The count of *all* `Skupiny` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `Skupiny` edge in the connection. */
["SkupiniesEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `Skupiny` at the end of the edge. */
	node?:ResolverInputTypes["Skupiny"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `Skupiny`. */
["SkupiniesOrderBy"]:SkupiniesOrderBy;
	/** A condition to be used against `Skupiny` object types. All fields are tested for equality and combined with a logical and. */
["SkupinyCondition"]: {
	/** Checks for equality with the objects `sId` field. */
	sId?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `sName` field. */
	sName?: string | undefined | null,
	/** Checks for equality with the objects `sDescription` field. */
	sDescription?: string | undefined | null,
	/** Checks for equality with the objects `sColorRgb` field. */
	sColorRgb?: string | undefined | null,
	/** Checks for equality with the objects `sColorText` field. */
	sColorText?: string | undefined | null,
	/** Checks for equality with the objects `sLocation` field. */
	sLocation?: string | undefined | null,
	/** Checks for equality with the objects `sVisible` field. */
	sVisible?: boolean | undefined | null
};
	/** A connection to a list of `UsersSkupiny` values. */
["UsersSkupiniesConnection"]: AliasType<{
	/** A list of `UsersSkupiny` objects. */
	nodes?:ResolverInputTypes["UsersSkupiny"],
	/** A list of edges which contains the `UsersSkupiny` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["UsersSkupiniesEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ResolverInputTypes["PageInfo"],
	/** The count of *all* `UsersSkupiny` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["UsersSkupiny"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	usId?:boolean | `@${string}`,
	usColor?:boolean | `@${string}`,
	usPlatbaMesic?:boolean | `@${string}`,
	usPlatbaCtvrtrok?:boolean | `@${string}`,
	usPlatbaPulrok?:boolean | `@${string}`,
	usPopis?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `UsersSkupiny` edge in the connection. */
["UsersSkupiniesEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `UsersSkupiny` at the end of the edge. */
	node?:ResolverInputTypes["UsersSkupiny"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `UsersSkupiny`. */
["UsersSkupiniesOrderBy"]:UsersSkupiniesOrderBy;
	/** A condition to be used against `UsersSkupiny` object types. All fields are
tested for equality and combined with a logical and. */
["UsersSkupinyCondition"]: {
	/** Checks for equality with the objects `usId` field. */
	usId?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `usColor` field. */
	usColor?: string | undefined | null,
	/** Checks for equality with the objects `usPlatbaMesic` field. */
	usPlatbaMesic?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `usPlatbaCtvrtrok` field. */
	usPlatbaCtvrtrok?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `usPlatbaPulrok` field. */
	usPlatbaPulrok?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `usPopis` field. */
	usPopis?: string | undefined | null
};
	/** A connection to a list of `Video` values. */
["VideosConnection"]: AliasType<{
	/** A list of `Video` objects. */
	nodes?:ResolverInputTypes["Video"],
	/** A list of edges which contains the `Video` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["VideosEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ResolverInputTypes["PageInfo"],
	/** The count of *all* `Video` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["Video"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	vId?:boolean | `@${string}`,
	vUri?:boolean | `@${string}`,
	vTitle?:boolean | `@${string}`,
	vAuthor?:boolean | `@${string}`,
	vDescription?:boolean | `@${string}`,
	vPlaylist?:boolean | `@${string}`,
	vCreatedAt?:boolean | `@${string}`,
	vUpdatedAt?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `Video` edge in the connection. */
["VideosEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `Video` at the end of the edge. */
	node?:ResolverInputTypes["Video"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `Video`. */
["VideosOrderBy"]:VideosOrderBy;
	/** A condition to be used against `Video` object types. All fields are tested for equality and combined with a logical and. */
["VideoCondition"]: {
	/** Checks for equality with the objects `vId` field. */
	vId?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `vUri` field. */
	vUri?: string | undefined | null,
	/** Checks for equality with the objects `vTitle` field. */
	vTitle?: string | undefined | null,
	/** Checks for equality with the objects `vAuthor` field. */
	vAuthor?: string | undefined | null,
	/** Checks for equality with the objects `vDescription` field. */
	vDescription?: string | undefined | null,
	/** Checks for equality with the objects `vPlaylist` field. */
	vPlaylist?: string | undefined | null,
	/** Checks for equality with the objects `vCreatedAt` field. */
	vCreatedAt?: ResolverInputTypes["Datetime"] | undefined | null,
	/** Checks for equality with the objects `vUpdatedAt` field. */
	vUpdatedAt?: ResolverInputTypes["Datetime"] | undefined | null
};
	/** A connection to a list of `VideoList` values. */
["VideoListsConnection"]: AliasType<{
	/** A list of `VideoList` objects. */
	nodes?:ResolverInputTypes["VideoList"],
	/** A list of edges which contains the `VideoList` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["VideoListsEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ResolverInputTypes["PageInfo"],
	/** The count of *all* `VideoList` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["VideoList"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	vlId?:boolean | `@${string}`,
	vlUrl?:boolean | `@${string}`,
	vlTitle?:boolean | `@${string}`,
	vlDescription?:boolean | `@${string}`,
	vlCount?:boolean | `@${string}`,
	vlCreatedAt?:boolean | `@${string}`,
	vlLastChecked?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `VideoList` edge in the connection. */
["VideoListsEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `VideoList` at the end of the edge. */
	node?:ResolverInputTypes["VideoList"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `VideoList`. */
["VideoListsOrderBy"]:VideoListsOrderBy;
	/** A condition to be used against `VideoList` object types. All fields are tested
for equality and combined with a logical and. */
["VideoListCondition"]: {
	/** Checks for equality with the objects `vlId` field. */
	vlId?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `vlUrl` field. */
	vlUrl?: string | undefined | null,
	/** Checks for equality with the objects `vlTitle` field. */
	vlTitle?: string | undefined | null,
	/** Checks for equality with the objects `vlDescription` field. */
	vlDescription?: string | undefined | null,
	/** Checks for equality with the objects `vlCount` field. */
	vlCount?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `vlCreatedAt` field. */
	vlCreatedAt?: ResolverInputTypes["Datetime"] | undefined | null,
	/** Checks for equality with the objects `vlLastChecked` field. */
	vlLastChecked?: ResolverInputTypes["Datetime"] | undefined | null
};
	/** A connection to a list of `VideoSource` values. */
["VideoSourcesConnection"]: AliasType<{
	/** A list of `VideoSource` objects. */
	nodes?:ResolverInputTypes["VideoSource"],
	/** A list of edges which contains the `VideoSource` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["VideoSourcesEdge"],
	/** Information to aid in pagination. */
	pageInfo?:ResolverInputTypes["PageInfo"],
	/** The count of *all* `VideoSource` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["VideoSource"]: AliasType<{
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId?:boolean | `@${string}`,
	vsId?:boolean | `@${string}`,
	vsUrl?:boolean | `@${string}`,
	vsTitle?:boolean | `@${string}`,
	vsDescription?:boolean | `@${string}`,
	vsCreatedAt?:boolean | `@${string}`,
	vsLastChecked?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `VideoSource` edge in the connection. */
["VideoSourcesEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `VideoSource` at the end of the edge. */
	node?:ResolverInputTypes["VideoSource"],
		__typename?: boolean | `@${string}`
}>;
	/** Methods to use when ordering `VideoSource`. */
["VideoSourcesOrderBy"]:VideoSourcesOrderBy;
	/** A condition to be used against `VideoSource` object types. All fields are tested
for equality and combined with a logical and. */
["VideoSourceCondition"]: {
	/** Checks for equality with the objects `vsId` field. */
	vsId?: ResolverInputTypes["BigInt"] | undefined | null,
	/** Checks for equality with the objects `vsUrl` field. */
	vsUrl?: string | undefined | null,
	/** Checks for equality with the objects `vsTitle` field. */
	vsTitle?: string | undefined | null,
	/** Checks for equality with the objects `vsDescription` field. */
	vsDescription?: string | undefined | null,
	/** Checks for equality with the objects `vsCreatedAt` field. */
	vsCreatedAt?: ResolverInputTypes["Datetime"] | undefined | null,
	/** Checks for equality with the objects `vsLastChecked` field. */
	vsLastChecked?: ResolverInputTypes["Datetime"] | undefined | null
};
	/** A connection to a list of `ActiveProspectsRecord` values. */
["ActiveProspectsConnection"]: AliasType<{
	/** A list of `ActiveProspectsRecord` objects. */
	nodes?:ResolverInputTypes["ActiveProspectsRecord"],
	/** A list of edges which contains the `ActiveProspectsRecord` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["ActiveProspectEdge"],
	/** The count of *all* `ActiveProspectsRecord` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** The return type of our `activeProspects` query. */
["ActiveProspectsRecord"]: AliasType<{
	id?:boolean | `@${string}`,
	data?:ResolverInputTypes["ProspectDatum"],
	cohort?:boolean | `@${string}`,
	updatedAt?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["ProspectDatum"]: AliasType<{
	name?:boolean | `@${string}`,
	surname?:boolean | `@${string}`,
	email?:boolean | `@${string}`,
	phone?:boolean | `@${string}`,
	yearofbirth?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["CrmCohort"]:CrmCohort;
	/** A `ActiveProspectsRecord` edge in the connection. */
["ActiveProspectEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `ActiveProspectsRecord` at the end of the edge. */
	node?:ResolverInputTypes["ActiveProspectsRecord"],
		__typename?: boolean | `@${string}`
}>;
	/** A connection to a list of `BigInt` values. */
["CurrentCoupleIdsConnection"]: AliasType<{
	/** A list of `BigInt` objects. */
	nodes?:boolean | `@${string}`,
	/** A list of edges which contains the `BigInt` and cursor to aid in pagination. */
	edges?:ResolverInputTypes["CurrentCoupleIdEdge"],
	/** The count of *all* `BigInt` you could get from the connection. */
	totalCount?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** A `BigInt` edge in the connection. */
["CurrentCoupleIdEdge"]: AliasType<{
	/** A cursor for use in pagination. */
	cursor?:boolean | `@${string}`,
	/** The `BigInt` at the end of the edge. */
	node?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	/** The root mutation type which contains root level fields which mutate data. */
["Mutation"]: AliasType<{
createAkce?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["CreateAkceInput"]},ResolverInputTypes["CreateAkcePayload"]],
createAkceItem?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["CreateAkceItemInput"]},ResolverInputTypes["CreateAkceItemPayload"]],
createAktuality?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["CreateAktualityInput"]},ResolverInputTypes["CreateAktualityPayload"]],
createDokumenty?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["CreateDokumentyInput"]},ResolverInputTypes["CreateDokumentyPayload"]],
createGalerieDir?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["CreateGalerieDirInput"]},ResolverInputTypes["CreateGalerieDirPayload"]],
createGalerieFoto?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["CreateGalerieFotoInput"]},ResolverInputTypes["CreateGalerieFotoPayload"]],
createNabidka?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["CreateNabidkaInput"]},ResolverInputTypes["CreateNabidkaPayload"]],
createNabidkaItem?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["CreateNabidkaItemInput"]},ResolverInputTypes["CreateNabidkaItemPayload"]],
createPage?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["CreatePageInput"]},ResolverInputTypes["CreatePagePayload"]],
createParameter?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["CreateParameterInput"]},ResolverInputTypes["CreateParameterPayload"]],
createPary?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["CreateParyInput"]},ResolverInputTypes["CreateParyPayload"]],
createParyNavrh?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["CreateParyNavrhInput"]},ResolverInputTypes["CreateParyNavrhPayload"]],
createPermission?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["CreatePermissionInput"]},ResolverInputTypes["CreatePermissionPayload"]],
createPlatbyCategory?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["CreatePlatbyCategoryInput"]},ResolverInputTypes["CreatePlatbyCategoryPayload"]],
createPlatbyCategoryGroup?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["CreatePlatbyCategoryGroupInput"]},ResolverInputTypes["CreatePlatbyCategoryGroupPayload"]],
createPlatbyGroup?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["CreatePlatbyGroupInput"]},ResolverInputTypes["CreatePlatbyGroupPayload"]],
createPlatbyGroupSkupina?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["CreatePlatbyGroupSkupinaInput"]},ResolverInputTypes["CreatePlatbyGroupSkupinaPayload"]],
createPlatbyItem?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["CreatePlatbyItemInput"]},ResolverInputTypes["CreatePlatbyItemPayload"]],
createPlatbyRaw?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["CreatePlatbyRawInput"]},ResolverInputTypes["CreatePlatbyRawPayload"]],
createRozpi?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["CreateRozpiInput"]},ResolverInputTypes["CreateRozpiPayload"]],
createRozpisItem?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["CreateRozpisItemInput"]},ResolverInputTypes["CreateRozpisItemPayload"]],
createSession?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["CreateSessionInput"]},ResolverInputTypes["CreateSessionPayload"]],
createSkupiny?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["CreateSkupinyInput"]},ResolverInputTypes["CreateSkupinyPayload"]],
createUpozorneni?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["CreateUpozorneniInput"]},ResolverInputTypes["CreateUpozorneniPayload"]],
createUpozorneniSkupiny?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["CreateUpozorneniSkupinyInput"]},ResolverInputTypes["CreateUpozorneniSkupinyPayload"]],
createUser?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["CreateUserInput"]},ResolverInputTypes["CreateUserPayload"]],
createUsersSkupiny?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["CreateUsersSkupinyInput"]},ResolverInputTypes["CreateUsersSkupinyPayload"]],
createVideo?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["CreateVideoInput"]},ResolverInputTypes["CreateVideoPayload"]],
createVideoList?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["CreateVideoListInput"]},ResolverInputTypes["CreateVideoListPayload"]],
createVideoSource?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["CreateVideoSourceInput"]},ResolverInputTypes["CreateVideoSourcePayload"]],
updateAkceByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateAkceByNodeIdInput"]},ResolverInputTypes["UpdateAkcePayload"]],
updateAkce?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateAkceInput"]},ResolverInputTypes["UpdateAkcePayload"]],
updateAkceItemByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateAkceItemByNodeIdInput"]},ResolverInputTypes["UpdateAkceItemPayload"]],
updateAkceItem?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateAkceItemInput"]},ResolverInputTypes["UpdateAkceItemPayload"]],
updateAktualityByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateAktualityByNodeIdInput"]},ResolverInputTypes["UpdateAktualityPayload"]],
updateAktuality?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateAktualityInput"]},ResolverInputTypes["UpdateAktualityPayload"]],
updateDokumentyByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateDokumentyByNodeIdInput"]},ResolverInputTypes["UpdateDokumentyPayload"]],
updateDokumenty?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateDokumentyInput"]},ResolverInputTypes["UpdateDokumentyPayload"]],
updateGalerieDirByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateGalerieDirByNodeIdInput"]},ResolverInputTypes["UpdateGalerieDirPayload"]],
updateGalerieDir?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateGalerieDirInput"]},ResolverInputTypes["UpdateGalerieDirPayload"]],
updateGalerieFotoByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateGalerieFotoByNodeIdInput"]},ResolverInputTypes["UpdateGalerieFotoPayload"]],
updateGalerieFoto?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateGalerieFotoInput"]},ResolverInputTypes["UpdateGalerieFotoPayload"]],
updateNabidkaByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateNabidkaByNodeIdInput"]},ResolverInputTypes["UpdateNabidkaPayload"]],
updateNabidka?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateNabidkaInput"]},ResolverInputTypes["UpdateNabidkaPayload"]],
updateNabidkaItemByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateNabidkaItemByNodeIdInput"]},ResolverInputTypes["UpdateNabidkaItemPayload"]],
updateNabidkaItem?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateNabidkaItemInput"]},ResolverInputTypes["UpdateNabidkaItemPayload"]],
updatePageByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdatePageByNodeIdInput"]},ResolverInputTypes["UpdatePagePayload"]],
updatePage?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdatePageInput"]},ResolverInputTypes["UpdatePagePayload"]],
updatePageByUrl?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdatePageByUrlInput"]},ResolverInputTypes["UpdatePagePayload"]],
updateParameterByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateParameterByNodeIdInput"]},ResolverInputTypes["UpdateParameterPayload"]],
updateParameter?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateParameterInput"]},ResolverInputTypes["UpdateParameterPayload"]],
updateParyByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateParyByNodeIdInput"]},ResolverInputTypes["UpdateParyPayload"]],
updatePary?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateParyInput"]},ResolverInputTypes["UpdateParyPayload"]],
updateParyNavrhByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateParyNavrhByNodeIdInput"]},ResolverInputTypes["UpdateParyNavrhPayload"]],
updateParyNavrh?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateParyNavrhInput"]},ResolverInputTypes["UpdateParyNavrhPayload"]],
updatePermissionByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdatePermissionByNodeIdInput"]},ResolverInputTypes["UpdatePermissionPayload"]],
updatePermission?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdatePermissionInput"]},ResolverInputTypes["UpdatePermissionPayload"]],
updatePlatbyCategoryByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdatePlatbyCategoryByNodeIdInput"]},ResolverInputTypes["UpdatePlatbyCategoryPayload"]],
updatePlatbyCategory?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdatePlatbyCategoryInput"]},ResolverInputTypes["UpdatePlatbyCategoryPayload"]],
updatePlatbyCategoryGroupByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdatePlatbyCategoryGroupByNodeIdInput"]},ResolverInputTypes["UpdatePlatbyCategoryGroupPayload"]],
updatePlatbyCategoryGroup?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdatePlatbyCategoryGroupInput"]},ResolverInputTypes["UpdatePlatbyCategoryGroupPayload"]],
updatePlatbyGroupByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdatePlatbyGroupByNodeIdInput"]},ResolverInputTypes["UpdatePlatbyGroupPayload"]],
updatePlatbyGroup?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdatePlatbyGroupInput"]},ResolverInputTypes["UpdatePlatbyGroupPayload"]],
updatePlatbyGroupSkupinaByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdatePlatbyGroupSkupinaByNodeIdInput"]},ResolverInputTypes["UpdatePlatbyGroupSkupinaPayload"]],
updatePlatbyGroupSkupina?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdatePlatbyGroupSkupinaInput"]},ResolverInputTypes["UpdatePlatbyGroupSkupinaPayload"]],
updatePlatbyItemByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdatePlatbyItemByNodeIdInput"]},ResolverInputTypes["UpdatePlatbyItemPayload"]],
updatePlatbyItem?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdatePlatbyItemInput"]},ResolverInputTypes["UpdatePlatbyItemPayload"]],
updatePlatbyRawByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdatePlatbyRawByNodeIdInput"]},ResolverInputTypes["UpdatePlatbyRawPayload"]],
updatePlatbyRaw?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdatePlatbyRawInput"]},ResolverInputTypes["UpdatePlatbyRawPayload"]],
updateRozpiByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateRozpiByNodeIdInput"]},ResolverInputTypes["UpdateRozpiPayload"]],
updateRozpi?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateRozpiInput"]},ResolverInputTypes["UpdateRozpiPayload"]],
updateRozpisItemByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateRozpisItemByNodeIdInput"]},ResolverInputTypes["UpdateRozpisItemPayload"]],
updateRozpisItem?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateRozpisItemInput"]},ResolverInputTypes["UpdateRozpisItemPayload"]],
updateSessionByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateSessionByNodeIdInput"]},ResolverInputTypes["UpdateSessionPayload"]],
updateSession?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateSessionInput"]},ResolverInputTypes["UpdateSessionPayload"]],
updateSkupinyByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateSkupinyByNodeIdInput"]},ResolverInputTypes["UpdateSkupinyPayload"]],
updateSkupiny?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateSkupinyInput"]},ResolverInputTypes["UpdateSkupinyPayload"]],
updateUpozorneniByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateUpozorneniByNodeIdInput"]},ResolverInputTypes["UpdateUpozorneniPayload"]],
updateUpozorneni?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateUpozorneniInput"]},ResolverInputTypes["UpdateUpozorneniPayload"]],
updateUpozorneniSkupinyByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateUpozorneniSkupinyByNodeIdInput"]},ResolverInputTypes["UpdateUpozorneniSkupinyPayload"]],
updateUpozorneniSkupiny?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateUpozorneniSkupinyInput"]},ResolverInputTypes["UpdateUpozorneniSkupinyPayload"]],
updateUserByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateUserByNodeIdInput"]},ResolverInputTypes["UpdateUserPayload"]],
updateUser?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateUserInput"]},ResolverInputTypes["UpdateUserPayload"]],
updateUsersSkupinyByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateUsersSkupinyByNodeIdInput"]},ResolverInputTypes["UpdateUsersSkupinyPayload"]],
updateUsersSkupiny?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateUsersSkupinyInput"]},ResolverInputTypes["UpdateUsersSkupinyPayload"]],
updateVideoByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateVideoByNodeIdInput"]},ResolverInputTypes["UpdateVideoPayload"]],
updateVideo?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateVideoInput"]},ResolverInputTypes["UpdateVideoPayload"]],
updateVideoListByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateVideoListByNodeIdInput"]},ResolverInputTypes["UpdateVideoListPayload"]],
updateVideoList?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateVideoListInput"]},ResolverInputTypes["UpdateVideoListPayload"]],
updateVideoSourceByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateVideoSourceByNodeIdInput"]},ResolverInputTypes["UpdateVideoSourcePayload"]],
updateVideoSource?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UpdateVideoSourceInput"]},ResolverInputTypes["UpdateVideoSourcePayload"]],
deleteAkceByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteAkceByNodeIdInput"]},ResolverInputTypes["DeleteAkcePayload"]],
deleteAkce?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteAkceInput"]},ResolverInputTypes["DeleteAkcePayload"]],
deleteAkceItemByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteAkceItemByNodeIdInput"]},ResolverInputTypes["DeleteAkceItemPayload"]],
deleteAkceItem?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteAkceItemInput"]},ResolverInputTypes["DeleteAkceItemPayload"]],
deleteAktualityByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteAktualityByNodeIdInput"]},ResolverInputTypes["DeleteAktualityPayload"]],
deleteAktuality?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteAktualityInput"]},ResolverInputTypes["DeleteAktualityPayload"]],
deleteDokumentyByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteDokumentyByNodeIdInput"]},ResolverInputTypes["DeleteDokumentyPayload"]],
deleteDokumenty?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteDokumentyInput"]},ResolverInputTypes["DeleteDokumentyPayload"]],
deleteGalerieDirByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteGalerieDirByNodeIdInput"]},ResolverInputTypes["DeleteGalerieDirPayload"]],
deleteGalerieDir?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteGalerieDirInput"]},ResolverInputTypes["DeleteGalerieDirPayload"]],
deleteGalerieFotoByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteGalerieFotoByNodeIdInput"]},ResolverInputTypes["DeleteGalerieFotoPayload"]],
deleteGalerieFoto?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteGalerieFotoInput"]},ResolverInputTypes["DeleteGalerieFotoPayload"]],
deleteNabidkaByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteNabidkaByNodeIdInput"]},ResolverInputTypes["DeleteNabidkaPayload"]],
deleteNabidka?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteNabidkaInput"]},ResolverInputTypes["DeleteNabidkaPayload"]],
deleteNabidkaItemByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteNabidkaItemByNodeIdInput"]},ResolverInputTypes["DeleteNabidkaItemPayload"]],
deleteNabidkaItem?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteNabidkaItemInput"]},ResolverInputTypes["DeleteNabidkaItemPayload"]],
deleteParameterByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteParameterByNodeIdInput"]},ResolverInputTypes["DeleteParameterPayload"]],
deleteParameter?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteParameterInput"]},ResolverInputTypes["DeleteParameterPayload"]],
deleteParyByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteParyByNodeIdInput"]},ResolverInputTypes["DeleteParyPayload"]],
deletePary?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteParyInput"]},ResolverInputTypes["DeleteParyPayload"]],
deleteParyNavrhByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteParyNavrhByNodeIdInput"]},ResolverInputTypes["DeleteParyNavrhPayload"]],
deleteParyNavrh?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteParyNavrhInput"]},ResolverInputTypes["DeleteParyNavrhPayload"]],
deletePermissionByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeletePermissionByNodeIdInput"]},ResolverInputTypes["DeletePermissionPayload"]],
deletePermission?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeletePermissionInput"]},ResolverInputTypes["DeletePermissionPayload"]],
deletePlatbyCategoryByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeletePlatbyCategoryByNodeIdInput"]},ResolverInputTypes["DeletePlatbyCategoryPayload"]],
deletePlatbyCategory?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeletePlatbyCategoryInput"]},ResolverInputTypes["DeletePlatbyCategoryPayload"]],
deletePlatbyCategoryGroupByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeletePlatbyCategoryGroupByNodeIdInput"]},ResolverInputTypes["DeletePlatbyCategoryGroupPayload"]],
deletePlatbyCategoryGroup?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeletePlatbyCategoryGroupInput"]},ResolverInputTypes["DeletePlatbyCategoryGroupPayload"]],
deletePlatbyGroupByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeletePlatbyGroupByNodeIdInput"]},ResolverInputTypes["DeletePlatbyGroupPayload"]],
deletePlatbyGroup?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeletePlatbyGroupInput"]},ResolverInputTypes["DeletePlatbyGroupPayload"]],
deletePlatbyGroupSkupinaByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeletePlatbyGroupSkupinaByNodeIdInput"]},ResolverInputTypes["DeletePlatbyGroupSkupinaPayload"]],
deletePlatbyGroupSkupina?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeletePlatbyGroupSkupinaInput"]},ResolverInputTypes["DeletePlatbyGroupSkupinaPayload"]],
deletePlatbyItemByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeletePlatbyItemByNodeIdInput"]},ResolverInputTypes["DeletePlatbyItemPayload"]],
deletePlatbyItem?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeletePlatbyItemInput"]},ResolverInputTypes["DeletePlatbyItemPayload"]],
deletePlatbyRawByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeletePlatbyRawByNodeIdInput"]},ResolverInputTypes["DeletePlatbyRawPayload"]],
deletePlatbyRaw?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeletePlatbyRawInput"]},ResolverInputTypes["DeletePlatbyRawPayload"]],
deleteRozpiByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteRozpiByNodeIdInput"]},ResolverInputTypes["DeleteRozpiPayload"]],
deleteRozpi?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteRozpiInput"]},ResolverInputTypes["DeleteRozpiPayload"]],
deleteRozpisItemByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteRozpisItemByNodeIdInput"]},ResolverInputTypes["DeleteRozpisItemPayload"]],
deleteRozpisItem?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteRozpisItemInput"]},ResolverInputTypes["DeleteRozpisItemPayload"]],
deleteSessionByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteSessionByNodeIdInput"]},ResolverInputTypes["DeleteSessionPayload"]],
deleteSession?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteSessionInput"]},ResolverInputTypes["DeleteSessionPayload"]],
deleteSkupinyByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteSkupinyByNodeIdInput"]},ResolverInputTypes["DeleteSkupinyPayload"]],
deleteSkupiny?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteSkupinyInput"]},ResolverInputTypes["DeleteSkupinyPayload"]],
deleteUpozorneniByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteUpozorneniByNodeIdInput"]},ResolverInputTypes["DeleteUpozorneniPayload"]],
deleteUpozorneni?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteUpozorneniInput"]},ResolverInputTypes["DeleteUpozorneniPayload"]],
deleteUpozorneniSkupinyByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteUpozorneniSkupinyByNodeIdInput"]},ResolverInputTypes["DeleteUpozorneniSkupinyPayload"]],
deleteUpozorneniSkupiny?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteUpozorneniSkupinyInput"]},ResolverInputTypes["DeleteUpozorneniSkupinyPayload"]],
deleteUserByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteUserByNodeIdInput"]},ResolverInputTypes["DeleteUserPayload"]],
deleteUser?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteUserInput"]},ResolverInputTypes["DeleteUserPayload"]],
deleteUsersSkupinyByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteUsersSkupinyByNodeIdInput"]},ResolverInputTypes["DeleteUsersSkupinyPayload"]],
deleteUsersSkupiny?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteUsersSkupinyInput"]},ResolverInputTypes["DeleteUsersSkupinyPayload"]],
deleteVideoByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteVideoByNodeIdInput"]},ResolverInputTypes["DeleteVideoPayload"]],
deleteVideo?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteVideoInput"]},ResolverInputTypes["DeleteVideoPayload"]],
deleteVideoListByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteVideoListByNodeIdInput"]},ResolverInputTypes["DeleteVideoListPayload"]],
deleteVideoList?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteVideoListInput"]},ResolverInputTypes["DeleteVideoListPayload"]],
deleteVideoSourceByNodeId?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteVideoSourceByNodeIdInput"]},ResolverInputTypes["DeleteVideoSourcePayload"]],
deleteVideoSource?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["DeleteVideoSourceInput"]},ResolverInputTypes["DeleteVideoSourcePayload"]],
login?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["LoginInput"]},ResolverInputTypes["LoginPayload"]],
logout?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["LogoutInput"]},ResolverInputTypes["LogoutPayload"]],
prospectFormDancer?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["ProspectFormDancerInput"]},ResolverInputTypes["ProspectFormDancerPayload"]],
uploadFile?: [{	/** The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields. */
	input: ResolverInputTypes["UploadInput"]},ResolverInputTypes["Upload"]],
		__typename?: boolean | `@${string}`
}>;
	/** The output of our create `Akce` mutation. */
["CreateAkcePayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Akce` that was created by this mutation. */
	akce?:ResolverInputTypes["Akce"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
akceEdge?: [{	/** The method to use when ordering `Akce`. */
	orderBy?: Array<ResolverInputTypes["AkcesOrderBy"]> | undefined | null},ResolverInputTypes["AkcesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `Akce` mutation. */
["CreateAkceInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The `Akce` to be created by this mutation. */
	akce: ResolverInputTypes["AkceInput"]
};
	/** An input for mutations affecting `Akce` */
["AkceInput"]: {
	aId?: ResolverInputTypes["BigInt"] | undefined | null,
	aJmeno: string,
	aKde: string,
	aInfo: string,
	aOd: ResolverInputTypes["Date"],
	aDo: ResolverInputTypes["Date"],
	aKapacita?: ResolverInputTypes["BigInt"] | undefined | null,
	aDokumenty: string,
	aTimestamp?: ResolverInputTypes["Datetime"] | undefined | null,
	aLock?: boolean | undefined | null,
	aVisible?: boolean | undefined | null
};
	/** The output of our create `AkceItem` mutation. */
["CreateAkceItemPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `AkceItem` that was created by this mutation. */
	akceItem?:ResolverInputTypes["AkceItem"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `Akce` that is related to this `AkceItem`. */
	akceByAiIdRodic?:ResolverInputTypes["Akce"],
	/** Reads a single `User` that is related to this `AkceItem`. */
	userByAiUser?:ResolverInputTypes["User"],
akceItemEdge?: [{	/** The method to use when ordering `AkceItem`. */
	orderBy?: Array<ResolverInputTypes["AkceItemsOrderBy"]> | undefined | null},ResolverInputTypes["AkceItemsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `AkceItem` mutation. */
["CreateAkceItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The `AkceItem` to be created by this mutation. */
	akceItem: ResolverInputTypes["AkceItemInput"]
};
	/** An input for mutations affecting `AkceItem` */
["AkceItemInput"]: {
	aiId?: ResolverInputTypes["BigInt"] | undefined | null,
	aiIdRodic: ResolverInputTypes["BigInt"],
	aiUser: ResolverInputTypes["BigInt"],
	aiRokNarozeni: number
};
	/** The output of our create `Aktuality` mutation. */
["CreateAktualityPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Aktuality` that was created by this mutation. */
	aktuality?:ResolverInputTypes["Aktuality"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `User` that is related to this `Aktuality`. */
	userByAtKdo?:ResolverInputTypes["User"],
	/** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
	galerieFotoByAtFotoMain?:ResolverInputTypes["GalerieFoto"],
aktualityEdge?: [{	/** The method to use when ordering `Aktuality`. */
	orderBy?: Array<ResolverInputTypes["AktualitiesOrderBy"]> | undefined | null},ResolverInputTypes["AktualitiesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `Aktuality` mutation. */
["CreateAktualityInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The `Aktuality` to be created by this mutation. */
	aktuality: ResolverInputTypes["AktualityInput"]
};
	/** An input for mutations affecting `Aktuality` */
["AktualityInput"]: {
	atId?: ResolverInputTypes["BigInt"] | undefined | null,
	atKdo: ResolverInputTypes["BigInt"],
	atKat: string,
	atJmeno: string,
	atText: string,
	atPreview: string,
	atFoto?: ResolverInputTypes["BigInt"] | undefined | null,
	atFotoMain?: ResolverInputTypes["BigInt"] | undefined | null,
	atTimestamp?: ResolverInputTypes["Datetime"] | undefined | null,
	atTimestampAdd?: ResolverInputTypes["Datetime"] | undefined | null
};
	/** The output of our create `Dokumenty` mutation. */
["CreateDokumentyPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Dokumenty` that was created by this mutation. */
	dokumenty?:ResolverInputTypes["Dokumenty"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `User` that is related to this `Dokumenty`. */
	userByDKdo?:ResolverInputTypes["User"],
dokumentyEdge?: [{	/** The method to use when ordering `Dokumenty`. */
	orderBy?: Array<ResolverInputTypes["DokumentiesOrderBy"]> | undefined | null},ResolverInputTypes["DokumentiesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `Dokumenty` mutation. */
["CreateDokumentyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The `Dokumenty` to be created by this mutation. */
	dokumenty: ResolverInputTypes["DokumentyInput"]
};
	/** An input for mutations affecting `Dokumenty` */
["DokumentyInput"]: {
	dId?: ResolverInputTypes["BigInt"] | undefined | null,
	dPath: string,
	dName: string,
	dFilename: string,
	dKategorie: number,
	dKdo: ResolverInputTypes["BigInt"],
	dTimestamp?: ResolverInputTypes["Datetime"] | undefined | null
};
	/** The output of our create `GalerieDir` mutation. */
["CreateGalerieDirPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `GalerieDir` that was created by this mutation. */
	galerieDir?:ResolverInputTypes["GalerieDir"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
galerieDirEdge?: [{	/** The method to use when ordering `GalerieDir`. */
	orderBy?: Array<ResolverInputTypes["GalerieDirsOrderBy"]> | undefined | null},ResolverInputTypes["GalerieDirsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `GalerieDir` mutation. */
["CreateGalerieDirInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The `GalerieDir` to be created by this mutation. */
	galerieDir: ResolverInputTypes["GalerieDirInput"]
};
	/** An input for mutations affecting `GalerieDir` */
["GalerieDirInput"]: {
	gdId?: ResolverInputTypes["BigInt"] | undefined | null,
	gdIdRodic: ResolverInputTypes["BigInt"],
	gdName: string,
	gdLevel?: number | undefined | null,
	gdPath: string,
	gdHidden?: boolean | undefined | null
};
	/** The output of our create `GalerieFoto` mutation. */
["CreateGalerieFotoPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `GalerieFoto` that was created by this mutation. */
	galerieFoto?:ResolverInputTypes["GalerieFoto"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
	galerieDirByGfIdRodic?:ResolverInputTypes["GalerieDir"],
	/** Reads a single `User` that is related to this `GalerieFoto`. */
	userByGfKdo?:ResolverInputTypes["User"],
galerieFotoEdge?: [{	/** The method to use when ordering `GalerieFoto`. */
	orderBy?: Array<ResolverInputTypes["GalerieFotosOrderBy"]> | undefined | null},ResolverInputTypes["GalerieFotosEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `GalerieFoto` mutation. */
["CreateGalerieFotoInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The `GalerieFoto` to be created by this mutation. */
	galerieFoto: ResolverInputTypes["GalerieFotoInput"]
};
	/** An input for mutations affecting `GalerieFoto` */
["GalerieFotoInput"]: {
	gfId?: ResolverInputTypes["BigInt"] | undefined | null,
	gfIdRodic: ResolverInputTypes["BigInt"],
	gfName: string,
	gfPath: string,
	gfKdo: ResolverInputTypes["BigInt"],
	gfTimestamp?: ResolverInputTypes["Datetime"] | undefined | null
};
	/** The output of our create `Nabidka` mutation. */
["CreateNabidkaPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Nabidka` that was created by this mutation. */
	nabidka?:ResolverInputTypes["Nabidka"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `User` that is related to this `Nabidka`. */
	userByNTrener?:ResolverInputTypes["User"],
nabidkaEdge?: [{	/** The method to use when ordering `Nabidka`. */
	orderBy?: Array<ResolverInputTypes["NabidkasOrderBy"]> | undefined | null},ResolverInputTypes["NabidkasEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `Nabidka` mutation. */
["CreateNabidkaInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The `Nabidka` to be created by this mutation. */
	nabidka: ResolverInputTypes["NabidkaInput"]
};
	/** An input for mutations affecting `Nabidka` */
["NabidkaInput"]: {
	nId?: ResolverInputTypes["BigInt"] | undefined | null,
	nTrener: ResolverInputTypes["BigInt"],
	nPocetHod?: number | undefined | null,
	nMaxPocetHod?: ResolverInputTypes["BigInt"] | undefined | null,
	nOd: ResolverInputTypes["Date"],
	nDo: ResolverInputTypes["Date"],
	nVisible?: boolean | undefined | null,
	nLock?: boolean | undefined | null,
	nTimestamp?: ResolverInputTypes["Datetime"] | undefined | null
};
	/** The output of our create `NabidkaItem` mutation. */
["CreateNabidkaItemPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `NabidkaItem` that was created by this mutation. */
	nabidkaItem?:ResolverInputTypes["NabidkaItem"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `Nabidka` that is related to this `NabidkaItem`. */
	nabidkaByNiIdRodic?:ResolverInputTypes["Nabidka"],
	/** Reads a single `Pary` that is related to this `NabidkaItem`. */
	paryByNiPartner?:ResolverInputTypes["Pary"],
nabidkaItemEdge?: [{	/** The method to use when ordering `NabidkaItem`. */
	orderBy?: Array<ResolverInputTypes["NabidkaItemsOrderBy"]> | undefined | null},ResolverInputTypes["NabidkaItemsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `NabidkaItem` mutation. */
["CreateNabidkaItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The `NabidkaItem` to be created by this mutation. */
	nabidkaItem: ResolverInputTypes["NabidkaItemInput"]
};
	/** An input for mutations affecting `NabidkaItem` */
["NabidkaItemInput"]: {
	niId?: ResolverInputTypes["BigInt"] | undefined | null,
	niIdRodic: ResolverInputTypes["BigInt"],
	niPartner: ResolverInputTypes["BigInt"],
	niPocetHod?: number | undefined | null,
	niLock?: boolean | undefined | null
};
	/** The output of our create `Page` mutation. */
["CreatePagePayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Page` that was created by this mutation. */
	page?:ResolverInputTypes["Page"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
pageEdge?: [{	/** The method to use when ordering `Page`. */
	orderBy?: Array<ResolverInputTypes["PagesOrderBy"]> | undefined | null},ResolverInputTypes["PagesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `Page` mutation. */
["CreatePageInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The `Page` to be created by this mutation. */
	page: ResolverInputTypes["PageInput"]
};
	/** An input for mutations affecting `Page` */
["PageInput"]: {
	id?: number | undefined | null,
	url: string,
	content: ResolverInputTypes["JSON"],
	createdAt?: ResolverInputTypes["Datetime"] | undefined | null,
	updatedAt?: ResolverInputTypes["Datetime"] | undefined | null,
	title?: string | undefined | null
};
	/** The output of our create `Parameter` mutation. */
["CreateParameterPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Parameter` that was created by this mutation. */
	parameter?:ResolverInputTypes["Parameter"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
parameterEdge?: [{	/** The method to use when ordering `Parameter`. */
	orderBy?: Array<ResolverInputTypes["ParametersOrderBy"]> | undefined | null},ResolverInputTypes["ParametersEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `Parameter` mutation. */
["CreateParameterInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The `Parameter` to be created by this mutation. */
	parameter: ResolverInputTypes["ParameterInput"]
};
	/** An input for mutations affecting `Parameter` */
["ParameterInput"]: {
	paName: string,
	paValue: string
};
	/** The output of our create `Pary` mutation. */
["CreateParyPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Pary` that was created by this mutation. */
	pary?:ResolverInputTypes["Pary"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `User` that is related to this `Pary`. */
	userByPIdPartner?:ResolverInputTypes["User"],
paryEdge?: [{	/** The method to use when ordering `Pary`. */
	orderBy?: Array<ResolverInputTypes["PariesOrderBy"]> | undefined | null},ResolverInputTypes["PariesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `Pary` mutation. */
["CreateParyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The `Pary` to be created by this mutation. */
	pary: ResolverInputTypes["ParyInput"]
};
	/** An input for mutations affecting `Pary` */
["ParyInput"]: {
	pId?: ResolverInputTypes["BigInt"] | undefined | null,
	pIdPartner: ResolverInputTypes["BigInt"],
	pIdPartnerka?: ResolverInputTypes["BigInt"] | undefined | null,
	pSttTrida?: ResolverInputTypes["ParyPSttTrida"] | undefined | null,
	pSttBody?: number | undefined | null,
	pSttFinale?: boolean | undefined | null,
	pLatTrida?: ResolverInputTypes["ParyPLatTrida"] | undefined | null,
	pLatBody?: number | undefined | null,
	pLatFinale?: boolean | undefined | null,
	pHodnoceni?: number | undefined | null,
	pArchiv?: boolean | undefined | null,
	pTimestampAdd?: ResolverInputTypes["Datetime"] | undefined | null,
	pTimestampArchive?: ResolverInputTypes["Datetime"] | undefined | null
};
	/** The output of our create `ParyNavrh` mutation. */
["CreateParyNavrhPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `ParyNavrh` that was created by this mutation. */
	paryNavrh?:ResolverInputTypes["ParyNavrh"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnNavrhl?:ResolverInputTypes["User"],
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnPartner?:ResolverInputTypes["User"],
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnPartnerka?:ResolverInputTypes["User"],
paryNavrhEdge?: [{	/** The method to use when ordering `ParyNavrh`. */
	orderBy?: Array<ResolverInputTypes["ParyNavrhsOrderBy"]> | undefined | null},ResolverInputTypes["ParyNavrhsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `ParyNavrh` mutation. */
["CreateParyNavrhInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The `ParyNavrh` to be created by this mutation. */
	paryNavrh: ResolverInputTypes["ParyNavrhInput"]
};
	/** An input for mutations affecting `ParyNavrh` */
["ParyNavrhInput"]: {
	pnId?: ResolverInputTypes["BigInt"] | undefined | null,
	pnNavrhl: ResolverInputTypes["BigInt"],
	pnPartner: ResolverInputTypes["BigInt"],
	pnPartnerka: ResolverInputTypes["BigInt"]
};
	/** The output of our create `Permission` mutation. */
["CreatePermissionPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Permission` that was created by this mutation. */
	permission?:ResolverInputTypes["Permission"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
permissionEdge?: [{	/** The method to use when ordering `Permission`. */
	orderBy?: Array<ResolverInputTypes["PermissionsOrderBy"]> | undefined | null},ResolverInputTypes["PermissionsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `Permission` mutation. */
["CreatePermissionInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The `Permission` to be created by this mutation. */
	permission: ResolverInputTypes["PermissionInput"]
};
	/** An input for mutations affecting `Permission` */
["PermissionInput"]: {
	peId?: ResolverInputTypes["BigInt"] | undefined | null,
	peName: string,
	peDescription: string,
	peAkce: number,
	peAktuality: number,
	peAnkety: number,
	peDokumenty: number,
	peGalerie: number,
	peInzerce: number,
	peKonzole: number,
	peNabidka: number,
	peNastenka: number,
	peNovinky: number,
	pePary: number,
	pePlatby: number,
	pePermissions: number,
	peRozpis: number,
	peSkupiny: number,
	peUsers: number,
	peMain: number
};
	/** The output of our create `PlatbyCategory` mutation. */
["CreatePlatbyCategoryPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyCategory` that was created by this mutation. */
	platbyCategory?:ResolverInputTypes["PlatbyCategory"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
platbyCategoryEdge?: [{	/** The method to use when ordering `PlatbyCategory`. */
	orderBy?: Array<ResolverInputTypes["PlatbyCategoriesOrderBy"]> | undefined | null},ResolverInputTypes["PlatbyCategoriesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `PlatbyCategory` mutation. */
["CreatePlatbyCategoryInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The `PlatbyCategory` to be created by this mutation. */
	platbyCategory: ResolverInputTypes["PlatbyCategoryInput"]
};
	/** An input for mutations affecting `PlatbyCategory` */
["PlatbyCategoryInput"]: {
	pcId?: ResolverInputTypes["BigInt"] | undefined | null,
	pcName: string,
	pcSymbol: ResolverInputTypes["BigInt"],
	pcAmount: ResolverInputTypes["BigFloat"],
	pcDateDue: ResolverInputTypes["Date"],
	pcValidFrom: ResolverInputTypes["Date"],
	pcValidTo: ResolverInputTypes["Date"],
	pcUseBase?: boolean | undefined | null,
	pcUsePrefix?: boolean | undefined | null,
	pcArchive?: boolean | undefined | null,
	pcVisible?: boolean | undefined | null
};
	/** The output of our create `PlatbyCategoryGroup` mutation. */
["CreatePlatbyCategoryGroupPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyCategoryGroup` that was created by this mutation. */
	platbyCategoryGroup?:ResolverInputTypes["PlatbyCategoryGroup"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `PlatbyGroup` that is related to this `PlatbyCategoryGroup`. */
	platbyGroupByPcgIdGroup?:ResolverInputTypes["PlatbyGroup"],
	/** Reads a single `PlatbyCategory` that is related to this `PlatbyCategoryGroup`. */
	platbyCategoryByPcgIdCategory?:ResolverInputTypes["PlatbyCategory"],
platbyCategoryGroupEdge?: [{	/** The method to use when ordering `PlatbyCategoryGroup`. */
	orderBy?: Array<ResolverInputTypes["PlatbyCategoryGroupsOrderBy"]> | undefined | null},ResolverInputTypes["PlatbyCategoryGroupsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `PlatbyCategoryGroup` mutation. */
["CreatePlatbyCategoryGroupInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The `PlatbyCategoryGroup` to be created by this mutation. */
	platbyCategoryGroup: ResolverInputTypes["PlatbyCategoryGroupInput"]
};
	/** An input for mutations affecting `PlatbyCategoryGroup` */
["PlatbyCategoryGroupInput"]: {
	pcgId?: ResolverInputTypes["BigInt"] | undefined | null,
	pcgIdGroup: ResolverInputTypes["BigInt"],
	pcgIdCategory: ResolverInputTypes["BigInt"]
};
	/** The output of our create `PlatbyGroup` mutation. */
["CreatePlatbyGroupPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyGroup` that was created by this mutation. */
	platbyGroup?:ResolverInputTypes["PlatbyGroup"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
platbyGroupEdge?: [{	/** The method to use when ordering `PlatbyGroup`. */
	orderBy?: Array<ResolverInputTypes["PlatbyGroupsOrderBy"]> | undefined | null},ResolverInputTypes["PlatbyGroupsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `PlatbyGroup` mutation. */
["CreatePlatbyGroupInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The `PlatbyGroup` to be created by this mutation. */
	platbyGroup: ResolverInputTypes["PlatbyGroupInput"]
};
	/** An input for mutations affecting `PlatbyGroup` */
["PlatbyGroupInput"]: {
	pgId?: ResolverInputTypes["BigInt"] | undefined | null,
	pgType?: ResolverInputTypes["BigFloat"] | undefined | null,
	pgName: string,
	pgDescription: string,
	pgBase?: ResolverInputTypes["BigInt"] | undefined | null
};
	/** The output of our create `PlatbyGroupSkupina` mutation. */
["CreatePlatbyGroupSkupinaPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyGroupSkupina` that was created by this mutation. */
	platbyGroupSkupina?:ResolverInputTypes["PlatbyGroupSkupina"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `Skupiny` that is related to this `PlatbyGroupSkupina`. */
	skupinyByPgsIdSkupina?:ResolverInputTypes["Skupiny"],
	/** Reads a single `PlatbyGroup` that is related to this `PlatbyGroupSkupina`. */
	platbyGroupByPgsIdGroup?:ResolverInputTypes["PlatbyGroup"],
platbyGroupSkupinaEdge?: [{	/** The method to use when ordering `PlatbyGroupSkupina`. */
	orderBy?: Array<ResolverInputTypes["PlatbyGroupSkupinasOrderBy"]> | undefined | null},ResolverInputTypes["PlatbyGroupSkupinasEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `PlatbyGroupSkupina` mutation. */
["CreatePlatbyGroupSkupinaInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The `PlatbyGroupSkupina` to be created by this mutation. */
	platbyGroupSkupina: ResolverInputTypes["PlatbyGroupSkupinaInput"]
};
	/** An input for mutations affecting `PlatbyGroupSkupina` */
["PlatbyGroupSkupinaInput"]: {
	pgsId?: ResolverInputTypes["BigInt"] | undefined | null,
	pgsIdSkupina: ResolverInputTypes["BigInt"],
	pgsIdGroup: ResolverInputTypes["BigInt"]
};
	/** The output of our create `PlatbyItem` mutation. */
["CreatePlatbyItemPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyItem` that was created by this mutation. */
	platbyItem?:ResolverInputTypes["PlatbyItem"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `User` that is related to this `PlatbyItem`. */
	userByPiIdUser?:ResolverInputTypes["User"],
	/** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
	platbyCategoryByPiIdCategory?:ResolverInputTypes["PlatbyCategory"],
	/** Reads a single `PlatbyRaw` that is related to this `PlatbyItem`. */
	platbyRawByPiIdRaw?:ResolverInputTypes["PlatbyRaw"],
platbyItemEdge?: [{	/** The method to use when ordering `PlatbyItem`. */
	orderBy?: Array<ResolverInputTypes["PlatbyItemsOrderBy"]> | undefined | null},ResolverInputTypes["PlatbyItemsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `PlatbyItem` mutation. */
["CreatePlatbyItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The `PlatbyItem` to be created by this mutation. */
	platbyItem: ResolverInputTypes["PlatbyItemInput"]
};
	/** An input for mutations affecting `PlatbyItem` */
["PlatbyItemInput"]: {
	piId?: ResolverInputTypes["BigInt"] | undefined | null,
	piIdUser?: ResolverInputTypes["BigInt"] | undefined | null,
	piIdCategory: ResolverInputTypes["BigInt"],
	piIdRaw?: ResolverInputTypes["BigInt"] | undefined | null,
	piAmount: ResolverInputTypes["BigFloat"],
	piDate: ResolverInputTypes["Date"],
	piPrefix?: number | undefined | null
};
	/** The output of our create `PlatbyRaw` mutation. */
["CreatePlatbyRawPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyRaw` that was created by this mutation. */
	platbyRaw?:ResolverInputTypes["PlatbyRaw"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
platbyRawEdge?: [{	/** The method to use when ordering `PlatbyRaw`. */
	orderBy?: Array<ResolverInputTypes["PlatbyRawsOrderBy"]> | undefined | null},ResolverInputTypes["PlatbyRawsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `PlatbyRaw` mutation. */
["CreatePlatbyRawInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The `PlatbyRaw` to be created by this mutation. */
	platbyRaw: ResolverInputTypes["PlatbyRawInput"]
};
	/** An input for mutations affecting `PlatbyRaw` */
["PlatbyRawInput"]: {
	prId?: ResolverInputTypes["BigInt"] | undefined | null,
	prRaw: string,
	prHash: string,
	prSorted?: boolean | undefined | null,
	prDiscarded?: boolean | undefined | null
};
	/** The output of our create `Rozpi` mutation. */
["CreateRozpiPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Rozpi` that was created by this mutation. */
	rozpi?:ResolverInputTypes["Rozpi"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `User` that is related to this `Rozpi`. */
	userByRTrener?:ResolverInputTypes["User"],
rozpiEdge?: [{	/** The method to use when ordering `Rozpi`. */
	orderBy?: Array<ResolverInputTypes["RozpisOrderBy"]> | undefined | null},ResolverInputTypes["RozpisEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `Rozpi` mutation. */
["CreateRozpiInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The `Rozpi` to be created by this mutation. */
	rozpi: ResolverInputTypes["RozpiInput"]
};
	/** An input for mutations affecting `Rozpi` */
["RozpiInput"]: {
	rId?: ResolverInputTypes["BigInt"] | undefined | null,
	rTrener: ResolverInputTypes["BigInt"],
	rKde: string,
	rDatum: ResolverInputTypes["Date"],
	rVisible?: boolean | undefined | null,
	rLock?: boolean | undefined | null,
	rTimestamp?: ResolverInputTypes["Datetime"] | undefined | null
};
	/** The output of our create `RozpisItem` mutation. */
["CreateRozpisItemPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `RozpisItem` that was created by this mutation. */
	rozpisItem?:ResolverInputTypes["RozpisItem"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `Rozpi` that is related to this `RozpisItem`. */
	rozpiByRiIdRodic?:ResolverInputTypes["Rozpi"],
	/** Reads a single `Pary` that is related to this `RozpisItem`. */
	paryByRiPartner?:ResolverInputTypes["Pary"],
rozpisItemEdge?: [{	/** The method to use when ordering `RozpisItem`. */
	orderBy?: Array<ResolverInputTypes["RozpisItemsOrderBy"]> | undefined | null},ResolverInputTypes["RozpisItemsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `RozpisItem` mutation. */
["CreateRozpisItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The `RozpisItem` to be created by this mutation. */
	rozpisItem: ResolverInputTypes["RozpisItemInput"]
};
	/** An input for mutations affecting `RozpisItem` */
["RozpisItemInput"]: {
	riId?: ResolverInputTypes["BigInt"] | undefined | null,
	riIdRodic: ResolverInputTypes["BigInt"],
	riPartner?: ResolverInputTypes["BigInt"] | undefined | null,
	riOd: ResolverInputTypes["Time"],
	riDo: ResolverInputTypes["Time"],
	riLock?: boolean | undefined | null
};
	/** The output of our create `Session` mutation. */
["CreateSessionPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Session` that was created by this mutation. */
	session?:ResolverInputTypes["Session"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `User` that is related to this `Session`. */
	userBySsUser?:ResolverInputTypes["User"],
sessionEdge?: [{	/** The method to use when ordering `Session`. */
	orderBy?: Array<ResolverInputTypes["SessionsOrderBy"]> | undefined | null},ResolverInputTypes["SessionsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `Session` mutation. */
["CreateSessionInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The `Session` to be created by this mutation. */
	session: ResolverInputTypes["SessionInput"]
};
	/** An input for mutations affecting `Session` */
["SessionInput"]: {
	ssId: string,
	ssData: string,
	ssUpdatedAt?: ResolverInputTypes["Datetime"] | undefined | null,
	ssLifetime: ResolverInputTypes["BigInt"],
	ssUser?: ResolverInputTypes["BigInt"] | undefined | null
};
	/** The output of our create `Skupiny` mutation. */
["CreateSkupinyPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Skupiny` that was created by this mutation. */
	skupiny?:ResolverInputTypes["Skupiny"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
skupinyEdge?: [{	/** The method to use when ordering `Skupiny`. */
	orderBy?: Array<ResolverInputTypes["SkupiniesOrderBy"]> | undefined | null},ResolverInputTypes["SkupiniesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `Skupiny` mutation. */
["CreateSkupinyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The `Skupiny` to be created by this mutation. */
	skupiny: ResolverInputTypes["SkupinyInput"]
};
	/** An input for mutations affecting `Skupiny` */
["SkupinyInput"]: {
	sId?: ResolverInputTypes["BigInt"] | undefined | null,
	sName: string,
	sDescription: string,
	sColorRgb: string,
	sColorText: string,
	sLocation?: string | undefined | null,
	sVisible?: boolean | undefined | null
};
	/** The output of our create `Upozorneni` mutation. */
["CreateUpozorneniPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Upozorneni` that was created by this mutation. */
	upozorneni?:ResolverInputTypes["Upozorneni"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `User` that is related to this `Upozorneni`. */
	userByUpKdo?:ResolverInputTypes["User"],
upozorneniEdge?: [{	/** The method to use when ordering `Upozorneni`. */
	orderBy?: Array<ResolverInputTypes["UpozornenisOrderBy"]> | undefined | null},ResolverInputTypes["UpozornenisEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `Upozorneni` mutation. */
["CreateUpozorneniInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The `Upozorneni` to be created by this mutation. */
	upozorneni: ResolverInputTypes["UpozorneniInput"]
};
	/** An input for mutations affecting `Upozorneni` */
["UpozorneniInput"]: {
	upId?: ResolverInputTypes["BigInt"] | undefined | null,
	upKdo: ResolverInputTypes["BigInt"],
	upNadpis: string,
	upText: string,
	upBarvy?: ResolverInputTypes["BigInt"] | undefined | null,
	upLock?: boolean | undefined | null,
	upTimestamp?: ResolverInputTypes["Datetime"] | undefined | null,
	upTimestampAdd?: ResolverInputTypes["Datetime"] | undefined | null
};
	/** The output of our create `UpozorneniSkupiny` mutation. */
["CreateUpozorneniSkupinyPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `UpozorneniSkupiny` that was created by this mutation. */
	upozorneniSkupiny?:ResolverInputTypes["UpozorneniSkupiny"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
	upozorneniByUpsIdRodic?:ResolverInputTypes["Upozorneni"],
	/** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
	skupinyByUpsIdSkupina?:ResolverInputTypes["Skupiny"],
upozorneniSkupinyEdge?: [{	/** The method to use when ordering `UpozorneniSkupiny`. */
	orderBy?: Array<ResolverInputTypes["UpozorneniSkupiniesOrderBy"]> | undefined | null},ResolverInputTypes["UpozorneniSkupiniesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `UpozorneniSkupiny` mutation. */
["CreateUpozorneniSkupinyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The `UpozorneniSkupiny` to be created by this mutation. */
	upozorneniSkupiny: ResolverInputTypes["UpozorneniSkupinyInput"]
};
	/** An input for mutations affecting `UpozorneniSkupiny` */
["UpozorneniSkupinyInput"]: {
	upsId?: ResolverInputTypes["BigInt"] | undefined | null,
	upsIdRodic: ResolverInputTypes["BigInt"],
	upsIdSkupina: ResolverInputTypes["BigInt"],
	upsColor: string,
	upsPopis: string
};
	/** The output of our create `User` mutation. */
["CreateUserPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `User` that was created by this mutation. */
	user?:ResolverInputTypes["User"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `Permission` that is related to this `User`. */
	permissionByUGroup?:ResolverInputTypes["Permission"],
	/** Reads a single `Skupiny` that is related to this `User`. */
	skupinyByUSkupina?:ResolverInputTypes["Skupiny"],
userEdge?: [{	/** The method to use when ordering `User`. */
	orderBy?: Array<ResolverInputTypes["UsersOrderBy"]> | undefined | null},ResolverInputTypes["UsersEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `User` mutation. */
["CreateUserInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The `User` to be created by this mutation. */
	user: ResolverInputTypes["UserInput"]
};
	/** An input for mutations affecting `User` */
["UserInput"]: {
	uId?: ResolverInputTypes["BigInt"] | undefined | null,
	uLogin: string,
	uPass: string,
	uJmeno: string,
	uPrijmeni: string,
	uPohlavi: string,
	uEmail: string,
	uTelefon: string,
	uNarozeni: ResolverInputTypes["Date"],
	uRodneCislo?: string | undefined | null,
	uPoznamky?: string | undefined | null,
	uTimestamp?: ResolverInputTypes["Datetime"] | undefined | null,
	uLevel?: number | undefined | null,
	uGroup: ResolverInputTypes["BigInt"],
	uSkupina?: ResolverInputTypes["BigInt"] | undefined | null,
	uDancer?: boolean | undefined | null,
	uBan?: boolean | undefined | null,
	uLock?: boolean | undefined | null,
	uConfirmed?: boolean | undefined | null,
	uSystem?: boolean | undefined | null,
	uStreet: string,
	uConscriptionNumber?: string | undefined | null,
	uOrientationNumber?: string | undefined | null,
	uDistrict?: string | undefined | null,
	uCity: string,
	uPostalCode: string,
	uNationality: string,
	uMemberSince?: ResolverInputTypes["Datetime"] | undefined | null,
	uMemberUntil?: ResolverInputTypes["Datetime"] | undefined | null,
	uCreatedAt?: ResolverInputTypes["Datetime"] | undefined | null,
	uTeacher?: boolean | undefined | null,
	uGdprSignedAt?: ResolverInputTypes["Datetime"] | undefined | null
};
	/** The output of our create `UsersSkupiny` mutation. */
["CreateUsersSkupinyPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `UsersSkupiny` that was created by this mutation. */
	usersSkupiny?:ResolverInputTypes["UsersSkupiny"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
usersSkupinyEdge?: [{	/** The method to use when ordering `UsersSkupiny`. */
	orderBy?: Array<ResolverInputTypes["UsersSkupiniesOrderBy"]> | undefined | null},ResolverInputTypes["UsersSkupiniesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `UsersSkupiny` mutation. */
["CreateUsersSkupinyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The `UsersSkupiny` to be created by this mutation. */
	usersSkupiny: ResolverInputTypes["UsersSkupinyInput"]
};
	/** An input for mutations affecting `UsersSkupiny` */
["UsersSkupinyInput"]: {
	usId?: ResolverInputTypes["BigInt"] | undefined | null,
	usColor?: string | undefined | null,
	usPlatbaMesic?: ResolverInputTypes["BigInt"] | undefined | null,
	usPlatbaCtvrtrok?: ResolverInputTypes["BigInt"] | undefined | null,
	usPlatbaPulrok?: ResolverInputTypes["BigInt"] | undefined | null,
	usPopis: string
};
	/** The output of our create `Video` mutation. */
["CreateVideoPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Video` that was created by this mutation. */
	video?:ResolverInputTypes["Video"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
videoEdge?: [{	/** The method to use when ordering `Video`. */
	orderBy?: Array<ResolverInputTypes["VideosOrderBy"]> | undefined | null},ResolverInputTypes["VideosEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `Video` mutation. */
["CreateVideoInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The `Video` to be created by this mutation. */
	video: ResolverInputTypes["VideoInput"]
};
	/** An input for mutations affecting `Video` */
["VideoInput"]: {
	vId?: ResolverInputTypes["BigInt"] | undefined | null,
	vUri: string,
	vTitle: string,
	vAuthor: string,
	vDescription: string,
	vPlaylist?: string | undefined | null,
	vCreatedAt: ResolverInputTypes["Datetime"],
	vUpdatedAt?: ResolverInputTypes["Datetime"] | undefined | null
};
	/** The output of our create `VideoList` mutation. */
["CreateVideoListPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `VideoList` that was created by this mutation. */
	videoList?:ResolverInputTypes["VideoList"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
videoListEdge?: [{	/** The method to use when ordering `VideoList`. */
	orderBy?: Array<ResolverInputTypes["VideoListsOrderBy"]> | undefined | null},ResolverInputTypes["VideoListsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `VideoList` mutation. */
["CreateVideoListInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The `VideoList` to be created by this mutation. */
	videoList: ResolverInputTypes["VideoListInput"]
};
	/** An input for mutations affecting `VideoList` */
["VideoListInput"]: {
	vlId?: ResolverInputTypes["BigInt"] | undefined | null,
	vlUrl: string,
	vlTitle: string,
	vlDescription: string,
	vlCount: ResolverInputTypes["BigInt"],
	vlCreatedAt: ResolverInputTypes["Datetime"],
	vlLastChecked?: ResolverInputTypes["Datetime"] | undefined | null
};
	/** The output of our create `VideoSource` mutation. */
["CreateVideoSourcePayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `VideoSource` that was created by this mutation. */
	videoSource?:ResolverInputTypes["VideoSource"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
videoSourceEdge?: [{	/** The method to use when ordering `VideoSource`. */
	orderBy?: Array<ResolverInputTypes["VideoSourcesOrderBy"]> | undefined | null},ResolverInputTypes["VideoSourcesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the create `VideoSource` mutation. */
["CreateVideoSourceInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The `VideoSource` to be created by this mutation. */
	videoSource: ResolverInputTypes["VideoSourceInput"]
};
	/** An input for mutations affecting `VideoSource` */
["VideoSourceInput"]: {
	vsId?: ResolverInputTypes["BigInt"] | undefined | null,
	vsUrl: string,
	vsTitle?: string | undefined | null,
	vsDescription?: string | undefined | null,
	vsCreatedAt?: ResolverInputTypes["Datetime"] | undefined | null,
	vsLastChecked?: ResolverInputTypes["Datetime"] | undefined | null
};
	/** The output of our update `Akce` mutation. */
["UpdateAkcePayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Akce` that was updated by this mutation. */
	akce?:ResolverInputTypes["Akce"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
akceEdge?: [{	/** The method to use when ordering `Akce`. */
	orderBy?: Array<ResolverInputTypes["AkcesOrderBy"]> | undefined | null},ResolverInputTypes["AkcesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateAkceByNodeId` mutation. */
["UpdateAkceByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `Akce` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Akce` being updated. */
	patch: ResolverInputTypes["AkcePatch"]
};
	/** Represents an update to a `Akce`. Fields that are set will be updated. */
["AkcePatch"]: {
	aId?: ResolverInputTypes["BigInt"] | undefined | null,
	aJmeno?: string | undefined | null,
	aKde?: string | undefined | null,
	aInfo?: string | undefined | null,
	aOd?: ResolverInputTypes["Date"] | undefined | null,
	aDo?: ResolverInputTypes["Date"] | undefined | null,
	aKapacita?: ResolverInputTypes["BigInt"] | undefined | null,
	aDokumenty?: string | undefined | null,
	aTimestamp?: ResolverInputTypes["Datetime"] | undefined | null,
	aLock?: boolean | undefined | null,
	aVisible?: boolean | undefined | null
};
	/** All input for the `updateAkce` mutation. */
["UpdateAkceInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** An object where the defined keys will be set on the `Akce` being updated. */
	patch: ResolverInputTypes["AkcePatch"],
	aId: ResolverInputTypes["BigInt"]
};
	/** The output of our update `AkceItem` mutation. */
["UpdateAkceItemPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `AkceItem` that was updated by this mutation. */
	akceItem?:ResolverInputTypes["AkceItem"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `Akce` that is related to this `AkceItem`. */
	akceByAiIdRodic?:ResolverInputTypes["Akce"],
	/** Reads a single `User` that is related to this `AkceItem`. */
	userByAiUser?:ResolverInputTypes["User"],
akceItemEdge?: [{	/** The method to use when ordering `AkceItem`. */
	orderBy?: Array<ResolverInputTypes["AkceItemsOrderBy"]> | undefined | null},ResolverInputTypes["AkceItemsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateAkceItemByNodeId` mutation. */
["UpdateAkceItemByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `AkceItem` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `AkceItem` being updated. */
	patch: ResolverInputTypes["AkceItemPatch"]
};
	/** Represents an update to a `AkceItem`. Fields that are set will be updated. */
["AkceItemPatch"]: {
	aiId?: ResolverInputTypes["BigInt"] | undefined | null,
	aiIdRodic?: ResolverInputTypes["BigInt"] | undefined | null,
	aiUser?: ResolverInputTypes["BigInt"] | undefined | null,
	aiRokNarozeni?: number | undefined | null
};
	/** All input for the `updateAkceItem` mutation. */
["UpdateAkceItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** An object where the defined keys will be set on the `AkceItem` being updated. */
	patch: ResolverInputTypes["AkceItemPatch"],
	aiId: ResolverInputTypes["BigInt"]
};
	/** The output of our update `Aktuality` mutation. */
["UpdateAktualityPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Aktuality` that was updated by this mutation. */
	aktuality?:ResolverInputTypes["Aktuality"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `User` that is related to this `Aktuality`. */
	userByAtKdo?:ResolverInputTypes["User"],
	/** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
	galerieFotoByAtFotoMain?:ResolverInputTypes["GalerieFoto"],
aktualityEdge?: [{	/** The method to use when ordering `Aktuality`. */
	orderBy?: Array<ResolverInputTypes["AktualitiesOrderBy"]> | undefined | null},ResolverInputTypes["AktualitiesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateAktualityByNodeId` mutation. */
["UpdateAktualityByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `Aktuality` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Aktuality` being updated. */
	patch: ResolverInputTypes["AktualityPatch"]
};
	/** Represents an update to a `Aktuality`. Fields that are set will be updated. */
["AktualityPatch"]: {
	atId?: ResolverInputTypes["BigInt"] | undefined | null,
	atKdo?: ResolverInputTypes["BigInt"] | undefined | null,
	atKat?: string | undefined | null,
	atJmeno?: string | undefined | null,
	atText?: string | undefined | null,
	atPreview?: string | undefined | null,
	atFoto?: ResolverInputTypes["BigInt"] | undefined | null,
	atFotoMain?: ResolverInputTypes["BigInt"] | undefined | null,
	atTimestamp?: ResolverInputTypes["Datetime"] | undefined | null,
	atTimestampAdd?: ResolverInputTypes["Datetime"] | undefined | null
};
	/** All input for the `updateAktuality` mutation. */
["UpdateAktualityInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** An object where the defined keys will be set on the `Aktuality` being updated. */
	patch: ResolverInputTypes["AktualityPatch"],
	atId: ResolverInputTypes["BigInt"]
};
	/** The output of our update `Dokumenty` mutation. */
["UpdateDokumentyPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Dokumenty` that was updated by this mutation. */
	dokumenty?:ResolverInputTypes["Dokumenty"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `User` that is related to this `Dokumenty`. */
	userByDKdo?:ResolverInputTypes["User"],
dokumentyEdge?: [{	/** The method to use when ordering `Dokumenty`. */
	orderBy?: Array<ResolverInputTypes["DokumentiesOrderBy"]> | undefined | null},ResolverInputTypes["DokumentiesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateDokumentyByNodeId` mutation. */
["UpdateDokumentyByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `Dokumenty` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Dokumenty` being updated. */
	patch: ResolverInputTypes["DokumentyPatch"]
};
	/** Represents an update to a `Dokumenty`. Fields that are set will be updated. */
["DokumentyPatch"]: {
	dId?: ResolverInputTypes["BigInt"] | undefined | null,
	dPath?: string | undefined | null,
	dName?: string | undefined | null,
	dFilename?: string | undefined | null,
	dKategorie?: number | undefined | null,
	dKdo?: ResolverInputTypes["BigInt"] | undefined | null,
	dTimestamp?: ResolverInputTypes["Datetime"] | undefined | null
};
	/** All input for the `updateDokumenty` mutation. */
["UpdateDokumentyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** An object where the defined keys will be set on the `Dokumenty` being updated. */
	patch: ResolverInputTypes["DokumentyPatch"],
	dId: ResolverInputTypes["BigInt"]
};
	/** The output of our update `GalerieDir` mutation. */
["UpdateGalerieDirPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `GalerieDir` that was updated by this mutation. */
	galerieDir?:ResolverInputTypes["GalerieDir"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
galerieDirEdge?: [{	/** The method to use when ordering `GalerieDir`. */
	orderBy?: Array<ResolverInputTypes["GalerieDirsOrderBy"]> | undefined | null},ResolverInputTypes["GalerieDirsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateGalerieDirByNodeId` mutation. */
["UpdateGalerieDirByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `GalerieDir` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `GalerieDir` being updated. */
	patch: ResolverInputTypes["GalerieDirPatch"]
};
	/** Represents an update to a `GalerieDir`. Fields that are set will be updated. */
["GalerieDirPatch"]: {
	gdId?: ResolverInputTypes["BigInt"] | undefined | null,
	gdIdRodic?: ResolverInputTypes["BigInt"] | undefined | null,
	gdName?: string | undefined | null,
	gdLevel?: number | undefined | null,
	gdPath?: string | undefined | null,
	gdHidden?: boolean | undefined | null
};
	/** All input for the `updateGalerieDir` mutation. */
["UpdateGalerieDirInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** An object where the defined keys will be set on the `GalerieDir` being updated. */
	patch: ResolverInputTypes["GalerieDirPatch"],
	gdId: ResolverInputTypes["BigInt"]
};
	/** The output of our update `GalerieFoto` mutation. */
["UpdateGalerieFotoPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `GalerieFoto` that was updated by this mutation. */
	galerieFoto?:ResolverInputTypes["GalerieFoto"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
	galerieDirByGfIdRodic?:ResolverInputTypes["GalerieDir"],
	/** Reads a single `User` that is related to this `GalerieFoto`. */
	userByGfKdo?:ResolverInputTypes["User"],
galerieFotoEdge?: [{	/** The method to use when ordering `GalerieFoto`. */
	orderBy?: Array<ResolverInputTypes["GalerieFotosOrderBy"]> | undefined | null},ResolverInputTypes["GalerieFotosEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateGalerieFotoByNodeId` mutation. */
["UpdateGalerieFotoByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `GalerieFoto` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `GalerieFoto` being updated. */
	patch: ResolverInputTypes["GalerieFotoPatch"]
};
	/** Represents an update to a `GalerieFoto`. Fields that are set will be updated. */
["GalerieFotoPatch"]: {
	gfId?: ResolverInputTypes["BigInt"] | undefined | null,
	gfIdRodic?: ResolverInputTypes["BigInt"] | undefined | null,
	gfName?: string | undefined | null,
	gfPath?: string | undefined | null,
	gfKdo?: ResolverInputTypes["BigInt"] | undefined | null,
	gfTimestamp?: ResolverInputTypes["Datetime"] | undefined | null
};
	/** All input for the `updateGalerieFoto` mutation. */
["UpdateGalerieFotoInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** An object where the defined keys will be set on the `GalerieFoto` being updated. */
	patch: ResolverInputTypes["GalerieFotoPatch"],
	gfId: ResolverInputTypes["BigInt"]
};
	/** The output of our update `Nabidka` mutation. */
["UpdateNabidkaPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Nabidka` that was updated by this mutation. */
	nabidka?:ResolverInputTypes["Nabidka"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `User` that is related to this `Nabidka`. */
	userByNTrener?:ResolverInputTypes["User"],
nabidkaEdge?: [{	/** The method to use when ordering `Nabidka`. */
	orderBy?: Array<ResolverInputTypes["NabidkasOrderBy"]> | undefined | null},ResolverInputTypes["NabidkasEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateNabidkaByNodeId` mutation. */
["UpdateNabidkaByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `Nabidka` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Nabidka` being updated. */
	patch: ResolverInputTypes["NabidkaPatch"]
};
	/** Represents an update to a `Nabidka`. Fields that are set will be updated. */
["NabidkaPatch"]: {
	nId?: ResolverInputTypes["BigInt"] | undefined | null,
	nTrener?: ResolverInputTypes["BigInt"] | undefined | null,
	nPocetHod?: number | undefined | null,
	nMaxPocetHod?: ResolverInputTypes["BigInt"] | undefined | null,
	nOd?: ResolverInputTypes["Date"] | undefined | null,
	nDo?: ResolverInputTypes["Date"] | undefined | null,
	nVisible?: boolean | undefined | null,
	nLock?: boolean | undefined | null,
	nTimestamp?: ResolverInputTypes["Datetime"] | undefined | null
};
	/** All input for the `updateNabidka` mutation. */
["UpdateNabidkaInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** An object where the defined keys will be set on the `Nabidka` being updated. */
	patch: ResolverInputTypes["NabidkaPatch"],
	nId: ResolverInputTypes["BigInt"]
};
	/** The output of our update `NabidkaItem` mutation. */
["UpdateNabidkaItemPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `NabidkaItem` that was updated by this mutation. */
	nabidkaItem?:ResolverInputTypes["NabidkaItem"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `Nabidka` that is related to this `NabidkaItem`. */
	nabidkaByNiIdRodic?:ResolverInputTypes["Nabidka"],
	/** Reads a single `Pary` that is related to this `NabidkaItem`. */
	paryByNiPartner?:ResolverInputTypes["Pary"],
nabidkaItemEdge?: [{	/** The method to use when ordering `NabidkaItem`. */
	orderBy?: Array<ResolverInputTypes["NabidkaItemsOrderBy"]> | undefined | null},ResolverInputTypes["NabidkaItemsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateNabidkaItemByNodeId` mutation. */
["UpdateNabidkaItemByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `NabidkaItem` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `NabidkaItem` being updated. */
	patch: ResolverInputTypes["NabidkaItemPatch"]
};
	/** Represents an update to a `NabidkaItem`. Fields that are set will be updated. */
["NabidkaItemPatch"]: {
	niId?: ResolverInputTypes["BigInt"] | undefined | null,
	niIdRodic?: ResolverInputTypes["BigInt"] | undefined | null,
	niPartner?: ResolverInputTypes["BigInt"] | undefined | null,
	niPocetHod?: number | undefined | null,
	niLock?: boolean | undefined | null
};
	/** All input for the `updateNabidkaItem` mutation. */
["UpdateNabidkaItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** An object where the defined keys will be set on the `NabidkaItem` being updated. */
	patch: ResolverInputTypes["NabidkaItemPatch"],
	niId: ResolverInputTypes["BigInt"]
};
	/** The output of our update `Page` mutation. */
["UpdatePagePayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Page` that was updated by this mutation. */
	page?:ResolverInputTypes["Page"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
pageEdge?: [{	/** The method to use when ordering `Page`. */
	orderBy?: Array<ResolverInputTypes["PagesOrderBy"]> | undefined | null},ResolverInputTypes["PagesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updatePageByNodeId` mutation. */
["UpdatePageByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `Page` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Page` being updated. */
	patch: ResolverInputTypes["PagePatch"]
};
	/** Represents an update to a `Page`. Fields that are set will be updated. */
["PagePatch"]: {
	id?: number | undefined | null,
	url?: string | undefined | null,
	content?: ResolverInputTypes["JSON"] | undefined | null,
	createdAt?: ResolverInputTypes["Datetime"] | undefined | null,
	updatedAt?: ResolverInputTypes["Datetime"] | undefined | null,
	title?: string | undefined | null
};
	/** All input for the `updatePage` mutation. */
["UpdatePageInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** An object where the defined keys will be set on the `Page` being updated. */
	patch: ResolverInputTypes["PagePatch"],
	id: number
};
	/** All input for the `updatePageByUrl` mutation. */
["UpdatePageByUrlInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** An object where the defined keys will be set on the `Page` being updated. */
	patch: ResolverInputTypes["PagePatch"],
	url: string
};
	/** The output of our update `Parameter` mutation. */
["UpdateParameterPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Parameter` that was updated by this mutation. */
	parameter?:ResolverInputTypes["Parameter"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
parameterEdge?: [{	/** The method to use when ordering `Parameter`. */
	orderBy?: Array<ResolverInputTypes["ParametersOrderBy"]> | undefined | null},ResolverInputTypes["ParametersEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateParameterByNodeId` mutation. */
["UpdateParameterByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `Parameter` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Parameter` being updated. */
	patch: ResolverInputTypes["ParameterPatch"]
};
	/** Represents an update to a `Parameter`. Fields that are set will be updated. */
["ParameterPatch"]: {
	paName?: string | undefined | null,
	paValue?: string | undefined | null
};
	/** All input for the `updateParameter` mutation. */
["UpdateParameterInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** An object where the defined keys will be set on the `Parameter` being updated. */
	patch: ResolverInputTypes["ParameterPatch"],
	paName: string
};
	/** The output of our update `Pary` mutation. */
["UpdateParyPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Pary` that was updated by this mutation. */
	pary?:ResolverInputTypes["Pary"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `User` that is related to this `Pary`. */
	userByPIdPartner?:ResolverInputTypes["User"],
paryEdge?: [{	/** The method to use when ordering `Pary`. */
	orderBy?: Array<ResolverInputTypes["PariesOrderBy"]> | undefined | null},ResolverInputTypes["PariesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateParyByNodeId` mutation. */
["UpdateParyByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `Pary` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Pary` being updated. */
	patch: ResolverInputTypes["ParyPatch"]
};
	/** Represents an update to a `Pary`. Fields that are set will be updated. */
["ParyPatch"]: {
	pId?: ResolverInputTypes["BigInt"] | undefined | null,
	pIdPartner?: ResolverInputTypes["BigInt"] | undefined | null,
	pIdPartnerka?: ResolverInputTypes["BigInt"] | undefined | null,
	pSttTrida?: ResolverInputTypes["ParyPSttTrida"] | undefined | null,
	pSttBody?: number | undefined | null,
	pSttFinale?: boolean | undefined | null,
	pLatTrida?: ResolverInputTypes["ParyPLatTrida"] | undefined | null,
	pLatBody?: number | undefined | null,
	pLatFinale?: boolean | undefined | null,
	pHodnoceni?: number | undefined | null,
	pArchiv?: boolean | undefined | null,
	pTimestampAdd?: ResolverInputTypes["Datetime"] | undefined | null,
	pTimestampArchive?: ResolverInputTypes["Datetime"] | undefined | null
};
	/** All input for the `updatePary` mutation. */
["UpdateParyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** An object where the defined keys will be set on the `Pary` being updated. */
	patch: ResolverInputTypes["ParyPatch"],
	pId: ResolverInputTypes["BigInt"]
};
	/** The output of our update `ParyNavrh` mutation. */
["UpdateParyNavrhPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `ParyNavrh` that was updated by this mutation. */
	paryNavrh?:ResolverInputTypes["ParyNavrh"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnNavrhl?:ResolverInputTypes["User"],
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnPartner?:ResolverInputTypes["User"],
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnPartnerka?:ResolverInputTypes["User"],
paryNavrhEdge?: [{	/** The method to use when ordering `ParyNavrh`. */
	orderBy?: Array<ResolverInputTypes["ParyNavrhsOrderBy"]> | undefined | null},ResolverInputTypes["ParyNavrhsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateParyNavrhByNodeId` mutation. */
["UpdateParyNavrhByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `ParyNavrh` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `ParyNavrh` being updated. */
	patch: ResolverInputTypes["ParyNavrhPatch"]
};
	/** Represents an update to a `ParyNavrh`. Fields that are set will be updated. */
["ParyNavrhPatch"]: {
	pnId?: ResolverInputTypes["BigInt"] | undefined | null,
	pnNavrhl?: ResolverInputTypes["BigInt"] | undefined | null,
	pnPartner?: ResolverInputTypes["BigInt"] | undefined | null,
	pnPartnerka?: ResolverInputTypes["BigInt"] | undefined | null
};
	/** All input for the `updateParyNavrh` mutation. */
["UpdateParyNavrhInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** An object where the defined keys will be set on the `ParyNavrh` being updated. */
	patch: ResolverInputTypes["ParyNavrhPatch"],
	pnId: ResolverInputTypes["BigInt"]
};
	/** The output of our update `Permission` mutation. */
["UpdatePermissionPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Permission` that was updated by this mutation. */
	permission?:ResolverInputTypes["Permission"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
permissionEdge?: [{	/** The method to use when ordering `Permission`. */
	orderBy?: Array<ResolverInputTypes["PermissionsOrderBy"]> | undefined | null},ResolverInputTypes["PermissionsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updatePermissionByNodeId` mutation. */
["UpdatePermissionByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `Permission` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Permission` being updated. */
	patch: ResolverInputTypes["PermissionPatch"]
};
	/** Represents an update to a `Permission`. Fields that are set will be updated. */
["PermissionPatch"]: {
	peId?: ResolverInputTypes["BigInt"] | undefined | null,
	peName?: string | undefined | null,
	peDescription?: string | undefined | null,
	peAkce?: number | undefined | null,
	peAktuality?: number | undefined | null,
	peAnkety?: number | undefined | null,
	peDokumenty?: number | undefined | null,
	peGalerie?: number | undefined | null,
	peInzerce?: number | undefined | null,
	peKonzole?: number | undefined | null,
	peNabidka?: number | undefined | null,
	peNastenka?: number | undefined | null,
	peNovinky?: number | undefined | null,
	pePary?: number | undefined | null,
	pePlatby?: number | undefined | null,
	pePermissions?: number | undefined | null,
	peRozpis?: number | undefined | null,
	peSkupiny?: number | undefined | null,
	peUsers?: number | undefined | null,
	peMain?: number | undefined | null
};
	/** All input for the `updatePermission` mutation. */
["UpdatePermissionInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** An object where the defined keys will be set on the `Permission` being updated. */
	patch: ResolverInputTypes["PermissionPatch"],
	peId: ResolverInputTypes["BigInt"]
};
	/** The output of our update `PlatbyCategory` mutation. */
["UpdatePlatbyCategoryPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyCategory` that was updated by this mutation. */
	platbyCategory?:ResolverInputTypes["PlatbyCategory"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
platbyCategoryEdge?: [{	/** The method to use when ordering `PlatbyCategory`. */
	orderBy?: Array<ResolverInputTypes["PlatbyCategoriesOrderBy"]> | undefined | null},ResolverInputTypes["PlatbyCategoriesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updatePlatbyCategoryByNodeId` mutation. */
["UpdatePlatbyCategoryByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `PlatbyCategory` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `PlatbyCategory` being updated. */
	patch: ResolverInputTypes["PlatbyCategoryPatch"]
};
	/** Represents an update to a `PlatbyCategory`. Fields that are set will be updated. */
["PlatbyCategoryPatch"]: {
	pcId?: ResolverInputTypes["BigInt"] | undefined | null,
	pcName?: string | undefined | null,
	pcSymbol?: ResolverInputTypes["BigInt"] | undefined | null,
	pcAmount?: ResolverInputTypes["BigFloat"] | undefined | null,
	pcDateDue?: ResolverInputTypes["Date"] | undefined | null,
	pcValidFrom?: ResolverInputTypes["Date"] | undefined | null,
	pcValidTo?: ResolverInputTypes["Date"] | undefined | null,
	pcUseBase?: boolean | undefined | null,
	pcUsePrefix?: boolean | undefined | null,
	pcArchive?: boolean | undefined | null,
	pcVisible?: boolean | undefined | null
};
	/** All input for the `updatePlatbyCategory` mutation. */
["UpdatePlatbyCategoryInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** An object where the defined keys will be set on the `PlatbyCategory` being updated. */
	patch: ResolverInputTypes["PlatbyCategoryPatch"],
	pcId: ResolverInputTypes["BigInt"]
};
	/** The output of our update `PlatbyCategoryGroup` mutation. */
["UpdatePlatbyCategoryGroupPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyCategoryGroup` that was updated by this mutation. */
	platbyCategoryGroup?:ResolverInputTypes["PlatbyCategoryGroup"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `PlatbyGroup` that is related to this `PlatbyCategoryGroup`. */
	platbyGroupByPcgIdGroup?:ResolverInputTypes["PlatbyGroup"],
	/** Reads a single `PlatbyCategory` that is related to this `PlatbyCategoryGroup`. */
	platbyCategoryByPcgIdCategory?:ResolverInputTypes["PlatbyCategory"],
platbyCategoryGroupEdge?: [{	/** The method to use when ordering `PlatbyCategoryGroup`. */
	orderBy?: Array<ResolverInputTypes["PlatbyCategoryGroupsOrderBy"]> | undefined | null},ResolverInputTypes["PlatbyCategoryGroupsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updatePlatbyCategoryGroupByNodeId` mutation. */
["UpdatePlatbyCategoryGroupByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `PlatbyCategoryGroup` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `PlatbyCategoryGroup` being updated. */
	patch: ResolverInputTypes["PlatbyCategoryGroupPatch"]
};
	/** Represents an update to a `PlatbyCategoryGroup`. Fields that are set will be updated. */
["PlatbyCategoryGroupPatch"]: {
	pcgId?: ResolverInputTypes["BigInt"] | undefined | null,
	pcgIdGroup?: ResolverInputTypes["BigInt"] | undefined | null,
	pcgIdCategory?: ResolverInputTypes["BigInt"] | undefined | null
};
	/** All input for the `updatePlatbyCategoryGroup` mutation. */
["UpdatePlatbyCategoryGroupInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** An object where the defined keys will be set on the `PlatbyCategoryGroup` being updated. */
	patch: ResolverInputTypes["PlatbyCategoryGroupPatch"],
	pcgId: ResolverInputTypes["BigInt"]
};
	/** The output of our update `PlatbyGroup` mutation. */
["UpdatePlatbyGroupPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyGroup` that was updated by this mutation. */
	platbyGroup?:ResolverInputTypes["PlatbyGroup"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
platbyGroupEdge?: [{	/** The method to use when ordering `PlatbyGroup`. */
	orderBy?: Array<ResolverInputTypes["PlatbyGroupsOrderBy"]> | undefined | null},ResolverInputTypes["PlatbyGroupsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updatePlatbyGroupByNodeId` mutation. */
["UpdatePlatbyGroupByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `PlatbyGroup` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `PlatbyGroup` being updated. */
	patch: ResolverInputTypes["PlatbyGroupPatch"]
};
	/** Represents an update to a `PlatbyGroup`. Fields that are set will be updated. */
["PlatbyGroupPatch"]: {
	pgId?: ResolverInputTypes["BigInt"] | undefined | null,
	pgType?: ResolverInputTypes["BigFloat"] | undefined | null,
	pgName?: string | undefined | null,
	pgDescription?: string | undefined | null,
	pgBase?: ResolverInputTypes["BigInt"] | undefined | null
};
	/** All input for the `updatePlatbyGroup` mutation. */
["UpdatePlatbyGroupInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** An object where the defined keys will be set on the `PlatbyGroup` being updated. */
	patch: ResolverInputTypes["PlatbyGroupPatch"],
	pgId: ResolverInputTypes["BigInt"]
};
	/** The output of our update `PlatbyGroupSkupina` mutation. */
["UpdatePlatbyGroupSkupinaPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyGroupSkupina` that was updated by this mutation. */
	platbyGroupSkupina?:ResolverInputTypes["PlatbyGroupSkupina"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `Skupiny` that is related to this `PlatbyGroupSkupina`. */
	skupinyByPgsIdSkupina?:ResolverInputTypes["Skupiny"],
	/** Reads a single `PlatbyGroup` that is related to this `PlatbyGroupSkupina`. */
	platbyGroupByPgsIdGroup?:ResolverInputTypes["PlatbyGroup"],
platbyGroupSkupinaEdge?: [{	/** The method to use when ordering `PlatbyGroupSkupina`. */
	orderBy?: Array<ResolverInputTypes["PlatbyGroupSkupinasOrderBy"]> | undefined | null},ResolverInputTypes["PlatbyGroupSkupinasEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updatePlatbyGroupSkupinaByNodeId` mutation. */
["UpdatePlatbyGroupSkupinaByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `PlatbyGroupSkupina` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `PlatbyGroupSkupina` being updated. */
	patch: ResolverInputTypes["PlatbyGroupSkupinaPatch"]
};
	/** Represents an update to a `PlatbyGroupSkupina`. Fields that are set will be updated. */
["PlatbyGroupSkupinaPatch"]: {
	pgsId?: ResolverInputTypes["BigInt"] | undefined | null,
	pgsIdSkupina?: ResolverInputTypes["BigInt"] | undefined | null,
	pgsIdGroup?: ResolverInputTypes["BigInt"] | undefined | null
};
	/** All input for the `updatePlatbyGroupSkupina` mutation. */
["UpdatePlatbyGroupSkupinaInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** An object where the defined keys will be set on the `PlatbyGroupSkupina` being updated. */
	patch: ResolverInputTypes["PlatbyGroupSkupinaPatch"],
	pgsId: ResolverInputTypes["BigInt"]
};
	/** The output of our update `PlatbyItem` mutation. */
["UpdatePlatbyItemPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyItem` that was updated by this mutation. */
	platbyItem?:ResolverInputTypes["PlatbyItem"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `User` that is related to this `PlatbyItem`. */
	userByPiIdUser?:ResolverInputTypes["User"],
	/** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
	platbyCategoryByPiIdCategory?:ResolverInputTypes["PlatbyCategory"],
	/** Reads a single `PlatbyRaw` that is related to this `PlatbyItem`. */
	platbyRawByPiIdRaw?:ResolverInputTypes["PlatbyRaw"],
platbyItemEdge?: [{	/** The method to use when ordering `PlatbyItem`. */
	orderBy?: Array<ResolverInputTypes["PlatbyItemsOrderBy"]> | undefined | null},ResolverInputTypes["PlatbyItemsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updatePlatbyItemByNodeId` mutation. */
["UpdatePlatbyItemByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `PlatbyItem` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `PlatbyItem` being updated. */
	patch: ResolverInputTypes["PlatbyItemPatch"]
};
	/** Represents an update to a `PlatbyItem`. Fields that are set will be updated. */
["PlatbyItemPatch"]: {
	piId?: ResolverInputTypes["BigInt"] | undefined | null,
	piIdUser?: ResolverInputTypes["BigInt"] | undefined | null,
	piIdCategory?: ResolverInputTypes["BigInt"] | undefined | null,
	piIdRaw?: ResolverInputTypes["BigInt"] | undefined | null,
	piAmount?: ResolverInputTypes["BigFloat"] | undefined | null,
	piDate?: ResolverInputTypes["Date"] | undefined | null,
	piPrefix?: number | undefined | null
};
	/** All input for the `updatePlatbyItem` mutation. */
["UpdatePlatbyItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** An object where the defined keys will be set on the `PlatbyItem` being updated. */
	patch: ResolverInputTypes["PlatbyItemPatch"],
	piId: ResolverInputTypes["BigInt"]
};
	/** The output of our update `PlatbyRaw` mutation. */
["UpdatePlatbyRawPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyRaw` that was updated by this mutation. */
	platbyRaw?:ResolverInputTypes["PlatbyRaw"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
platbyRawEdge?: [{	/** The method to use when ordering `PlatbyRaw`. */
	orderBy?: Array<ResolverInputTypes["PlatbyRawsOrderBy"]> | undefined | null},ResolverInputTypes["PlatbyRawsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updatePlatbyRawByNodeId` mutation. */
["UpdatePlatbyRawByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `PlatbyRaw` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `PlatbyRaw` being updated. */
	patch: ResolverInputTypes["PlatbyRawPatch"]
};
	/** Represents an update to a `PlatbyRaw`. Fields that are set will be updated. */
["PlatbyRawPatch"]: {
	prId?: ResolverInputTypes["BigInt"] | undefined | null,
	prRaw?: string | undefined | null,
	prHash?: string | undefined | null,
	prSorted?: boolean | undefined | null,
	prDiscarded?: boolean | undefined | null
};
	/** All input for the `updatePlatbyRaw` mutation. */
["UpdatePlatbyRawInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** An object where the defined keys will be set on the `PlatbyRaw` being updated. */
	patch: ResolverInputTypes["PlatbyRawPatch"],
	prId: ResolverInputTypes["BigInt"]
};
	/** The output of our update `Rozpi` mutation. */
["UpdateRozpiPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Rozpi` that was updated by this mutation. */
	rozpi?:ResolverInputTypes["Rozpi"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `User` that is related to this `Rozpi`. */
	userByRTrener?:ResolverInputTypes["User"],
rozpiEdge?: [{	/** The method to use when ordering `Rozpi`. */
	orderBy?: Array<ResolverInputTypes["RozpisOrderBy"]> | undefined | null},ResolverInputTypes["RozpisEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateRozpiByNodeId` mutation. */
["UpdateRozpiByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `Rozpi` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Rozpi` being updated. */
	patch: ResolverInputTypes["RozpiPatch"]
};
	/** Represents an update to a `Rozpi`. Fields that are set will be updated. */
["RozpiPatch"]: {
	rId?: ResolverInputTypes["BigInt"] | undefined | null,
	rTrener?: ResolverInputTypes["BigInt"] | undefined | null,
	rKde?: string | undefined | null,
	rDatum?: ResolverInputTypes["Date"] | undefined | null,
	rVisible?: boolean | undefined | null,
	rLock?: boolean | undefined | null,
	rTimestamp?: ResolverInputTypes["Datetime"] | undefined | null
};
	/** All input for the `updateRozpi` mutation. */
["UpdateRozpiInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** An object where the defined keys will be set on the `Rozpi` being updated. */
	patch: ResolverInputTypes["RozpiPatch"],
	rId: ResolverInputTypes["BigInt"]
};
	/** The output of our update `RozpisItem` mutation. */
["UpdateRozpisItemPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `RozpisItem` that was updated by this mutation. */
	rozpisItem?:ResolverInputTypes["RozpisItem"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `Rozpi` that is related to this `RozpisItem`. */
	rozpiByRiIdRodic?:ResolverInputTypes["Rozpi"],
	/** Reads a single `Pary` that is related to this `RozpisItem`. */
	paryByRiPartner?:ResolverInputTypes["Pary"],
rozpisItemEdge?: [{	/** The method to use when ordering `RozpisItem`. */
	orderBy?: Array<ResolverInputTypes["RozpisItemsOrderBy"]> | undefined | null},ResolverInputTypes["RozpisItemsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateRozpisItemByNodeId` mutation. */
["UpdateRozpisItemByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `RozpisItem` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `RozpisItem` being updated. */
	patch: ResolverInputTypes["RozpisItemPatch"]
};
	/** Represents an update to a `RozpisItem`. Fields that are set will be updated. */
["RozpisItemPatch"]: {
	riId?: ResolverInputTypes["BigInt"] | undefined | null,
	riIdRodic?: ResolverInputTypes["BigInt"] | undefined | null,
	riPartner?: ResolverInputTypes["BigInt"] | undefined | null,
	riOd?: ResolverInputTypes["Time"] | undefined | null,
	riDo?: ResolverInputTypes["Time"] | undefined | null,
	riLock?: boolean | undefined | null
};
	/** All input for the `updateRozpisItem` mutation. */
["UpdateRozpisItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** An object where the defined keys will be set on the `RozpisItem` being updated. */
	patch: ResolverInputTypes["RozpisItemPatch"],
	riId: ResolverInputTypes["BigInt"]
};
	/** The output of our update `Session` mutation. */
["UpdateSessionPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Session` that was updated by this mutation. */
	session?:ResolverInputTypes["Session"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `User` that is related to this `Session`. */
	userBySsUser?:ResolverInputTypes["User"],
sessionEdge?: [{	/** The method to use when ordering `Session`. */
	orderBy?: Array<ResolverInputTypes["SessionsOrderBy"]> | undefined | null},ResolverInputTypes["SessionsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateSessionByNodeId` mutation. */
["UpdateSessionByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `Session` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Session` being updated. */
	patch: ResolverInputTypes["SessionPatch"]
};
	/** Represents an update to a `Session`. Fields that are set will be updated. */
["SessionPatch"]: {
	ssId?: string | undefined | null,
	ssData?: string | undefined | null,
	ssUpdatedAt?: ResolverInputTypes["Datetime"] | undefined | null,
	ssLifetime?: ResolverInputTypes["BigInt"] | undefined | null,
	ssUser?: ResolverInputTypes["BigInt"] | undefined | null
};
	/** All input for the `updateSession` mutation. */
["UpdateSessionInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** An object where the defined keys will be set on the `Session` being updated. */
	patch: ResolverInputTypes["SessionPatch"],
	ssId: string
};
	/** The output of our update `Skupiny` mutation. */
["UpdateSkupinyPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Skupiny` that was updated by this mutation. */
	skupiny?:ResolverInputTypes["Skupiny"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
skupinyEdge?: [{	/** The method to use when ordering `Skupiny`. */
	orderBy?: Array<ResolverInputTypes["SkupiniesOrderBy"]> | undefined | null},ResolverInputTypes["SkupiniesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateSkupinyByNodeId` mutation. */
["UpdateSkupinyByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `Skupiny` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Skupiny` being updated. */
	patch: ResolverInputTypes["SkupinyPatch"]
};
	/** Represents an update to a `Skupiny`. Fields that are set will be updated. */
["SkupinyPatch"]: {
	sId?: ResolverInputTypes["BigInt"] | undefined | null,
	sName?: string | undefined | null,
	sDescription?: string | undefined | null,
	sColorRgb?: string | undefined | null,
	sColorText?: string | undefined | null,
	sLocation?: string | undefined | null,
	sVisible?: boolean | undefined | null
};
	/** All input for the `updateSkupiny` mutation. */
["UpdateSkupinyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** An object where the defined keys will be set on the `Skupiny` being updated. */
	patch: ResolverInputTypes["SkupinyPatch"],
	sId: ResolverInputTypes["BigInt"]
};
	/** The output of our update `Upozorneni` mutation. */
["UpdateUpozorneniPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Upozorneni` that was updated by this mutation. */
	upozorneni?:ResolverInputTypes["Upozorneni"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `User` that is related to this `Upozorneni`. */
	userByUpKdo?:ResolverInputTypes["User"],
upozorneniEdge?: [{	/** The method to use when ordering `Upozorneni`. */
	orderBy?: Array<ResolverInputTypes["UpozornenisOrderBy"]> | undefined | null},ResolverInputTypes["UpozornenisEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateUpozorneniByNodeId` mutation. */
["UpdateUpozorneniByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `Upozorneni` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Upozorneni` being updated. */
	patch: ResolverInputTypes["UpozorneniPatch"]
};
	/** Represents an update to a `Upozorneni`. Fields that are set will be updated. */
["UpozorneniPatch"]: {
	upId?: ResolverInputTypes["BigInt"] | undefined | null,
	upKdo?: ResolverInputTypes["BigInt"] | undefined | null,
	upNadpis?: string | undefined | null,
	upText?: string | undefined | null,
	upBarvy?: ResolverInputTypes["BigInt"] | undefined | null,
	upLock?: boolean | undefined | null,
	upTimestamp?: ResolverInputTypes["Datetime"] | undefined | null,
	upTimestampAdd?: ResolverInputTypes["Datetime"] | undefined | null
};
	/** All input for the `updateUpozorneni` mutation. */
["UpdateUpozorneniInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** An object where the defined keys will be set on the `Upozorneni` being updated. */
	patch: ResolverInputTypes["UpozorneniPatch"],
	upId: ResolverInputTypes["BigInt"]
};
	/** The output of our update `UpozorneniSkupiny` mutation. */
["UpdateUpozorneniSkupinyPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `UpozorneniSkupiny` that was updated by this mutation. */
	upozorneniSkupiny?:ResolverInputTypes["UpozorneniSkupiny"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
	upozorneniByUpsIdRodic?:ResolverInputTypes["Upozorneni"],
	/** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
	skupinyByUpsIdSkupina?:ResolverInputTypes["Skupiny"],
upozorneniSkupinyEdge?: [{	/** The method to use when ordering `UpozorneniSkupiny`. */
	orderBy?: Array<ResolverInputTypes["UpozorneniSkupiniesOrderBy"]> | undefined | null},ResolverInputTypes["UpozorneniSkupiniesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateUpozorneniSkupinyByNodeId` mutation. */
["UpdateUpozorneniSkupinyByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `UpozorneniSkupiny` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `UpozorneniSkupiny` being updated. */
	patch: ResolverInputTypes["UpozorneniSkupinyPatch"]
};
	/** Represents an update to a `UpozorneniSkupiny`. Fields that are set will be updated. */
["UpozorneniSkupinyPatch"]: {
	upsId?: ResolverInputTypes["BigInt"] | undefined | null,
	upsIdRodic?: ResolverInputTypes["BigInt"] | undefined | null,
	upsIdSkupina?: ResolverInputTypes["BigInt"] | undefined | null,
	upsColor?: string | undefined | null,
	upsPopis?: string | undefined | null
};
	/** All input for the `updateUpozorneniSkupiny` mutation. */
["UpdateUpozorneniSkupinyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** An object where the defined keys will be set on the `UpozorneniSkupiny` being updated. */
	patch: ResolverInputTypes["UpozorneniSkupinyPatch"],
	upsId: ResolverInputTypes["BigInt"]
};
	/** The output of our update `User` mutation. */
["UpdateUserPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `User` that was updated by this mutation. */
	user?:ResolverInputTypes["User"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `Permission` that is related to this `User`. */
	permissionByUGroup?:ResolverInputTypes["Permission"],
	/** Reads a single `Skupiny` that is related to this `User`. */
	skupinyByUSkupina?:ResolverInputTypes["Skupiny"],
userEdge?: [{	/** The method to use when ordering `User`. */
	orderBy?: Array<ResolverInputTypes["UsersOrderBy"]> | undefined | null},ResolverInputTypes["UsersEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateUserByNodeId` mutation. */
["UpdateUserByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `User` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `User` being updated. */
	patch: ResolverInputTypes["UserPatch"]
};
	/** Represents an update to a `User`. Fields that are set will be updated. */
["UserPatch"]: {
	uId?: ResolverInputTypes["BigInt"] | undefined | null,
	uLogin?: string | undefined | null,
	uPass?: string | undefined | null,
	uJmeno?: string | undefined | null,
	uPrijmeni?: string | undefined | null,
	uPohlavi?: string | undefined | null,
	uEmail?: string | undefined | null,
	uTelefon?: string | undefined | null,
	uNarozeni?: ResolverInputTypes["Date"] | undefined | null,
	uRodneCislo?: string | undefined | null,
	uPoznamky?: string | undefined | null,
	uTimestamp?: ResolverInputTypes["Datetime"] | undefined | null,
	uLevel?: number | undefined | null,
	uGroup?: ResolverInputTypes["BigInt"] | undefined | null,
	uSkupina?: ResolverInputTypes["BigInt"] | undefined | null,
	uDancer?: boolean | undefined | null,
	uBan?: boolean | undefined | null,
	uLock?: boolean | undefined | null,
	uConfirmed?: boolean | undefined | null,
	uSystem?: boolean | undefined | null,
	uStreet?: string | undefined | null,
	uConscriptionNumber?: string | undefined | null,
	uOrientationNumber?: string | undefined | null,
	uDistrict?: string | undefined | null,
	uCity?: string | undefined | null,
	uPostalCode?: string | undefined | null,
	uNationality?: string | undefined | null,
	uMemberSince?: ResolverInputTypes["Datetime"] | undefined | null,
	uMemberUntil?: ResolverInputTypes["Datetime"] | undefined | null,
	uCreatedAt?: ResolverInputTypes["Datetime"] | undefined | null,
	uTeacher?: boolean | undefined | null,
	uGdprSignedAt?: ResolverInputTypes["Datetime"] | undefined | null
};
	/** All input for the `updateUser` mutation. */
["UpdateUserInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** An object where the defined keys will be set on the `User` being updated. */
	patch: ResolverInputTypes["UserPatch"],
	uId: ResolverInputTypes["BigInt"]
};
	/** The output of our update `UsersSkupiny` mutation. */
["UpdateUsersSkupinyPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `UsersSkupiny` that was updated by this mutation. */
	usersSkupiny?:ResolverInputTypes["UsersSkupiny"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
usersSkupinyEdge?: [{	/** The method to use when ordering `UsersSkupiny`. */
	orderBy?: Array<ResolverInputTypes["UsersSkupiniesOrderBy"]> | undefined | null},ResolverInputTypes["UsersSkupiniesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateUsersSkupinyByNodeId` mutation. */
["UpdateUsersSkupinyByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `UsersSkupiny` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `UsersSkupiny` being updated. */
	patch: ResolverInputTypes["UsersSkupinyPatch"]
};
	/** Represents an update to a `UsersSkupiny`. Fields that are set will be updated. */
["UsersSkupinyPatch"]: {
	usId?: ResolverInputTypes["BigInt"] | undefined | null,
	usColor?: string | undefined | null,
	usPlatbaMesic?: ResolverInputTypes["BigInt"] | undefined | null,
	usPlatbaCtvrtrok?: ResolverInputTypes["BigInt"] | undefined | null,
	usPlatbaPulrok?: ResolverInputTypes["BigInt"] | undefined | null,
	usPopis?: string | undefined | null
};
	/** All input for the `updateUsersSkupiny` mutation. */
["UpdateUsersSkupinyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** An object where the defined keys will be set on the `UsersSkupiny` being updated. */
	patch: ResolverInputTypes["UsersSkupinyPatch"],
	usId: ResolverInputTypes["BigInt"]
};
	/** The output of our update `Video` mutation. */
["UpdateVideoPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Video` that was updated by this mutation. */
	video?:ResolverInputTypes["Video"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
videoEdge?: [{	/** The method to use when ordering `Video`. */
	orderBy?: Array<ResolverInputTypes["VideosOrderBy"]> | undefined | null},ResolverInputTypes["VideosEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateVideoByNodeId` mutation. */
["UpdateVideoByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `Video` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Video` being updated. */
	patch: ResolverInputTypes["VideoPatch"]
};
	/** Represents an update to a `Video`. Fields that are set will be updated. */
["VideoPatch"]: {
	vId?: ResolverInputTypes["BigInt"] | undefined | null,
	vUri?: string | undefined | null,
	vTitle?: string | undefined | null,
	vAuthor?: string | undefined | null,
	vDescription?: string | undefined | null,
	vPlaylist?: string | undefined | null,
	vCreatedAt?: ResolverInputTypes["Datetime"] | undefined | null,
	vUpdatedAt?: ResolverInputTypes["Datetime"] | undefined | null
};
	/** All input for the `updateVideo` mutation. */
["UpdateVideoInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** An object where the defined keys will be set on the `Video` being updated. */
	patch: ResolverInputTypes["VideoPatch"],
	vId: ResolverInputTypes["BigInt"]
};
	/** The output of our update `VideoList` mutation. */
["UpdateVideoListPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `VideoList` that was updated by this mutation. */
	videoList?:ResolverInputTypes["VideoList"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
videoListEdge?: [{	/** The method to use when ordering `VideoList`. */
	orderBy?: Array<ResolverInputTypes["VideoListsOrderBy"]> | undefined | null},ResolverInputTypes["VideoListsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateVideoListByNodeId` mutation. */
["UpdateVideoListByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `VideoList` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `VideoList` being updated. */
	patch: ResolverInputTypes["VideoListPatch"]
};
	/** Represents an update to a `VideoList`. Fields that are set will be updated. */
["VideoListPatch"]: {
	vlId?: ResolverInputTypes["BigInt"] | undefined | null,
	vlUrl?: string | undefined | null,
	vlTitle?: string | undefined | null,
	vlDescription?: string | undefined | null,
	vlCount?: ResolverInputTypes["BigInt"] | undefined | null,
	vlCreatedAt?: ResolverInputTypes["Datetime"] | undefined | null,
	vlLastChecked?: ResolverInputTypes["Datetime"] | undefined | null
};
	/** All input for the `updateVideoList` mutation. */
["UpdateVideoListInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** An object where the defined keys will be set on the `VideoList` being updated. */
	patch: ResolverInputTypes["VideoListPatch"],
	vlId: ResolverInputTypes["BigInt"]
};
	/** The output of our update `VideoSource` mutation. */
["UpdateVideoSourcePayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `VideoSource` that was updated by this mutation. */
	videoSource?:ResolverInputTypes["VideoSource"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
videoSourceEdge?: [{	/** The method to use when ordering `VideoSource`. */
	orderBy?: Array<ResolverInputTypes["VideoSourcesOrderBy"]> | undefined | null},ResolverInputTypes["VideoSourcesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `updateVideoSourceByNodeId` mutation. */
["UpdateVideoSourceByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `VideoSource` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `VideoSource` being updated. */
	patch: ResolverInputTypes["VideoSourcePatch"]
};
	/** Represents an update to a `VideoSource`. Fields that are set will be updated. */
["VideoSourcePatch"]: {
	vsId?: ResolverInputTypes["BigInt"] | undefined | null,
	vsUrl?: string | undefined | null,
	vsTitle?: string | undefined | null,
	vsDescription?: string | undefined | null,
	vsCreatedAt?: ResolverInputTypes["Datetime"] | undefined | null,
	vsLastChecked?: ResolverInputTypes["Datetime"] | undefined | null
};
	/** All input for the `updateVideoSource` mutation. */
["UpdateVideoSourceInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** An object where the defined keys will be set on the `VideoSource` being updated. */
	patch: ResolverInputTypes["VideoSourcePatch"],
	vsId: ResolverInputTypes["BigInt"]
};
	/** The output of our delete `Akce` mutation. */
["DeleteAkcePayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Akce` that was deleted by this mutation. */
	akce?:ResolverInputTypes["Akce"],
	deletedAkceNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
akceEdge?: [{	/** The method to use when ordering `Akce`. */
	orderBy?: Array<ResolverInputTypes["AkcesOrderBy"]> | undefined | null},ResolverInputTypes["AkcesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteAkceByNodeId` mutation. */
["DeleteAkceByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `Akce` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteAkce` mutation. */
["DeleteAkceInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	aId: ResolverInputTypes["BigInt"]
};
	/** The output of our delete `AkceItem` mutation. */
["DeleteAkceItemPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `AkceItem` that was deleted by this mutation. */
	akceItem?:ResolverInputTypes["AkceItem"],
	deletedAkceItemNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `Akce` that is related to this `AkceItem`. */
	akceByAiIdRodic?:ResolverInputTypes["Akce"],
	/** Reads a single `User` that is related to this `AkceItem`. */
	userByAiUser?:ResolverInputTypes["User"],
akceItemEdge?: [{	/** The method to use when ordering `AkceItem`. */
	orderBy?: Array<ResolverInputTypes["AkceItemsOrderBy"]> | undefined | null},ResolverInputTypes["AkceItemsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteAkceItemByNodeId` mutation. */
["DeleteAkceItemByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `AkceItem` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteAkceItem` mutation. */
["DeleteAkceItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	aiId: ResolverInputTypes["BigInt"]
};
	/** The output of our delete `Aktuality` mutation. */
["DeleteAktualityPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Aktuality` that was deleted by this mutation. */
	aktuality?:ResolverInputTypes["Aktuality"],
	deletedAktualityNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `User` that is related to this `Aktuality`. */
	userByAtKdo?:ResolverInputTypes["User"],
	/** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
	galerieFotoByAtFotoMain?:ResolverInputTypes["GalerieFoto"],
aktualityEdge?: [{	/** The method to use when ordering `Aktuality`. */
	orderBy?: Array<ResolverInputTypes["AktualitiesOrderBy"]> | undefined | null},ResolverInputTypes["AktualitiesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteAktualityByNodeId` mutation. */
["DeleteAktualityByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `Aktuality` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteAktuality` mutation. */
["DeleteAktualityInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	atId: ResolverInputTypes["BigInt"]
};
	/** The output of our delete `Dokumenty` mutation. */
["DeleteDokumentyPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Dokumenty` that was deleted by this mutation. */
	dokumenty?:ResolverInputTypes["Dokumenty"],
	deletedDokumentyNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `User` that is related to this `Dokumenty`. */
	userByDKdo?:ResolverInputTypes["User"],
dokumentyEdge?: [{	/** The method to use when ordering `Dokumenty`. */
	orderBy?: Array<ResolverInputTypes["DokumentiesOrderBy"]> | undefined | null},ResolverInputTypes["DokumentiesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteDokumentyByNodeId` mutation. */
["DeleteDokumentyByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `Dokumenty` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteDokumenty` mutation. */
["DeleteDokumentyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	dId: ResolverInputTypes["BigInt"]
};
	/** The output of our delete `GalerieDir` mutation. */
["DeleteGalerieDirPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `GalerieDir` that was deleted by this mutation. */
	galerieDir?:ResolverInputTypes["GalerieDir"],
	deletedGalerieDirNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
galerieDirEdge?: [{	/** The method to use when ordering `GalerieDir`. */
	orderBy?: Array<ResolverInputTypes["GalerieDirsOrderBy"]> | undefined | null},ResolverInputTypes["GalerieDirsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteGalerieDirByNodeId` mutation. */
["DeleteGalerieDirByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `GalerieDir` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteGalerieDir` mutation. */
["DeleteGalerieDirInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	gdId: ResolverInputTypes["BigInt"]
};
	/** The output of our delete `GalerieFoto` mutation. */
["DeleteGalerieFotoPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `GalerieFoto` that was deleted by this mutation. */
	galerieFoto?:ResolverInputTypes["GalerieFoto"],
	deletedGalerieFotoNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
	galerieDirByGfIdRodic?:ResolverInputTypes["GalerieDir"],
	/** Reads a single `User` that is related to this `GalerieFoto`. */
	userByGfKdo?:ResolverInputTypes["User"],
galerieFotoEdge?: [{	/** The method to use when ordering `GalerieFoto`. */
	orderBy?: Array<ResolverInputTypes["GalerieFotosOrderBy"]> | undefined | null},ResolverInputTypes["GalerieFotosEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteGalerieFotoByNodeId` mutation. */
["DeleteGalerieFotoByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `GalerieFoto` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteGalerieFoto` mutation. */
["DeleteGalerieFotoInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	gfId: ResolverInputTypes["BigInt"]
};
	/** The output of our delete `Nabidka` mutation. */
["DeleteNabidkaPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Nabidka` that was deleted by this mutation. */
	nabidka?:ResolverInputTypes["Nabidka"],
	deletedNabidkaNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `User` that is related to this `Nabidka`. */
	userByNTrener?:ResolverInputTypes["User"],
nabidkaEdge?: [{	/** The method to use when ordering `Nabidka`. */
	orderBy?: Array<ResolverInputTypes["NabidkasOrderBy"]> | undefined | null},ResolverInputTypes["NabidkasEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteNabidkaByNodeId` mutation. */
["DeleteNabidkaByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `Nabidka` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteNabidka` mutation. */
["DeleteNabidkaInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	nId: ResolverInputTypes["BigInt"]
};
	/** The output of our delete `NabidkaItem` mutation. */
["DeleteNabidkaItemPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `NabidkaItem` that was deleted by this mutation. */
	nabidkaItem?:ResolverInputTypes["NabidkaItem"],
	deletedNabidkaItemNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `Nabidka` that is related to this `NabidkaItem`. */
	nabidkaByNiIdRodic?:ResolverInputTypes["Nabidka"],
	/** Reads a single `Pary` that is related to this `NabidkaItem`. */
	paryByNiPartner?:ResolverInputTypes["Pary"],
nabidkaItemEdge?: [{	/** The method to use when ordering `NabidkaItem`. */
	orderBy?: Array<ResolverInputTypes["NabidkaItemsOrderBy"]> | undefined | null},ResolverInputTypes["NabidkaItemsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteNabidkaItemByNodeId` mutation. */
["DeleteNabidkaItemByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `NabidkaItem` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteNabidkaItem` mutation. */
["DeleteNabidkaItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	niId: ResolverInputTypes["BigInt"]
};
	/** The output of our delete `Parameter` mutation. */
["DeleteParameterPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Parameter` that was deleted by this mutation. */
	parameter?:ResolverInputTypes["Parameter"],
	deletedParameterNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
parameterEdge?: [{	/** The method to use when ordering `Parameter`. */
	orderBy?: Array<ResolverInputTypes["ParametersOrderBy"]> | undefined | null},ResolverInputTypes["ParametersEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteParameterByNodeId` mutation. */
["DeleteParameterByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `Parameter` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteParameter` mutation. */
["DeleteParameterInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	paName: string
};
	/** The output of our delete `Pary` mutation. */
["DeleteParyPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Pary` that was deleted by this mutation. */
	pary?:ResolverInputTypes["Pary"],
	deletedParyNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `User` that is related to this `Pary`. */
	userByPIdPartner?:ResolverInputTypes["User"],
paryEdge?: [{	/** The method to use when ordering `Pary`. */
	orderBy?: Array<ResolverInputTypes["PariesOrderBy"]> | undefined | null},ResolverInputTypes["PariesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteParyByNodeId` mutation. */
["DeleteParyByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `Pary` to be deleted. */
	nodeId: string
};
	/** All input for the `deletePary` mutation. */
["DeleteParyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	pId: ResolverInputTypes["BigInt"]
};
	/** The output of our delete `ParyNavrh` mutation. */
["DeleteParyNavrhPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `ParyNavrh` that was deleted by this mutation. */
	paryNavrh?:ResolverInputTypes["ParyNavrh"],
	deletedParyNavrhNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnNavrhl?:ResolverInputTypes["User"],
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnPartner?:ResolverInputTypes["User"],
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnPartnerka?:ResolverInputTypes["User"],
paryNavrhEdge?: [{	/** The method to use when ordering `ParyNavrh`. */
	orderBy?: Array<ResolverInputTypes["ParyNavrhsOrderBy"]> | undefined | null},ResolverInputTypes["ParyNavrhsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteParyNavrhByNodeId` mutation. */
["DeleteParyNavrhByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `ParyNavrh` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteParyNavrh` mutation. */
["DeleteParyNavrhInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	pnId: ResolverInputTypes["BigInt"]
};
	/** The output of our delete `Permission` mutation. */
["DeletePermissionPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Permission` that was deleted by this mutation. */
	permission?:ResolverInputTypes["Permission"],
	deletedPermissionNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
permissionEdge?: [{	/** The method to use when ordering `Permission`. */
	orderBy?: Array<ResolverInputTypes["PermissionsOrderBy"]> | undefined | null},ResolverInputTypes["PermissionsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deletePermissionByNodeId` mutation. */
["DeletePermissionByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `Permission` to be deleted. */
	nodeId: string
};
	/** All input for the `deletePermission` mutation. */
["DeletePermissionInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	peId: ResolverInputTypes["BigInt"]
};
	/** The output of our delete `PlatbyCategory` mutation. */
["DeletePlatbyCategoryPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyCategory` that was deleted by this mutation. */
	platbyCategory?:ResolverInputTypes["PlatbyCategory"],
	deletedPlatbyCategoryNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
platbyCategoryEdge?: [{	/** The method to use when ordering `PlatbyCategory`. */
	orderBy?: Array<ResolverInputTypes["PlatbyCategoriesOrderBy"]> | undefined | null},ResolverInputTypes["PlatbyCategoriesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deletePlatbyCategoryByNodeId` mutation. */
["DeletePlatbyCategoryByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `PlatbyCategory` to be deleted. */
	nodeId: string
};
	/** All input for the `deletePlatbyCategory` mutation. */
["DeletePlatbyCategoryInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	pcId: ResolverInputTypes["BigInt"]
};
	/** The output of our delete `PlatbyCategoryGroup` mutation. */
["DeletePlatbyCategoryGroupPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyCategoryGroup` that was deleted by this mutation. */
	platbyCategoryGroup?:ResolverInputTypes["PlatbyCategoryGroup"],
	deletedPlatbyCategoryGroupNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `PlatbyGroup` that is related to this `PlatbyCategoryGroup`. */
	platbyGroupByPcgIdGroup?:ResolverInputTypes["PlatbyGroup"],
	/** Reads a single `PlatbyCategory` that is related to this `PlatbyCategoryGroup`. */
	platbyCategoryByPcgIdCategory?:ResolverInputTypes["PlatbyCategory"],
platbyCategoryGroupEdge?: [{	/** The method to use when ordering `PlatbyCategoryGroup`. */
	orderBy?: Array<ResolverInputTypes["PlatbyCategoryGroupsOrderBy"]> | undefined | null},ResolverInputTypes["PlatbyCategoryGroupsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deletePlatbyCategoryGroupByNodeId` mutation. */
["DeletePlatbyCategoryGroupByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `PlatbyCategoryGroup` to be deleted. */
	nodeId: string
};
	/** All input for the `deletePlatbyCategoryGroup` mutation. */
["DeletePlatbyCategoryGroupInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	pcgId: ResolverInputTypes["BigInt"]
};
	/** The output of our delete `PlatbyGroup` mutation. */
["DeletePlatbyGroupPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyGroup` that was deleted by this mutation. */
	platbyGroup?:ResolverInputTypes["PlatbyGroup"],
	deletedPlatbyGroupNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
platbyGroupEdge?: [{	/** The method to use when ordering `PlatbyGroup`. */
	orderBy?: Array<ResolverInputTypes["PlatbyGroupsOrderBy"]> | undefined | null},ResolverInputTypes["PlatbyGroupsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deletePlatbyGroupByNodeId` mutation. */
["DeletePlatbyGroupByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `PlatbyGroup` to be deleted. */
	nodeId: string
};
	/** All input for the `deletePlatbyGroup` mutation. */
["DeletePlatbyGroupInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	pgId: ResolverInputTypes["BigInt"]
};
	/** The output of our delete `PlatbyGroupSkupina` mutation. */
["DeletePlatbyGroupSkupinaPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyGroupSkupina` that was deleted by this mutation. */
	platbyGroupSkupina?:ResolverInputTypes["PlatbyGroupSkupina"],
	deletedPlatbyGroupSkupinaNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `Skupiny` that is related to this `PlatbyGroupSkupina`. */
	skupinyByPgsIdSkupina?:ResolverInputTypes["Skupiny"],
	/** Reads a single `PlatbyGroup` that is related to this `PlatbyGroupSkupina`. */
	platbyGroupByPgsIdGroup?:ResolverInputTypes["PlatbyGroup"],
platbyGroupSkupinaEdge?: [{	/** The method to use when ordering `PlatbyGroupSkupina`. */
	orderBy?: Array<ResolverInputTypes["PlatbyGroupSkupinasOrderBy"]> | undefined | null},ResolverInputTypes["PlatbyGroupSkupinasEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deletePlatbyGroupSkupinaByNodeId` mutation. */
["DeletePlatbyGroupSkupinaByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `PlatbyGroupSkupina` to be deleted. */
	nodeId: string
};
	/** All input for the `deletePlatbyGroupSkupina` mutation. */
["DeletePlatbyGroupSkupinaInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	pgsId: ResolverInputTypes["BigInt"]
};
	/** The output of our delete `PlatbyItem` mutation. */
["DeletePlatbyItemPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyItem` that was deleted by this mutation. */
	platbyItem?:ResolverInputTypes["PlatbyItem"],
	deletedPlatbyItemNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `User` that is related to this `PlatbyItem`. */
	userByPiIdUser?:ResolverInputTypes["User"],
	/** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
	platbyCategoryByPiIdCategory?:ResolverInputTypes["PlatbyCategory"],
	/** Reads a single `PlatbyRaw` that is related to this `PlatbyItem`. */
	platbyRawByPiIdRaw?:ResolverInputTypes["PlatbyRaw"],
platbyItemEdge?: [{	/** The method to use when ordering `PlatbyItem`. */
	orderBy?: Array<ResolverInputTypes["PlatbyItemsOrderBy"]> | undefined | null},ResolverInputTypes["PlatbyItemsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deletePlatbyItemByNodeId` mutation. */
["DeletePlatbyItemByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `PlatbyItem` to be deleted. */
	nodeId: string
};
	/** All input for the `deletePlatbyItem` mutation. */
["DeletePlatbyItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	piId: ResolverInputTypes["BigInt"]
};
	/** The output of our delete `PlatbyRaw` mutation. */
["DeletePlatbyRawPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `PlatbyRaw` that was deleted by this mutation. */
	platbyRaw?:ResolverInputTypes["PlatbyRaw"],
	deletedPlatbyRawNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
platbyRawEdge?: [{	/** The method to use when ordering `PlatbyRaw`. */
	orderBy?: Array<ResolverInputTypes["PlatbyRawsOrderBy"]> | undefined | null},ResolverInputTypes["PlatbyRawsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deletePlatbyRawByNodeId` mutation. */
["DeletePlatbyRawByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `PlatbyRaw` to be deleted. */
	nodeId: string
};
	/** All input for the `deletePlatbyRaw` mutation. */
["DeletePlatbyRawInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	prId: ResolverInputTypes["BigInt"]
};
	/** The output of our delete `Rozpi` mutation. */
["DeleteRozpiPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Rozpi` that was deleted by this mutation. */
	rozpi?:ResolverInputTypes["Rozpi"],
	deletedRozpiNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `User` that is related to this `Rozpi`. */
	userByRTrener?:ResolverInputTypes["User"],
rozpiEdge?: [{	/** The method to use when ordering `Rozpi`. */
	orderBy?: Array<ResolverInputTypes["RozpisOrderBy"]> | undefined | null},ResolverInputTypes["RozpisEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteRozpiByNodeId` mutation. */
["DeleteRozpiByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `Rozpi` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteRozpi` mutation. */
["DeleteRozpiInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	rId: ResolverInputTypes["BigInt"]
};
	/** The output of our delete `RozpisItem` mutation. */
["DeleteRozpisItemPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `RozpisItem` that was deleted by this mutation. */
	rozpisItem?:ResolverInputTypes["RozpisItem"],
	deletedRozpisItemNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `Rozpi` that is related to this `RozpisItem`. */
	rozpiByRiIdRodic?:ResolverInputTypes["Rozpi"],
	/** Reads a single `Pary` that is related to this `RozpisItem`. */
	paryByRiPartner?:ResolverInputTypes["Pary"],
rozpisItemEdge?: [{	/** The method to use when ordering `RozpisItem`. */
	orderBy?: Array<ResolverInputTypes["RozpisItemsOrderBy"]> | undefined | null},ResolverInputTypes["RozpisItemsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteRozpisItemByNodeId` mutation. */
["DeleteRozpisItemByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `RozpisItem` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteRozpisItem` mutation. */
["DeleteRozpisItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	riId: ResolverInputTypes["BigInt"]
};
	/** The output of our delete `Session` mutation. */
["DeleteSessionPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Session` that was deleted by this mutation. */
	session?:ResolverInputTypes["Session"],
	deletedSessionNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `User` that is related to this `Session`. */
	userBySsUser?:ResolverInputTypes["User"],
sessionEdge?: [{	/** The method to use when ordering `Session`. */
	orderBy?: Array<ResolverInputTypes["SessionsOrderBy"]> | undefined | null},ResolverInputTypes["SessionsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteSessionByNodeId` mutation. */
["DeleteSessionByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `Session` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteSession` mutation. */
["DeleteSessionInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	ssId: string
};
	/** The output of our delete `Skupiny` mutation. */
["DeleteSkupinyPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Skupiny` that was deleted by this mutation. */
	skupiny?:ResolverInputTypes["Skupiny"],
	deletedSkupinyNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
skupinyEdge?: [{	/** The method to use when ordering `Skupiny`. */
	orderBy?: Array<ResolverInputTypes["SkupiniesOrderBy"]> | undefined | null},ResolverInputTypes["SkupiniesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteSkupinyByNodeId` mutation. */
["DeleteSkupinyByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `Skupiny` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteSkupiny` mutation. */
["DeleteSkupinyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	sId: ResolverInputTypes["BigInt"]
};
	/** The output of our delete `Upozorneni` mutation. */
["DeleteUpozorneniPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Upozorneni` that was deleted by this mutation. */
	upozorneni?:ResolverInputTypes["Upozorneni"],
	deletedUpozorneniNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `User` that is related to this `Upozorneni`. */
	userByUpKdo?:ResolverInputTypes["User"],
upozorneniEdge?: [{	/** The method to use when ordering `Upozorneni`. */
	orderBy?: Array<ResolverInputTypes["UpozornenisOrderBy"]> | undefined | null},ResolverInputTypes["UpozornenisEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteUpozorneniByNodeId` mutation. */
["DeleteUpozorneniByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `Upozorneni` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteUpozorneni` mutation. */
["DeleteUpozorneniInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	upId: ResolverInputTypes["BigInt"]
};
	/** The output of our delete `UpozorneniSkupiny` mutation. */
["DeleteUpozorneniSkupinyPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `UpozorneniSkupiny` that was deleted by this mutation. */
	upozorneniSkupiny?:ResolverInputTypes["UpozorneniSkupiny"],
	deletedUpozorneniSkupinyNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
	upozorneniByUpsIdRodic?:ResolverInputTypes["Upozorneni"],
	/** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
	skupinyByUpsIdSkupina?:ResolverInputTypes["Skupiny"],
upozorneniSkupinyEdge?: [{	/** The method to use when ordering `UpozorneniSkupiny`. */
	orderBy?: Array<ResolverInputTypes["UpozorneniSkupiniesOrderBy"]> | undefined | null},ResolverInputTypes["UpozorneniSkupiniesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteUpozorneniSkupinyByNodeId` mutation. */
["DeleteUpozorneniSkupinyByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `UpozorneniSkupiny` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteUpozorneniSkupiny` mutation. */
["DeleteUpozorneniSkupinyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	upsId: ResolverInputTypes["BigInt"]
};
	/** The output of our delete `User` mutation. */
["DeleteUserPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `User` that was deleted by this mutation. */
	user?:ResolverInputTypes["User"],
	deletedUserNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
	/** Reads a single `Permission` that is related to this `User`. */
	permissionByUGroup?:ResolverInputTypes["Permission"],
	/** Reads a single `Skupiny` that is related to this `User`. */
	skupinyByUSkupina?:ResolverInputTypes["Skupiny"],
userEdge?: [{	/** The method to use when ordering `User`. */
	orderBy?: Array<ResolverInputTypes["UsersOrderBy"]> | undefined | null},ResolverInputTypes["UsersEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteUserByNodeId` mutation. */
["DeleteUserByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `User` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteUser` mutation. */
["DeleteUserInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	uId: ResolverInputTypes["BigInt"]
};
	/** The output of our delete `UsersSkupiny` mutation. */
["DeleteUsersSkupinyPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `UsersSkupiny` that was deleted by this mutation. */
	usersSkupiny?:ResolverInputTypes["UsersSkupiny"],
	deletedUsersSkupinyNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
usersSkupinyEdge?: [{	/** The method to use when ordering `UsersSkupiny`. */
	orderBy?: Array<ResolverInputTypes["UsersSkupiniesOrderBy"]> | undefined | null},ResolverInputTypes["UsersSkupiniesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteUsersSkupinyByNodeId` mutation. */
["DeleteUsersSkupinyByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `UsersSkupiny` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteUsersSkupiny` mutation. */
["DeleteUsersSkupinyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	usId: ResolverInputTypes["BigInt"]
};
	/** The output of our delete `Video` mutation. */
["DeleteVideoPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `Video` that was deleted by this mutation. */
	video?:ResolverInputTypes["Video"],
	deletedVideoNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
videoEdge?: [{	/** The method to use when ordering `Video`. */
	orderBy?: Array<ResolverInputTypes["VideosOrderBy"]> | undefined | null},ResolverInputTypes["VideosEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteVideoByNodeId` mutation. */
["DeleteVideoByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `Video` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteVideo` mutation. */
["DeleteVideoInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	vId: ResolverInputTypes["BigInt"]
};
	/** The output of our delete `VideoList` mutation. */
["DeleteVideoListPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `VideoList` that was deleted by this mutation. */
	videoList?:ResolverInputTypes["VideoList"],
	deletedVideoListNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
videoListEdge?: [{	/** The method to use when ordering `VideoList`. */
	orderBy?: Array<ResolverInputTypes["VideoListsOrderBy"]> | undefined | null},ResolverInputTypes["VideoListsEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteVideoListByNodeId` mutation. */
["DeleteVideoListByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `VideoList` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteVideoList` mutation. */
["DeleteVideoListInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	vlId: ResolverInputTypes["BigInt"]
};
	/** The output of our delete `VideoSource` mutation. */
["DeleteVideoSourcePayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** The `VideoSource` that was deleted by this mutation. */
	videoSource?:ResolverInputTypes["VideoSource"],
	deletedVideoSourceNodeId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
videoSourceEdge?: [{	/** The method to use when ordering `VideoSource`. */
	orderBy?: Array<ResolverInputTypes["VideoSourcesOrderBy"]> | undefined | null},ResolverInputTypes["VideoSourcesEdge"]],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `deleteVideoSourceByNodeId` mutation. */
["DeleteVideoSourceByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	/** The globally unique `ID` which will identify a single `VideoSource` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteVideoSource` mutation. */
["DeleteVideoSourceInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	vsId: ResolverInputTypes["BigInt"]
};
	/** The output of our `login` mutation. */
["LoginPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	result?:ResolverInputTypes["LoginRecord"],
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
		__typename?: boolean | `@${string}`
}>;
	/** The return type of our `login` mutation. */
["LoginRecord"]: AliasType<{
	couple?:ResolverInputTypes["Pary"],
	sess?:ResolverInputTypes["Session"],
	usr?:ResolverInputTypes["User"],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `login` mutation. */
["LoginInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	login: string,
	passwd: string
};
	/** The output of our `logout` mutation. */
["LogoutPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `logout` mutation. */
["LogoutInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null
};
	/** The output of our `prospectFormDancer` mutation. */
["ProspectFormDancerPayload"]: AliasType<{
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?:boolean | `@${string}`,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?:ResolverInputTypes["Query"],
		__typename?: boolean | `@${string}`
}>;
	/** All input for the `prospectFormDancer` mutation. */
["ProspectFormDancerInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined | null,
	cohort: ResolverInputTypes["CrmCohort"],
	prospectData: ResolverInputTypes["ProspectDatumInput"],
	origin: string,
	note: string
};
	/** An input for mutations affecting `ProspectDatum` */
["ProspectDatumInput"]: {
	name?: string | undefined | null,
	surname?: string | undefined | null,
	email?: string | undefined | null,
	phone?: string | undefined | null,
	yearofbirth?: string | undefined | null
};
	["Upload"]: AliasType<{
	uploadUrl?:boolean | `@${string}`,
		__typename?: boolean | `@${string}`
}>;
	["UploadInput"]: {
	directory?: string | undefined | null,
	filename: string
}
  }

export type ModelTypes = {
    /** The root query type which gives access points into the data universe. */
["Query"]: {
		/** Exposes the root query type nested one level down. This is helpful for Relay 1
which can only query top level fields if they are in a particular form. */
	query: ModelTypes["Query"],
	/** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
	nodeId: string,
	/** Fetches an object given its globally unique `ID`. */
	node?: ModelTypes["Node"] | undefined,
	/** Reads and enables pagination through a set of `Akce`. */
	akces?: ModelTypes["AkcesConnection"] | undefined,
	/** Reads and enables pagination through a set of `AkceItem`. */
	akceItems?: ModelTypes["AkceItemsConnection"] | undefined,
	/** Reads and enables pagination through a set of `Aktuality`. */
	aktualities?: ModelTypes["AktualitiesConnection"] | undefined,
	/** Reads and enables pagination through a set of `Dokumenty`. */
	dokumenties?: ModelTypes["DokumentiesConnection"] | undefined,
	/** Reads and enables pagination through a set of `GalerieDir`. */
	galerieDirs?: ModelTypes["GalerieDirsConnection"] | undefined,
	/** Reads and enables pagination through a set of `GalerieFoto`. */
	galerieFotos?: ModelTypes["GalerieFotosConnection"] | undefined,
	/** Reads and enables pagination through a set of `Member`. */
	members?: ModelTypes["MembersConnection"] | undefined,
	/** Reads and enables pagination through a set of `Nabidka`. */
	nabidkas?: ModelTypes["NabidkasConnection"] | undefined,
	/** Reads and enables pagination through a set of `NabidkaItem`. */
	nabidkaItems?: ModelTypes["NabidkaItemsConnection"] | undefined,
	/** Reads and enables pagination through a set of `Page`. */
	pages?: ModelTypes["PagesConnection"] | undefined,
	/** Reads and enables pagination through a set of `PageRevision`. */
	pageRevisions?: ModelTypes["PageRevisionsConnection"] | undefined,
	/** Reads and enables pagination through a set of `Parameter`. */
	parameters?: ModelTypes["ParametersConnection"] | undefined,
	/** Reads and enables pagination through a set of `Pary`. */
	paries?: ModelTypes["PariesConnection"] | undefined,
	/** Reads and enables pagination through a set of `ParyNavrh`. */
	paryNavrhs?: ModelTypes["ParyNavrhsConnection"] | undefined,
	/** Reads and enables pagination through a set of `Permission`. */
	permissions?: ModelTypes["PermissionsConnection"] | undefined,
	/** Reads and enables pagination through a set of `PlatbyCategory`. */
	platbyCategories?: ModelTypes["PlatbyCategoriesConnection"] | undefined,
	/** Reads and enables pagination through a set of `PlatbyCategoryGroup`. */
	platbyCategoryGroups?: ModelTypes["PlatbyCategoryGroupsConnection"] | undefined,
	/** Reads and enables pagination through a set of `PlatbyGroup`. */
	platbyGroups?: ModelTypes["PlatbyGroupsConnection"] | undefined,
	/** Reads and enables pagination through a set of `PlatbyGroupSkupina`. */
	platbyGroupSkupinas?: ModelTypes["PlatbyGroupSkupinasConnection"] | undefined,
	/** Reads and enables pagination through a set of `PlatbyItem`. */
	platbyItems?: ModelTypes["PlatbyItemsConnection"] | undefined,
	/** Reads and enables pagination through a set of `PlatbyRaw`. */
	platbyRaws?: ModelTypes["PlatbyRawsConnection"] | undefined,
	/** Reads and enables pagination through a set of `Rozpi`. */
	rozpis?: ModelTypes["RozpisConnection"] | undefined,
	/** Reads and enables pagination through a set of `RozpisItem`. */
	rozpisItems?: ModelTypes["RozpisItemsConnection"] | undefined,
	/** Reads and enables pagination through a set of `Session`. */
	sessions?: ModelTypes["SessionsConnection"] | undefined,
	/** Reads and enables pagination through a set of `Skupiny`. */
	skupinies?: ModelTypes["SkupiniesConnection"] | undefined,
	/** Reads and enables pagination through a set of `Upozorneni`. */
	upozornenis?: ModelTypes["UpozornenisConnection"] | undefined,
	/** Reads and enables pagination through a set of `UpozorneniSkupiny`. */
	upozorneniSkupinies?: ModelTypes["UpozorneniSkupiniesConnection"] | undefined,
	/** Reads and enables pagination through a set of `User`. */
	users?: ModelTypes["UsersConnection"] | undefined,
	/** Reads and enables pagination through a set of `UsersSkupiny`. */
	usersSkupinies?: ModelTypes["UsersSkupiniesConnection"] | undefined,
	/** Reads and enables pagination through a set of `Video`. */
	videos?: ModelTypes["VideosConnection"] | undefined,
	/** Reads and enables pagination through a set of `VideoList`. */
	videoLists?: ModelTypes["VideoListsConnection"] | undefined,
	/** Reads and enables pagination through a set of `VideoSource`. */
	videoSources?: ModelTypes["VideoSourcesConnection"] | undefined,
	akce?: ModelTypes["Akce"] | undefined,
	akceItem?: ModelTypes["AkceItem"] | undefined,
	aktuality?: ModelTypes["Aktuality"] | undefined,
	dokumenty?: ModelTypes["Dokumenty"] | undefined,
	galerieDir?: ModelTypes["GalerieDir"] | undefined,
	galerieFoto?: ModelTypes["GalerieFoto"] | undefined,
	nabidka?: ModelTypes["Nabidka"] | undefined,
	nabidkaItem?: ModelTypes["NabidkaItem"] | undefined,
	page?: ModelTypes["Page"] | undefined,
	pageByUrl?: ModelTypes["Page"] | undefined,
	pageRevision?: ModelTypes["PageRevision"] | undefined,
	parameter?: ModelTypes["Parameter"] | undefined,
	pary?: ModelTypes["Pary"] | undefined,
	paryNavrh?: ModelTypes["ParyNavrh"] | undefined,
	permission?: ModelTypes["Permission"] | undefined,
	platbyCategory?: ModelTypes["PlatbyCategory"] | undefined,
	platbyCategoryGroup?: ModelTypes["PlatbyCategoryGroup"] | undefined,
	platbyGroup?: ModelTypes["PlatbyGroup"] | undefined,
	platbyGroupSkupina?: ModelTypes["PlatbyGroupSkupina"] | undefined,
	platbyItem?: ModelTypes["PlatbyItem"] | undefined,
	platbyRaw?: ModelTypes["PlatbyRaw"] | undefined,
	rozpi?: ModelTypes["Rozpi"] | undefined,
	rozpisItem?: ModelTypes["RozpisItem"] | undefined,
	session?: ModelTypes["Session"] | undefined,
	skupiny?: ModelTypes["Skupiny"] | undefined,
	upozorneni?: ModelTypes["Upozorneni"] | undefined,
	upozorneniSkupiny?: ModelTypes["UpozorneniSkupiny"] | undefined,
	user?: ModelTypes["User"] | undefined,
	usersSkupiny?: ModelTypes["UsersSkupiny"] | undefined,
	video?: ModelTypes["Video"] | undefined,
	videoList?: ModelTypes["VideoList"] | undefined,
	videoSource?: ModelTypes["VideoSource"] | undefined,
	activeProspects?: ModelTypes["ActiveProspectsConnection"] | undefined,
	/** Reads and enables pagination through a set of `Member`. */
	cohortMembers?: ModelTypes["MembersConnection"] | undefined,
	currentCoupleIds?: ModelTypes["CurrentCoupleIdsConnection"] | undefined,
	currentSessionId?: string | undefined,
	currentUserId?: ModelTypes["BigInt"] | undefined,
	getCurrentUser?: ModelTypes["User"] | undefined,
	/** Reads and enables pagination through a set of `Nabidka`. */
	reservationsForRange?: ModelTypes["NabidkasConnection"] | undefined,
	/** Reads and enables pagination through a set of `Rozpi`. */
	schedulesForRange?: ModelTypes["RozpisConnection"] | undefined,
	/** Reads and enables pagination through a set of `Video`. */
	titleVideos?: ModelTypes["VideosConnection"] | undefined,
	/** Reads a single `Akce` using its globally unique `ID`. */
	akceByNodeId?: ModelTypes["Akce"] | undefined,
	/** Reads a single `AkceItem` using its globally unique `ID`. */
	akceItemByNodeId?: ModelTypes["AkceItem"] | undefined,
	/** Reads a single `Aktuality` using its globally unique `ID`. */
	aktualityByNodeId?: ModelTypes["Aktuality"] | undefined,
	/** Reads a single `Dokumenty` using its globally unique `ID`. */
	dokumentyByNodeId?: ModelTypes["Dokumenty"] | undefined,
	/** Reads a single `GalerieDir` using its globally unique `ID`. */
	galerieDirByNodeId?: ModelTypes["GalerieDir"] | undefined,
	/** Reads a single `GalerieFoto` using its globally unique `ID`. */
	galerieFotoByNodeId?: ModelTypes["GalerieFoto"] | undefined,
	/** Reads a single `Nabidka` using its globally unique `ID`. */
	nabidkaByNodeId?: ModelTypes["Nabidka"] | undefined,
	/** Reads a single `NabidkaItem` using its globally unique `ID`. */
	nabidkaItemByNodeId?: ModelTypes["NabidkaItem"] | undefined,
	/** Reads a single `Page` using its globally unique `ID`. */
	pageByNodeId?: ModelTypes["Page"] | undefined,
	/** Reads a single `PageRevision` using its globally unique `ID`. */
	pageRevisionByNodeId?: ModelTypes["PageRevision"] | undefined,
	/** Reads a single `Parameter` using its globally unique `ID`. */
	parameterByNodeId?: ModelTypes["Parameter"] | undefined,
	/** Reads a single `Pary` using its globally unique `ID`. */
	paryByNodeId?: ModelTypes["Pary"] | undefined,
	/** Reads a single `ParyNavrh` using its globally unique `ID`. */
	paryNavrhByNodeId?: ModelTypes["ParyNavrh"] | undefined,
	/** Reads a single `Permission` using its globally unique `ID`. */
	permissionByNodeId?: ModelTypes["Permission"] | undefined,
	/** Reads a single `PlatbyCategory` using its globally unique `ID`. */
	platbyCategoryByNodeId?: ModelTypes["PlatbyCategory"] | undefined,
	/** Reads a single `PlatbyCategoryGroup` using its globally unique `ID`. */
	platbyCategoryGroupByNodeId?: ModelTypes["PlatbyCategoryGroup"] | undefined,
	/** Reads a single `PlatbyGroup` using its globally unique `ID`. */
	platbyGroupByNodeId?: ModelTypes["PlatbyGroup"] | undefined,
	/** Reads a single `PlatbyGroupSkupina` using its globally unique `ID`. */
	platbyGroupSkupinaByNodeId?: ModelTypes["PlatbyGroupSkupina"] | undefined,
	/** Reads a single `PlatbyItem` using its globally unique `ID`. */
	platbyItemByNodeId?: ModelTypes["PlatbyItem"] | undefined,
	/** Reads a single `PlatbyRaw` using its globally unique `ID`. */
	platbyRawByNodeId?: ModelTypes["PlatbyRaw"] | undefined,
	/** Reads a single `Rozpi` using its globally unique `ID`. */
	rozpiByNodeId?: ModelTypes["Rozpi"] | undefined,
	/** Reads a single `RozpisItem` using its globally unique `ID`. */
	rozpisItemByNodeId?: ModelTypes["RozpisItem"] | undefined,
	/** Reads a single `Session` using its globally unique `ID`. */
	sessionByNodeId?: ModelTypes["Session"] | undefined,
	/** Reads a single `Skupiny` using its globally unique `ID`. */
	skupinyByNodeId?: ModelTypes["Skupiny"] | undefined,
	/** Reads a single `Upozorneni` using its globally unique `ID`. */
	upozorneniByNodeId?: ModelTypes["Upozorneni"] | undefined,
	/** Reads a single `UpozorneniSkupiny` using its globally unique `ID`. */
	upozorneniSkupinyByNodeId?: ModelTypes["UpozorneniSkupiny"] | undefined,
	/** Reads a single `User` using its globally unique `ID`. */
	userByNodeId?: ModelTypes["User"] | undefined,
	/** Reads a single `UsersSkupiny` using its globally unique `ID`. */
	usersSkupinyByNodeId?: ModelTypes["UsersSkupiny"] | undefined,
	/** Reads a single `Video` using its globally unique `ID`. */
	videoByNodeId?: ModelTypes["Video"] | undefined,
	/** Reads a single `VideoList` using its globally unique `ID`. */
	videoListByNodeId?: ModelTypes["VideoList"] | undefined,
	/** Reads a single `VideoSource` using its globally unique `ID`. */
	videoSourceByNodeId?: ModelTypes["VideoSource"] | undefined
};
	/** An object with a globally unique `ID`. */
["Node"]: ModelTypes["Query"] | ModelTypes["Akce"] | ModelTypes["AkceItem"] | ModelTypes["User"] | ModelTypes["Permission"] | ModelTypes["Skupiny"] | ModelTypes["PlatbyGroupSkupina"] | ModelTypes["PlatbyGroup"] | ModelTypes["PlatbyCategoryGroup"] | ModelTypes["PlatbyCategory"] | ModelTypes["PlatbyItem"] | ModelTypes["PlatbyRaw"] | ModelTypes["UpozorneniSkupiny"] | ModelTypes["Upozorneni"] | ModelTypes["Aktuality"] | ModelTypes["GalerieFoto"] | ModelTypes["GalerieDir"] | ModelTypes["Nabidka"] | ModelTypes["NabidkaItem"] | ModelTypes["Pary"] | ModelTypes["RozpisItem"] | ModelTypes["Rozpi"] | ModelTypes["Session"] | ModelTypes["Dokumenty"] | ModelTypes["ParyNavrh"] | ModelTypes["Page"] | ModelTypes["PageRevision"] | ModelTypes["Parameter"] | ModelTypes["UsersSkupiny"] | ModelTypes["Video"] | ModelTypes["VideoList"] | ModelTypes["VideoSource"];
	/** A connection to a list of `Akce` values. */
["AkcesConnection"]: {
		/** A list of `Akce` objects. */
	nodes: Array<ModelTypes["Akce"]>,
	/** A list of edges which contains the `Akce` and cursor to aid in pagination. */
	edges: Array<ModelTypes["AkcesEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: ModelTypes["PageInfo"],
	/** The count of *all* `Akce` you could get from the connection. */
	totalCount: number
};
	["Akce"]: {
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	aId: ModelTypes["BigInt"],
	aJmeno: string,
	aKde: string,
	aInfo: string,
	aOd: ModelTypes["Date"],
	aDo: ModelTypes["Date"],
	aKapacita: ModelTypes["BigInt"],
	aDokumenty: string,
	aTimestamp?: ModelTypes["Datetime"] | undefined,
	aLock: boolean,
	aVisible: boolean,
	/** Reads and enables pagination through a set of `AkceItem`. */
	akceItemsByAiIdRodic: ModelTypes["AkceItemsConnection"]
};
	/** A signed eight-byte integer. The upper big integer values are greater than the
max value for a JavaScript number. Therefore all big integers will be output as
strings and not numbers. */
["BigInt"]:any;
	/** The day, does not include a time. */
["Date"]:any;
	/** A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone. */
["Datetime"]:any;
	/** A connection to a list of `AkceItem` values. */
["AkceItemsConnection"]: {
		/** A list of `AkceItem` objects. */
	nodes: Array<ModelTypes["AkceItem"]>,
	/** A list of edges which contains the `AkceItem` and cursor to aid in pagination. */
	edges: Array<ModelTypes["AkceItemsEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: ModelTypes["PageInfo"],
	/** The count of *all* `AkceItem` you could get from the connection. */
	totalCount: number
};
	["AkceItem"]: {
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	aiId: ModelTypes["BigInt"],
	aiIdRodic: ModelTypes["BigInt"],
	aiUser: ModelTypes["BigInt"],
	aiRokNarozeni: number,
	/** Reads a single `Akce` that is related to this `AkceItem`. */
	akceByAiIdRodic?: ModelTypes["Akce"] | undefined,
	/** Reads a single `User` that is related to this `AkceItem`. */
	userByAiUser?: ModelTypes["User"] | undefined
};
	["User"]: {
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	uId: ModelTypes["BigInt"],
	uLogin: string,
	uPass: string,
	uJmeno: string,
	uPrijmeni: string,
	uPohlavi: string,
	uEmail: string,
	uTelefon: string,
	uNarozeni: ModelTypes["Date"],
	uRodneCislo?: string | undefined,
	uPoznamky: string,
	uTimestamp: ModelTypes["Datetime"],
	uLevel: number,
	uGroup: ModelTypes["BigInt"],
	uSkupina: ModelTypes["BigInt"],
	uDancer: boolean,
	uBan: boolean,
	uLock: boolean,
	uConfirmed: boolean,
	uSystem: boolean,
	uStreet: string,
	uConscriptionNumber: string,
	uOrientationNumber: string,
	uDistrict: string,
	uCity: string,
	uPostalCode: string,
	uNationality: string,
	uMemberSince?: ModelTypes["Datetime"] | undefined,
	uMemberUntil?: ModelTypes["Datetime"] | undefined,
	uCreatedAt: ModelTypes["Datetime"],
	uTeacher: boolean,
	uGdprSignedAt?: ModelTypes["Datetime"] | undefined,
	/** Reads a single `Permission` that is related to this `User`. */
	permissionByUGroup?: ModelTypes["Permission"] | undefined,
	/** Reads a single `Skupiny` that is related to this `User`. */
	skupinyByUSkupina?: ModelTypes["Skupiny"] | undefined,
	/** Reads and enables pagination through a set of `Aktuality`. */
	aktualitiesByAtKdo: ModelTypes["AktualitiesConnection"],
	/** Reads and enables pagination through a set of `Nabidka`. */
	nabidkasByNTrener: ModelTypes["NabidkasConnection"],
	/** Reads and enables pagination through a set of `Rozpi`. */
	rozpisByRTrener: ModelTypes["RozpisConnection"],
	/** Reads and enables pagination through a set of `PlatbyItem`. */
	platbyItemsByPiIdUser: ModelTypes["PlatbyItemsConnection"],
	/** Reads and enables pagination through a set of `Pary`. */
	pariesByPIdPartner: ModelTypes["PariesConnection"],
	/** Reads and enables pagination through a set of `Session`. */
	sessionsBySsUser: ModelTypes["SessionsConnection"],
	/** Reads and enables pagination through a set of `AkceItem`. */
	akceItemsByAiUser: ModelTypes["AkceItemsConnection"],
	/** Reads and enables pagination through a set of `Dokumenty`. */
	dokumentiesByDKdo: ModelTypes["DokumentiesConnection"],
	/** Reads and enables pagination through a set of `GalerieFoto`. */
	galerieFotosByGfKdo: ModelTypes["GalerieFotosConnection"],
	/** Reads and enables pagination through a set of `ParyNavrh`. */
	paryNavrhsByPnNavrhl: ModelTypes["ParyNavrhsConnection"],
	/** Reads and enables pagination through a set of `ParyNavrh`. */
	paryNavrhsByPnPartner: ModelTypes["ParyNavrhsConnection"],
	/** Reads and enables pagination through a set of `ParyNavrh`. */
	paryNavrhsByPnPartnerka: ModelTypes["ParyNavrhsConnection"],
	/** Reads and enables pagination through a set of `Upozorneni`. */
	upozornenisByUpKdo: ModelTypes["UpozornenisConnection"]
};
	["Permission"]: {
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	peId: ModelTypes["BigInt"],
	peName: string,
	peDescription: string,
	peAkce: number,
	peAktuality: number,
	peAnkety: number,
	peDokumenty: number,
	peGalerie: number,
	peInzerce: number,
	peKonzole: number,
	peNabidka: number,
	peNastenka: number,
	peNovinky: number,
	pePary: number,
	pePlatby: number,
	pePermissions: number,
	peRozpis: number,
	peSkupiny: number,
	peUsers: number,
	peMain: number,
	/** Reads and enables pagination through a set of `User`. */
	usersByUGroup: ModelTypes["UsersConnection"]
};
	/** A connection to a list of `User` values. */
["UsersConnection"]: {
		/** A list of `User` objects. */
	nodes: Array<ModelTypes["User"]>,
	/** A list of edges which contains the `User` and cursor to aid in pagination. */
	edges: Array<ModelTypes["UsersEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: ModelTypes["PageInfo"],
	/** The count of *all* `User` you could get from the connection. */
	totalCount: number
};
	/** A `User` edge in the connection. */
["UsersEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `User` at the end of the edge. */
	node: ModelTypes["User"]
};
	/** A location in a connection that can be used for resuming pagination. */
["Cursor"]:any;
	/** Information about pagination in a connection. */
["PageInfo"]: {
		/** When paginating forwards, are there more items? */
	hasNextPage: boolean,
	/** When paginating backwards, are there more items? */
	hasPreviousPage: boolean,
	/** When paginating backwards, the cursor to continue. */
	startCursor?: ModelTypes["Cursor"] | undefined,
	/** When paginating forwards, the cursor to continue. */
	endCursor?: ModelTypes["Cursor"] | undefined
};
	["UsersOrderBy"]:UsersOrderBy;
	/** A condition to be used against `User` object types. All fields are tested for equality and combined with a logical and. */
["UserCondition"]: {
	/** Checks for equality with the objects `uId` field. */
	uId?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `uLogin` field. */
	uLogin?: string | undefined,
	/** Checks for equality with the objects `uPass` field. */
	uPass?: string | undefined,
	/** Checks for equality with the objects `uJmeno` field. */
	uJmeno?: string | undefined,
	/** Checks for equality with the objects `uPrijmeni` field. */
	uPrijmeni?: string | undefined,
	/** Checks for equality with the objects `uPohlavi` field. */
	uPohlavi?: string | undefined,
	/** Checks for equality with the objects `uEmail` field. */
	uEmail?: string | undefined,
	/** Checks for equality with the objects `uTelefon` field. */
	uTelefon?: string | undefined,
	/** Checks for equality with the objects `uNarozeni` field. */
	uNarozeni?: ModelTypes["Date"] | undefined,
	/** Checks for equality with the objects `uRodneCislo` field. */
	uRodneCislo?: string | undefined,
	/** Checks for equality with the objects `uPoznamky` field. */
	uPoznamky?: string | undefined,
	/** Checks for equality with the objects `uTimestamp` field. */
	uTimestamp?: ModelTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `uLevel` field. */
	uLevel?: number | undefined,
	/** Checks for equality with the objects `uGroup` field. */
	uGroup?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `uSkupina` field. */
	uSkupina?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `uDancer` field. */
	uDancer?: boolean | undefined,
	/** Checks for equality with the objects `uBan` field. */
	uBan?: boolean | undefined,
	/** Checks for equality with the objects `uLock` field. */
	uLock?: boolean | undefined,
	/** Checks for equality with the objects `uConfirmed` field. */
	uConfirmed?: boolean | undefined,
	/** Checks for equality with the objects `uSystem` field. */
	uSystem?: boolean | undefined,
	/** Checks for equality with the objects `uStreet` field. */
	uStreet?: string | undefined,
	/** Checks for equality with the objects `uConscriptionNumber` field. */
	uConscriptionNumber?: string | undefined,
	/** Checks for equality with the objects `uOrientationNumber` field. */
	uOrientationNumber?: string | undefined,
	/** Checks for equality with the objects `uDistrict` field. */
	uDistrict?: string | undefined,
	/** Checks for equality with the objects `uCity` field. */
	uCity?: string | undefined,
	/** Checks for equality with the objects `uPostalCode` field. */
	uPostalCode?: string | undefined,
	/** Checks for equality with the objects `uNationality` field. */
	uNationality?: string | undefined,
	/** Checks for equality with the objects `uMemberSince` field. */
	uMemberSince?: ModelTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `uMemberUntil` field. */
	uMemberUntil?: ModelTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `uCreatedAt` field. */
	uCreatedAt?: ModelTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `uTeacher` field. */
	uTeacher?: boolean | undefined,
	/** Checks for equality with the objects `uGdprSignedAt` field. */
	uGdprSignedAt?: ModelTypes["Datetime"] | undefined
};
	["Skupiny"]: {
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	sId: ModelTypes["BigInt"],
	sName: string,
	sDescription: string,
	sColorRgb: string,
	sColorText: string,
	sLocation: string,
	sVisible: boolean,
	/** Reads and enables pagination through a set of `User`. */
	usersByUSkupina: ModelTypes["UsersConnection"],
	/** Reads and enables pagination through a set of `PlatbyGroupSkupina`. */
	platbyGroupSkupinasByPgsIdSkupina: ModelTypes["PlatbyGroupSkupinasConnection"],
	/** Reads and enables pagination through a set of `UpozorneniSkupiny`. */
	upozorneniSkupiniesByUpsIdSkupina: ModelTypes["UpozorneniSkupiniesConnection"]
};
	/** A connection to a list of `PlatbyGroupSkupina` values. */
["PlatbyGroupSkupinasConnection"]: {
		/** A list of `PlatbyGroupSkupina` objects. */
	nodes: Array<ModelTypes["PlatbyGroupSkupina"]>,
	/** A list of edges which contains the `PlatbyGroupSkupina` and cursor to aid in pagination. */
	edges: Array<ModelTypes["PlatbyGroupSkupinasEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: ModelTypes["PageInfo"],
	/** The count of *all* `PlatbyGroupSkupina` you could get from the connection. */
	totalCount: number
};
	["PlatbyGroupSkupina"]: {
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	pgsId: ModelTypes["BigInt"],
	pgsIdSkupina: ModelTypes["BigInt"],
	pgsIdGroup: ModelTypes["BigInt"],
	/** Reads a single `Skupiny` that is related to this `PlatbyGroupSkupina`. */
	skupinyByPgsIdSkupina?: ModelTypes["Skupiny"] | undefined,
	/** Reads a single `PlatbyGroup` that is related to this `PlatbyGroupSkupina`. */
	platbyGroupByPgsIdGroup?: ModelTypes["PlatbyGroup"] | undefined
};
	["PlatbyGroup"]: {
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	pgId: ModelTypes["BigInt"],
	pgType: ModelTypes["BigFloat"],
	pgName: string,
	pgDescription: string,
	pgBase: ModelTypes["BigInt"],
	/** Reads and enables pagination through a set of `PlatbyCategoryGroup`. */
	platbyCategoryGroupsByPcgIdGroup: ModelTypes["PlatbyCategoryGroupsConnection"],
	/** Reads and enables pagination through a set of `PlatbyGroupSkupina`. */
	platbyGroupSkupinasByPgsIdGroup: ModelTypes["PlatbyGroupSkupinasConnection"]
};
	/** A floating point number that requires more precision than IEEE 754 binary 64 */
["BigFloat"]:any;
	/** A connection to a list of `PlatbyCategoryGroup` values. */
["PlatbyCategoryGroupsConnection"]: {
		/** A list of `PlatbyCategoryGroup` objects. */
	nodes: Array<ModelTypes["PlatbyCategoryGroup"]>,
	/** A list of edges which contains the `PlatbyCategoryGroup` and cursor to aid in pagination. */
	edges: Array<ModelTypes["PlatbyCategoryGroupsEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: ModelTypes["PageInfo"],
	/** The count of *all* `PlatbyCategoryGroup` you could get from the connection. */
	totalCount: number
};
	["PlatbyCategoryGroup"]: {
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	pcgId: ModelTypes["BigInt"],
	pcgIdGroup: ModelTypes["BigInt"],
	pcgIdCategory: ModelTypes["BigInt"],
	/** Reads a single `PlatbyGroup` that is related to this `PlatbyCategoryGroup`. */
	platbyGroupByPcgIdGroup?: ModelTypes["PlatbyGroup"] | undefined,
	/** Reads a single `PlatbyCategory` that is related to this `PlatbyCategoryGroup`. */
	platbyCategoryByPcgIdCategory?: ModelTypes["PlatbyCategory"] | undefined
};
	["PlatbyCategory"]: {
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	pcId: ModelTypes["BigInt"],
	pcName: string,
	pcSymbol: ModelTypes["BigInt"],
	pcAmount: ModelTypes["BigFloat"],
	pcDateDue: ModelTypes["Date"],
	pcValidFrom: ModelTypes["Date"],
	pcValidTo: ModelTypes["Date"],
	pcUseBase: boolean,
	pcUsePrefix: boolean,
	pcArchive: boolean,
	pcVisible: boolean,
	/** Reads and enables pagination through a set of `PlatbyCategoryGroup`. */
	platbyCategoryGroupsByPcgIdCategory: ModelTypes["PlatbyCategoryGroupsConnection"],
	/** Reads and enables pagination through a set of `PlatbyItem`. */
	platbyItemsByPiIdCategory: ModelTypes["PlatbyItemsConnection"]
};
	["PlatbyCategoryGroupsOrderBy"]:PlatbyCategoryGroupsOrderBy;
	/** A condition to be used against `PlatbyCategoryGroup` object types. All fields
are tested for equality and combined with a logical and. */
["PlatbyCategoryGroupCondition"]: {
	/** Checks for equality with the objects `pcgId` field. */
	pcgId?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `pcgIdGroup` field. */
	pcgIdGroup?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `pcgIdCategory` field. */
	pcgIdCategory?: ModelTypes["BigInt"] | undefined
};
	/** A connection to a list of `PlatbyItem` values. */
["PlatbyItemsConnection"]: {
		/** A list of `PlatbyItem` objects. */
	nodes: Array<ModelTypes["PlatbyItem"]>,
	/** A list of edges which contains the `PlatbyItem` and cursor to aid in pagination. */
	edges: Array<ModelTypes["PlatbyItemsEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: ModelTypes["PageInfo"],
	/** The count of *all* `PlatbyItem` you could get from the connection. */
	totalCount: number
};
	["PlatbyItem"]: {
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	piId: ModelTypes["BigInt"],
	piIdUser?: ModelTypes["BigInt"] | undefined,
	piIdCategory: ModelTypes["BigInt"],
	piIdRaw?: ModelTypes["BigInt"] | undefined,
	piAmount: ModelTypes["BigFloat"],
	piDate: ModelTypes["Date"],
	piPrefix: number,
	/** Reads a single `User` that is related to this `PlatbyItem`. */
	userByPiIdUser?: ModelTypes["User"] | undefined,
	/** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
	platbyCategoryByPiIdCategory?: ModelTypes["PlatbyCategory"] | undefined,
	/** Reads a single `PlatbyRaw` that is related to this `PlatbyItem`. */
	platbyRawByPiIdRaw?: ModelTypes["PlatbyRaw"] | undefined
};
	["PlatbyRaw"]: {
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	prId: ModelTypes["BigInt"],
	prRaw: string,
	prHash: string,
	prSorted: boolean,
	prDiscarded: boolean,
	/** Reads and enables pagination through a set of `PlatbyItem`. */
	platbyItemsByPiIdRaw: ModelTypes["PlatbyItemsConnection"]
};
	["PlatbyItemsOrderBy"]:PlatbyItemsOrderBy;
	/** A condition to be used against `PlatbyItem` object types. All fields are tested
for equality and combined with a logical and. */
["PlatbyItemCondition"]: {
	/** Checks for equality with the objects `piId` field. */
	piId?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `piIdUser` field. */
	piIdUser?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `piIdCategory` field. */
	piIdCategory?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `piIdRaw` field. */
	piIdRaw?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `piAmount` field. */
	piAmount?: ModelTypes["BigFloat"] | undefined,
	/** Checks for equality with the objects `piDate` field. */
	piDate?: ModelTypes["Date"] | undefined,
	/** Checks for equality with the objects `piPrefix` field. */
	piPrefix?: number | undefined
};
	/** A `PlatbyItem` edge in the connection. */
["PlatbyItemsEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `PlatbyItem` at the end of the edge. */
	node: ModelTypes["PlatbyItem"]
};
	/** A `PlatbyCategoryGroup` edge in the connection. */
["PlatbyCategoryGroupsEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `PlatbyCategoryGroup` at the end of the edge. */
	node: ModelTypes["PlatbyCategoryGroup"]
};
	["PlatbyGroupSkupinasOrderBy"]:PlatbyGroupSkupinasOrderBy;
	/** A condition to be used against `PlatbyGroupSkupina` object types. All fields are
tested for equality and combined with a logical and. */
["PlatbyGroupSkupinaCondition"]: {
	/** Checks for equality with the objects `pgsId` field. */
	pgsId?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `pgsIdSkupina` field. */
	pgsIdSkupina?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `pgsIdGroup` field. */
	pgsIdGroup?: ModelTypes["BigInt"] | undefined
};
	/** A `PlatbyGroupSkupina` edge in the connection. */
["PlatbyGroupSkupinasEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `PlatbyGroupSkupina` at the end of the edge. */
	node: ModelTypes["PlatbyGroupSkupina"]
};
	/** A connection to a list of `UpozorneniSkupiny` values. */
["UpozorneniSkupiniesConnection"]: {
		/** A list of `UpozorneniSkupiny` objects. */
	nodes: Array<ModelTypes["UpozorneniSkupiny"]>,
	/** A list of edges which contains the `UpozorneniSkupiny` and cursor to aid in pagination. */
	edges: Array<ModelTypes["UpozorneniSkupiniesEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: ModelTypes["PageInfo"],
	/** The count of *all* `UpozorneniSkupiny` you could get from the connection. */
	totalCount: number
};
	["UpozorneniSkupiny"]: {
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	upsId: ModelTypes["BigInt"],
	upsIdRodic: ModelTypes["BigInt"],
	upsIdSkupina: ModelTypes["BigInt"],
	upsColor: string,
	upsPopis: string,
	/** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
	upozorneniByUpsIdRodic?: ModelTypes["Upozorneni"] | undefined,
	/** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
	skupinyByUpsIdSkupina?: ModelTypes["Skupiny"] | undefined
};
	["Upozorneni"]: {
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	upId: ModelTypes["BigInt"],
	upKdo: ModelTypes["BigInt"],
	upNadpis: string,
	upText: string,
	upBarvy: ModelTypes["BigInt"],
	upLock: boolean,
	upTimestamp?: ModelTypes["Datetime"] | undefined,
	upTimestampAdd: ModelTypes["Datetime"],
	/** Reads a single `User` that is related to this `Upozorneni`. */
	userByUpKdo?: ModelTypes["User"] | undefined,
	/** Reads and enables pagination through a set of `UpozorneniSkupiny`. */
	upozorneniSkupiniesByUpsIdRodic: ModelTypes["UpozorneniSkupiniesConnection"]
};
	["UpozorneniSkupiniesOrderBy"]:UpozorneniSkupiniesOrderBy;
	/** A condition to be used against `UpozorneniSkupiny` object types. All fields are
tested for equality and combined with a logical and. */
["UpozorneniSkupinyCondition"]: {
	/** Checks for equality with the objects `upsId` field. */
	upsId?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `upsIdRodic` field. */
	upsIdRodic?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `upsIdSkupina` field. */
	upsIdSkupina?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `upsColor` field. */
	upsColor?: string | undefined,
	/** Checks for equality with the objects `upsPopis` field. */
	upsPopis?: string | undefined
};
	/** A `UpozorneniSkupiny` edge in the connection. */
["UpozorneniSkupiniesEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `UpozorneniSkupiny` at the end of the edge. */
	node: ModelTypes["UpozorneniSkupiny"]
};
	/** A connection to a list of `Aktuality` values. */
["AktualitiesConnection"]: {
		/** A list of `Aktuality` objects. */
	nodes: Array<ModelTypes["Aktuality"]>,
	/** A list of edges which contains the `Aktuality` and cursor to aid in pagination. */
	edges: Array<ModelTypes["AktualitiesEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: ModelTypes["PageInfo"],
	/** The count of *all* `Aktuality` you could get from the connection. */
	totalCount: number
};
	["Aktuality"]: {
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	atId: ModelTypes["BigInt"],
	atKdo: ModelTypes["BigInt"],
	atKat: string,
	atJmeno: string,
	atText: string,
	atPreview: string,
	atFoto?: ModelTypes["BigInt"] | undefined,
	atFotoMain?: ModelTypes["BigInt"] | undefined,
	atTimestamp?: ModelTypes["Datetime"] | undefined,
	atTimestampAdd?: ModelTypes["Datetime"] | undefined,
	/** Reads a single `User` that is related to this `Aktuality`. */
	userByAtKdo?: ModelTypes["User"] | undefined,
	/** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
	galerieFotoByAtFotoMain?: ModelTypes["GalerieFoto"] | undefined
};
	["GalerieFoto"]: {
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	gfId: ModelTypes["BigInt"],
	gfIdRodic: ModelTypes["BigInt"],
	gfName: string,
	gfPath: string,
	gfKdo: ModelTypes["BigInt"],
	gfTimestamp?: ModelTypes["Datetime"] | undefined,
	/** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
	galerieDirByGfIdRodic?: ModelTypes["GalerieDir"] | undefined,
	/** Reads a single `User` that is related to this `GalerieFoto`. */
	userByGfKdo?: ModelTypes["User"] | undefined,
	/** Reads and enables pagination through a set of `Aktuality`. */
	aktualitiesByAtFotoMain: ModelTypes["AktualitiesConnection"]
};
	["GalerieDir"]: {
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	gdId: ModelTypes["BigInt"],
	gdIdRodic: ModelTypes["BigInt"],
	gdName: string,
	gdLevel: number,
	gdPath: string,
	gdHidden: boolean,
	/** Reads and enables pagination through a set of `GalerieFoto`. */
	galerieFotosByGfIdRodic: ModelTypes["GalerieFotosConnection"]
};
	/** A connection to a list of `GalerieFoto` values. */
["GalerieFotosConnection"]: {
		/** A list of `GalerieFoto` objects. */
	nodes: Array<ModelTypes["GalerieFoto"]>,
	/** A list of edges which contains the `GalerieFoto` and cursor to aid in pagination. */
	edges: Array<ModelTypes["GalerieFotosEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: ModelTypes["PageInfo"],
	/** The count of *all* `GalerieFoto` you could get from the connection. */
	totalCount: number
};
	/** A `GalerieFoto` edge in the connection. */
["GalerieFotosEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `GalerieFoto` at the end of the edge. */
	node: ModelTypes["GalerieFoto"]
};
	["GalerieFotosOrderBy"]:GalerieFotosOrderBy;
	/** A condition to be used against `GalerieFoto` object types. All fields are tested
for equality and combined with a logical and. */
["GalerieFotoCondition"]: {
	/** Checks for equality with the objects `gfId` field. */
	gfId?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `gfIdRodic` field. */
	gfIdRodic?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `gfName` field. */
	gfName?: string | undefined,
	/** Checks for equality with the objects `gfPath` field. */
	gfPath?: string | undefined,
	/** Checks for equality with the objects `gfKdo` field. */
	gfKdo?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `gfTimestamp` field. */
	gfTimestamp?: ModelTypes["Datetime"] | undefined
};
	["AktualitiesOrderBy"]:AktualitiesOrderBy;
	/** A condition to be used against `Aktuality` object types. All fields are tested
for equality and combined with a logical and. */
["AktualityCondition"]: {
	/** Checks for equality with the objects `atId` field. */
	atId?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `atKdo` field. */
	atKdo?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `atKat` field. */
	atKat?: string | undefined,
	/** Checks for equality with the objects `atJmeno` field. */
	atJmeno?: string | undefined,
	/** Checks for equality with the objects `atText` field. */
	atText?: string | undefined,
	/** Checks for equality with the objects `atPreview` field. */
	atPreview?: string | undefined,
	/** Checks for equality with the objects `atFoto` field. */
	atFoto?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `atFotoMain` field. */
	atFotoMain?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `atTimestamp` field. */
	atTimestamp?: ModelTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `atTimestampAdd` field. */
	atTimestampAdd?: ModelTypes["Datetime"] | undefined
};
	/** A `Aktuality` edge in the connection. */
["AktualitiesEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `Aktuality` at the end of the edge. */
	node: ModelTypes["Aktuality"]
};
	/** A connection to a list of `Nabidka` values. */
["NabidkasConnection"]: {
		/** A list of `Nabidka` objects. */
	nodes: Array<ModelTypes["Nabidka"]>,
	/** A list of edges which contains the `Nabidka` and cursor to aid in pagination. */
	edges: Array<ModelTypes["NabidkasEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: ModelTypes["PageInfo"],
	/** The count of *all* `Nabidka` you could get from the connection. */
	totalCount: number
};
	["Nabidka"]: {
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	nId: ModelTypes["BigInt"],
	nTrener: ModelTypes["BigInt"],
	nPocetHod: number,
	nMaxPocetHod: ModelTypes["BigInt"],
	nOd: ModelTypes["Date"],
	nDo: ModelTypes["Date"],
	nVisible: boolean,
	nLock: boolean,
	nTimestamp?: ModelTypes["Datetime"] | undefined,
	/** Reads a single `User` that is related to this `Nabidka`. */
	userByNTrener?: ModelTypes["User"] | undefined,
	/** Reads and enables pagination through a set of `NabidkaItem`. */
	nabidkaItemsByNiIdRodic: ModelTypes["NabidkaItemsConnection"]
};
	/** A connection to a list of `NabidkaItem` values. */
["NabidkaItemsConnection"]: {
		/** A list of `NabidkaItem` objects. */
	nodes: Array<ModelTypes["NabidkaItem"]>,
	/** A list of edges which contains the `NabidkaItem` and cursor to aid in pagination. */
	edges: Array<ModelTypes["NabidkaItemsEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: ModelTypes["PageInfo"],
	/** The count of *all* `NabidkaItem` you could get from the connection. */
	totalCount: number
};
	["NabidkaItem"]: {
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	niId: ModelTypes["BigInt"],
	niIdRodic: ModelTypes["BigInt"],
	niPartner: ModelTypes["BigInt"],
	niPocetHod: number,
	niLock: boolean,
	/** Reads a single `Nabidka` that is related to this `NabidkaItem`. */
	nabidkaByNiIdRodic?: ModelTypes["Nabidka"] | undefined,
	/** Reads a single `Pary` that is related to this `NabidkaItem`. */
	paryByNiPartner?: ModelTypes["Pary"] | undefined
};
	["Pary"]: {
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	pId: ModelTypes["BigInt"],
	pIdPartner: ModelTypes["BigInt"],
	pIdPartnerka?: ModelTypes["BigInt"] | undefined,
	pSttTrida: ModelTypes["ParyPSttTrida"],
	pSttBody: number,
	pSttFinale: boolean,
	pLatTrida: ModelTypes["ParyPLatTrida"],
	pLatBody: number,
	pLatFinale: boolean,
	pHodnoceni: number,
	pArchiv: boolean,
	pTimestampAdd: ModelTypes["Datetime"],
	pTimestampArchive?: ModelTypes["Datetime"] | undefined,
	/** Reads a single `User` that is related to this `Pary`. */
	userByPIdPartner?: ModelTypes["User"] | undefined,
	/** Reads and enables pagination through a set of `NabidkaItem`. */
	nabidkaItemsByNiPartner: ModelTypes["NabidkaItemsConnection"],
	/** Reads and enables pagination through a set of `RozpisItem`. */
	rozpisItemsByRiPartner: ModelTypes["RozpisItemsConnection"]
};
	["ParyPSttTrida"]:ParyPSttTrida;
	["ParyPLatTrida"]:ParyPLatTrida;
	["NabidkaItemsOrderBy"]:NabidkaItemsOrderBy;
	/** A condition to be used against `NabidkaItem` object types. All fields are tested
for equality and combined with a logical and. */
["NabidkaItemCondition"]: {
	/** Checks for equality with the objects `niId` field. */
	niId?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `niIdRodic` field. */
	niIdRodic?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `niPartner` field. */
	niPartner?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `niPocetHod` field. */
	niPocetHod?: number | undefined,
	/** Checks for equality with the objects `niLock` field. */
	niLock?: boolean | undefined
};
	/** A connection to a list of `RozpisItem` values. */
["RozpisItemsConnection"]: {
		/** A list of `RozpisItem` objects. */
	nodes: Array<ModelTypes["RozpisItem"]>,
	/** A list of edges which contains the `RozpisItem` and cursor to aid in pagination. */
	edges: Array<ModelTypes["RozpisItemsEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: ModelTypes["PageInfo"],
	/** The count of *all* `RozpisItem` you could get from the connection. */
	totalCount: number
};
	["RozpisItem"]: {
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	riId: ModelTypes["BigInt"],
	riIdRodic: ModelTypes["BigInt"],
	riPartner?: ModelTypes["BigInt"] | undefined,
	riOd: ModelTypes["Time"],
	riDo: ModelTypes["Time"],
	riLock: boolean,
	/** Reads a single `Rozpi` that is related to this `RozpisItem`. */
	rozpiByRiIdRodic?: ModelTypes["Rozpi"] | undefined,
	/** Reads a single `Pary` that is related to this `RozpisItem`. */
	paryByRiPartner?: ModelTypes["Pary"] | undefined
};
	/** The exact time of day, does not include the date. May or may not have a timezone offset. */
["Time"]:any;
	["Rozpi"]: {
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	rId: ModelTypes["BigInt"],
	rTrener: ModelTypes["BigInt"],
	rKde: string,
	rDatum: ModelTypes["Date"],
	rVisible: boolean,
	rLock: boolean,
	rTimestamp?: ModelTypes["Datetime"] | undefined,
	/** Reads a single `User` that is related to this `Rozpi`. */
	userByRTrener?: ModelTypes["User"] | undefined,
	/** Reads and enables pagination through a set of `RozpisItem`. */
	rozpisItemsByRiIdRodic: ModelTypes["RozpisItemsConnection"]
};
	["RozpisItemsOrderBy"]:RozpisItemsOrderBy;
	/** A condition to be used against `RozpisItem` object types. All fields are tested
for equality and combined with a logical and. */
["RozpisItemCondition"]: {
	/** Checks for equality with the objects `riId` field. */
	riId?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `riIdRodic` field. */
	riIdRodic?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `riPartner` field. */
	riPartner?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `riOd` field. */
	riOd?: ModelTypes["Time"] | undefined,
	/** Checks for equality with the objects `riDo` field. */
	riDo?: ModelTypes["Time"] | undefined,
	/** Checks for equality with the objects `riLock` field. */
	riLock?: boolean | undefined
};
	/** A `RozpisItem` edge in the connection. */
["RozpisItemsEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `RozpisItem` at the end of the edge. */
	node: ModelTypes["RozpisItem"]
};
	/** A `NabidkaItem` edge in the connection. */
["NabidkaItemsEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `NabidkaItem` at the end of the edge. */
	node: ModelTypes["NabidkaItem"]
};
	/** A `Nabidka` edge in the connection. */
["NabidkasEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `Nabidka` at the end of the edge. */
	node: ModelTypes["Nabidka"]
};
	["NabidkasOrderBy"]:NabidkasOrderBy;
	/** A condition to be used against `Nabidka` object types. All fields are tested for equality and combined with a logical and. */
["NabidkaCondition"]: {
	/** Checks for equality with the objects `nId` field. */
	nId?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `nTrener` field. */
	nTrener?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `nPocetHod` field. */
	nPocetHod?: number | undefined,
	/** Checks for equality with the objects `nMaxPocetHod` field. */
	nMaxPocetHod?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `nOd` field. */
	nOd?: ModelTypes["Date"] | undefined,
	/** Checks for equality with the objects `nDo` field. */
	nDo?: ModelTypes["Date"] | undefined,
	/** Checks for equality with the objects `nVisible` field. */
	nVisible?: boolean | undefined,
	/** Checks for equality with the objects `nLock` field. */
	nLock?: boolean | undefined,
	/** Checks for equality with the objects `nTimestamp` field. */
	nTimestamp?: ModelTypes["Datetime"] | undefined
};
	/** A connection to a list of `Rozpi` values. */
["RozpisConnection"]: {
		/** A list of `Rozpi` objects. */
	nodes: Array<ModelTypes["Rozpi"]>,
	/** A list of edges which contains the `Rozpi` and cursor to aid in pagination. */
	edges: Array<ModelTypes["RozpisEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: ModelTypes["PageInfo"],
	/** The count of *all* `Rozpi` you could get from the connection. */
	totalCount: number
};
	/** A `Rozpi` edge in the connection. */
["RozpisEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `Rozpi` at the end of the edge. */
	node: ModelTypes["Rozpi"]
};
	["RozpisOrderBy"]:RozpisOrderBy;
	/** A condition to be used against `Rozpi` object types. All fields are tested for equality and combined with a logical and. */
["RozpiCondition"]: {
	/** Checks for equality with the objects `rId` field. */
	rId?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `rTrener` field. */
	rTrener?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `rKde` field. */
	rKde?: string | undefined,
	/** Checks for equality with the objects `rDatum` field. */
	rDatum?: ModelTypes["Date"] | undefined,
	/** Checks for equality with the objects `rVisible` field. */
	rVisible?: boolean | undefined,
	/** Checks for equality with the objects `rLock` field. */
	rLock?: boolean | undefined,
	/** Checks for equality with the objects `rTimestamp` field. */
	rTimestamp?: ModelTypes["Datetime"] | undefined
};
	/** A connection to a list of `Pary` values. */
["PariesConnection"]: {
		/** A list of `Pary` objects. */
	nodes: Array<ModelTypes["Pary"]>,
	/** A list of edges which contains the `Pary` and cursor to aid in pagination. */
	edges: Array<ModelTypes["PariesEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: ModelTypes["PageInfo"],
	/** The count of *all* `Pary` you could get from the connection. */
	totalCount: number
};
	/** A `Pary` edge in the connection. */
["PariesEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `Pary` at the end of the edge. */
	node: ModelTypes["Pary"]
};
	["PariesOrderBy"]:PariesOrderBy;
	/** A condition to be used against `Pary` object types. All fields are tested for equality and combined with a logical and. */
["ParyCondition"]: {
	/** Checks for equality with the objects `pId` field. */
	pId?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `pIdPartner` field. */
	pIdPartner?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `pIdPartnerka` field. */
	pIdPartnerka?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `pSttTrida` field. */
	pSttTrida?: ModelTypes["ParyPSttTrida"] | undefined,
	/** Checks for equality with the objects `pSttBody` field. */
	pSttBody?: number | undefined,
	/** Checks for equality with the objects `pSttFinale` field. */
	pSttFinale?: boolean | undefined,
	/** Checks for equality with the objects `pLatTrida` field. */
	pLatTrida?: ModelTypes["ParyPLatTrida"] | undefined,
	/** Checks for equality with the objects `pLatBody` field. */
	pLatBody?: number | undefined,
	/** Checks for equality with the objects `pLatFinale` field. */
	pLatFinale?: boolean | undefined,
	/** Checks for equality with the objects `pHodnoceni` field. */
	pHodnoceni?: number | undefined,
	/** Checks for equality with the objects `pArchiv` field. */
	pArchiv?: boolean | undefined,
	/** Checks for equality with the objects `pTimestampAdd` field. */
	pTimestampAdd?: ModelTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `pTimestampArchive` field. */
	pTimestampArchive?: ModelTypes["Datetime"] | undefined
};
	/** A connection to a list of `Session` values. */
["SessionsConnection"]: {
		/** A list of `Session` objects. */
	nodes: Array<ModelTypes["Session"]>,
	/** A list of edges which contains the `Session` and cursor to aid in pagination. */
	edges: Array<ModelTypes["SessionsEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: ModelTypes["PageInfo"],
	/** The count of *all* `Session` you could get from the connection. */
	totalCount: number
};
	["Session"]: {
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	ssId: string,
	ssData: string,
	ssUpdatedAt: ModelTypes["Datetime"],
	ssLifetime: ModelTypes["BigInt"],
	ssUser?: ModelTypes["BigInt"] | undefined,
	/** Reads a single `User` that is related to this `Session`. */
	userBySsUser?: ModelTypes["User"] | undefined
};
	/** A `Session` edge in the connection. */
["SessionsEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `Session` at the end of the edge. */
	node: ModelTypes["Session"]
};
	["SessionsOrderBy"]:SessionsOrderBy;
	/** A condition to be used against `Session` object types. All fields are tested for equality and combined with a logical and. */
["SessionCondition"]: {
	/** Checks for equality with the objects `ssId` field. */
	ssId?: string | undefined,
	/** Checks for equality with the objects `ssData` field. */
	ssData?: string | undefined,
	/** Checks for equality with the objects `ssUpdatedAt` field. */
	ssUpdatedAt?: ModelTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `ssLifetime` field. */
	ssLifetime?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `ssUser` field. */
	ssUser?: ModelTypes["BigInt"] | undefined
};
	["AkceItemsOrderBy"]:AkceItemsOrderBy;
	/** A condition to be used against `AkceItem` object types. All fields are tested
for equality and combined with a logical and. */
["AkceItemCondition"]: {
	/** Checks for equality with the objects `aiId` field. */
	aiId?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `aiIdRodic` field. */
	aiIdRodic?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `aiUser` field. */
	aiUser?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `aiRokNarozeni` field. */
	aiRokNarozeni?: number | undefined
};
	/** A connection to a list of `Dokumenty` values. */
["DokumentiesConnection"]: {
		/** A list of `Dokumenty` objects. */
	nodes: Array<ModelTypes["Dokumenty"]>,
	/** A list of edges which contains the `Dokumenty` and cursor to aid in pagination. */
	edges: Array<ModelTypes["DokumentiesEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: ModelTypes["PageInfo"],
	/** The count of *all* `Dokumenty` you could get from the connection. */
	totalCount: number
};
	["Dokumenty"]: {
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	dId: ModelTypes["BigInt"],
	dPath: string,
	dName: string,
	dFilename: string,
	dKategorie: number,
	dKdo: ModelTypes["BigInt"],
	dTimestamp?: ModelTypes["Datetime"] | undefined,
	/** Reads a single `User` that is related to this `Dokumenty`. */
	userByDKdo?: ModelTypes["User"] | undefined
};
	/** A `Dokumenty` edge in the connection. */
["DokumentiesEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `Dokumenty` at the end of the edge. */
	node: ModelTypes["Dokumenty"]
};
	["DokumentiesOrderBy"]:DokumentiesOrderBy;
	/** A condition to be used against `Dokumenty` object types. All fields are tested
for equality and combined with a logical and. */
["DokumentyCondition"]: {
	/** Checks for equality with the objects `dId` field. */
	dId?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `dPath` field. */
	dPath?: string | undefined,
	/** Checks for equality with the objects `dName` field. */
	dName?: string | undefined,
	/** Checks for equality with the objects `dFilename` field. */
	dFilename?: string | undefined,
	/** Checks for equality with the objects `dKategorie` field. */
	dKategorie?: number | undefined,
	/** Checks for equality with the objects `dKdo` field. */
	dKdo?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `dTimestamp` field. */
	dTimestamp?: ModelTypes["Datetime"] | undefined
};
	/** A connection to a list of `ParyNavrh` values. */
["ParyNavrhsConnection"]: {
		/** A list of `ParyNavrh` objects. */
	nodes: Array<ModelTypes["ParyNavrh"]>,
	/** A list of edges which contains the `ParyNavrh` and cursor to aid in pagination. */
	edges: Array<ModelTypes["ParyNavrhsEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: ModelTypes["PageInfo"],
	/** The count of *all* `ParyNavrh` you could get from the connection. */
	totalCount: number
};
	["ParyNavrh"]: {
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	pnId: ModelTypes["BigInt"],
	pnNavrhl: ModelTypes["BigInt"],
	pnPartner: ModelTypes["BigInt"],
	pnPartnerka: ModelTypes["BigInt"],
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnNavrhl?: ModelTypes["User"] | undefined,
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnPartner?: ModelTypes["User"] | undefined,
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnPartnerka?: ModelTypes["User"] | undefined
};
	/** A `ParyNavrh` edge in the connection. */
["ParyNavrhsEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `ParyNavrh` at the end of the edge. */
	node: ModelTypes["ParyNavrh"]
};
	["ParyNavrhsOrderBy"]:ParyNavrhsOrderBy;
	/** A condition to be used against `ParyNavrh` object types. All fields are tested
for equality and combined with a logical and. */
["ParyNavrhCondition"]: {
	/** Checks for equality with the objects `pnId` field. */
	pnId?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `pnNavrhl` field. */
	pnNavrhl?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `pnPartner` field. */
	pnPartner?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `pnPartnerka` field. */
	pnPartnerka?: ModelTypes["BigInt"] | undefined
};
	/** A connection to a list of `Upozorneni` values. */
["UpozornenisConnection"]: {
		/** A list of `Upozorneni` objects. */
	nodes: Array<ModelTypes["Upozorneni"]>,
	/** A list of edges which contains the `Upozorneni` and cursor to aid in pagination. */
	edges: Array<ModelTypes["UpozornenisEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: ModelTypes["PageInfo"],
	/** The count of *all* `Upozorneni` you could get from the connection. */
	totalCount: number
};
	/** A `Upozorneni` edge in the connection. */
["UpozornenisEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `Upozorneni` at the end of the edge. */
	node: ModelTypes["Upozorneni"]
};
	["UpozornenisOrderBy"]:UpozornenisOrderBy;
	/** A condition to be used against `Upozorneni` object types. All fields are tested
for equality and combined with a logical and. */
["UpozorneniCondition"]: {
	/** Checks for equality with the objects `upId` field. */
	upId?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `upKdo` field. */
	upKdo?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `upNadpis` field. */
	upNadpis?: string | undefined,
	/** Checks for equality with the objects `upText` field. */
	upText?: string | undefined,
	/** Checks for equality with the objects `upBarvy` field. */
	upBarvy?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `upLock` field. */
	upLock?: boolean | undefined,
	/** Checks for equality with the objects `upTimestamp` field. */
	upTimestamp?: ModelTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `upTimestampAdd` field. */
	upTimestampAdd?: ModelTypes["Datetime"] | undefined
};
	/** A `AkceItem` edge in the connection. */
["AkceItemsEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `AkceItem` at the end of the edge. */
	node: ModelTypes["AkceItem"]
};
	/** A `Akce` edge in the connection. */
["AkcesEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `Akce` at the end of the edge. */
	node: ModelTypes["Akce"]
};
	["AkcesOrderBy"]:AkcesOrderBy;
	/** A condition to be used against `Akce` object types. All fields are tested for equality and combined with a logical and. */
["AkceCondition"]: {
	/** Checks for equality with the objects `aId` field. */
	aId?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `aJmeno` field. */
	aJmeno?: string | undefined,
	/** Checks for equality with the objects `aKde` field. */
	aKde?: string | undefined,
	/** Checks for equality with the objects `aInfo` field. */
	aInfo?: string | undefined,
	/** Checks for equality with the objects `aOd` field. */
	aOd?: ModelTypes["Date"] | undefined,
	/** Checks for equality with the objects `aDo` field. */
	aDo?: ModelTypes["Date"] | undefined,
	/** Checks for equality with the objects `aKapacita` field. */
	aKapacita?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `aDokumenty` field. */
	aDokumenty?: string | undefined,
	/** Checks for equality with the objects `aTimestamp` field. */
	aTimestamp?: ModelTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `aLock` field. */
	aLock?: boolean | undefined,
	/** Checks for equality with the objects `aVisible` field. */
	aVisible?: boolean | undefined
};
	/** A connection to a list of `GalerieDir` values. */
["GalerieDirsConnection"]: {
		/** A list of `GalerieDir` objects. */
	nodes: Array<ModelTypes["GalerieDir"]>,
	/** A list of edges which contains the `GalerieDir` and cursor to aid in pagination. */
	edges: Array<ModelTypes["GalerieDirsEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: ModelTypes["PageInfo"],
	/** The count of *all* `GalerieDir` you could get from the connection. */
	totalCount: number
};
	/** A `GalerieDir` edge in the connection. */
["GalerieDirsEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `GalerieDir` at the end of the edge. */
	node: ModelTypes["GalerieDir"]
};
	["GalerieDirsOrderBy"]:GalerieDirsOrderBy;
	/** A condition to be used against `GalerieDir` object types. All fields are tested
for equality and combined with a logical and. */
["GalerieDirCondition"]: {
	/** Checks for equality with the objects `gdId` field. */
	gdId?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `gdIdRodic` field. */
	gdIdRodic?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `gdName` field. */
	gdName?: string | undefined,
	/** Checks for equality with the objects `gdLevel` field. */
	gdLevel?: number | undefined,
	/** Checks for equality with the objects `gdPath` field. */
	gdPath?: string | undefined,
	/** Checks for equality with the objects `gdHidden` field. */
	gdHidden?: boolean | undefined
};
	/** A connection to a list of `Member` values. */
["MembersConnection"]: {
		/** A list of `Member` objects. */
	nodes: Array<ModelTypes["Member"]>,
	/** A list of edges which contains the `Member` and cursor to aid in pagination. */
	edges: Array<ModelTypes["MembersEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: ModelTypes["PageInfo"],
	/** The count of *all* `Member` you could get from the connection. */
	totalCount: number
};
	["Member"]: {
		uId?: ModelTypes["BigInt"] | undefined,
	uLogin?: string | undefined,
	uPass?: string | undefined,
	uJmeno?: string | undefined,
	uPrijmeni?: string | undefined,
	uPohlavi?: string | undefined,
	uEmail?: string | undefined,
	uTelefon?: string | undefined,
	uNarozeni?: ModelTypes["Date"] | undefined,
	uRodneCislo?: string | undefined,
	uPoznamky?: string | undefined,
	uTimestamp?: ModelTypes["Datetime"] | undefined,
	uLevel?: number | undefined,
	uGroup?: ModelTypes["BigInt"] | undefined,
	uSkupina?: ModelTypes["BigInt"] | undefined,
	uDancer?: boolean | undefined,
	uBan?: boolean | undefined,
	uLock?: boolean | undefined,
	uConfirmed?: boolean | undefined,
	uSystem?: boolean | undefined,
	uStreet?: string | undefined,
	uConscriptionNumber?: string | undefined,
	uOrientationNumber?: string | undefined,
	uDistrict?: string | undefined,
	uCity?: string | undefined,
	uPostalCode?: string | undefined,
	uNationality?: string | undefined,
	uMemberSince?: ModelTypes["Datetime"] | undefined,
	uMemberUntil?: ModelTypes["Datetime"] | undefined,
	uCreatedAt?: ModelTypes["Datetime"] | undefined,
	uTeacher?: boolean | undefined,
	uGdprSignedAt?: ModelTypes["Datetime"] | undefined,
	sId?: ModelTypes["BigInt"] | undefined,
	sName?: string | undefined,
	paymentValid?: boolean | undefined
};
	/** A `Member` edge in the connection. */
["MembersEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `Member` at the end of the edge. */
	node: ModelTypes["Member"]
};
	["MembersOrderBy"]:MembersOrderBy;
	/** A condition to be used against `Member` object types. All fields are tested for equality and combined with a logical and. */
["MemberCondition"]: {
	/** Checks for equality with the objects `uId` field. */
	uId?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `uLogin` field. */
	uLogin?: string | undefined,
	/** Checks for equality with the objects `uPass` field. */
	uPass?: string | undefined,
	/** Checks for equality with the objects `uJmeno` field. */
	uJmeno?: string | undefined,
	/** Checks for equality with the objects `uPrijmeni` field. */
	uPrijmeni?: string | undefined,
	/** Checks for equality with the objects `uPohlavi` field. */
	uPohlavi?: string | undefined,
	/** Checks for equality with the objects `uEmail` field. */
	uEmail?: string | undefined,
	/** Checks for equality with the objects `uTelefon` field. */
	uTelefon?: string | undefined,
	/** Checks for equality with the objects `uNarozeni` field. */
	uNarozeni?: ModelTypes["Date"] | undefined,
	/** Checks for equality with the objects `uRodneCislo` field. */
	uRodneCislo?: string | undefined,
	/** Checks for equality with the objects `uPoznamky` field. */
	uPoznamky?: string | undefined,
	/** Checks for equality with the objects `uTimestamp` field. */
	uTimestamp?: ModelTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `uLevel` field. */
	uLevel?: number | undefined,
	/** Checks for equality with the objects `uGroup` field. */
	uGroup?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `uSkupina` field. */
	uSkupina?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `uDancer` field. */
	uDancer?: boolean | undefined,
	/** Checks for equality with the objects `uBan` field. */
	uBan?: boolean | undefined,
	/** Checks for equality with the objects `uLock` field. */
	uLock?: boolean | undefined,
	/** Checks for equality with the objects `uConfirmed` field. */
	uConfirmed?: boolean | undefined,
	/** Checks for equality with the objects `uSystem` field. */
	uSystem?: boolean | undefined,
	/** Checks for equality with the objects `uStreet` field. */
	uStreet?: string | undefined,
	/** Checks for equality with the objects `uConscriptionNumber` field. */
	uConscriptionNumber?: string | undefined,
	/** Checks for equality with the objects `uOrientationNumber` field. */
	uOrientationNumber?: string | undefined,
	/** Checks for equality with the objects `uDistrict` field. */
	uDistrict?: string | undefined,
	/** Checks for equality with the objects `uCity` field. */
	uCity?: string | undefined,
	/** Checks for equality with the objects `uPostalCode` field. */
	uPostalCode?: string | undefined,
	/** Checks for equality with the objects `uNationality` field. */
	uNationality?: string | undefined,
	/** Checks for equality with the objects `uMemberSince` field. */
	uMemberSince?: ModelTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `uMemberUntil` field. */
	uMemberUntil?: ModelTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `uCreatedAt` field. */
	uCreatedAt?: ModelTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `uTeacher` field. */
	uTeacher?: boolean | undefined,
	/** Checks for equality with the objects `uGdprSignedAt` field. */
	uGdprSignedAt?: ModelTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `sId` field. */
	sId?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `sName` field. */
	sName?: string | undefined,
	/** Checks for equality with the objects `paymentValid` field. */
	paymentValid?: boolean | undefined
};
	/** A connection to a list of `Page` values. */
["PagesConnection"]: {
		/** A list of `Page` objects. */
	nodes: Array<ModelTypes["Page"]>,
	/** A list of edges which contains the `Page` and cursor to aid in pagination. */
	edges: Array<ModelTypes["PagesEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: ModelTypes["PageInfo"],
	/** The count of *all* `Page` you could get from the connection. */
	totalCount: number
};
	["Page"]: {
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	id: number,
	url: string,
	content: ModelTypes["JSON"],
	createdAt: ModelTypes["Datetime"],
	updatedAt: ModelTypes["Datetime"],
	title: string
};
	/** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
["JSON"]:any;
	/** A `Page` edge in the connection. */
["PagesEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `Page` at the end of the edge. */
	node: ModelTypes["Page"]
};
	["PagesOrderBy"]:PagesOrderBy;
	/** A condition to be used against `Page` object types. All fields are tested for equality and combined with a logical and. */
["PageCondition"]: {
	/** Checks for equality with the objects `id` field. */
	id?: number | undefined,
	/** Checks for equality with the objects `url` field. */
	url?: string | undefined,
	/** Checks for equality with the objects `content` field. */
	content?: ModelTypes["JSON"] | undefined,
	/** Checks for equality with the objects `createdAt` field. */
	createdAt?: ModelTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `updatedAt` field. */
	updatedAt?: ModelTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `title` field. */
	title?: string | undefined
};
	/** A connection to a list of `PageRevision` values. */
["PageRevisionsConnection"]: {
		/** A list of `PageRevision` objects. */
	nodes: Array<ModelTypes["PageRevision"]>,
	/** A list of edges which contains the `PageRevision` and cursor to aid in pagination. */
	edges: Array<ModelTypes["PageRevisionsEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: ModelTypes["PageInfo"],
	/** The count of *all* `PageRevision` you could get from the connection. */
	totalCount: number
};
	["PageRevision"]: {
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	revNumber: number,
	revOperation: string,
	revTimestamp?: ModelTypes["Datetime"] | undefined,
	id: number,
	url: string,
	content: ModelTypes["JSON"],
	createdAt: ModelTypes["Datetime"],
	updatedAt: ModelTypes["Datetime"],
	title: string
};
	/** A `PageRevision` edge in the connection. */
["PageRevisionsEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `PageRevision` at the end of the edge. */
	node: ModelTypes["PageRevision"]
};
	["PageRevisionsOrderBy"]:PageRevisionsOrderBy;
	/** A condition to be used against `PageRevision` object types. All fields are
tested for equality and combined with a logical and. */
["PageRevisionCondition"]: {
	/** Checks for equality with the objects `revNumber` field. */
	revNumber?: number | undefined,
	/** Checks for equality with the objects `revOperation` field. */
	revOperation?: string | undefined,
	/** Checks for equality with the objects `revTimestamp` field. */
	revTimestamp?: ModelTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `id` field. */
	id?: number | undefined,
	/** Checks for equality with the objects `url` field. */
	url?: string | undefined,
	/** Checks for equality with the objects `content` field. */
	content?: ModelTypes["JSON"] | undefined,
	/** Checks for equality with the objects `createdAt` field. */
	createdAt?: ModelTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `updatedAt` field. */
	updatedAt?: ModelTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `title` field. */
	title?: string | undefined
};
	/** A connection to a list of `Parameter` values. */
["ParametersConnection"]: {
		/** A list of `Parameter` objects. */
	nodes: Array<ModelTypes["Parameter"]>,
	/** A list of edges which contains the `Parameter` and cursor to aid in pagination. */
	edges: Array<ModelTypes["ParametersEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: ModelTypes["PageInfo"],
	/** The count of *all* `Parameter` you could get from the connection. */
	totalCount: number
};
	["Parameter"]: {
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	paName: string,
	paValue: string
};
	/** A `Parameter` edge in the connection. */
["ParametersEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `Parameter` at the end of the edge. */
	node: ModelTypes["Parameter"]
};
	["ParametersOrderBy"]:ParametersOrderBy;
	/** A condition to be used against `Parameter` object types. All fields are tested
for equality and combined with a logical and. */
["ParameterCondition"]: {
	/** Checks for equality with the objects `paName` field. */
	paName?: string | undefined,
	/** Checks for equality with the objects `paValue` field. */
	paValue?: string | undefined
};
	/** A connection to a list of `Permission` values. */
["PermissionsConnection"]: {
		/** A list of `Permission` objects. */
	nodes: Array<ModelTypes["Permission"]>,
	/** A list of edges which contains the `Permission` and cursor to aid in pagination. */
	edges: Array<ModelTypes["PermissionsEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: ModelTypes["PageInfo"],
	/** The count of *all* `Permission` you could get from the connection. */
	totalCount: number
};
	/** A `Permission` edge in the connection. */
["PermissionsEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `Permission` at the end of the edge. */
	node: ModelTypes["Permission"]
};
	["PermissionsOrderBy"]:PermissionsOrderBy;
	/** A condition to be used against `Permission` object types. All fields are tested
for equality and combined with a logical and. */
["PermissionCondition"]: {
	/** Checks for equality with the objects `peId` field. */
	peId?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `peName` field. */
	peName?: string | undefined,
	/** Checks for equality with the objects `peDescription` field. */
	peDescription?: string | undefined,
	/** Checks for equality with the objects `peAkce` field. */
	peAkce?: number | undefined,
	/** Checks for equality with the objects `peAktuality` field. */
	peAktuality?: number | undefined,
	/** Checks for equality with the objects `peAnkety` field. */
	peAnkety?: number | undefined,
	/** Checks for equality with the objects `peDokumenty` field. */
	peDokumenty?: number | undefined,
	/** Checks for equality with the objects `peGalerie` field. */
	peGalerie?: number | undefined,
	/** Checks for equality with the objects `peInzerce` field. */
	peInzerce?: number | undefined,
	/** Checks for equality with the objects `peKonzole` field. */
	peKonzole?: number | undefined,
	/** Checks for equality with the objects `peNabidka` field. */
	peNabidka?: number | undefined,
	/** Checks for equality with the objects `peNastenka` field. */
	peNastenka?: number | undefined,
	/** Checks for equality with the objects `peNovinky` field. */
	peNovinky?: number | undefined,
	/** Checks for equality with the objects `pePary` field. */
	pePary?: number | undefined,
	/** Checks for equality with the objects `pePlatby` field. */
	pePlatby?: number | undefined,
	/** Checks for equality with the objects `pePermissions` field. */
	pePermissions?: number | undefined,
	/** Checks for equality with the objects `peRozpis` field. */
	peRozpis?: number | undefined,
	/** Checks for equality with the objects `peSkupiny` field. */
	peSkupiny?: number | undefined,
	/** Checks for equality with the objects `peUsers` field. */
	peUsers?: number | undefined,
	/** Checks for equality with the objects `peMain` field. */
	peMain?: number | undefined
};
	/** A connection to a list of `PlatbyCategory` values. */
["PlatbyCategoriesConnection"]: {
		/** A list of `PlatbyCategory` objects. */
	nodes: Array<ModelTypes["PlatbyCategory"]>,
	/** A list of edges which contains the `PlatbyCategory` and cursor to aid in pagination. */
	edges: Array<ModelTypes["PlatbyCategoriesEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: ModelTypes["PageInfo"],
	/** The count of *all* `PlatbyCategory` you could get from the connection. */
	totalCount: number
};
	/** A `PlatbyCategory` edge in the connection. */
["PlatbyCategoriesEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `PlatbyCategory` at the end of the edge. */
	node: ModelTypes["PlatbyCategory"]
};
	["PlatbyCategoriesOrderBy"]:PlatbyCategoriesOrderBy;
	/** A condition to be used against `PlatbyCategory` object types. All fields are
tested for equality and combined with a logical and. */
["PlatbyCategoryCondition"]: {
	/** Checks for equality with the objects `pcId` field. */
	pcId?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `pcName` field. */
	pcName?: string | undefined,
	/** Checks for equality with the objects `pcSymbol` field. */
	pcSymbol?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `pcAmount` field. */
	pcAmount?: ModelTypes["BigFloat"] | undefined,
	/** Checks for equality with the objects `pcDateDue` field. */
	pcDateDue?: ModelTypes["Date"] | undefined,
	/** Checks for equality with the objects `pcValidFrom` field. */
	pcValidFrom?: ModelTypes["Date"] | undefined,
	/** Checks for equality with the objects `pcValidTo` field. */
	pcValidTo?: ModelTypes["Date"] | undefined,
	/** Checks for equality with the objects `pcUseBase` field. */
	pcUseBase?: boolean | undefined,
	/** Checks for equality with the objects `pcUsePrefix` field. */
	pcUsePrefix?: boolean | undefined,
	/** Checks for equality with the objects `pcArchive` field. */
	pcArchive?: boolean | undefined,
	/** Checks for equality with the objects `pcVisible` field. */
	pcVisible?: boolean | undefined
};
	/** A connection to a list of `PlatbyGroup` values. */
["PlatbyGroupsConnection"]: {
		/** A list of `PlatbyGroup` objects. */
	nodes: Array<ModelTypes["PlatbyGroup"]>,
	/** A list of edges which contains the `PlatbyGroup` and cursor to aid in pagination. */
	edges: Array<ModelTypes["PlatbyGroupsEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: ModelTypes["PageInfo"],
	/** The count of *all* `PlatbyGroup` you could get from the connection. */
	totalCount: number
};
	/** A `PlatbyGroup` edge in the connection. */
["PlatbyGroupsEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `PlatbyGroup` at the end of the edge. */
	node: ModelTypes["PlatbyGroup"]
};
	["PlatbyGroupsOrderBy"]:PlatbyGroupsOrderBy;
	/** A condition to be used against `PlatbyGroup` object types. All fields are tested
for equality and combined with a logical and. */
["PlatbyGroupCondition"]: {
	/** Checks for equality with the objects `pgId` field. */
	pgId?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `pgType` field. */
	pgType?: ModelTypes["BigFloat"] | undefined,
	/** Checks for equality with the objects `pgName` field. */
	pgName?: string | undefined,
	/** Checks for equality with the objects `pgDescription` field. */
	pgDescription?: string | undefined,
	/** Checks for equality with the objects `pgBase` field. */
	pgBase?: ModelTypes["BigInt"] | undefined
};
	/** A connection to a list of `PlatbyRaw` values. */
["PlatbyRawsConnection"]: {
		/** A list of `PlatbyRaw` objects. */
	nodes: Array<ModelTypes["PlatbyRaw"]>,
	/** A list of edges which contains the `PlatbyRaw` and cursor to aid in pagination. */
	edges: Array<ModelTypes["PlatbyRawsEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: ModelTypes["PageInfo"],
	/** The count of *all* `PlatbyRaw` you could get from the connection. */
	totalCount: number
};
	/** A `PlatbyRaw` edge in the connection. */
["PlatbyRawsEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `PlatbyRaw` at the end of the edge. */
	node: ModelTypes["PlatbyRaw"]
};
	["PlatbyRawsOrderBy"]:PlatbyRawsOrderBy;
	/** A condition to be used against `PlatbyRaw` object types. All fields are tested
for equality and combined with a logical and. */
["PlatbyRawCondition"]: {
	/** Checks for equality with the objects `prId` field. */
	prId?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `prRaw` field. */
	prRaw?: string | undefined,
	/** Checks for equality with the objects `prHash` field. */
	prHash?: string | undefined,
	/** Checks for equality with the objects `prSorted` field. */
	prSorted?: boolean | undefined,
	/** Checks for equality with the objects `prDiscarded` field. */
	prDiscarded?: boolean | undefined
};
	/** A connection to a list of `Skupiny` values. */
["SkupiniesConnection"]: {
		/** A list of `Skupiny` objects. */
	nodes: Array<ModelTypes["Skupiny"]>,
	/** A list of edges which contains the `Skupiny` and cursor to aid in pagination. */
	edges: Array<ModelTypes["SkupiniesEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: ModelTypes["PageInfo"],
	/** The count of *all* `Skupiny` you could get from the connection. */
	totalCount: number
};
	/** A `Skupiny` edge in the connection. */
["SkupiniesEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `Skupiny` at the end of the edge. */
	node: ModelTypes["Skupiny"]
};
	["SkupiniesOrderBy"]:SkupiniesOrderBy;
	/** A condition to be used against `Skupiny` object types. All fields are tested for equality and combined with a logical and. */
["SkupinyCondition"]: {
	/** Checks for equality with the objects `sId` field. */
	sId?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `sName` field. */
	sName?: string | undefined,
	/** Checks for equality with the objects `sDescription` field. */
	sDescription?: string | undefined,
	/** Checks for equality with the objects `sColorRgb` field. */
	sColorRgb?: string | undefined,
	/** Checks for equality with the objects `sColorText` field. */
	sColorText?: string | undefined,
	/** Checks for equality with the objects `sLocation` field. */
	sLocation?: string | undefined,
	/** Checks for equality with the objects `sVisible` field. */
	sVisible?: boolean | undefined
};
	/** A connection to a list of `UsersSkupiny` values. */
["UsersSkupiniesConnection"]: {
		/** A list of `UsersSkupiny` objects. */
	nodes: Array<ModelTypes["UsersSkupiny"]>,
	/** A list of edges which contains the `UsersSkupiny` and cursor to aid in pagination. */
	edges: Array<ModelTypes["UsersSkupiniesEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: ModelTypes["PageInfo"],
	/** The count of *all* `UsersSkupiny` you could get from the connection. */
	totalCount: number
};
	["UsersSkupiny"]: {
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	usId: ModelTypes["BigInt"],
	usColor: string,
	usPlatbaMesic: ModelTypes["BigInt"],
	usPlatbaCtvrtrok: ModelTypes["BigInt"],
	usPlatbaPulrok: ModelTypes["BigInt"],
	usPopis: string
};
	/** A `UsersSkupiny` edge in the connection. */
["UsersSkupiniesEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `UsersSkupiny` at the end of the edge. */
	node: ModelTypes["UsersSkupiny"]
};
	["UsersSkupiniesOrderBy"]:UsersSkupiniesOrderBy;
	/** A condition to be used against `UsersSkupiny` object types. All fields are
tested for equality and combined with a logical and. */
["UsersSkupinyCondition"]: {
	/** Checks for equality with the objects `usId` field. */
	usId?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `usColor` field. */
	usColor?: string | undefined,
	/** Checks for equality with the objects `usPlatbaMesic` field. */
	usPlatbaMesic?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `usPlatbaCtvrtrok` field. */
	usPlatbaCtvrtrok?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `usPlatbaPulrok` field. */
	usPlatbaPulrok?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `usPopis` field. */
	usPopis?: string | undefined
};
	/** A connection to a list of `Video` values. */
["VideosConnection"]: {
		/** A list of `Video` objects. */
	nodes: Array<ModelTypes["Video"]>,
	/** A list of edges which contains the `Video` and cursor to aid in pagination. */
	edges: Array<ModelTypes["VideosEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: ModelTypes["PageInfo"],
	/** The count of *all* `Video` you could get from the connection. */
	totalCount: number
};
	["Video"]: {
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	vId: ModelTypes["BigInt"],
	vUri: string,
	vTitle: string,
	vAuthor: string,
	vDescription: string,
	vPlaylist?: string | undefined,
	vCreatedAt: ModelTypes["Datetime"],
	vUpdatedAt: ModelTypes["Datetime"]
};
	/** A `Video` edge in the connection. */
["VideosEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `Video` at the end of the edge. */
	node: ModelTypes["Video"]
};
	["VideosOrderBy"]:VideosOrderBy;
	/** A condition to be used against `Video` object types. All fields are tested for equality and combined with a logical and. */
["VideoCondition"]: {
	/** Checks for equality with the objects `vId` field. */
	vId?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `vUri` field. */
	vUri?: string | undefined,
	/** Checks for equality with the objects `vTitle` field. */
	vTitle?: string | undefined,
	/** Checks for equality with the objects `vAuthor` field. */
	vAuthor?: string | undefined,
	/** Checks for equality with the objects `vDescription` field. */
	vDescription?: string | undefined,
	/** Checks for equality with the objects `vPlaylist` field. */
	vPlaylist?: string | undefined,
	/** Checks for equality with the objects `vCreatedAt` field. */
	vCreatedAt?: ModelTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `vUpdatedAt` field. */
	vUpdatedAt?: ModelTypes["Datetime"] | undefined
};
	/** A connection to a list of `VideoList` values. */
["VideoListsConnection"]: {
		/** A list of `VideoList` objects. */
	nodes: Array<ModelTypes["VideoList"]>,
	/** A list of edges which contains the `VideoList` and cursor to aid in pagination. */
	edges: Array<ModelTypes["VideoListsEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: ModelTypes["PageInfo"],
	/** The count of *all* `VideoList` you could get from the connection. */
	totalCount: number
};
	["VideoList"]: {
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	vlId: ModelTypes["BigInt"],
	vlUrl: string,
	vlTitle: string,
	vlDescription: string,
	vlCount: ModelTypes["BigInt"],
	vlCreatedAt: ModelTypes["Datetime"],
	vlLastChecked?: ModelTypes["Datetime"] | undefined
};
	/** A `VideoList` edge in the connection. */
["VideoListsEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `VideoList` at the end of the edge. */
	node: ModelTypes["VideoList"]
};
	["VideoListsOrderBy"]:VideoListsOrderBy;
	/** A condition to be used against `VideoList` object types. All fields are tested
for equality and combined with a logical and. */
["VideoListCondition"]: {
	/** Checks for equality with the objects `vlId` field. */
	vlId?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `vlUrl` field. */
	vlUrl?: string | undefined,
	/** Checks for equality with the objects `vlTitle` field. */
	vlTitle?: string | undefined,
	/** Checks for equality with the objects `vlDescription` field. */
	vlDescription?: string | undefined,
	/** Checks for equality with the objects `vlCount` field. */
	vlCount?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `vlCreatedAt` field. */
	vlCreatedAt?: ModelTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `vlLastChecked` field. */
	vlLastChecked?: ModelTypes["Datetime"] | undefined
};
	/** A connection to a list of `VideoSource` values. */
["VideoSourcesConnection"]: {
		/** A list of `VideoSource` objects. */
	nodes: Array<ModelTypes["VideoSource"]>,
	/** A list of edges which contains the `VideoSource` and cursor to aid in pagination. */
	edges: Array<ModelTypes["VideoSourcesEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: ModelTypes["PageInfo"],
	/** The count of *all* `VideoSource` you could get from the connection. */
	totalCount: number
};
	["VideoSource"]: {
		/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	vsId: ModelTypes["BigInt"],
	vsUrl: string,
	vsTitle?: string | undefined,
	vsDescription?: string | undefined,
	vsCreatedAt: ModelTypes["Datetime"],
	vsLastChecked?: ModelTypes["Datetime"] | undefined
};
	/** A `VideoSource` edge in the connection. */
["VideoSourcesEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `VideoSource` at the end of the edge. */
	node: ModelTypes["VideoSource"]
};
	["VideoSourcesOrderBy"]:VideoSourcesOrderBy;
	/** A condition to be used against `VideoSource` object types. All fields are tested
for equality and combined with a logical and. */
["VideoSourceCondition"]: {
	/** Checks for equality with the objects `vsId` field. */
	vsId?: ModelTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `vsUrl` field. */
	vsUrl?: string | undefined,
	/** Checks for equality with the objects `vsTitle` field. */
	vsTitle?: string | undefined,
	/** Checks for equality with the objects `vsDescription` field. */
	vsDescription?: string | undefined,
	/** Checks for equality with the objects `vsCreatedAt` field. */
	vsCreatedAt?: ModelTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `vsLastChecked` field. */
	vsLastChecked?: ModelTypes["Datetime"] | undefined
};
	/** A connection to a list of `ActiveProspectsRecord` values. */
["ActiveProspectsConnection"]: {
		/** A list of `ActiveProspectsRecord` objects. */
	nodes: Array<ModelTypes["ActiveProspectsRecord"]>,
	/** A list of edges which contains the `ActiveProspectsRecord` and cursor to aid in pagination. */
	edges: Array<ModelTypes["ActiveProspectEdge"]>,
	/** The count of *all* `ActiveProspectsRecord` you could get from the connection. */
	totalCount: number
};
	/** The return type of our `activeProspects` query. */
["ActiveProspectsRecord"]: {
		id?: ModelTypes["BigInt"] | undefined,
	data?: ModelTypes["ProspectDatum"] | undefined,
	cohort?: ModelTypes["CrmCohort"] | undefined,
	updatedAt?: ModelTypes["Datetime"] | undefined
};
	["ProspectDatum"]: {
		name?: string | undefined,
	surname?: string | undefined,
	email?: string | undefined,
	phone?: string | undefined,
	yearofbirth?: string | undefined
};
	["CrmCohort"]:CrmCohort;
	/** A `ActiveProspectsRecord` edge in the connection. */
["ActiveProspectEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `ActiveProspectsRecord` at the end of the edge. */
	node: ModelTypes["ActiveProspectsRecord"]
};
	/** A connection to a list of `BigInt` values. */
["CurrentCoupleIdsConnection"]: {
		/** A list of `BigInt` objects. */
	nodes: Array<ModelTypes["BigInt"] | undefined>,
	/** A list of edges which contains the `BigInt` and cursor to aid in pagination. */
	edges: Array<ModelTypes["CurrentCoupleIdEdge"]>,
	/** The count of *all* `BigInt` you could get from the connection. */
	totalCount: number
};
	/** A `BigInt` edge in the connection. */
["CurrentCoupleIdEdge"]: {
		/** A cursor for use in pagination. */
	cursor?: ModelTypes["Cursor"] | undefined,
	/** The `BigInt` at the end of the edge. */
	node?: ModelTypes["BigInt"] | undefined
};
	/** The root mutation type which contains root level fields which mutate data. */
["Mutation"]: {
		/** Creates a single `Akce`. */
	createAkce?: ModelTypes["CreateAkcePayload"] | undefined,
	/** Creates a single `AkceItem`. */
	createAkceItem?: ModelTypes["CreateAkceItemPayload"] | undefined,
	/** Creates a single `Aktuality`. */
	createAktuality?: ModelTypes["CreateAktualityPayload"] | undefined,
	/** Creates a single `Dokumenty`. */
	createDokumenty?: ModelTypes["CreateDokumentyPayload"] | undefined,
	/** Creates a single `GalerieDir`. */
	createGalerieDir?: ModelTypes["CreateGalerieDirPayload"] | undefined,
	/** Creates a single `GalerieFoto`. */
	createGalerieFoto?: ModelTypes["CreateGalerieFotoPayload"] | undefined,
	/** Creates a single `Nabidka`. */
	createNabidka?: ModelTypes["CreateNabidkaPayload"] | undefined,
	/** Creates a single `NabidkaItem`. */
	createNabidkaItem?: ModelTypes["CreateNabidkaItemPayload"] | undefined,
	/** Creates a single `Page`. */
	createPage?: ModelTypes["CreatePagePayload"] | undefined,
	/** Creates a single `Parameter`. */
	createParameter?: ModelTypes["CreateParameterPayload"] | undefined,
	/** Creates a single `Pary`. */
	createPary?: ModelTypes["CreateParyPayload"] | undefined,
	/** Creates a single `ParyNavrh`. */
	createParyNavrh?: ModelTypes["CreateParyNavrhPayload"] | undefined,
	/** Creates a single `Permission`. */
	createPermission?: ModelTypes["CreatePermissionPayload"] | undefined,
	/** Creates a single `PlatbyCategory`. */
	createPlatbyCategory?: ModelTypes["CreatePlatbyCategoryPayload"] | undefined,
	/** Creates a single `PlatbyCategoryGroup`. */
	createPlatbyCategoryGroup?: ModelTypes["CreatePlatbyCategoryGroupPayload"] | undefined,
	/** Creates a single `PlatbyGroup`. */
	createPlatbyGroup?: ModelTypes["CreatePlatbyGroupPayload"] | undefined,
	/** Creates a single `PlatbyGroupSkupina`. */
	createPlatbyGroupSkupina?: ModelTypes["CreatePlatbyGroupSkupinaPayload"] | undefined,
	/** Creates a single `PlatbyItem`. */
	createPlatbyItem?: ModelTypes["CreatePlatbyItemPayload"] | undefined,
	/** Creates a single `PlatbyRaw`. */
	createPlatbyRaw?: ModelTypes["CreatePlatbyRawPayload"] | undefined,
	/** Creates a single `Rozpi`. */
	createRozpi?: ModelTypes["CreateRozpiPayload"] | undefined,
	/** Creates a single `RozpisItem`. */
	createRozpisItem?: ModelTypes["CreateRozpisItemPayload"] | undefined,
	/** Creates a single `Session`. */
	createSession?: ModelTypes["CreateSessionPayload"] | undefined,
	/** Creates a single `Skupiny`. */
	createSkupiny?: ModelTypes["CreateSkupinyPayload"] | undefined,
	/** Creates a single `Upozorneni`. */
	createUpozorneni?: ModelTypes["CreateUpozorneniPayload"] | undefined,
	/** Creates a single `UpozorneniSkupiny`. */
	createUpozorneniSkupiny?: ModelTypes["CreateUpozorneniSkupinyPayload"] | undefined,
	/** Creates a single `User`. */
	createUser?: ModelTypes["CreateUserPayload"] | undefined,
	/** Creates a single `UsersSkupiny`. */
	createUsersSkupiny?: ModelTypes["CreateUsersSkupinyPayload"] | undefined,
	/** Creates a single `Video`. */
	createVideo?: ModelTypes["CreateVideoPayload"] | undefined,
	/** Creates a single `VideoList`. */
	createVideoList?: ModelTypes["CreateVideoListPayload"] | undefined,
	/** Creates a single `VideoSource`. */
	createVideoSource?: ModelTypes["CreateVideoSourcePayload"] | undefined,
	/** Updates a single `Akce` using its globally unique id and a patch. */
	updateAkceByNodeId?: ModelTypes["UpdateAkcePayload"] | undefined,
	/** Updates a single `Akce` using a unique key and a patch. */
	updateAkce?: ModelTypes["UpdateAkcePayload"] | undefined,
	/** Updates a single `AkceItem` using its globally unique id and a patch. */
	updateAkceItemByNodeId?: ModelTypes["UpdateAkceItemPayload"] | undefined,
	/** Updates a single `AkceItem` using a unique key and a patch. */
	updateAkceItem?: ModelTypes["UpdateAkceItemPayload"] | undefined,
	/** Updates a single `Aktuality` using its globally unique id and a patch. */
	updateAktualityByNodeId?: ModelTypes["UpdateAktualityPayload"] | undefined,
	/** Updates a single `Aktuality` using a unique key and a patch. */
	updateAktuality?: ModelTypes["UpdateAktualityPayload"] | undefined,
	/** Updates a single `Dokumenty` using its globally unique id and a patch. */
	updateDokumentyByNodeId?: ModelTypes["UpdateDokumentyPayload"] | undefined,
	/** Updates a single `Dokumenty` using a unique key and a patch. */
	updateDokumenty?: ModelTypes["UpdateDokumentyPayload"] | undefined,
	/** Updates a single `GalerieDir` using its globally unique id and a patch. */
	updateGalerieDirByNodeId?: ModelTypes["UpdateGalerieDirPayload"] | undefined,
	/** Updates a single `GalerieDir` using a unique key and a patch. */
	updateGalerieDir?: ModelTypes["UpdateGalerieDirPayload"] | undefined,
	/** Updates a single `GalerieFoto` using its globally unique id and a patch. */
	updateGalerieFotoByNodeId?: ModelTypes["UpdateGalerieFotoPayload"] | undefined,
	/** Updates a single `GalerieFoto` using a unique key and a patch. */
	updateGalerieFoto?: ModelTypes["UpdateGalerieFotoPayload"] | undefined,
	/** Updates a single `Nabidka` using its globally unique id and a patch. */
	updateNabidkaByNodeId?: ModelTypes["UpdateNabidkaPayload"] | undefined,
	/** Updates a single `Nabidka` using a unique key and a patch. */
	updateNabidka?: ModelTypes["UpdateNabidkaPayload"] | undefined,
	/** Updates a single `NabidkaItem` using its globally unique id and a patch. */
	updateNabidkaItemByNodeId?: ModelTypes["UpdateNabidkaItemPayload"] | undefined,
	/** Updates a single `NabidkaItem` using a unique key and a patch. */
	updateNabidkaItem?: ModelTypes["UpdateNabidkaItemPayload"] | undefined,
	/** Updates a single `Page` using its globally unique id and a patch. */
	updatePageByNodeId?: ModelTypes["UpdatePagePayload"] | undefined,
	/** Updates a single `Page` using a unique key and a patch. */
	updatePage?: ModelTypes["UpdatePagePayload"] | undefined,
	/** Updates a single `Page` using a unique key and a patch. */
	updatePageByUrl?: ModelTypes["UpdatePagePayload"] | undefined,
	/** Updates a single `Parameter` using its globally unique id and a patch. */
	updateParameterByNodeId?: ModelTypes["UpdateParameterPayload"] | undefined,
	/** Updates a single `Parameter` using a unique key and a patch. */
	updateParameter?: ModelTypes["UpdateParameterPayload"] | undefined,
	/** Updates a single `Pary` using its globally unique id and a patch. */
	updateParyByNodeId?: ModelTypes["UpdateParyPayload"] | undefined,
	/** Updates a single `Pary` using a unique key and a patch. */
	updatePary?: ModelTypes["UpdateParyPayload"] | undefined,
	/** Updates a single `ParyNavrh` using its globally unique id and a patch. */
	updateParyNavrhByNodeId?: ModelTypes["UpdateParyNavrhPayload"] | undefined,
	/** Updates a single `ParyNavrh` using a unique key and a patch. */
	updateParyNavrh?: ModelTypes["UpdateParyNavrhPayload"] | undefined,
	/** Updates a single `Permission` using its globally unique id and a patch. */
	updatePermissionByNodeId?: ModelTypes["UpdatePermissionPayload"] | undefined,
	/** Updates a single `Permission` using a unique key and a patch. */
	updatePermission?: ModelTypes["UpdatePermissionPayload"] | undefined,
	/** Updates a single `PlatbyCategory` using its globally unique id and a patch. */
	updatePlatbyCategoryByNodeId?: ModelTypes["UpdatePlatbyCategoryPayload"] | undefined,
	/** Updates a single `PlatbyCategory` using a unique key and a patch. */
	updatePlatbyCategory?: ModelTypes["UpdatePlatbyCategoryPayload"] | undefined,
	/** Updates a single `PlatbyCategoryGroup` using its globally unique id and a patch. */
	updatePlatbyCategoryGroupByNodeId?: ModelTypes["UpdatePlatbyCategoryGroupPayload"] | undefined,
	/** Updates a single `PlatbyCategoryGroup` using a unique key and a patch. */
	updatePlatbyCategoryGroup?: ModelTypes["UpdatePlatbyCategoryGroupPayload"] | undefined,
	/** Updates a single `PlatbyGroup` using its globally unique id and a patch. */
	updatePlatbyGroupByNodeId?: ModelTypes["UpdatePlatbyGroupPayload"] | undefined,
	/** Updates a single `PlatbyGroup` using a unique key and a patch. */
	updatePlatbyGroup?: ModelTypes["UpdatePlatbyGroupPayload"] | undefined,
	/** Updates a single `PlatbyGroupSkupina` using its globally unique id and a patch. */
	updatePlatbyGroupSkupinaByNodeId?: ModelTypes["UpdatePlatbyGroupSkupinaPayload"] | undefined,
	/** Updates a single `PlatbyGroupSkupina` using a unique key and a patch. */
	updatePlatbyGroupSkupina?: ModelTypes["UpdatePlatbyGroupSkupinaPayload"] | undefined,
	/** Updates a single `PlatbyItem` using its globally unique id and a patch. */
	updatePlatbyItemByNodeId?: ModelTypes["UpdatePlatbyItemPayload"] | undefined,
	/** Updates a single `PlatbyItem` using a unique key and a patch. */
	updatePlatbyItem?: ModelTypes["UpdatePlatbyItemPayload"] | undefined,
	/** Updates a single `PlatbyRaw` using its globally unique id and a patch. */
	updatePlatbyRawByNodeId?: ModelTypes["UpdatePlatbyRawPayload"] | undefined,
	/** Updates a single `PlatbyRaw` using a unique key and a patch. */
	updatePlatbyRaw?: ModelTypes["UpdatePlatbyRawPayload"] | undefined,
	/** Updates a single `Rozpi` using its globally unique id and a patch. */
	updateRozpiByNodeId?: ModelTypes["UpdateRozpiPayload"] | undefined,
	/** Updates a single `Rozpi` using a unique key and a patch. */
	updateRozpi?: ModelTypes["UpdateRozpiPayload"] | undefined,
	/** Updates a single `RozpisItem` using its globally unique id and a patch. */
	updateRozpisItemByNodeId?: ModelTypes["UpdateRozpisItemPayload"] | undefined,
	/** Updates a single `RozpisItem` using a unique key and a patch. */
	updateRozpisItem?: ModelTypes["UpdateRozpisItemPayload"] | undefined,
	/** Updates a single `Session` using its globally unique id and a patch. */
	updateSessionByNodeId?: ModelTypes["UpdateSessionPayload"] | undefined,
	/** Updates a single `Session` using a unique key and a patch. */
	updateSession?: ModelTypes["UpdateSessionPayload"] | undefined,
	/** Updates a single `Skupiny` using its globally unique id and a patch. */
	updateSkupinyByNodeId?: ModelTypes["UpdateSkupinyPayload"] | undefined,
	/** Updates a single `Skupiny` using a unique key and a patch. */
	updateSkupiny?: ModelTypes["UpdateSkupinyPayload"] | undefined,
	/** Updates a single `Upozorneni` using its globally unique id and a patch. */
	updateUpozorneniByNodeId?: ModelTypes["UpdateUpozorneniPayload"] | undefined,
	/** Updates a single `Upozorneni` using a unique key and a patch. */
	updateUpozorneni?: ModelTypes["UpdateUpozorneniPayload"] | undefined,
	/** Updates a single `UpozorneniSkupiny` using its globally unique id and a patch. */
	updateUpozorneniSkupinyByNodeId?: ModelTypes["UpdateUpozorneniSkupinyPayload"] | undefined,
	/** Updates a single `UpozorneniSkupiny` using a unique key and a patch. */
	updateUpozorneniSkupiny?: ModelTypes["UpdateUpozorneniSkupinyPayload"] | undefined,
	/** Updates a single `User` using its globally unique id and a patch. */
	updateUserByNodeId?: ModelTypes["UpdateUserPayload"] | undefined,
	/** Updates a single `User` using a unique key and a patch. */
	updateUser?: ModelTypes["UpdateUserPayload"] | undefined,
	/** Updates a single `UsersSkupiny` using its globally unique id and a patch. */
	updateUsersSkupinyByNodeId?: ModelTypes["UpdateUsersSkupinyPayload"] | undefined,
	/** Updates a single `UsersSkupiny` using a unique key and a patch. */
	updateUsersSkupiny?: ModelTypes["UpdateUsersSkupinyPayload"] | undefined,
	/** Updates a single `Video` using its globally unique id and a patch. */
	updateVideoByNodeId?: ModelTypes["UpdateVideoPayload"] | undefined,
	/** Updates a single `Video` using a unique key and a patch. */
	updateVideo?: ModelTypes["UpdateVideoPayload"] | undefined,
	/** Updates a single `VideoList` using its globally unique id and a patch. */
	updateVideoListByNodeId?: ModelTypes["UpdateVideoListPayload"] | undefined,
	/** Updates a single `VideoList` using a unique key and a patch. */
	updateVideoList?: ModelTypes["UpdateVideoListPayload"] | undefined,
	/** Updates a single `VideoSource` using its globally unique id and a patch. */
	updateVideoSourceByNodeId?: ModelTypes["UpdateVideoSourcePayload"] | undefined,
	/** Updates a single `VideoSource` using a unique key and a patch. */
	updateVideoSource?: ModelTypes["UpdateVideoSourcePayload"] | undefined,
	/** Deletes a single `Akce` using its globally unique id. */
	deleteAkceByNodeId?: ModelTypes["DeleteAkcePayload"] | undefined,
	/** Deletes a single `Akce` using a unique key. */
	deleteAkce?: ModelTypes["DeleteAkcePayload"] | undefined,
	/** Deletes a single `AkceItem` using its globally unique id. */
	deleteAkceItemByNodeId?: ModelTypes["DeleteAkceItemPayload"] | undefined,
	/** Deletes a single `AkceItem` using a unique key. */
	deleteAkceItem?: ModelTypes["DeleteAkceItemPayload"] | undefined,
	/** Deletes a single `Aktuality` using its globally unique id. */
	deleteAktualityByNodeId?: ModelTypes["DeleteAktualityPayload"] | undefined,
	/** Deletes a single `Aktuality` using a unique key. */
	deleteAktuality?: ModelTypes["DeleteAktualityPayload"] | undefined,
	/** Deletes a single `Dokumenty` using its globally unique id. */
	deleteDokumentyByNodeId?: ModelTypes["DeleteDokumentyPayload"] | undefined,
	/** Deletes a single `Dokumenty` using a unique key. */
	deleteDokumenty?: ModelTypes["DeleteDokumentyPayload"] | undefined,
	/** Deletes a single `GalerieDir` using its globally unique id. */
	deleteGalerieDirByNodeId?: ModelTypes["DeleteGalerieDirPayload"] | undefined,
	/** Deletes a single `GalerieDir` using a unique key. */
	deleteGalerieDir?: ModelTypes["DeleteGalerieDirPayload"] | undefined,
	/** Deletes a single `GalerieFoto` using its globally unique id. */
	deleteGalerieFotoByNodeId?: ModelTypes["DeleteGalerieFotoPayload"] | undefined,
	/** Deletes a single `GalerieFoto` using a unique key. */
	deleteGalerieFoto?: ModelTypes["DeleteGalerieFotoPayload"] | undefined,
	/** Deletes a single `Nabidka` using its globally unique id. */
	deleteNabidkaByNodeId?: ModelTypes["DeleteNabidkaPayload"] | undefined,
	/** Deletes a single `Nabidka` using a unique key. */
	deleteNabidka?: ModelTypes["DeleteNabidkaPayload"] | undefined,
	/** Deletes a single `NabidkaItem` using its globally unique id. */
	deleteNabidkaItemByNodeId?: ModelTypes["DeleteNabidkaItemPayload"] | undefined,
	/** Deletes a single `NabidkaItem` using a unique key. */
	deleteNabidkaItem?: ModelTypes["DeleteNabidkaItemPayload"] | undefined,
	/** Deletes a single `Parameter` using its globally unique id. */
	deleteParameterByNodeId?: ModelTypes["DeleteParameterPayload"] | undefined,
	/** Deletes a single `Parameter` using a unique key. */
	deleteParameter?: ModelTypes["DeleteParameterPayload"] | undefined,
	/** Deletes a single `Pary` using its globally unique id. */
	deleteParyByNodeId?: ModelTypes["DeleteParyPayload"] | undefined,
	/** Deletes a single `Pary` using a unique key. */
	deletePary?: ModelTypes["DeleteParyPayload"] | undefined,
	/** Deletes a single `ParyNavrh` using its globally unique id. */
	deleteParyNavrhByNodeId?: ModelTypes["DeleteParyNavrhPayload"] | undefined,
	/** Deletes a single `ParyNavrh` using a unique key. */
	deleteParyNavrh?: ModelTypes["DeleteParyNavrhPayload"] | undefined,
	/** Deletes a single `Permission` using its globally unique id. */
	deletePermissionByNodeId?: ModelTypes["DeletePermissionPayload"] | undefined,
	/** Deletes a single `Permission` using a unique key. */
	deletePermission?: ModelTypes["DeletePermissionPayload"] | undefined,
	/** Deletes a single `PlatbyCategory` using its globally unique id. */
	deletePlatbyCategoryByNodeId?: ModelTypes["DeletePlatbyCategoryPayload"] | undefined,
	/** Deletes a single `PlatbyCategory` using a unique key. */
	deletePlatbyCategory?: ModelTypes["DeletePlatbyCategoryPayload"] | undefined,
	/** Deletes a single `PlatbyCategoryGroup` using its globally unique id. */
	deletePlatbyCategoryGroupByNodeId?: ModelTypes["DeletePlatbyCategoryGroupPayload"] | undefined,
	/** Deletes a single `PlatbyCategoryGroup` using a unique key. */
	deletePlatbyCategoryGroup?: ModelTypes["DeletePlatbyCategoryGroupPayload"] | undefined,
	/** Deletes a single `PlatbyGroup` using its globally unique id. */
	deletePlatbyGroupByNodeId?: ModelTypes["DeletePlatbyGroupPayload"] | undefined,
	/** Deletes a single `PlatbyGroup` using a unique key. */
	deletePlatbyGroup?: ModelTypes["DeletePlatbyGroupPayload"] | undefined,
	/** Deletes a single `PlatbyGroupSkupina` using its globally unique id. */
	deletePlatbyGroupSkupinaByNodeId?: ModelTypes["DeletePlatbyGroupSkupinaPayload"] | undefined,
	/** Deletes a single `PlatbyGroupSkupina` using a unique key. */
	deletePlatbyGroupSkupina?: ModelTypes["DeletePlatbyGroupSkupinaPayload"] | undefined,
	/** Deletes a single `PlatbyItem` using its globally unique id. */
	deletePlatbyItemByNodeId?: ModelTypes["DeletePlatbyItemPayload"] | undefined,
	/** Deletes a single `PlatbyItem` using a unique key. */
	deletePlatbyItem?: ModelTypes["DeletePlatbyItemPayload"] | undefined,
	/** Deletes a single `PlatbyRaw` using its globally unique id. */
	deletePlatbyRawByNodeId?: ModelTypes["DeletePlatbyRawPayload"] | undefined,
	/** Deletes a single `PlatbyRaw` using a unique key. */
	deletePlatbyRaw?: ModelTypes["DeletePlatbyRawPayload"] | undefined,
	/** Deletes a single `Rozpi` using its globally unique id. */
	deleteRozpiByNodeId?: ModelTypes["DeleteRozpiPayload"] | undefined,
	/** Deletes a single `Rozpi` using a unique key. */
	deleteRozpi?: ModelTypes["DeleteRozpiPayload"] | undefined,
	/** Deletes a single `RozpisItem` using its globally unique id. */
	deleteRozpisItemByNodeId?: ModelTypes["DeleteRozpisItemPayload"] | undefined,
	/** Deletes a single `RozpisItem` using a unique key. */
	deleteRozpisItem?: ModelTypes["DeleteRozpisItemPayload"] | undefined,
	/** Deletes a single `Session` using its globally unique id. */
	deleteSessionByNodeId?: ModelTypes["DeleteSessionPayload"] | undefined,
	/** Deletes a single `Session` using a unique key. */
	deleteSession?: ModelTypes["DeleteSessionPayload"] | undefined,
	/** Deletes a single `Skupiny` using its globally unique id. */
	deleteSkupinyByNodeId?: ModelTypes["DeleteSkupinyPayload"] | undefined,
	/** Deletes a single `Skupiny` using a unique key. */
	deleteSkupiny?: ModelTypes["DeleteSkupinyPayload"] | undefined,
	/** Deletes a single `Upozorneni` using its globally unique id. */
	deleteUpozorneniByNodeId?: ModelTypes["DeleteUpozorneniPayload"] | undefined,
	/** Deletes a single `Upozorneni` using a unique key. */
	deleteUpozorneni?: ModelTypes["DeleteUpozorneniPayload"] | undefined,
	/** Deletes a single `UpozorneniSkupiny` using its globally unique id. */
	deleteUpozorneniSkupinyByNodeId?: ModelTypes["DeleteUpozorneniSkupinyPayload"] | undefined,
	/** Deletes a single `UpozorneniSkupiny` using a unique key. */
	deleteUpozorneniSkupiny?: ModelTypes["DeleteUpozorneniSkupinyPayload"] | undefined,
	/** Deletes a single `User` using its globally unique id. */
	deleteUserByNodeId?: ModelTypes["DeleteUserPayload"] | undefined,
	/** Deletes a single `User` using a unique key. */
	deleteUser?: ModelTypes["DeleteUserPayload"] | undefined,
	/** Deletes a single `UsersSkupiny` using its globally unique id. */
	deleteUsersSkupinyByNodeId?: ModelTypes["DeleteUsersSkupinyPayload"] | undefined,
	/** Deletes a single `UsersSkupiny` using a unique key. */
	deleteUsersSkupiny?: ModelTypes["DeleteUsersSkupinyPayload"] | undefined,
	/** Deletes a single `Video` using its globally unique id. */
	deleteVideoByNodeId?: ModelTypes["DeleteVideoPayload"] | undefined,
	/** Deletes a single `Video` using a unique key. */
	deleteVideo?: ModelTypes["DeleteVideoPayload"] | undefined,
	/** Deletes a single `VideoList` using its globally unique id. */
	deleteVideoListByNodeId?: ModelTypes["DeleteVideoListPayload"] | undefined,
	/** Deletes a single `VideoList` using a unique key. */
	deleteVideoList?: ModelTypes["DeleteVideoListPayload"] | undefined,
	/** Deletes a single `VideoSource` using its globally unique id. */
	deleteVideoSourceByNodeId?: ModelTypes["DeleteVideoSourcePayload"] | undefined,
	/** Deletes a single `VideoSource` using a unique key. */
	deleteVideoSource?: ModelTypes["DeleteVideoSourcePayload"] | undefined,
	login?: ModelTypes["LoginPayload"] | undefined,
	logout?: ModelTypes["LogoutPayload"] | undefined,
	prospectFormDancer?: ModelTypes["ProspectFormDancerPayload"] | undefined,
	uploadFile: ModelTypes["Upload"]
};
	/** The output of our create `Akce` mutation. */
["CreateAkcePayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Akce` that was created by this mutation. */
	akce?: ModelTypes["Akce"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `Akce`. May be used by Relay 1. */
	akceEdge?: ModelTypes["AkcesEdge"] | undefined
};
	/** All input for the create `Akce` mutation. */
["CreateAkceInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `Akce` to be created by this mutation. */
	akce: ModelTypes["AkceInput"]
};
	/** An input for mutations affecting `Akce` */
["AkceInput"]: {
	aId?: ModelTypes["BigInt"] | undefined,
	aJmeno: string,
	aKde: string,
	aInfo: string,
	aOd: ModelTypes["Date"],
	aDo: ModelTypes["Date"],
	aKapacita?: ModelTypes["BigInt"] | undefined,
	aDokumenty: string,
	aTimestamp?: ModelTypes["Datetime"] | undefined,
	aLock?: boolean | undefined,
	aVisible?: boolean | undefined
};
	/** The output of our create `AkceItem` mutation. */
["CreateAkceItemPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `AkceItem` that was created by this mutation. */
	akceItem?: ModelTypes["AkceItem"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `Akce` that is related to this `AkceItem`. */
	akceByAiIdRodic?: ModelTypes["Akce"] | undefined,
	/** Reads a single `User` that is related to this `AkceItem`. */
	userByAiUser?: ModelTypes["User"] | undefined,
	/** An edge for our `AkceItem`. May be used by Relay 1. */
	akceItemEdge?: ModelTypes["AkceItemsEdge"] | undefined
};
	/** All input for the create `AkceItem` mutation. */
["CreateAkceItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `AkceItem` to be created by this mutation. */
	akceItem: ModelTypes["AkceItemInput"]
};
	/** An input for mutations affecting `AkceItem` */
["AkceItemInput"]: {
	aiId?: ModelTypes["BigInt"] | undefined,
	aiIdRodic: ModelTypes["BigInt"],
	aiUser: ModelTypes["BigInt"],
	aiRokNarozeni: number
};
	/** The output of our create `Aktuality` mutation. */
["CreateAktualityPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Aktuality` that was created by this mutation. */
	aktuality?: ModelTypes["Aktuality"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Aktuality`. */
	userByAtKdo?: ModelTypes["User"] | undefined,
	/** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
	galerieFotoByAtFotoMain?: ModelTypes["GalerieFoto"] | undefined,
	/** An edge for our `Aktuality`. May be used by Relay 1. */
	aktualityEdge?: ModelTypes["AktualitiesEdge"] | undefined
};
	/** All input for the create `Aktuality` mutation. */
["CreateAktualityInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `Aktuality` to be created by this mutation. */
	aktuality: ModelTypes["AktualityInput"]
};
	/** An input for mutations affecting `Aktuality` */
["AktualityInput"]: {
	atId?: ModelTypes["BigInt"] | undefined,
	atKdo: ModelTypes["BigInt"],
	atKat: string,
	atJmeno: string,
	atText: string,
	atPreview: string,
	atFoto?: ModelTypes["BigInt"] | undefined,
	atFotoMain?: ModelTypes["BigInt"] | undefined,
	atTimestamp?: ModelTypes["Datetime"] | undefined,
	atTimestampAdd?: ModelTypes["Datetime"] | undefined
};
	/** The output of our create `Dokumenty` mutation. */
["CreateDokumentyPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Dokumenty` that was created by this mutation. */
	dokumenty?: ModelTypes["Dokumenty"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Dokumenty`. */
	userByDKdo?: ModelTypes["User"] | undefined,
	/** An edge for our `Dokumenty`. May be used by Relay 1. */
	dokumentyEdge?: ModelTypes["DokumentiesEdge"] | undefined
};
	/** All input for the create `Dokumenty` mutation. */
["CreateDokumentyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `Dokumenty` to be created by this mutation. */
	dokumenty: ModelTypes["DokumentyInput"]
};
	/** An input for mutations affecting `Dokumenty` */
["DokumentyInput"]: {
	dId?: ModelTypes["BigInt"] | undefined,
	dPath: string,
	dName: string,
	dFilename: string,
	dKategorie: number,
	dKdo: ModelTypes["BigInt"],
	dTimestamp?: ModelTypes["Datetime"] | undefined
};
	/** The output of our create `GalerieDir` mutation. */
["CreateGalerieDirPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `GalerieDir` that was created by this mutation. */
	galerieDir?: ModelTypes["GalerieDir"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `GalerieDir`. May be used by Relay 1. */
	galerieDirEdge?: ModelTypes["GalerieDirsEdge"] | undefined
};
	/** All input for the create `GalerieDir` mutation. */
["CreateGalerieDirInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `GalerieDir` to be created by this mutation. */
	galerieDir: ModelTypes["GalerieDirInput"]
};
	/** An input for mutations affecting `GalerieDir` */
["GalerieDirInput"]: {
	gdId?: ModelTypes["BigInt"] | undefined,
	gdIdRodic: ModelTypes["BigInt"],
	gdName: string,
	gdLevel?: number | undefined,
	gdPath: string,
	gdHidden?: boolean | undefined
};
	/** The output of our create `GalerieFoto` mutation. */
["CreateGalerieFotoPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `GalerieFoto` that was created by this mutation. */
	galerieFoto?: ModelTypes["GalerieFoto"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
	galerieDirByGfIdRodic?: ModelTypes["GalerieDir"] | undefined,
	/** Reads a single `User` that is related to this `GalerieFoto`. */
	userByGfKdo?: ModelTypes["User"] | undefined,
	/** An edge for our `GalerieFoto`. May be used by Relay 1. */
	galerieFotoEdge?: ModelTypes["GalerieFotosEdge"] | undefined
};
	/** All input for the create `GalerieFoto` mutation. */
["CreateGalerieFotoInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `GalerieFoto` to be created by this mutation. */
	galerieFoto: ModelTypes["GalerieFotoInput"]
};
	/** An input for mutations affecting `GalerieFoto` */
["GalerieFotoInput"]: {
	gfId?: ModelTypes["BigInt"] | undefined,
	gfIdRodic: ModelTypes["BigInt"],
	gfName: string,
	gfPath: string,
	gfKdo: ModelTypes["BigInt"],
	gfTimestamp?: ModelTypes["Datetime"] | undefined
};
	/** The output of our create `Nabidka` mutation. */
["CreateNabidkaPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Nabidka` that was created by this mutation. */
	nabidka?: ModelTypes["Nabidka"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Nabidka`. */
	userByNTrener?: ModelTypes["User"] | undefined,
	/** An edge for our `Nabidka`. May be used by Relay 1. */
	nabidkaEdge?: ModelTypes["NabidkasEdge"] | undefined
};
	/** All input for the create `Nabidka` mutation. */
["CreateNabidkaInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `Nabidka` to be created by this mutation. */
	nabidka: ModelTypes["NabidkaInput"]
};
	/** An input for mutations affecting `Nabidka` */
["NabidkaInput"]: {
	nId?: ModelTypes["BigInt"] | undefined,
	nTrener: ModelTypes["BigInt"],
	nPocetHod?: number | undefined,
	nMaxPocetHod?: ModelTypes["BigInt"] | undefined,
	nOd: ModelTypes["Date"],
	nDo: ModelTypes["Date"],
	nVisible?: boolean | undefined,
	nLock?: boolean | undefined,
	nTimestamp?: ModelTypes["Datetime"] | undefined
};
	/** The output of our create `NabidkaItem` mutation. */
["CreateNabidkaItemPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `NabidkaItem` that was created by this mutation. */
	nabidkaItem?: ModelTypes["NabidkaItem"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `Nabidka` that is related to this `NabidkaItem`. */
	nabidkaByNiIdRodic?: ModelTypes["Nabidka"] | undefined,
	/** Reads a single `Pary` that is related to this `NabidkaItem`. */
	paryByNiPartner?: ModelTypes["Pary"] | undefined,
	/** An edge for our `NabidkaItem`. May be used by Relay 1. */
	nabidkaItemEdge?: ModelTypes["NabidkaItemsEdge"] | undefined
};
	/** All input for the create `NabidkaItem` mutation. */
["CreateNabidkaItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `NabidkaItem` to be created by this mutation. */
	nabidkaItem: ModelTypes["NabidkaItemInput"]
};
	/** An input for mutations affecting `NabidkaItem` */
["NabidkaItemInput"]: {
	niId?: ModelTypes["BigInt"] | undefined,
	niIdRodic: ModelTypes["BigInt"],
	niPartner: ModelTypes["BigInt"],
	niPocetHod?: number | undefined,
	niLock?: boolean | undefined
};
	/** The output of our create `Page` mutation. */
["CreatePagePayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Page` that was created by this mutation. */
	page?: ModelTypes["Page"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `Page`. May be used by Relay 1. */
	pageEdge?: ModelTypes["PagesEdge"] | undefined
};
	/** All input for the create `Page` mutation. */
["CreatePageInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `Page` to be created by this mutation. */
	page: ModelTypes["PageInput"]
};
	/** An input for mutations affecting `Page` */
["PageInput"]: {
	id?: number | undefined,
	url: string,
	content: ModelTypes["JSON"],
	createdAt?: ModelTypes["Datetime"] | undefined,
	updatedAt?: ModelTypes["Datetime"] | undefined,
	title?: string | undefined
};
	/** The output of our create `Parameter` mutation. */
["CreateParameterPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Parameter` that was created by this mutation. */
	parameter?: ModelTypes["Parameter"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `Parameter`. May be used by Relay 1. */
	parameterEdge?: ModelTypes["ParametersEdge"] | undefined
};
	/** All input for the create `Parameter` mutation. */
["CreateParameterInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `Parameter` to be created by this mutation. */
	parameter: ModelTypes["ParameterInput"]
};
	/** An input for mutations affecting `Parameter` */
["ParameterInput"]: {
	paName: string,
	paValue: string
};
	/** The output of our create `Pary` mutation. */
["CreateParyPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Pary` that was created by this mutation. */
	pary?: ModelTypes["Pary"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Pary`. */
	userByPIdPartner?: ModelTypes["User"] | undefined,
	/** An edge for our `Pary`. May be used by Relay 1. */
	paryEdge?: ModelTypes["PariesEdge"] | undefined
};
	/** All input for the create `Pary` mutation. */
["CreateParyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `Pary` to be created by this mutation. */
	pary: ModelTypes["ParyInput"]
};
	/** An input for mutations affecting `Pary` */
["ParyInput"]: {
	pId?: ModelTypes["BigInt"] | undefined,
	pIdPartner: ModelTypes["BigInt"],
	pIdPartnerka?: ModelTypes["BigInt"] | undefined,
	pSttTrida?: ModelTypes["ParyPSttTrida"] | undefined,
	pSttBody?: number | undefined,
	pSttFinale?: boolean | undefined,
	pLatTrida?: ModelTypes["ParyPLatTrida"] | undefined,
	pLatBody?: number | undefined,
	pLatFinale?: boolean | undefined,
	pHodnoceni?: number | undefined,
	pArchiv?: boolean | undefined,
	pTimestampAdd?: ModelTypes["Datetime"] | undefined,
	pTimestampArchive?: ModelTypes["Datetime"] | undefined
};
	/** The output of our create `ParyNavrh` mutation. */
["CreateParyNavrhPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `ParyNavrh` that was created by this mutation. */
	paryNavrh?: ModelTypes["ParyNavrh"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnNavrhl?: ModelTypes["User"] | undefined,
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnPartner?: ModelTypes["User"] | undefined,
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnPartnerka?: ModelTypes["User"] | undefined,
	/** An edge for our `ParyNavrh`. May be used by Relay 1. */
	paryNavrhEdge?: ModelTypes["ParyNavrhsEdge"] | undefined
};
	/** All input for the create `ParyNavrh` mutation. */
["CreateParyNavrhInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `ParyNavrh` to be created by this mutation. */
	paryNavrh: ModelTypes["ParyNavrhInput"]
};
	/** An input for mutations affecting `ParyNavrh` */
["ParyNavrhInput"]: {
	pnId?: ModelTypes["BigInt"] | undefined,
	pnNavrhl: ModelTypes["BigInt"],
	pnPartner: ModelTypes["BigInt"],
	pnPartnerka: ModelTypes["BigInt"]
};
	/** The output of our create `Permission` mutation. */
["CreatePermissionPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Permission` that was created by this mutation. */
	permission?: ModelTypes["Permission"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `Permission`. May be used by Relay 1. */
	permissionEdge?: ModelTypes["PermissionsEdge"] | undefined
};
	/** All input for the create `Permission` mutation. */
["CreatePermissionInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `Permission` to be created by this mutation. */
	permission: ModelTypes["PermissionInput"]
};
	/** An input for mutations affecting `Permission` */
["PermissionInput"]: {
	peId?: ModelTypes["BigInt"] | undefined,
	peName: string,
	peDescription: string,
	peAkce: number,
	peAktuality: number,
	peAnkety: number,
	peDokumenty: number,
	peGalerie: number,
	peInzerce: number,
	peKonzole: number,
	peNabidka: number,
	peNastenka: number,
	peNovinky: number,
	pePary: number,
	pePlatby: number,
	pePermissions: number,
	peRozpis: number,
	peSkupiny: number,
	peUsers: number,
	peMain: number
};
	/** The output of our create `PlatbyCategory` mutation. */
["CreatePlatbyCategoryPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyCategory` that was created by this mutation. */
	platbyCategory?: ModelTypes["PlatbyCategory"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `PlatbyCategory`. May be used by Relay 1. */
	platbyCategoryEdge?: ModelTypes["PlatbyCategoriesEdge"] | undefined
};
	/** All input for the create `PlatbyCategory` mutation. */
["CreatePlatbyCategoryInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `PlatbyCategory` to be created by this mutation. */
	platbyCategory: ModelTypes["PlatbyCategoryInput"]
};
	/** An input for mutations affecting `PlatbyCategory` */
["PlatbyCategoryInput"]: {
	pcId?: ModelTypes["BigInt"] | undefined,
	pcName: string,
	pcSymbol: ModelTypes["BigInt"],
	pcAmount: ModelTypes["BigFloat"],
	pcDateDue: ModelTypes["Date"],
	pcValidFrom: ModelTypes["Date"],
	pcValidTo: ModelTypes["Date"],
	pcUseBase?: boolean | undefined,
	pcUsePrefix?: boolean | undefined,
	pcArchive?: boolean | undefined,
	pcVisible?: boolean | undefined
};
	/** The output of our create `PlatbyCategoryGroup` mutation. */
["CreatePlatbyCategoryGroupPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyCategoryGroup` that was created by this mutation. */
	platbyCategoryGroup?: ModelTypes["PlatbyCategoryGroup"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `PlatbyGroup` that is related to this `PlatbyCategoryGroup`. */
	platbyGroupByPcgIdGroup?: ModelTypes["PlatbyGroup"] | undefined,
	/** Reads a single `PlatbyCategory` that is related to this `PlatbyCategoryGroup`. */
	platbyCategoryByPcgIdCategory?: ModelTypes["PlatbyCategory"] | undefined,
	/** An edge for our `PlatbyCategoryGroup`. May be used by Relay 1. */
	platbyCategoryGroupEdge?: ModelTypes["PlatbyCategoryGroupsEdge"] | undefined
};
	/** All input for the create `PlatbyCategoryGroup` mutation. */
["CreatePlatbyCategoryGroupInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `PlatbyCategoryGroup` to be created by this mutation. */
	platbyCategoryGroup: ModelTypes["PlatbyCategoryGroupInput"]
};
	/** An input for mutations affecting `PlatbyCategoryGroup` */
["PlatbyCategoryGroupInput"]: {
	pcgId?: ModelTypes["BigInt"] | undefined,
	pcgIdGroup: ModelTypes["BigInt"],
	pcgIdCategory: ModelTypes["BigInt"]
};
	/** The output of our create `PlatbyGroup` mutation. */
["CreatePlatbyGroupPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyGroup` that was created by this mutation. */
	platbyGroup?: ModelTypes["PlatbyGroup"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `PlatbyGroup`. May be used by Relay 1. */
	platbyGroupEdge?: ModelTypes["PlatbyGroupsEdge"] | undefined
};
	/** All input for the create `PlatbyGroup` mutation. */
["CreatePlatbyGroupInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `PlatbyGroup` to be created by this mutation. */
	platbyGroup: ModelTypes["PlatbyGroupInput"]
};
	/** An input for mutations affecting `PlatbyGroup` */
["PlatbyGroupInput"]: {
	pgId?: ModelTypes["BigInt"] | undefined,
	pgType?: ModelTypes["BigFloat"] | undefined,
	pgName: string,
	pgDescription: string,
	pgBase?: ModelTypes["BigInt"] | undefined
};
	/** The output of our create `PlatbyGroupSkupina` mutation. */
["CreatePlatbyGroupSkupinaPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyGroupSkupina` that was created by this mutation. */
	platbyGroupSkupina?: ModelTypes["PlatbyGroupSkupina"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `Skupiny` that is related to this `PlatbyGroupSkupina`. */
	skupinyByPgsIdSkupina?: ModelTypes["Skupiny"] | undefined,
	/** Reads a single `PlatbyGroup` that is related to this `PlatbyGroupSkupina`. */
	platbyGroupByPgsIdGroup?: ModelTypes["PlatbyGroup"] | undefined,
	/** An edge for our `PlatbyGroupSkupina`. May be used by Relay 1. */
	platbyGroupSkupinaEdge?: ModelTypes["PlatbyGroupSkupinasEdge"] | undefined
};
	/** All input for the create `PlatbyGroupSkupina` mutation. */
["CreatePlatbyGroupSkupinaInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `PlatbyGroupSkupina` to be created by this mutation. */
	platbyGroupSkupina: ModelTypes["PlatbyGroupSkupinaInput"]
};
	/** An input for mutations affecting `PlatbyGroupSkupina` */
["PlatbyGroupSkupinaInput"]: {
	pgsId?: ModelTypes["BigInt"] | undefined,
	pgsIdSkupina: ModelTypes["BigInt"],
	pgsIdGroup: ModelTypes["BigInt"]
};
	/** The output of our create `PlatbyItem` mutation. */
["CreatePlatbyItemPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyItem` that was created by this mutation. */
	platbyItem?: ModelTypes["PlatbyItem"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `PlatbyItem`. */
	userByPiIdUser?: ModelTypes["User"] | undefined,
	/** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
	platbyCategoryByPiIdCategory?: ModelTypes["PlatbyCategory"] | undefined,
	/** Reads a single `PlatbyRaw` that is related to this `PlatbyItem`. */
	platbyRawByPiIdRaw?: ModelTypes["PlatbyRaw"] | undefined,
	/** An edge for our `PlatbyItem`. May be used by Relay 1. */
	platbyItemEdge?: ModelTypes["PlatbyItemsEdge"] | undefined
};
	/** All input for the create `PlatbyItem` mutation. */
["CreatePlatbyItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `PlatbyItem` to be created by this mutation. */
	platbyItem: ModelTypes["PlatbyItemInput"]
};
	/** An input for mutations affecting `PlatbyItem` */
["PlatbyItemInput"]: {
	piId?: ModelTypes["BigInt"] | undefined,
	piIdUser?: ModelTypes["BigInt"] | undefined,
	piIdCategory: ModelTypes["BigInt"],
	piIdRaw?: ModelTypes["BigInt"] | undefined,
	piAmount: ModelTypes["BigFloat"],
	piDate: ModelTypes["Date"],
	piPrefix?: number | undefined
};
	/** The output of our create `PlatbyRaw` mutation. */
["CreatePlatbyRawPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyRaw` that was created by this mutation. */
	platbyRaw?: ModelTypes["PlatbyRaw"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `PlatbyRaw`. May be used by Relay 1. */
	platbyRawEdge?: ModelTypes["PlatbyRawsEdge"] | undefined
};
	/** All input for the create `PlatbyRaw` mutation. */
["CreatePlatbyRawInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `PlatbyRaw` to be created by this mutation. */
	platbyRaw: ModelTypes["PlatbyRawInput"]
};
	/** An input for mutations affecting `PlatbyRaw` */
["PlatbyRawInput"]: {
	prId?: ModelTypes["BigInt"] | undefined,
	prRaw: string,
	prHash: string,
	prSorted?: boolean | undefined,
	prDiscarded?: boolean | undefined
};
	/** The output of our create `Rozpi` mutation. */
["CreateRozpiPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Rozpi` that was created by this mutation. */
	rozpi?: ModelTypes["Rozpi"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Rozpi`. */
	userByRTrener?: ModelTypes["User"] | undefined,
	/** An edge for our `Rozpi`. May be used by Relay 1. */
	rozpiEdge?: ModelTypes["RozpisEdge"] | undefined
};
	/** All input for the create `Rozpi` mutation. */
["CreateRozpiInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `Rozpi` to be created by this mutation. */
	rozpi: ModelTypes["RozpiInput"]
};
	/** An input for mutations affecting `Rozpi` */
["RozpiInput"]: {
	rId?: ModelTypes["BigInt"] | undefined,
	rTrener: ModelTypes["BigInt"],
	rKde: string,
	rDatum: ModelTypes["Date"],
	rVisible?: boolean | undefined,
	rLock?: boolean | undefined,
	rTimestamp?: ModelTypes["Datetime"] | undefined
};
	/** The output of our create `RozpisItem` mutation. */
["CreateRozpisItemPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `RozpisItem` that was created by this mutation. */
	rozpisItem?: ModelTypes["RozpisItem"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `Rozpi` that is related to this `RozpisItem`. */
	rozpiByRiIdRodic?: ModelTypes["Rozpi"] | undefined,
	/** Reads a single `Pary` that is related to this `RozpisItem`. */
	paryByRiPartner?: ModelTypes["Pary"] | undefined,
	/** An edge for our `RozpisItem`. May be used by Relay 1. */
	rozpisItemEdge?: ModelTypes["RozpisItemsEdge"] | undefined
};
	/** All input for the create `RozpisItem` mutation. */
["CreateRozpisItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `RozpisItem` to be created by this mutation. */
	rozpisItem: ModelTypes["RozpisItemInput"]
};
	/** An input for mutations affecting `RozpisItem` */
["RozpisItemInput"]: {
	riId?: ModelTypes["BigInt"] | undefined,
	riIdRodic: ModelTypes["BigInt"],
	riPartner?: ModelTypes["BigInt"] | undefined,
	riOd: ModelTypes["Time"],
	riDo: ModelTypes["Time"],
	riLock?: boolean | undefined
};
	/** The output of our create `Session` mutation. */
["CreateSessionPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Session` that was created by this mutation. */
	session?: ModelTypes["Session"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Session`. */
	userBySsUser?: ModelTypes["User"] | undefined,
	/** An edge for our `Session`. May be used by Relay 1. */
	sessionEdge?: ModelTypes["SessionsEdge"] | undefined
};
	/** All input for the create `Session` mutation. */
["CreateSessionInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `Session` to be created by this mutation. */
	session: ModelTypes["SessionInput"]
};
	/** An input for mutations affecting `Session` */
["SessionInput"]: {
	ssId: string,
	ssData: string,
	ssUpdatedAt?: ModelTypes["Datetime"] | undefined,
	ssLifetime: ModelTypes["BigInt"],
	ssUser?: ModelTypes["BigInt"] | undefined
};
	/** The output of our create `Skupiny` mutation. */
["CreateSkupinyPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Skupiny` that was created by this mutation. */
	skupiny?: ModelTypes["Skupiny"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `Skupiny`. May be used by Relay 1. */
	skupinyEdge?: ModelTypes["SkupiniesEdge"] | undefined
};
	/** All input for the create `Skupiny` mutation. */
["CreateSkupinyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `Skupiny` to be created by this mutation. */
	skupiny: ModelTypes["SkupinyInput"]
};
	/** An input for mutations affecting `Skupiny` */
["SkupinyInput"]: {
	sId?: ModelTypes["BigInt"] | undefined,
	sName: string,
	sDescription: string,
	sColorRgb: string,
	sColorText: string,
	sLocation?: string | undefined,
	sVisible?: boolean | undefined
};
	/** The output of our create `Upozorneni` mutation. */
["CreateUpozorneniPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Upozorneni` that was created by this mutation. */
	upozorneni?: ModelTypes["Upozorneni"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Upozorneni`. */
	userByUpKdo?: ModelTypes["User"] | undefined,
	/** An edge for our `Upozorneni`. May be used by Relay 1. */
	upozorneniEdge?: ModelTypes["UpozornenisEdge"] | undefined
};
	/** All input for the create `Upozorneni` mutation. */
["CreateUpozorneniInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `Upozorneni` to be created by this mutation. */
	upozorneni: ModelTypes["UpozorneniInput"]
};
	/** An input for mutations affecting `Upozorneni` */
["UpozorneniInput"]: {
	upId?: ModelTypes["BigInt"] | undefined,
	upKdo: ModelTypes["BigInt"],
	upNadpis: string,
	upText: string,
	upBarvy?: ModelTypes["BigInt"] | undefined,
	upLock?: boolean | undefined,
	upTimestamp?: ModelTypes["Datetime"] | undefined,
	upTimestampAdd?: ModelTypes["Datetime"] | undefined
};
	/** The output of our create `UpozorneniSkupiny` mutation. */
["CreateUpozorneniSkupinyPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `UpozorneniSkupiny` that was created by this mutation. */
	upozorneniSkupiny?: ModelTypes["UpozorneniSkupiny"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
	upozorneniByUpsIdRodic?: ModelTypes["Upozorneni"] | undefined,
	/** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
	skupinyByUpsIdSkupina?: ModelTypes["Skupiny"] | undefined,
	/** An edge for our `UpozorneniSkupiny`. May be used by Relay 1. */
	upozorneniSkupinyEdge?: ModelTypes["UpozorneniSkupiniesEdge"] | undefined
};
	/** All input for the create `UpozorneniSkupiny` mutation. */
["CreateUpozorneniSkupinyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `UpozorneniSkupiny` to be created by this mutation. */
	upozorneniSkupiny: ModelTypes["UpozorneniSkupinyInput"]
};
	/** An input for mutations affecting `UpozorneniSkupiny` */
["UpozorneniSkupinyInput"]: {
	upsId?: ModelTypes["BigInt"] | undefined,
	upsIdRodic: ModelTypes["BigInt"],
	upsIdSkupina: ModelTypes["BigInt"],
	upsColor: string,
	upsPopis: string
};
	/** The output of our create `User` mutation. */
["CreateUserPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `User` that was created by this mutation. */
	user?: ModelTypes["User"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `Permission` that is related to this `User`. */
	permissionByUGroup?: ModelTypes["Permission"] | undefined,
	/** Reads a single `Skupiny` that is related to this `User`. */
	skupinyByUSkupina?: ModelTypes["Skupiny"] | undefined,
	/** An edge for our `User`. May be used by Relay 1. */
	userEdge?: ModelTypes["UsersEdge"] | undefined
};
	/** All input for the create `User` mutation. */
["CreateUserInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `User` to be created by this mutation. */
	user: ModelTypes["UserInput"]
};
	/** An input for mutations affecting `User` */
["UserInput"]: {
	uId?: ModelTypes["BigInt"] | undefined,
	uLogin: string,
	uPass: string,
	uJmeno: string,
	uPrijmeni: string,
	uPohlavi: string,
	uEmail: string,
	uTelefon: string,
	uNarozeni: ModelTypes["Date"],
	uRodneCislo?: string | undefined,
	uPoznamky?: string | undefined,
	uTimestamp?: ModelTypes["Datetime"] | undefined,
	uLevel?: number | undefined,
	uGroup: ModelTypes["BigInt"],
	uSkupina?: ModelTypes["BigInt"] | undefined,
	uDancer?: boolean | undefined,
	uBan?: boolean | undefined,
	uLock?: boolean | undefined,
	uConfirmed?: boolean | undefined,
	uSystem?: boolean | undefined,
	uStreet: string,
	uConscriptionNumber?: string | undefined,
	uOrientationNumber?: string | undefined,
	uDistrict?: string | undefined,
	uCity: string,
	uPostalCode: string,
	uNationality: string,
	uMemberSince?: ModelTypes["Datetime"] | undefined,
	uMemberUntil?: ModelTypes["Datetime"] | undefined,
	uCreatedAt?: ModelTypes["Datetime"] | undefined,
	uTeacher?: boolean | undefined,
	uGdprSignedAt?: ModelTypes["Datetime"] | undefined
};
	/** The output of our create `UsersSkupiny` mutation. */
["CreateUsersSkupinyPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `UsersSkupiny` that was created by this mutation. */
	usersSkupiny?: ModelTypes["UsersSkupiny"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `UsersSkupiny`. May be used by Relay 1. */
	usersSkupinyEdge?: ModelTypes["UsersSkupiniesEdge"] | undefined
};
	/** All input for the create `UsersSkupiny` mutation. */
["CreateUsersSkupinyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `UsersSkupiny` to be created by this mutation. */
	usersSkupiny: ModelTypes["UsersSkupinyInput"]
};
	/** An input for mutations affecting `UsersSkupiny` */
["UsersSkupinyInput"]: {
	usId?: ModelTypes["BigInt"] | undefined,
	usColor?: string | undefined,
	usPlatbaMesic?: ModelTypes["BigInt"] | undefined,
	usPlatbaCtvrtrok?: ModelTypes["BigInt"] | undefined,
	usPlatbaPulrok?: ModelTypes["BigInt"] | undefined,
	usPopis: string
};
	/** The output of our create `Video` mutation. */
["CreateVideoPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Video` that was created by this mutation. */
	video?: ModelTypes["Video"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `Video`. May be used by Relay 1. */
	videoEdge?: ModelTypes["VideosEdge"] | undefined
};
	/** All input for the create `Video` mutation. */
["CreateVideoInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `Video` to be created by this mutation. */
	video: ModelTypes["VideoInput"]
};
	/** An input for mutations affecting `Video` */
["VideoInput"]: {
	vId?: ModelTypes["BigInt"] | undefined,
	vUri: string,
	vTitle: string,
	vAuthor: string,
	vDescription: string,
	vPlaylist?: string | undefined,
	vCreatedAt: ModelTypes["Datetime"],
	vUpdatedAt?: ModelTypes["Datetime"] | undefined
};
	/** The output of our create `VideoList` mutation. */
["CreateVideoListPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `VideoList` that was created by this mutation. */
	videoList?: ModelTypes["VideoList"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `VideoList`. May be used by Relay 1. */
	videoListEdge?: ModelTypes["VideoListsEdge"] | undefined
};
	/** All input for the create `VideoList` mutation. */
["CreateVideoListInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `VideoList` to be created by this mutation. */
	videoList: ModelTypes["VideoListInput"]
};
	/** An input for mutations affecting `VideoList` */
["VideoListInput"]: {
	vlId?: ModelTypes["BigInt"] | undefined,
	vlUrl: string,
	vlTitle: string,
	vlDescription: string,
	vlCount: ModelTypes["BigInt"],
	vlCreatedAt: ModelTypes["Datetime"],
	vlLastChecked?: ModelTypes["Datetime"] | undefined
};
	/** The output of our create `VideoSource` mutation. */
["CreateVideoSourcePayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `VideoSource` that was created by this mutation. */
	videoSource?: ModelTypes["VideoSource"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `VideoSource`. May be used by Relay 1. */
	videoSourceEdge?: ModelTypes["VideoSourcesEdge"] | undefined
};
	/** All input for the create `VideoSource` mutation. */
["CreateVideoSourceInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `VideoSource` to be created by this mutation. */
	videoSource: ModelTypes["VideoSourceInput"]
};
	/** An input for mutations affecting `VideoSource` */
["VideoSourceInput"]: {
	vsId?: ModelTypes["BigInt"] | undefined,
	vsUrl: string,
	vsTitle?: string | undefined,
	vsDescription?: string | undefined,
	vsCreatedAt?: ModelTypes["Datetime"] | undefined,
	vsLastChecked?: ModelTypes["Datetime"] | undefined
};
	/** The output of our update `Akce` mutation. */
["UpdateAkcePayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Akce` that was updated by this mutation. */
	akce?: ModelTypes["Akce"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `Akce`. May be used by Relay 1. */
	akceEdge?: ModelTypes["AkcesEdge"] | undefined
};
	/** All input for the `updateAkceByNodeId` mutation. */
["UpdateAkceByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Akce` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Akce` being updated. */
	patch: ModelTypes["AkcePatch"]
};
	/** Represents an update to a `Akce`. Fields that are set will be updated. */
["AkcePatch"]: {
	aId?: ModelTypes["BigInt"] | undefined,
	aJmeno?: string | undefined,
	aKde?: string | undefined,
	aInfo?: string | undefined,
	aOd?: ModelTypes["Date"] | undefined,
	aDo?: ModelTypes["Date"] | undefined,
	aKapacita?: ModelTypes["BigInt"] | undefined,
	aDokumenty?: string | undefined,
	aTimestamp?: ModelTypes["Datetime"] | undefined,
	aLock?: boolean | undefined,
	aVisible?: boolean | undefined
};
	/** All input for the `updateAkce` mutation. */
["UpdateAkceInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `Akce` being updated. */
	patch: ModelTypes["AkcePatch"],
	aId: ModelTypes["BigInt"]
};
	/** The output of our update `AkceItem` mutation. */
["UpdateAkceItemPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `AkceItem` that was updated by this mutation. */
	akceItem?: ModelTypes["AkceItem"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `Akce` that is related to this `AkceItem`. */
	akceByAiIdRodic?: ModelTypes["Akce"] | undefined,
	/** Reads a single `User` that is related to this `AkceItem`. */
	userByAiUser?: ModelTypes["User"] | undefined,
	/** An edge for our `AkceItem`. May be used by Relay 1. */
	akceItemEdge?: ModelTypes["AkceItemsEdge"] | undefined
};
	/** All input for the `updateAkceItemByNodeId` mutation. */
["UpdateAkceItemByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `AkceItem` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `AkceItem` being updated. */
	patch: ModelTypes["AkceItemPatch"]
};
	/** Represents an update to a `AkceItem`. Fields that are set will be updated. */
["AkceItemPatch"]: {
	aiId?: ModelTypes["BigInt"] | undefined,
	aiIdRodic?: ModelTypes["BigInt"] | undefined,
	aiUser?: ModelTypes["BigInt"] | undefined,
	aiRokNarozeni?: number | undefined
};
	/** All input for the `updateAkceItem` mutation. */
["UpdateAkceItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `AkceItem` being updated. */
	patch: ModelTypes["AkceItemPatch"],
	aiId: ModelTypes["BigInt"]
};
	/** The output of our update `Aktuality` mutation. */
["UpdateAktualityPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Aktuality` that was updated by this mutation. */
	aktuality?: ModelTypes["Aktuality"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Aktuality`. */
	userByAtKdo?: ModelTypes["User"] | undefined,
	/** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
	galerieFotoByAtFotoMain?: ModelTypes["GalerieFoto"] | undefined,
	/** An edge for our `Aktuality`. May be used by Relay 1. */
	aktualityEdge?: ModelTypes["AktualitiesEdge"] | undefined
};
	/** All input for the `updateAktualityByNodeId` mutation. */
["UpdateAktualityByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Aktuality` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Aktuality` being updated. */
	patch: ModelTypes["AktualityPatch"]
};
	/** Represents an update to a `Aktuality`. Fields that are set will be updated. */
["AktualityPatch"]: {
	atId?: ModelTypes["BigInt"] | undefined,
	atKdo?: ModelTypes["BigInt"] | undefined,
	atKat?: string | undefined,
	atJmeno?: string | undefined,
	atText?: string | undefined,
	atPreview?: string | undefined,
	atFoto?: ModelTypes["BigInt"] | undefined,
	atFotoMain?: ModelTypes["BigInt"] | undefined,
	atTimestamp?: ModelTypes["Datetime"] | undefined,
	atTimestampAdd?: ModelTypes["Datetime"] | undefined
};
	/** All input for the `updateAktuality` mutation. */
["UpdateAktualityInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `Aktuality` being updated. */
	patch: ModelTypes["AktualityPatch"],
	atId: ModelTypes["BigInt"]
};
	/** The output of our update `Dokumenty` mutation. */
["UpdateDokumentyPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Dokumenty` that was updated by this mutation. */
	dokumenty?: ModelTypes["Dokumenty"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Dokumenty`. */
	userByDKdo?: ModelTypes["User"] | undefined,
	/** An edge for our `Dokumenty`. May be used by Relay 1. */
	dokumentyEdge?: ModelTypes["DokumentiesEdge"] | undefined
};
	/** All input for the `updateDokumentyByNodeId` mutation. */
["UpdateDokumentyByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Dokumenty` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Dokumenty` being updated. */
	patch: ModelTypes["DokumentyPatch"]
};
	/** Represents an update to a `Dokumenty`. Fields that are set will be updated. */
["DokumentyPatch"]: {
	dId?: ModelTypes["BigInt"] | undefined,
	dPath?: string | undefined,
	dName?: string | undefined,
	dFilename?: string | undefined,
	dKategorie?: number | undefined,
	dKdo?: ModelTypes["BigInt"] | undefined,
	dTimestamp?: ModelTypes["Datetime"] | undefined
};
	/** All input for the `updateDokumenty` mutation. */
["UpdateDokumentyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `Dokumenty` being updated. */
	patch: ModelTypes["DokumentyPatch"],
	dId: ModelTypes["BigInt"]
};
	/** The output of our update `GalerieDir` mutation. */
["UpdateGalerieDirPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `GalerieDir` that was updated by this mutation. */
	galerieDir?: ModelTypes["GalerieDir"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `GalerieDir`. May be used by Relay 1. */
	galerieDirEdge?: ModelTypes["GalerieDirsEdge"] | undefined
};
	/** All input for the `updateGalerieDirByNodeId` mutation. */
["UpdateGalerieDirByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `GalerieDir` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `GalerieDir` being updated. */
	patch: ModelTypes["GalerieDirPatch"]
};
	/** Represents an update to a `GalerieDir`. Fields that are set will be updated. */
["GalerieDirPatch"]: {
	gdId?: ModelTypes["BigInt"] | undefined,
	gdIdRodic?: ModelTypes["BigInt"] | undefined,
	gdName?: string | undefined,
	gdLevel?: number | undefined,
	gdPath?: string | undefined,
	gdHidden?: boolean | undefined
};
	/** All input for the `updateGalerieDir` mutation. */
["UpdateGalerieDirInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `GalerieDir` being updated. */
	patch: ModelTypes["GalerieDirPatch"],
	gdId: ModelTypes["BigInt"]
};
	/** The output of our update `GalerieFoto` mutation. */
["UpdateGalerieFotoPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `GalerieFoto` that was updated by this mutation. */
	galerieFoto?: ModelTypes["GalerieFoto"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
	galerieDirByGfIdRodic?: ModelTypes["GalerieDir"] | undefined,
	/** Reads a single `User` that is related to this `GalerieFoto`. */
	userByGfKdo?: ModelTypes["User"] | undefined,
	/** An edge for our `GalerieFoto`. May be used by Relay 1. */
	galerieFotoEdge?: ModelTypes["GalerieFotosEdge"] | undefined
};
	/** All input for the `updateGalerieFotoByNodeId` mutation. */
["UpdateGalerieFotoByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `GalerieFoto` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `GalerieFoto` being updated. */
	patch: ModelTypes["GalerieFotoPatch"]
};
	/** Represents an update to a `GalerieFoto`. Fields that are set will be updated. */
["GalerieFotoPatch"]: {
	gfId?: ModelTypes["BigInt"] | undefined,
	gfIdRodic?: ModelTypes["BigInt"] | undefined,
	gfName?: string | undefined,
	gfPath?: string | undefined,
	gfKdo?: ModelTypes["BigInt"] | undefined,
	gfTimestamp?: ModelTypes["Datetime"] | undefined
};
	/** All input for the `updateGalerieFoto` mutation. */
["UpdateGalerieFotoInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `GalerieFoto` being updated. */
	patch: ModelTypes["GalerieFotoPatch"],
	gfId: ModelTypes["BigInt"]
};
	/** The output of our update `Nabidka` mutation. */
["UpdateNabidkaPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Nabidka` that was updated by this mutation. */
	nabidka?: ModelTypes["Nabidka"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Nabidka`. */
	userByNTrener?: ModelTypes["User"] | undefined,
	/** An edge for our `Nabidka`. May be used by Relay 1. */
	nabidkaEdge?: ModelTypes["NabidkasEdge"] | undefined
};
	/** All input for the `updateNabidkaByNodeId` mutation. */
["UpdateNabidkaByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Nabidka` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Nabidka` being updated. */
	patch: ModelTypes["NabidkaPatch"]
};
	/** Represents an update to a `Nabidka`. Fields that are set will be updated. */
["NabidkaPatch"]: {
	nId?: ModelTypes["BigInt"] | undefined,
	nTrener?: ModelTypes["BigInt"] | undefined,
	nPocetHod?: number | undefined,
	nMaxPocetHod?: ModelTypes["BigInt"] | undefined,
	nOd?: ModelTypes["Date"] | undefined,
	nDo?: ModelTypes["Date"] | undefined,
	nVisible?: boolean | undefined,
	nLock?: boolean | undefined,
	nTimestamp?: ModelTypes["Datetime"] | undefined
};
	/** All input for the `updateNabidka` mutation. */
["UpdateNabidkaInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `Nabidka` being updated. */
	patch: ModelTypes["NabidkaPatch"],
	nId: ModelTypes["BigInt"]
};
	/** The output of our update `NabidkaItem` mutation. */
["UpdateNabidkaItemPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `NabidkaItem` that was updated by this mutation. */
	nabidkaItem?: ModelTypes["NabidkaItem"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `Nabidka` that is related to this `NabidkaItem`. */
	nabidkaByNiIdRodic?: ModelTypes["Nabidka"] | undefined,
	/** Reads a single `Pary` that is related to this `NabidkaItem`. */
	paryByNiPartner?: ModelTypes["Pary"] | undefined,
	/** An edge for our `NabidkaItem`. May be used by Relay 1. */
	nabidkaItemEdge?: ModelTypes["NabidkaItemsEdge"] | undefined
};
	/** All input for the `updateNabidkaItemByNodeId` mutation. */
["UpdateNabidkaItemByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `NabidkaItem` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `NabidkaItem` being updated. */
	patch: ModelTypes["NabidkaItemPatch"]
};
	/** Represents an update to a `NabidkaItem`. Fields that are set will be updated. */
["NabidkaItemPatch"]: {
	niId?: ModelTypes["BigInt"] | undefined,
	niIdRodic?: ModelTypes["BigInt"] | undefined,
	niPartner?: ModelTypes["BigInt"] | undefined,
	niPocetHod?: number | undefined,
	niLock?: boolean | undefined
};
	/** All input for the `updateNabidkaItem` mutation. */
["UpdateNabidkaItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `NabidkaItem` being updated. */
	patch: ModelTypes["NabidkaItemPatch"],
	niId: ModelTypes["BigInt"]
};
	/** The output of our update `Page` mutation. */
["UpdatePagePayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Page` that was updated by this mutation. */
	page?: ModelTypes["Page"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `Page`. May be used by Relay 1. */
	pageEdge?: ModelTypes["PagesEdge"] | undefined
};
	/** All input for the `updatePageByNodeId` mutation. */
["UpdatePageByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Page` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Page` being updated. */
	patch: ModelTypes["PagePatch"]
};
	/** Represents an update to a `Page`. Fields that are set will be updated. */
["PagePatch"]: {
	id?: number | undefined,
	url?: string | undefined,
	content?: ModelTypes["JSON"] | undefined,
	createdAt?: ModelTypes["Datetime"] | undefined,
	updatedAt?: ModelTypes["Datetime"] | undefined,
	title?: string | undefined
};
	/** All input for the `updatePage` mutation. */
["UpdatePageInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `Page` being updated. */
	patch: ModelTypes["PagePatch"],
	id: number
};
	/** All input for the `updatePageByUrl` mutation. */
["UpdatePageByUrlInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `Page` being updated. */
	patch: ModelTypes["PagePatch"],
	url: string
};
	/** The output of our update `Parameter` mutation. */
["UpdateParameterPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Parameter` that was updated by this mutation. */
	parameter?: ModelTypes["Parameter"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `Parameter`. May be used by Relay 1. */
	parameterEdge?: ModelTypes["ParametersEdge"] | undefined
};
	/** All input for the `updateParameterByNodeId` mutation. */
["UpdateParameterByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Parameter` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Parameter` being updated. */
	patch: ModelTypes["ParameterPatch"]
};
	/** Represents an update to a `Parameter`. Fields that are set will be updated. */
["ParameterPatch"]: {
	paName?: string | undefined,
	paValue?: string | undefined
};
	/** All input for the `updateParameter` mutation. */
["UpdateParameterInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `Parameter` being updated. */
	patch: ModelTypes["ParameterPatch"],
	paName: string
};
	/** The output of our update `Pary` mutation. */
["UpdateParyPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Pary` that was updated by this mutation. */
	pary?: ModelTypes["Pary"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Pary`. */
	userByPIdPartner?: ModelTypes["User"] | undefined,
	/** An edge for our `Pary`. May be used by Relay 1. */
	paryEdge?: ModelTypes["PariesEdge"] | undefined
};
	/** All input for the `updateParyByNodeId` mutation. */
["UpdateParyByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Pary` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Pary` being updated. */
	patch: ModelTypes["ParyPatch"]
};
	/** Represents an update to a `Pary`. Fields that are set will be updated. */
["ParyPatch"]: {
	pId?: ModelTypes["BigInt"] | undefined,
	pIdPartner?: ModelTypes["BigInt"] | undefined,
	pIdPartnerka?: ModelTypes["BigInt"] | undefined,
	pSttTrida?: ModelTypes["ParyPSttTrida"] | undefined,
	pSttBody?: number | undefined,
	pSttFinale?: boolean | undefined,
	pLatTrida?: ModelTypes["ParyPLatTrida"] | undefined,
	pLatBody?: number | undefined,
	pLatFinale?: boolean | undefined,
	pHodnoceni?: number | undefined,
	pArchiv?: boolean | undefined,
	pTimestampAdd?: ModelTypes["Datetime"] | undefined,
	pTimestampArchive?: ModelTypes["Datetime"] | undefined
};
	/** All input for the `updatePary` mutation. */
["UpdateParyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `Pary` being updated. */
	patch: ModelTypes["ParyPatch"],
	pId: ModelTypes["BigInt"]
};
	/** The output of our update `ParyNavrh` mutation. */
["UpdateParyNavrhPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `ParyNavrh` that was updated by this mutation. */
	paryNavrh?: ModelTypes["ParyNavrh"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnNavrhl?: ModelTypes["User"] | undefined,
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnPartner?: ModelTypes["User"] | undefined,
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnPartnerka?: ModelTypes["User"] | undefined,
	/** An edge for our `ParyNavrh`. May be used by Relay 1. */
	paryNavrhEdge?: ModelTypes["ParyNavrhsEdge"] | undefined
};
	/** All input for the `updateParyNavrhByNodeId` mutation. */
["UpdateParyNavrhByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `ParyNavrh` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `ParyNavrh` being updated. */
	patch: ModelTypes["ParyNavrhPatch"]
};
	/** Represents an update to a `ParyNavrh`. Fields that are set will be updated. */
["ParyNavrhPatch"]: {
	pnId?: ModelTypes["BigInt"] | undefined,
	pnNavrhl?: ModelTypes["BigInt"] | undefined,
	pnPartner?: ModelTypes["BigInt"] | undefined,
	pnPartnerka?: ModelTypes["BigInt"] | undefined
};
	/** All input for the `updateParyNavrh` mutation. */
["UpdateParyNavrhInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `ParyNavrh` being updated. */
	patch: ModelTypes["ParyNavrhPatch"],
	pnId: ModelTypes["BigInt"]
};
	/** The output of our update `Permission` mutation. */
["UpdatePermissionPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Permission` that was updated by this mutation. */
	permission?: ModelTypes["Permission"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `Permission`. May be used by Relay 1. */
	permissionEdge?: ModelTypes["PermissionsEdge"] | undefined
};
	/** All input for the `updatePermissionByNodeId` mutation. */
["UpdatePermissionByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Permission` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Permission` being updated. */
	patch: ModelTypes["PermissionPatch"]
};
	/** Represents an update to a `Permission`. Fields that are set will be updated. */
["PermissionPatch"]: {
	peId?: ModelTypes["BigInt"] | undefined,
	peName?: string | undefined,
	peDescription?: string | undefined,
	peAkce?: number | undefined,
	peAktuality?: number | undefined,
	peAnkety?: number | undefined,
	peDokumenty?: number | undefined,
	peGalerie?: number | undefined,
	peInzerce?: number | undefined,
	peKonzole?: number | undefined,
	peNabidka?: number | undefined,
	peNastenka?: number | undefined,
	peNovinky?: number | undefined,
	pePary?: number | undefined,
	pePlatby?: number | undefined,
	pePermissions?: number | undefined,
	peRozpis?: number | undefined,
	peSkupiny?: number | undefined,
	peUsers?: number | undefined,
	peMain?: number | undefined
};
	/** All input for the `updatePermission` mutation. */
["UpdatePermissionInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `Permission` being updated. */
	patch: ModelTypes["PermissionPatch"],
	peId: ModelTypes["BigInt"]
};
	/** The output of our update `PlatbyCategory` mutation. */
["UpdatePlatbyCategoryPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyCategory` that was updated by this mutation. */
	platbyCategory?: ModelTypes["PlatbyCategory"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `PlatbyCategory`. May be used by Relay 1. */
	platbyCategoryEdge?: ModelTypes["PlatbyCategoriesEdge"] | undefined
};
	/** All input for the `updatePlatbyCategoryByNodeId` mutation. */
["UpdatePlatbyCategoryByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `PlatbyCategory` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `PlatbyCategory` being updated. */
	patch: ModelTypes["PlatbyCategoryPatch"]
};
	/** Represents an update to a `PlatbyCategory`. Fields that are set will be updated. */
["PlatbyCategoryPatch"]: {
	pcId?: ModelTypes["BigInt"] | undefined,
	pcName?: string | undefined,
	pcSymbol?: ModelTypes["BigInt"] | undefined,
	pcAmount?: ModelTypes["BigFloat"] | undefined,
	pcDateDue?: ModelTypes["Date"] | undefined,
	pcValidFrom?: ModelTypes["Date"] | undefined,
	pcValidTo?: ModelTypes["Date"] | undefined,
	pcUseBase?: boolean | undefined,
	pcUsePrefix?: boolean | undefined,
	pcArchive?: boolean | undefined,
	pcVisible?: boolean | undefined
};
	/** All input for the `updatePlatbyCategory` mutation. */
["UpdatePlatbyCategoryInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `PlatbyCategory` being updated. */
	patch: ModelTypes["PlatbyCategoryPatch"],
	pcId: ModelTypes["BigInt"]
};
	/** The output of our update `PlatbyCategoryGroup` mutation. */
["UpdatePlatbyCategoryGroupPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyCategoryGroup` that was updated by this mutation. */
	platbyCategoryGroup?: ModelTypes["PlatbyCategoryGroup"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `PlatbyGroup` that is related to this `PlatbyCategoryGroup`. */
	platbyGroupByPcgIdGroup?: ModelTypes["PlatbyGroup"] | undefined,
	/** Reads a single `PlatbyCategory` that is related to this `PlatbyCategoryGroup`. */
	platbyCategoryByPcgIdCategory?: ModelTypes["PlatbyCategory"] | undefined,
	/** An edge for our `PlatbyCategoryGroup`. May be used by Relay 1. */
	platbyCategoryGroupEdge?: ModelTypes["PlatbyCategoryGroupsEdge"] | undefined
};
	/** All input for the `updatePlatbyCategoryGroupByNodeId` mutation. */
["UpdatePlatbyCategoryGroupByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `PlatbyCategoryGroup` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `PlatbyCategoryGroup` being updated. */
	patch: ModelTypes["PlatbyCategoryGroupPatch"]
};
	/** Represents an update to a `PlatbyCategoryGroup`. Fields that are set will be updated. */
["PlatbyCategoryGroupPatch"]: {
	pcgId?: ModelTypes["BigInt"] | undefined,
	pcgIdGroup?: ModelTypes["BigInt"] | undefined,
	pcgIdCategory?: ModelTypes["BigInt"] | undefined
};
	/** All input for the `updatePlatbyCategoryGroup` mutation. */
["UpdatePlatbyCategoryGroupInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `PlatbyCategoryGroup` being updated. */
	patch: ModelTypes["PlatbyCategoryGroupPatch"],
	pcgId: ModelTypes["BigInt"]
};
	/** The output of our update `PlatbyGroup` mutation. */
["UpdatePlatbyGroupPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyGroup` that was updated by this mutation. */
	platbyGroup?: ModelTypes["PlatbyGroup"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `PlatbyGroup`. May be used by Relay 1. */
	platbyGroupEdge?: ModelTypes["PlatbyGroupsEdge"] | undefined
};
	/** All input for the `updatePlatbyGroupByNodeId` mutation. */
["UpdatePlatbyGroupByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `PlatbyGroup` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `PlatbyGroup` being updated. */
	patch: ModelTypes["PlatbyGroupPatch"]
};
	/** Represents an update to a `PlatbyGroup`. Fields that are set will be updated. */
["PlatbyGroupPatch"]: {
	pgId?: ModelTypes["BigInt"] | undefined,
	pgType?: ModelTypes["BigFloat"] | undefined,
	pgName?: string | undefined,
	pgDescription?: string | undefined,
	pgBase?: ModelTypes["BigInt"] | undefined
};
	/** All input for the `updatePlatbyGroup` mutation. */
["UpdatePlatbyGroupInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `PlatbyGroup` being updated. */
	patch: ModelTypes["PlatbyGroupPatch"],
	pgId: ModelTypes["BigInt"]
};
	/** The output of our update `PlatbyGroupSkupina` mutation. */
["UpdatePlatbyGroupSkupinaPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyGroupSkupina` that was updated by this mutation. */
	platbyGroupSkupina?: ModelTypes["PlatbyGroupSkupina"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `Skupiny` that is related to this `PlatbyGroupSkupina`. */
	skupinyByPgsIdSkupina?: ModelTypes["Skupiny"] | undefined,
	/** Reads a single `PlatbyGroup` that is related to this `PlatbyGroupSkupina`. */
	platbyGroupByPgsIdGroup?: ModelTypes["PlatbyGroup"] | undefined,
	/** An edge for our `PlatbyGroupSkupina`. May be used by Relay 1. */
	platbyGroupSkupinaEdge?: ModelTypes["PlatbyGroupSkupinasEdge"] | undefined
};
	/** All input for the `updatePlatbyGroupSkupinaByNodeId` mutation. */
["UpdatePlatbyGroupSkupinaByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `PlatbyGroupSkupina` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `PlatbyGroupSkupina` being updated. */
	patch: ModelTypes["PlatbyGroupSkupinaPatch"]
};
	/** Represents an update to a `PlatbyGroupSkupina`. Fields that are set will be updated. */
["PlatbyGroupSkupinaPatch"]: {
	pgsId?: ModelTypes["BigInt"] | undefined,
	pgsIdSkupina?: ModelTypes["BigInt"] | undefined,
	pgsIdGroup?: ModelTypes["BigInt"] | undefined
};
	/** All input for the `updatePlatbyGroupSkupina` mutation. */
["UpdatePlatbyGroupSkupinaInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `PlatbyGroupSkupina` being updated. */
	patch: ModelTypes["PlatbyGroupSkupinaPatch"],
	pgsId: ModelTypes["BigInt"]
};
	/** The output of our update `PlatbyItem` mutation. */
["UpdatePlatbyItemPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyItem` that was updated by this mutation. */
	platbyItem?: ModelTypes["PlatbyItem"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `PlatbyItem`. */
	userByPiIdUser?: ModelTypes["User"] | undefined,
	/** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
	platbyCategoryByPiIdCategory?: ModelTypes["PlatbyCategory"] | undefined,
	/** Reads a single `PlatbyRaw` that is related to this `PlatbyItem`. */
	platbyRawByPiIdRaw?: ModelTypes["PlatbyRaw"] | undefined,
	/** An edge for our `PlatbyItem`. May be used by Relay 1. */
	platbyItemEdge?: ModelTypes["PlatbyItemsEdge"] | undefined
};
	/** All input for the `updatePlatbyItemByNodeId` mutation. */
["UpdatePlatbyItemByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `PlatbyItem` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `PlatbyItem` being updated. */
	patch: ModelTypes["PlatbyItemPatch"]
};
	/** Represents an update to a `PlatbyItem`. Fields that are set will be updated. */
["PlatbyItemPatch"]: {
	piId?: ModelTypes["BigInt"] | undefined,
	piIdUser?: ModelTypes["BigInt"] | undefined,
	piIdCategory?: ModelTypes["BigInt"] | undefined,
	piIdRaw?: ModelTypes["BigInt"] | undefined,
	piAmount?: ModelTypes["BigFloat"] | undefined,
	piDate?: ModelTypes["Date"] | undefined,
	piPrefix?: number | undefined
};
	/** All input for the `updatePlatbyItem` mutation. */
["UpdatePlatbyItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `PlatbyItem` being updated. */
	patch: ModelTypes["PlatbyItemPatch"],
	piId: ModelTypes["BigInt"]
};
	/** The output of our update `PlatbyRaw` mutation. */
["UpdatePlatbyRawPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyRaw` that was updated by this mutation. */
	platbyRaw?: ModelTypes["PlatbyRaw"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `PlatbyRaw`. May be used by Relay 1. */
	platbyRawEdge?: ModelTypes["PlatbyRawsEdge"] | undefined
};
	/** All input for the `updatePlatbyRawByNodeId` mutation. */
["UpdatePlatbyRawByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `PlatbyRaw` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `PlatbyRaw` being updated. */
	patch: ModelTypes["PlatbyRawPatch"]
};
	/** Represents an update to a `PlatbyRaw`. Fields that are set will be updated. */
["PlatbyRawPatch"]: {
	prId?: ModelTypes["BigInt"] | undefined,
	prRaw?: string | undefined,
	prHash?: string | undefined,
	prSorted?: boolean | undefined,
	prDiscarded?: boolean | undefined
};
	/** All input for the `updatePlatbyRaw` mutation. */
["UpdatePlatbyRawInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `PlatbyRaw` being updated. */
	patch: ModelTypes["PlatbyRawPatch"],
	prId: ModelTypes["BigInt"]
};
	/** The output of our update `Rozpi` mutation. */
["UpdateRozpiPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Rozpi` that was updated by this mutation. */
	rozpi?: ModelTypes["Rozpi"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Rozpi`. */
	userByRTrener?: ModelTypes["User"] | undefined,
	/** An edge for our `Rozpi`. May be used by Relay 1. */
	rozpiEdge?: ModelTypes["RozpisEdge"] | undefined
};
	/** All input for the `updateRozpiByNodeId` mutation. */
["UpdateRozpiByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Rozpi` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Rozpi` being updated. */
	patch: ModelTypes["RozpiPatch"]
};
	/** Represents an update to a `Rozpi`. Fields that are set will be updated. */
["RozpiPatch"]: {
	rId?: ModelTypes["BigInt"] | undefined,
	rTrener?: ModelTypes["BigInt"] | undefined,
	rKde?: string | undefined,
	rDatum?: ModelTypes["Date"] | undefined,
	rVisible?: boolean | undefined,
	rLock?: boolean | undefined,
	rTimestamp?: ModelTypes["Datetime"] | undefined
};
	/** All input for the `updateRozpi` mutation. */
["UpdateRozpiInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `Rozpi` being updated. */
	patch: ModelTypes["RozpiPatch"],
	rId: ModelTypes["BigInt"]
};
	/** The output of our update `RozpisItem` mutation. */
["UpdateRozpisItemPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `RozpisItem` that was updated by this mutation. */
	rozpisItem?: ModelTypes["RozpisItem"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `Rozpi` that is related to this `RozpisItem`. */
	rozpiByRiIdRodic?: ModelTypes["Rozpi"] | undefined,
	/** Reads a single `Pary` that is related to this `RozpisItem`. */
	paryByRiPartner?: ModelTypes["Pary"] | undefined,
	/** An edge for our `RozpisItem`. May be used by Relay 1. */
	rozpisItemEdge?: ModelTypes["RozpisItemsEdge"] | undefined
};
	/** All input for the `updateRozpisItemByNodeId` mutation. */
["UpdateRozpisItemByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `RozpisItem` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `RozpisItem` being updated. */
	patch: ModelTypes["RozpisItemPatch"]
};
	/** Represents an update to a `RozpisItem`. Fields that are set will be updated. */
["RozpisItemPatch"]: {
	riId?: ModelTypes["BigInt"] | undefined,
	riIdRodic?: ModelTypes["BigInt"] | undefined,
	riPartner?: ModelTypes["BigInt"] | undefined,
	riOd?: ModelTypes["Time"] | undefined,
	riDo?: ModelTypes["Time"] | undefined,
	riLock?: boolean | undefined
};
	/** All input for the `updateRozpisItem` mutation. */
["UpdateRozpisItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `RozpisItem` being updated. */
	patch: ModelTypes["RozpisItemPatch"],
	riId: ModelTypes["BigInt"]
};
	/** The output of our update `Session` mutation. */
["UpdateSessionPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Session` that was updated by this mutation. */
	session?: ModelTypes["Session"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Session`. */
	userBySsUser?: ModelTypes["User"] | undefined,
	/** An edge for our `Session`. May be used by Relay 1. */
	sessionEdge?: ModelTypes["SessionsEdge"] | undefined
};
	/** All input for the `updateSessionByNodeId` mutation. */
["UpdateSessionByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Session` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Session` being updated. */
	patch: ModelTypes["SessionPatch"]
};
	/** Represents an update to a `Session`. Fields that are set will be updated. */
["SessionPatch"]: {
	ssId?: string | undefined,
	ssData?: string | undefined,
	ssUpdatedAt?: ModelTypes["Datetime"] | undefined,
	ssLifetime?: ModelTypes["BigInt"] | undefined,
	ssUser?: ModelTypes["BigInt"] | undefined
};
	/** All input for the `updateSession` mutation. */
["UpdateSessionInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `Session` being updated. */
	patch: ModelTypes["SessionPatch"],
	ssId: string
};
	/** The output of our update `Skupiny` mutation. */
["UpdateSkupinyPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Skupiny` that was updated by this mutation. */
	skupiny?: ModelTypes["Skupiny"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `Skupiny`. May be used by Relay 1. */
	skupinyEdge?: ModelTypes["SkupiniesEdge"] | undefined
};
	/** All input for the `updateSkupinyByNodeId` mutation. */
["UpdateSkupinyByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Skupiny` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Skupiny` being updated. */
	patch: ModelTypes["SkupinyPatch"]
};
	/** Represents an update to a `Skupiny`. Fields that are set will be updated. */
["SkupinyPatch"]: {
	sId?: ModelTypes["BigInt"] | undefined,
	sName?: string | undefined,
	sDescription?: string | undefined,
	sColorRgb?: string | undefined,
	sColorText?: string | undefined,
	sLocation?: string | undefined,
	sVisible?: boolean | undefined
};
	/** All input for the `updateSkupiny` mutation. */
["UpdateSkupinyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `Skupiny` being updated. */
	patch: ModelTypes["SkupinyPatch"],
	sId: ModelTypes["BigInt"]
};
	/** The output of our update `Upozorneni` mutation. */
["UpdateUpozorneniPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Upozorneni` that was updated by this mutation. */
	upozorneni?: ModelTypes["Upozorneni"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Upozorneni`. */
	userByUpKdo?: ModelTypes["User"] | undefined,
	/** An edge for our `Upozorneni`. May be used by Relay 1. */
	upozorneniEdge?: ModelTypes["UpozornenisEdge"] | undefined
};
	/** All input for the `updateUpozorneniByNodeId` mutation. */
["UpdateUpozorneniByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Upozorneni` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Upozorneni` being updated. */
	patch: ModelTypes["UpozorneniPatch"]
};
	/** Represents an update to a `Upozorneni`. Fields that are set will be updated. */
["UpozorneniPatch"]: {
	upId?: ModelTypes["BigInt"] | undefined,
	upKdo?: ModelTypes["BigInt"] | undefined,
	upNadpis?: string | undefined,
	upText?: string | undefined,
	upBarvy?: ModelTypes["BigInt"] | undefined,
	upLock?: boolean | undefined,
	upTimestamp?: ModelTypes["Datetime"] | undefined,
	upTimestampAdd?: ModelTypes["Datetime"] | undefined
};
	/** All input for the `updateUpozorneni` mutation. */
["UpdateUpozorneniInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `Upozorneni` being updated. */
	patch: ModelTypes["UpozorneniPatch"],
	upId: ModelTypes["BigInt"]
};
	/** The output of our update `UpozorneniSkupiny` mutation. */
["UpdateUpozorneniSkupinyPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `UpozorneniSkupiny` that was updated by this mutation. */
	upozorneniSkupiny?: ModelTypes["UpozorneniSkupiny"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
	upozorneniByUpsIdRodic?: ModelTypes["Upozorneni"] | undefined,
	/** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
	skupinyByUpsIdSkupina?: ModelTypes["Skupiny"] | undefined,
	/** An edge for our `UpozorneniSkupiny`. May be used by Relay 1. */
	upozorneniSkupinyEdge?: ModelTypes["UpozorneniSkupiniesEdge"] | undefined
};
	/** All input for the `updateUpozorneniSkupinyByNodeId` mutation. */
["UpdateUpozorneniSkupinyByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `UpozorneniSkupiny` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `UpozorneniSkupiny` being updated. */
	patch: ModelTypes["UpozorneniSkupinyPatch"]
};
	/** Represents an update to a `UpozorneniSkupiny`. Fields that are set will be updated. */
["UpozorneniSkupinyPatch"]: {
	upsId?: ModelTypes["BigInt"] | undefined,
	upsIdRodic?: ModelTypes["BigInt"] | undefined,
	upsIdSkupina?: ModelTypes["BigInt"] | undefined,
	upsColor?: string | undefined,
	upsPopis?: string | undefined
};
	/** All input for the `updateUpozorneniSkupiny` mutation. */
["UpdateUpozorneniSkupinyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `UpozorneniSkupiny` being updated. */
	patch: ModelTypes["UpozorneniSkupinyPatch"],
	upsId: ModelTypes["BigInt"]
};
	/** The output of our update `User` mutation. */
["UpdateUserPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `User` that was updated by this mutation. */
	user?: ModelTypes["User"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `Permission` that is related to this `User`. */
	permissionByUGroup?: ModelTypes["Permission"] | undefined,
	/** Reads a single `Skupiny` that is related to this `User`. */
	skupinyByUSkupina?: ModelTypes["Skupiny"] | undefined,
	/** An edge for our `User`. May be used by Relay 1. */
	userEdge?: ModelTypes["UsersEdge"] | undefined
};
	/** All input for the `updateUserByNodeId` mutation. */
["UpdateUserByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `User` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `User` being updated. */
	patch: ModelTypes["UserPatch"]
};
	/** Represents an update to a `User`. Fields that are set will be updated. */
["UserPatch"]: {
	uId?: ModelTypes["BigInt"] | undefined,
	uLogin?: string | undefined,
	uPass?: string | undefined,
	uJmeno?: string | undefined,
	uPrijmeni?: string | undefined,
	uPohlavi?: string | undefined,
	uEmail?: string | undefined,
	uTelefon?: string | undefined,
	uNarozeni?: ModelTypes["Date"] | undefined,
	uRodneCislo?: string | undefined,
	uPoznamky?: string | undefined,
	uTimestamp?: ModelTypes["Datetime"] | undefined,
	uLevel?: number | undefined,
	uGroup?: ModelTypes["BigInt"] | undefined,
	uSkupina?: ModelTypes["BigInt"] | undefined,
	uDancer?: boolean | undefined,
	uBan?: boolean | undefined,
	uLock?: boolean | undefined,
	uConfirmed?: boolean | undefined,
	uSystem?: boolean | undefined,
	uStreet?: string | undefined,
	uConscriptionNumber?: string | undefined,
	uOrientationNumber?: string | undefined,
	uDistrict?: string | undefined,
	uCity?: string | undefined,
	uPostalCode?: string | undefined,
	uNationality?: string | undefined,
	uMemberSince?: ModelTypes["Datetime"] | undefined,
	uMemberUntil?: ModelTypes["Datetime"] | undefined,
	uCreatedAt?: ModelTypes["Datetime"] | undefined,
	uTeacher?: boolean | undefined,
	uGdprSignedAt?: ModelTypes["Datetime"] | undefined
};
	/** All input for the `updateUser` mutation. */
["UpdateUserInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `User` being updated. */
	patch: ModelTypes["UserPatch"],
	uId: ModelTypes["BigInt"]
};
	/** The output of our update `UsersSkupiny` mutation. */
["UpdateUsersSkupinyPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `UsersSkupiny` that was updated by this mutation. */
	usersSkupiny?: ModelTypes["UsersSkupiny"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `UsersSkupiny`. May be used by Relay 1. */
	usersSkupinyEdge?: ModelTypes["UsersSkupiniesEdge"] | undefined
};
	/** All input for the `updateUsersSkupinyByNodeId` mutation. */
["UpdateUsersSkupinyByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `UsersSkupiny` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `UsersSkupiny` being updated. */
	patch: ModelTypes["UsersSkupinyPatch"]
};
	/** Represents an update to a `UsersSkupiny`. Fields that are set will be updated. */
["UsersSkupinyPatch"]: {
	usId?: ModelTypes["BigInt"] | undefined,
	usColor?: string | undefined,
	usPlatbaMesic?: ModelTypes["BigInt"] | undefined,
	usPlatbaCtvrtrok?: ModelTypes["BigInt"] | undefined,
	usPlatbaPulrok?: ModelTypes["BigInt"] | undefined,
	usPopis?: string | undefined
};
	/** All input for the `updateUsersSkupiny` mutation. */
["UpdateUsersSkupinyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `UsersSkupiny` being updated. */
	patch: ModelTypes["UsersSkupinyPatch"],
	usId: ModelTypes["BigInt"]
};
	/** The output of our update `Video` mutation. */
["UpdateVideoPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Video` that was updated by this mutation. */
	video?: ModelTypes["Video"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `Video`. May be used by Relay 1. */
	videoEdge?: ModelTypes["VideosEdge"] | undefined
};
	/** All input for the `updateVideoByNodeId` mutation. */
["UpdateVideoByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Video` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Video` being updated. */
	patch: ModelTypes["VideoPatch"]
};
	/** Represents an update to a `Video`. Fields that are set will be updated. */
["VideoPatch"]: {
	vId?: ModelTypes["BigInt"] | undefined,
	vUri?: string | undefined,
	vTitle?: string | undefined,
	vAuthor?: string | undefined,
	vDescription?: string | undefined,
	vPlaylist?: string | undefined,
	vCreatedAt?: ModelTypes["Datetime"] | undefined,
	vUpdatedAt?: ModelTypes["Datetime"] | undefined
};
	/** All input for the `updateVideo` mutation. */
["UpdateVideoInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `Video` being updated. */
	patch: ModelTypes["VideoPatch"],
	vId: ModelTypes["BigInt"]
};
	/** The output of our update `VideoList` mutation. */
["UpdateVideoListPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `VideoList` that was updated by this mutation. */
	videoList?: ModelTypes["VideoList"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `VideoList`. May be used by Relay 1. */
	videoListEdge?: ModelTypes["VideoListsEdge"] | undefined
};
	/** All input for the `updateVideoListByNodeId` mutation. */
["UpdateVideoListByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `VideoList` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `VideoList` being updated. */
	patch: ModelTypes["VideoListPatch"]
};
	/** Represents an update to a `VideoList`. Fields that are set will be updated. */
["VideoListPatch"]: {
	vlId?: ModelTypes["BigInt"] | undefined,
	vlUrl?: string | undefined,
	vlTitle?: string | undefined,
	vlDescription?: string | undefined,
	vlCount?: ModelTypes["BigInt"] | undefined,
	vlCreatedAt?: ModelTypes["Datetime"] | undefined,
	vlLastChecked?: ModelTypes["Datetime"] | undefined
};
	/** All input for the `updateVideoList` mutation. */
["UpdateVideoListInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `VideoList` being updated. */
	patch: ModelTypes["VideoListPatch"],
	vlId: ModelTypes["BigInt"]
};
	/** The output of our update `VideoSource` mutation. */
["UpdateVideoSourcePayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `VideoSource` that was updated by this mutation. */
	videoSource?: ModelTypes["VideoSource"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `VideoSource`. May be used by Relay 1. */
	videoSourceEdge?: ModelTypes["VideoSourcesEdge"] | undefined
};
	/** All input for the `updateVideoSourceByNodeId` mutation. */
["UpdateVideoSourceByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `VideoSource` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `VideoSource` being updated. */
	patch: ModelTypes["VideoSourcePatch"]
};
	/** Represents an update to a `VideoSource`. Fields that are set will be updated. */
["VideoSourcePatch"]: {
	vsId?: ModelTypes["BigInt"] | undefined,
	vsUrl?: string | undefined,
	vsTitle?: string | undefined,
	vsDescription?: string | undefined,
	vsCreatedAt?: ModelTypes["Datetime"] | undefined,
	vsLastChecked?: ModelTypes["Datetime"] | undefined
};
	/** All input for the `updateVideoSource` mutation. */
["UpdateVideoSourceInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `VideoSource` being updated. */
	patch: ModelTypes["VideoSourcePatch"],
	vsId: ModelTypes["BigInt"]
};
	/** The output of our delete `Akce` mutation. */
["DeleteAkcePayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Akce` that was deleted by this mutation. */
	akce?: ModelTypes["Akce"] | undefined,
	deletedAkceNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `Akce`. May be used by Relay 1. */
	akceEdge?: ModelTypes["AkcesEdge"] | undefined
};
	/** All input for the `deleteAkceByNodeId` mutation. */
["DeleteAkceByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Akce` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteAkce` mutation. */
["DeleteAkceInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	aId: ModelTypes["BigInt"]
};
	/** The output of our delete `AkceItem` mutation. */
["DeleteAkceItemPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `AkceItem` that was deleted by this mutation. */
	akceItem?: ModelTypes["AkceItem"] | undefined,
	deletedAkceItemNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `Akce` that is related to this `AkceItem`. */
	akceByAiIdRodic?: ModelTypes["Akce"] | undefined,
	/** Reads a single `User` that is related to this `AkceItem`. */
	userByAiUser?: ModelTypes["User"] | undefined,
	/** An edge for our `AkceItem`. May be used by Relay 1. */
	akceItemEdge?: ModelTypes["AkceItemsEdge"] | undefined
};
	/** All input for the `deleteAkceItemByNodeId` mutation. */
["DeleteAkceItemByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `AkceItem` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteAkceItem` mutation. */
["DeleteAkceItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	aiId: ModelTypes["BigInt"]
};
	/** The output of our delete `Aktuality` mutation. */
["DeleteAktualityPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Aktuality` that was deleted by this mutation. */
	aktuality?: ModelTypes["Aktuality"] | undefined,
	deletedAktualityNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Aktuality`. */
	userByAtKdo?: ModelTypes["User"] | undefined,
	/** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
	galerieFotoByAtFotoMain?: ModelTypes["GalerieFoto"] | undefined,
	/** An edge for our `Aktuality`. May be used by Relay 1. */
	aktualityEdge?: ModelTypes["AktualitiesEdge"] | undefined
};
	/** All input for the `deleteAktualityByNodeId` mutation. */
["DeleteAktualityByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Aktuality` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteAktuality` mutation. */
["DeleteAktualityInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	atId: ModelTypes["BigInt"]
};
	/** The output of our delete `Dokumenty` mutation. */
["DeleteDokumentyPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Dokumenty` that was deleted by this mutation. */
	dokumenty?: ModelTypes["Dokumenty"] | undefined,
	deletedDokumentyNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Dokumenty`. */
	userByDKdo?: ModelTypes["User"] | undefined,
	/** An edge for our `Dokumenty`. May be used by Relay 1. */
	dokumentyEdge?: ModelTypes["DokumentiesEdge"] | undefined
};
	/** All input for the `deleteDokumentyByNodeId` mutation. */
["DeleteDokumentyByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Dokumenty` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteDokumenty` mutation. */
["DeleteDokumentyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	dId: ModelTypes["BigInt"]
};
	/** The output of our delete `GalerieDir` mutation. */
["DeleteGalerieDirPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `GalerieDir` that was deleted by this mutation. */
	galerieDir?: ModelTypes["GalerieDir"] | undefined,
	deletedGalerieDirNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `GalerieDir`. May be used by Relay 1. */
	galerieDirEdge?: ModelTypes["GalerieDirsEdge"] | undefined
};
	/** All input for the `deleteGalerieDirByNodeId` mutation. */
["DeleteGalerieDirByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `GalerieDir` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteGalerieDir` mutation. */
["DeleteGalerieDirInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	gdId: ModelTypes["BigInt"]
};
	/** The output of our delete `GalerieFoto` mutation. */
["DeleteGalerieFotoPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `GalerieFoto` that was deleted by this mutation. */
	galerieFoto?: ModelTypes["GalerieFoto"] | undefined,
	deletedGalerieFotoNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
	galerieDirByGfIdRodic?: ModelTypes["GalerieDir"] | undefined,
	/** Reads a single `User` that is related to this `GalerieFoto`. */
	userByGfKdo?: ModelTypes["User"] | undefined,
	/** An edge for our `GalerieFoto`. May be used by Relay 1. */
	galerieFotoEdge?: ModelTypes["GalerieFotosEdge"] | undefined
};
	/** All input for the `deleteGalerieFotoByNodeId` mutation. */
["DeleteGalerieFotoByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `GalerieFoto` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteGalerieFoto` mutation. */
["DeleteGalerieFotoInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	gfId: ModelTypes["BigInt"]
};
	/** The output of our delete `Nabidka` mutation. */
["DeleteNabidkaPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Nabidka` that was deleted by this mutation. */
	nabidka?: ModelTypes["Nabidka"] | undefined,
	deletedNabidkaNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Nabidka`. */
	userByNTrener?: ModelTypes["User"] | undefined,
	/** An edge for our `Nabidka`. May be used by Relay 1. */
	nabidkaEdge?: ModelTypes["NabidkasEdge"] | undefined
};
	/** All input for the `deleteNabidkaByNodeId` mutation. */
["DeleteNabidkaByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Nabidka` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteNabidka` mutation. */
["DeleteNabidkaInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	nId: ModelTypes["BigInt"]
};
	/** The output of our delete `NabidkaItem` mutation. */
["DeleteNabidkaItemPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `NabidkaItem` that was deleted by this mutation. */
	nabidkaItem?: ModelTypes["NabidkaItem"] | undefined,
	deletedNabidkaItemNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `Nabidka` that is related to this `NabidkaItem`. */
	nabidkaByNiIdRodic?: ModelTypes["Nabidka"] | undefined,
	/** Reads a single `Pary` that is related to this `NabidkaItem`. */
	paryByNiPartner?: ModelTypes["Pary"] | undefined,
	/** An edge for our `NabidkaItem`. May be used by Relay 1. */
	nabidkaItemEdge?: ModelTypes["NabidkaItemsEdge"] | undefined
};
	/** All input for the `deleteNabidkaItemByNodeId` mutation. */
["DeleteNabidkaItemByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `NabidkaItem` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteNabidkaItem` mutation. */
["DeleteNabidkaItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	niId: ModelTypes["BigInt"]
};
	/** The output of our delete `Parameter` mutation. */
["DeleteParameterPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Parameter` that was deleted by this mutation. */
	parameter?: ModelTypes["Parameter"] | undefined,
	deletedParameterNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `Parameter`. May be used by Relay 1. */
	parameterEdge?: ModelTypes["ParametersEdge"] | undefined
};
	/** All input for the `deleteParameterByNodeId` mutation. */
["DeleteParameterByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Parameter` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteParameter` mutation. */
["DeleteParameterInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	paName: string
};
	/** The output of our delete `Pary` mutation. */
["DeleteParyPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Pary` that was deleted by this mutation. */
	pary?: ModelTypes["Pary"] | undefined,
	deletedParyNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Pary`. */
	userByPIdPartner?: ModelTypes["User"] | undefined,
	/** An edge for our `Pary`. May be used by Relay 1. */
	paryEdge?: ModelTypes["PariesEdge"] | undefined
};
	/** All input for the `deleteParyByNodeId` mutation. */
["DeleteParyByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Pary` to be deleted. */
	nodeId: string
};
	/** All input for the `deletePary` mutation. */
["DeleteParyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	pId: ModelTypes["BigInt"]
};
	/** The output of our delete `ParyNavrh` mutation. */
["DeleteParyNavrhPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `ParyNavrh` that was deleted by this mutation. */
	paryNavrh?: ModelTypes["ParyNavrh"] | undefined,
	deletedParyNavrhNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnNavrhl?: ModelTypes["User"] | undefined,
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnPartner?: ModelTypes["User"] | undefined,
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnPartnerka?: ModelTypes["User"] | undefined,
	/** An edge for our `ParyNavrh`. May be used by Relay 1. */
	paryNavrhEdge?: ModelTypes["ParyNavrhsEdge"] | undefined
};
	/** All input for the `deleteParyNavrhByNodeId` mutation. */
["DeleteParyNavrhByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `ParyNavrh` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteParyNavrh` mutation. */
["DeleteParyNavrhInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	pnId: ModelTypes["BigInt"]
};
	/** The output of our delete `Permission` mutation. */
["DeletePermissionPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Permission` that was deleted by this mutation. */
	permission?: ModelTypes["Permission"] | undefined,
	deletedPermissionNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `Permission`. May be used by Relay 1. */
	permissionEdge?: ModelTypes["PermissionsEdge"] | undefined
};
	/** All input for the `deletePermissionByNodeId` mutation. */
["DeletePermissionByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Permission` to be deleted. */
	nodeId: string
};
	/** All input for the `deletePermission` mutation. */
["DeletePermissionInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	peId: ModelTypes["BigInt"]
};
	/** The output of our delete `PlatbyCategory` mutation. */
["DeletePlatbyCategoryPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyCategory` that was deleted by this mutation. */
	platbyCategory?: ModelTypes["PlatbyCategory"] | undefined,
	deletedPlatbyCategoryNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `PlatbyCategory`. May be used by Relay 1. */
	platbyCategoryEdge?: ModelTypes["PlatbyCategoriesEdge"] | undefined
};
	/** All input for the `deletePlatbyCategoryByNodeId` mutation. */
["DeletePlatbyCategoryByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `PlatbyCategory` to be deleted. */
	nodeId: string
};
	/** All input for the `deletePlatbyCategory` mutation. */
["DeletePlatbyCategoryInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	pcId: ModelTypes["BigInt"]
};
	/** The output of our delete `PlatbyCategoryGroup` mutation. */
["DeletePlatbyCategoryGroupPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyCategoryGroup` that was deleted by this mutation. */
	platbyCategoryGroup?: ModelTypes["PlatbyCategoryGroup"] | undefined,
	deletedPlatbyCategoryGroupNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `PlatbyGroup` that is related to this `PlatbyCategoryGroup`. */
	platbyGroupByPcgIdGroup?: ModelTypes["PlatbyGroup"] | undefined,
	/** Reads a single `PlatbyCategory` that is related to this `PlatbyCategoryGroup`. */
	platbyCategoryByPcgIdCategory?: ModelTypes["PlatbyCategory"] | undefined,
	/** An edge for our `PlatbyCategoryGroup`. May be used by Relay 1. */
	platbyCategoryGroupEdge?: ModelTypes["PlatbyCategoryGroupsEdge"] | undefined
};
	/** All input for the `deletePlatbyCategoryGroupByNodeId` mutation. */
["DeletePlatbyCategoryGroupByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `PlatbyCategoryGroup` to be deleted. */
	nodeId: string
};
	/** All input for the `deletePlatbyCategoryGroup` mutation. */
["DeletePlatbyCategoryGroupInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	pcgId: ModelTypes["BigInt"]
};
	/** The output of our delete `PlatbyGroup` mutation. */
["DeletePlatbyGroupPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyGroup` that was deleted by this mutation. */
	platbyGroup?: ModelTypes["PlatbyGroup"] | undefined,
	deletedPlatbyGroupNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `PlatbyGroup`. May be used by Relay 1. */
	platbyGroupEdge?: ModelTypes["PlatbyGroupsEdge"] | undefined
};
	/** All input for the `deletePlatbyGroupByNodeId` mutation. */
["DeletePlatbyGroupByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `PlatbyGroup` to be deleted. */
	nodeId: string
};
	/** All input for the `deletePlatbyGroup` mutation. */
["DeletePlatbyGroupInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	pgId: ModelTypes["BigInt"]
};
	/** The output of our delete `PlatbyGroupSkupina` mutation. */
["DeletePlatbyGroupSkupinaPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyGroupSkupina` that was deleted by this mutation. */
	platbyGroupSkupina?: ModelTypes["PlatbyGroupSkupina"] | undefined,
	deletedPlatbyGroupSkupinaNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `Skupiny` that is related to this `PlatbyGroupSkupina`. */
	skupinyByPgsIdSkupina?: ModelTypes["Skupiny"] | undefined,
	/** Reads a single `PlatbyGroup` that is related to this `PlatbyGroupSkupina`. */
	platbyGroupByPgsIdGroup?: ModelTypes["PlatbyGroup"] | undefined,
	/** An edge for our `PlatbyGroupSkupina`. May be used by Relay 1. */
	platbyGroupSkupinaEdge?: ModelTypes["PlatbyGroupSkupinasEdge"] | undefined
};
	/** All input for the `deletePlatbyGroupSkupinaByNodeId` mutation. */
["DeletePlatbyGroupSkupinaByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `PlatbyGroupSkupina` to be deleted. */
	nodeId: string
};
	/** All input for the `deletePlatbyGroupSkupina` mutation. */
["DeletePlatbyGroupSkupinaInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	pgsId: ModelTypes["BigInt"]
};
	/** The output of our delete `PlatbyItem` mutation. */
["DeletePlatbyItemPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyItem` that was deleted by this mutation. */
	platbyItem?: ModelTypes["PlatbyItem"] | undefined,
	deletedPlatbyItemNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `PlatbyItem`. */
	userByPiIdUser?: ModelTypes["User"] | undefined,
	/** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
	platbyCategoryByPiIdCategory?: ModelTypes["PlatbyCategory"] | undefined,
	/** Reads a single `PlatbyRaw` that is related to this `PlatbyItem`. */
	platbyRawByPiIdRaw?: ModelTypes["PlatbyRaw"] | undefined,
	/** An edge for our `PlatbyItem`. May be used by Relay 1. */
	platbyItemEdge?: ModelTypes["PlatbyItemsEdge"] | undefined
};
	/** All input for the `deletePlatbyItemByNodeId` mutation. */
["DeletePlatbyItemByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `PlatbyItem` to be deleted. */
	nodeId: string
};
	/** All input for the `deletePlatbyItem` mutation. */
["DeletePlatbyItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	piId: ModelTypes["BigInt"]
};
	/** The output of our delete `PlatbyRaw` mutation. */
["DeletePlatbyRawPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyRaw` that was deleted by this mutation. */
	platbyRaw?: ModelTypes["PlatbyRaw"] | undefined,
	deletedPlatbyRawNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `PlatbyRaw`. May be used by Relay 1. */
	platbyRawEdge?: ModelTypes["PlatbyRawsEdge"] | undefined
};
	/** All input for the `deletePlatbyRawByNodeId` mutation. */
["DeletePlatbyRawByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `PlatbyRaw` to be deleted. */
	nodeId: string
};
	/** All input for the `deletePlatbyRaw` mutation. */
["DeletePlatbyRawInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	prId: ModelTypes["BigInt"]
};
	/** The output of our delete `Rozpi` mutation. */
["DeleteRozpiPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Rozpi` that was deleted by this mutation. */
	rozpi?: ModelTypes["Rozpi"] | undefined,
	deletedRozpiNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Rozpi`. */
	userByRTrener?: ModelTypes["User"] | undefined,
	/** An edge for our `Rozpi`. May be used by Relay 1. */
	rozpiEdge?: ModelTypes["RozpisEdge"] | undefined
};
	/** All input for the `deleteRozpiByNodeId` mutation. */
["DeleteRozpiByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Rozpi` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteRozpi` mutation. */
["DeleteRozpiInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	rId: ModelTypes["BigInt"]
};
	/** The output of our delete `RozpisItem` mutation. */
["DeleteRozpisItemPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `RozpisItem` that was deleted by this mutation. */
	rozpisItem?: ModelTypes["RozpisItem"] | undefined,
	deletedRozpisItemNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `Rozpi` that is related to this `RozpisItem`. */
	rozpiByRiIdRodic?: ModelTypes["Rozpi"] | undefined,
	/** Reads a single `Pary` that is related to this `RozpisItem`. */
	paryByRiPartner?: ModelTypes["Pary"] | undefined,
	/** An edge for our `RozpisItem`. May be used by Relay 1. */
	rozpisItemEdge?: ModelTypes["RozpisItemsEdge"] | undefined
};
	/** All input for the `deleteRozpisItemByNodeId` mutation. */
["DeleteRozpisItemByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `RozpisItem` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteRozpisItem` mutation. */
["DeleteRozpisItemInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	riId: ModelTypes["BigInt"]
};
	/** The output of our delete `Session` mutation. */
["DeleteSessionPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Session` that was deleted by this mutation. */
	session?: ModelTypes["Session"] | undefined,
	deletedSessionNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Session`. */
	userBySsUser?: ModelTypes["User"] | undefined,
	/** An edge for our `Session`. May be used by Relay 1. */
	sessionEdge?: ModelTypes["SessionsEdge"] | undefined
};
	/** All input for the `deleteSessionByNodeId` mutation. */
["DeleteSessionByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Session` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteSession` mutation. */
["DeleteSessionInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	ssId: string
};
	/** The output of our delete `Skupiny` mutation. */
["DeleteSkupinyPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Skupiny` that was deleted by this mutation. */
	skupiny?: ModelTypes["Skupiny"] | undefined,
	deletedSkupinyNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `Skupiny`. May be used by Relay 1. */
	skupinyEdge?: ModelTypes["SkupiniesEdge"] | undefined
};
	/** All input for the `deleteSkupinyByNodeId` mutation. */
["DeleteSkupinyByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Skupiny` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteSkupiny` mutation. */
["DeleteSkupinyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	sId: ModelTypes["BigInt"]
};
	/** The output of our delete `Upozorneni` mutation. */
["DeleteUpozorneniPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Upozorneni` that was deleted by this mutation. */
	upozorneni?: ModelTypes["Upozorneni"] | undefined,
	deletedUpozorneniNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Upozorneni`. */
	userByUpKdo?: ModelTypes["User"] | undefined,
	/** An edge for our `Upozorneni`. May be used by Relay 1. */
	upozorneniEdge?: ModelTypes["UpozornenisEdge"] | undefined
};
	/** All input for the `deleteUpozorneniByNodeId` mutation. */
["DeleteUpozorneniByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Upozorneni` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteUpozorneni` mutation. */
["DeleteUpozorneniInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	upId: ModelTypes["BigInt"]
};
	/** The output of our delete `UpozorneniSkupiny` mutation. */
["DeleteUpozorneniSkupinyPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `UpozorneniSkupiny` that was deleted by this mutation. */
	upozorneniSkupiny?: ModelTypes["UpozorneniSkupiny"] | undefined,
	deletedUpozorneniSkupinyNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
	upozorneniByUpsIdRodic?: ModelTypes["Upozorneni"] | undefined,
	/** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
	skupinyByUpsIdSkupina?: ModelTypes["Skupiny"] | undefined,
	/** An edge for our `UpozorneniSkupiny`. May be used by Relay 1. */
	upozorneniSkupinyEdge?: ModelTypes["UpozorneniSkupiniesEdge"] | undefined
};
	/** All input for the `deleteUpozorneniSkupinyByNodeId` mutation. */
["DeleteUpozorneniSkupinyByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `UpozorneniSkupiny` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteUpozorneniSkupiny` mutation. */
["DeleteUpozorneniSkupinyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	upsId: ModelTypes["BigInt"]
};
	/** The output of our delete `User` mutation. */
["DeleteUserPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `User` that was deleted by this mutation. */
	user?: ModelTypes["User"] | undefined,
	deletedUserNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** Reads a single `Permission` that is related to this `User`. */
	permissionByUGroup?: ModelTypes["Permission"] | undefined,
	/** Reads a single `Skupiny` that is related to this `User`. */
	skupinyByUSkupina?: ModelTypes["Skupiny"] | undefined,
	/** An edge for our `User`. May be used by Relay 1. */
	userEdge?: ModelTypes["UsersEdge"] | undefined
};
	/** All input for the `deleteUserByNodeId` mutation. */
["DeleteUserByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `User` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteUser` mutation. */
["DeleteUserInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	uId: ModelTypes["BigInt"]
};
	/** The output of our delete `UsersSkupiny` mutation. */
["DeleteUsersSkupinyPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `UsersSkupiny` that was deleted by this mutation. */
	usersSkupiny?: ModelTypes["UsersSkupiny"] | undefined,
	deletedUsersSkupinyNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `UsersSkupiny`. May be used by Relay 1. */
	usersSkupinyEdge?: ModelTypes["UsersSkupiniesEdge"] | undefined
};
	/** All input for the `deleteUsersSkupinyByNodeId` mutation. */
["DeleteUsersSkupinyByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `UsersSkupiny` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteUsersSkupiny` mutation. */
["DeleteUsersSkupinyInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	usId: ModelTypes["BigInt"]
};
	/** The output of our delete `Video` mutation. */
["DeleteVideoPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Video` that was deleted by this mutation. */
	video?: ModelTypes["Video"] | undefined,
	deletedVideoNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `Video`. May be used by Relay 1. */
	videoEdge?: ModelTypes["VideosEdge"] | undefined
};
	/** All input for the `deleteVideoByNodeId` mutation. */
["DeleteVideoByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Video` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteVideo` mutation. */
["DeleteVideoInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	vId: ModelTypes["BigInt"]
};
	/** The output of our delete `VideoList` mutation. */
["DeleteVideoListPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `VideoList` that was deleted by this mutation. */
	videoList?: ModelTypes["VideoList"] | undefined,
	deletedVideoListNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `VideoList`. May be used by Relay 1. */
	videoListEdge?: ModelTypes["VideoListsEdge"] | undefined
};
	/** All input for the `deleteVideoListByNodeId` mutation. */
["DeleteVideoListByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `VideoList` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteVideoList` mutation. */
["DeleteVideoListInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	vlId: ModelTypes["BigInt"]
};
	/** The output of our delete `VideoSource` mutation. */
["DeleteVideoSourcePayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `VideoSource` that was deleted by this mutation. */
	videoSource?: ModelTypes["VideoSource"] | undefined,
	deletedVideoSourceNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined,
	/** An edge for our `VideoSource`. May be used by Relay 1. */
	videoSourceEdge?: ModelTypes["VideoSourcesEdge"] | undefined
};
	/** All input for the `deleteVideoSourceByNodeId` mutation. */
["DeleteVideoSourceByNodeIdInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `VideoSource` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteVideoSource` mutation. */
["DeleteVideoSourceInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	vsId: ModelTypes["BigInt"]
};
	/** The output of our `login` mutation. */
["LoginPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	result?: ModelTypes["LoginRecord"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined
};
	/** The return type of our `login` mutation. */
["LoginRecord"]: {
		couple?: ModelTypes["Pary"] | undefined,
	sess?: ModelTypes["Session"] | undefined,
	usr?: ModelTypes["User"] | undefined
};
	/** All input for the `login` mutation. */
["LoginInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	login: string,
	passwd: string
};
	/** The output of our `logout` mutation. */
["LogoutPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined
};
	/** All input for the `logout` mutation. */
["LogoutInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined
};
	/** The output of our `prospectFormDancer` mutation. */
["ProspectFormDancerPayload"]: {
		/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: ModelTypes["Query"] | undefined
};
	/** All input for the `prospectFormDancer` mutation. */
["ProspectFormDancerInput"]: {
	/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	cohort: ModelTypes["CrmCohort"],
	prospectData: ModelTypes["ProspectDatumInput"],
	origin: string,
	note: string
};
	/** An input for mutations affecting `ProspectDatum` */
["ProspectDatumInput"]: {
	name?: string | undefined,
	surname?: string | undefined,
	email?: string | undefined,
	phone?: string | undefined,
	yearofbirth?: string | undefined
};
	["Upload"]: {
		uploadUrl: string
};
	["UploadInput"]: {
	directory?: string | undefined,
	filename: string
}
    }

export type GraphQLTypes = {
    /** The root query type which gives access points into the data universe. */
["Query"]: {
	__typename: "Query",
	/** Exposes the root query type nested one level down. This is helpful for Relay 1
which can only query top level fields if they are in a particular form. */
	query: GraphQLTypes["Query"],
	/** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
	nodeId: string,
	/** Fetches an object given its globally unique `ID`. */
	node?: GraphQLTypes["Node"] | undefined,
	/** Reads and enables pagination through a set of `Akce`. */
	akces?: GraphQLTypes["AkcesConnection"] | undefined,
	/** Reads and enables pagination through a set of `AkceItem`. */
	akceItems?: GraphQLTypes["AkceItemsConnection"] | undefined,
	/** Reads and enables pagination through a set of `Aktuality`. */
	aktualities?: GraphQLTypes["AktualitiesConnection"] | undefined,
	/** Reads and enables pagination through a set of `Dokumenty`. */
	dokumenties?: GraphQLTypes["DokumentiesConnection"] | undefined,
	/** Reads and enables pagination through a set of `GalerieDir`. */
	galerieDirs?: GraphQLTypes["GalerieDirsConnection"] | undefined,
	/** Reads and enables pagination through a set of `GalerieFoto`. */
	galerieFotos?: GraphQLTypes["GalerieFotosConnection"] | undefined,
	/** Reads and enables pagination through a set of `Member`. */
	members?: GraphQLTypes["MembersConnection"] | undefined,
	/** Reads and enables pagination through a set of `Nabidka`. */
	nabidkas?: GraphQLTypes["NabidkasConnection"] | undefined,
	/** Reads and enables pagination through a set of `NabidkaItem`. */
	nabidkaItems?: GraphQLTypes["NabidkaItemsConnection"] | undefined,
	/** Reads and enables pagination through a set of `Page`. */
	pages?: GraphQLTypes["PagesConnection"] | undefined,
	/** Reads and enables pagination through a set of `PageRevision`. */
	pageRevisions?: GraphQLTypes["PageRevisionsConnection"] | undefined,
	/** Reads and enables pagination through a set of `Parameter`. */
	parameters?: GraphQLTypes["ParametersConnection"] | undefined,
	/** Reads and enables pagination through a set of `Pary`. */
	paries?: GraphQLTypes["PariesConnection"] | undefined,
	/** Reads and enables pagination through a set of `ParyNavrh`. */
	paryNavrhs?: GraphQLTypes["ParyNavrhsConnection"] | undefined,
	/** Reads and enables pagination through a set of `Permission`. */
	permissions?: GraphQLTypes["PermissionsConnection"] | undefined,
	/** Reads and enables pagination through a set of `PlatbyCategory`. */
	platbyCategories?: GraphQLTypes["PlatbyCategoriesConnection"] | undefined,
	/** Reads and enables pagination through a set of `PlatbyCategoryGroup`. */
	platbyCategoryGroups?: GraphQLTypes["PlatbyCategoryGroupsConnection"] | undefined,
	/** Reads and enables pagination through a set of `PlatbyGroup`. */
	platbyGroups?: GraphQLTypes["PlatbyGroupsConnection"] | undefined,
	/** Reads and enables pagination through a set of `PlatbyGroupSkupina`. */
	platbyGroupSkupinas?: GraphQLTypes["PlatbyGroupSkupinasConnection"] | undefined,
	/** Reads and enables pagination through a set of `PlatbyItem`. */
	platbyItems?: GraphQLTypes["PlatbyItemsConnection"] | undefined,
	/** Reads and enables pagination through a set of `PlatbyRaw`. */
	platbyRaws?: GraphQLTypes["PlatbyRawsConnection"] | undefined,
	/** Reads and enables pagination through a set of `Rozpi`. */
	rozpis?: GraphQLTypes["RozpisConnection"] | undefined,
	/** Reads and enables pagination through a set of `RozpisItem`. */
	rozpisItems?: GraphQLTypes["RozpisItemsConnection"] | undefined,
	/** Reads and enables pagination through a set of `Session`. */
	sessions?: GraphQLTypes["SessionsConnection"] | undefined,
	/** Reads and enables pagination through a set of `Skupiny`. */
	skupinies?: GraphQLTypes["SkupiniesConnection"] | undefined,
	/** Reads and enables pagination through a set of `Upozorneni`. */
	upozornenis?: GraphQLTypes["UpozornenisConnection"] | undefined,
	/** Reads and enables pagination through a set of `UpozorneniSkupiny`. */
	upozorneniSkupinies?: GraphQLTypes["UpozorneniSkupiniesConnection"] | undefined,
	/** Reads and enables pagination through a set of `User`. */
	users?: GraphQLTypes["UsersConnection"] | undefined,
	/** Reads and enables pagination through a set of `UsersSkupiny`. */
	usersSkupinies?: GraphQLTypes["UsersSkupiniesConnection"] | undefined,
	/** Reads and enables pagination through a set of `Video`. */
	videos?: GraphQLTypes["VideosConnection"] | undefined,
	/** Reads and enables pagination through a set of `VideoList`. */
	videoLists?: GraphQLTypes["VideoListsConnection"] | undefined,
	/** Reads and enables pagination through a set of `VideoSource`. */
	videoSources?: GraphQLTypes["VideoSourcesConnection"] | undefined,
	akce?: GraphQLTypes["Akce"] | undefined,
	akceItem?: GraphQLTypes["AkceItem"] | undefined,
	aktuality?: GraphQLTypes["Aktuality"] | undefined,
	dokumenty?: GraphQLTypes["Dokumenty"] | undefined,
	galerieDir?: GraphQLTypes["GalerieDir"] | undefined,
	galerieFoto?: GraphQLTypes["GalerieFoto"] | undefined,
	nabidka?: GraphQLTypes["Nabidka"] | undefined,
	nabidkaItem?: GraphQLTypes["NabidkaItem"] | undefined,
	page?: GraphQLTypes["Page"] | undefined,
	pageByUrl?: GraphQLTypes["Page"] | undefined,
	pageRevision?: GraphQLTypes["PageRevision"] | undefined,
	parameter?: GraphQLTypes["Parameter"] | undefined,
	pary?: GraphQLTypes["Pary"] | undefined,
	paryNavrh?: GraphQLTypes["ParyNavrh"] | undefined,
	permission?: GraphQLTypes["Permission"] | undefined,
	platbyCategory?: GraphQLTypes["PlatbyCategory"] | undefined,
	platbyCategoryGroup?: GraphQLTypes["PlatbyCategoryGroup"] | undefined,
	platbyGroup?: GraphQLTypes["PlatbyGroup"] | undefined,
	platbyGroupSkupina?: GraphQLTypes["PlatbyGroupSkupina"] | undefined,
	platbyItem?: GraphQLTypes["PlatbyItem"] | undefined,
	platbyRaw?: GraphQLTypes["PlatbyRaw"] | undefined,
	rozpi?: GraphQLTypes["Rozpi"] | undefined,
	rozpisItem?: GraphQLTypes["RozpisItem"] | undefined,
	session?: GraphQLTypes["Session"] | undefined,
	skupiny?: GraphQLTypes["Skupiny"] | undefined,
	upozorneni?: GraphQLTypes["Upozorneni"] | undefined,
	upozorneniSkupiny?: GraphQLTypes["UpozorneniSkupiny"] | undefined,
	user?: GraphQLTypes["User"] | undefined,
	usersSkupiny?: GraphQLTypes["UsersSkupiny"] | undefined,
	video?: GraphQLTypes["Video"] | undefined,
	videoList?: GraphQLTypes["VideoList"] | undefined,
	videoSource?: GraphQLTypes["VideoSource"] | undefined,
	activeProspects?: GraphQLTypes["ActiveProspectsConnection"] | undefined,
	/** Reads and enables pagination through a set of `Member`. */
	cohortMembers?: GraphQLTypes["MembersConnection"] | undefined,
	currentCoupleIds?: GraphQLTypes["CurrentCoupleIdsConnection"] | undefined,
	currentSessionId?: string | undefined,
	currentUserId?: GraphQLTypes["BigInt"] | undefined,
	getCurrentUser?: GraphQLTypes["User"] | undefined,
	/** Reads and enables pagination through a set of `Nabidka`. */
	reservationsForRange?: GraphQLTypes["NabidkasConnection"] | undefined,
	/** Reads and enables pagination through a set of `Rozpi`. */
	schedulesForRange?: GraphQLTypes["RozpisConnection"] | undefined,
	/** Reads and enables pagination through a set of `Video`. */
	titleVideos?: GraphQLTypes["VideosConnection"] | undefined,
	/** Reads a single `Akce` using its globally unique `ID`. */
	akceByNodeId?: GraphQLTypes["Akce"] | undefined,
	/** Reads a single `AkceItem` using its globally unique `ID`. */
	akceItemByNodeId?: GraphQLTypes["AkceItem"] | undefined,
	/** Reads a single `Aktuality` using its globally unique `ID`. */
	aktualityByNodeId?: GraphQLTypes["Aktuality"] | undefined,
	/** Reads a single `Dokumenty` using its globally unique `ID`. */
	dokumentyByNodeId?: GraphQLTypes["Dokumenty"] | undefined,
	/** Reads a single `GalerieDir` using its globally unique `ID`. */
	galerieDirByNodeId?: GraphQLTypes["GalerieDir"] | undefined,
	/** Reads a single `GalerieFoto` using its globally unique `ID`. */
	galerieFotoByNodeId?: GraphQLTypes["GalerieFoto"] | undefined,
	/** Reads a single `Nabidka` using its globally unique `ID`. */
	nabidkaByNodeId?: GraphQLTypes["Nabidka"] | undefined,
	/** Reads a single `NabidkaItem` using its globally unique `ID`. */
	nabidkaItemByNodeId?: GraphQLTypes["NabidkaItem"] | undefined,
	/** Reads a single `Page` using its globally unique `ID`. */
	pageByNodeId?: GraphQLTypes["Page"] | undefined,
	/** Reads a single `PageRevision` using its globally unique `ID`. */
	pageRevisionByNodeId?: GraphQLTypes["PageRevision"] | undefined,
	/** Reads a single `Parameter` using its globally unique `ID`. */
	parameterByNodeId?: GraphQLTypes["Parameter"] | undefined,
	/** Reads a single `Pary` using its globally unique `ID`. */
	paryByNodeId?: GraphQLTypes["Pary"] | undefined,
	/** Reads a single `ParyNavrh` using its globally unique `ID`. */
	paryNavrhByNodeId?: GraphQLTypes["ParyNavrh"] | undefined,
	/** Reads a single `Permission` using its globally unique `ID`. */
	permissionByNodeId?: GraphQLTypes["Permission"] | undefined,
	/** Reads a single `PlatbyCategory` using its globally unique `ID`. */
	platbyCategoryByNodeId?: GraphQLTypes["PlatbyCategory"] | undefined,
	/** Reads a single `PlatbyCategoryGroup` using its globally unique `ID`. */
	platbyCategoryGroupByNodeId?: GraphQLTypes["PlatbyCategoryGroup"] | undefined,
	/** Reads a single `PlatbyGroup` using its globally unique `ID`. */
	platbyGroupByNodeId?: GraphQLTypes["PlatbyGroup"] | undefined,
	/** Reads a single `PlatbyGroupSkupina` using its globally unique `ID`. */
	platbyGroupSkupinaByNodeId?: GraphQLTypes["PlatbyGroupSkupina"] | undefined,
	/** Reads a single `PlatbyItem` using its globally unique `ID`. */
	platbyItemByNodeId?: GraphQLTypes["PlatbyItem"] | undefined,
	/** Reads a single `PlatbyRaw` using its globally unique `ID`. */
	platbyRawByNodeId?: GraphQLTypes["PlatbyRaw"] | undefined,
	/** Reads a single `Rozpi` using its globally unique `ID`. */
	rozpiByNodeId?: GraphQLTypes["Rozpi"] | undefined,
	/** Reads a single `RozpisItem` using its globally unique `ID`. */
	rozpisItemByNodeId?: GraphQLTypes["RozpisItem"] | undefined,
	/** Reads a single `Session` using its globally unique `ID`. */
	sessionByNodeId?: GraphQLTypes["Session"] | undefined,
	/** Reads a single `Skupiny` using its globally unique `ID`. */
	skupinyByNodeId?: GraphQLTypes["Skupiny"] | undefined,
	/** Reads a single `Upozorneni` using its globally unique `ID`. */
	upozorneniByNodeId?: GraphQLTypes["Upozorneni"] | undefined,
	/** Reads a single `UpozorneniSkupiny` using its globally unique `ID`. */
	upozorneniSkupinyByNodeId?: GraphQLTypes["UpozorneniSkupiny"] | undefined,
	/** Reads a single `User` using its globally unique `ID`. */
	userByNodeId?: GraphQLTypes["User"] | undefined,
	/** Reads a single `UsersSkupiny` using its globally unique `ID`. */
	usersSkupinyByNodeId?: GraphQLTypes["UsersSkupiny"] | undefined,
	/** Reads a single `Video` using its globally unique `ID`. */
	videoByNodeId?: GraphQLTypes["Video"] | undefined,
	/** Reads a single `VideoList` using its globally unique `ID`. */
	videoListByNodeId?: GraphQLTypes["VideoList"] | undefined,
	/** Reads a single `VideoSource` using its globally unique `ID`. */
	videoSourceByNodeId?: GraphQLTypes["VideoSource"] | undefined
};
	/** An object with a globally unique `ID`. */
["Node"]: {
	__typename:"Query" | "Akce" | "AkceItem" | "User" | "Permission" | "Skupiny" | "PlatbyGroupSkupina" | "PlatbyGroup" | "PlatbyCategoryGroup" | "PlatbyCategory" | "PlatbyItem" | "PlatbyRaw" | "UpozorneniSkupiny" | "Upozorneni" | "Aktuality" | "GalerieFoto" | "GalerieDir" | "Nabidka" | "NabidkaItem" | "Pary" | "RozpisItem" | "Rozpi" | "Session" | "Dokumenty" | "ParyNavrh" | "Page" | "PageRevision" | "Parameter" | "UsersSkupiny" | "Video" | "VideoList" | "VideoSource",
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string
	['...on Query']: '__union' & GraphQLTypes["Query"];
	['...on Akce']: '__union' & GraphQLTypes["Akce"];
	['...on AkceItem']: '__union' & GraphQLTypes["AkceItem"];
	['...on User']: '__union' & GraphQLTypes["User"];
	['...on Permission']: '__union' & GraphQLTypes["Permission"];
	['...on Skupiny']: '__union' & GraphQLTypes["Skupiny"];
	['...on PlatbyGroupSkupina']: '__union' & GraphQLTypes["PlatbyGroupSkupina"];
	['...on PlatbyGroup']: '__union' & GraphQLTypes["PlatbyGroup"];
	['...on PlatbyCategoryGroup']: '__union' & GraphQLTypes["PlatbyCategoryGroup"];
	['...on PlatbyCategory']: '__union' & GraphQLTypes["PlatbyCategory"];
	['...on PlatbyItem']: '__union' & GraphQLTypes["PlatbyItem"];
	['...on PlatbyRaw']: '__union' & GraphQLTypes["PlatbyRaw"];
	['...on UpozorneniSkupiny']: '__union' & GraphQLTypes["UpozorneniSkupiny"];
	['...on Upozorneni']: '__union' & GraphQLTypes["Upozorneni"];
	['...on Aktuality']: '__union' & GraphQLTypes["Aktuality"];
	['...on GalerieFoto']: '__union' & GraphQLTypes["GalerieFoto"];
	['...on GalerieDir']: '__union' & GraphQLTypes["GalerieDir"];
	['...on Nabidka']: '__union' & GraphQLTypes["Nabidka"];
	['...on NabidkaItem']: '__union' & GraphQLTypes["NabidkaItem"];
	['...on Pary']: '__union' & GraphQLTypes["Pary"];
	['...on RozpisItem']: '__union' & GraphQLTypes["RozpisItem"];
	['...on Rozpi']: '__union' & GraphQLTypes["Rozpi"];
	['...on Session']: '__union' & GraphQLTypes["Session"];
	['...on Dokumenty']: '__union' & GraphQLTypes["Dokumenty"];
	['...on ParyNavrh']: '__union' & GraphQLTypes["ParyNavrh"];
	['...on Page']: '__union' & GraphQLTypes["Page"];
	['...on PageRevision']: '__union' & GraphQLTypes["PageRevision"];
	['...on Parameter']: '__union' & GraphQLTypes["Parameter"];
	['...on UsersSkupiny']: '__union' & GraphQLTypes["UsersSkupiny"];
	['...on Video']: '__union' & GraphQLTypes["Video"];
	['...on VideoList']: '__union' & GraphQLTypes["VideoList"];
	['...on VideoSource']: '__union' & GraphQLTypes["VideoSource"];
};
	/** A connection to a list of `Akce` values. */
["AkcesConnection"]: {
	__typename: "AkcesConnection",
	/** A list of `Akce` objects. */
	nodes: Array<GraphQLTypes["Akce"]>,
	/** A list of edges which contains the `Akce` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["AkcesEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: GraphQLTypes["PageInfo"],
	/** The count of *all* `Akce` you could get from the connection. */
	totalCount: number
};
	["Akce"]: {
	__typename: "Akce",
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	aId: GraphQLTypes["BigInt"],
	aJmeno: string,
	aKde: string,
	aInfo: string,
	aOd: GraphQLTypes["Date"],
	aDo: GraphQLTypes["Date"],
	aKapacita: GraphQLTypes["BigInt"],
	aDokumenty: string,
	aTimestamp?: GraphQLTypes["Datetime"] | undefined,
	aLock: boolean,
	aVisible: boolean,
	/** Reads and enables pagination through a set of `AkceItem`. */
	akceItemsByAiIdRodic: GraphQLTypes["AkceItemsConnection"]
};
	/** A signed eight-byte integer. The upper big integer values are greater than the
max value for a JavaScript number. Therefore all big integers will be output as
strings and not numbers. */
["BigInt"]: "scalar" & { name: "BigInt" };
	/** The day, does not include a time. */
["Date"]: "scalar" & { name: "Date" };
	/** A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone. */
["Datetime"]: "scalar" & { name: "Datetime" };
	/** A connection to a list of `AkceItem` values. */
["AkceItemsConnection"]: {
	__typename: "AkceItemsConnection",
	/** A list of `AkceItem` objects. */
	nodes: Array<GraphQLTypes["AkceItem"]>,
	/** A list of edges which contains the `AkceItem` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["AkceItemsEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: GraphQLTypes["PageInfo"],
	/** The count of *all* `AkceItem` you could get from the connection. */
	totalCount: number
};
	["AkceItem"]: {
	__typename: "AkceItem",
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	aiId: GraphQLTypes["BigInt"],
	aiIdRodic: GraphQLTypes["BigInt"],
	aiUser: GraphQLTypes["BigInt"],
	aiRokNarozeni: number,
	/** Reads a single `Akce` that is related to this `AkceItem`. */
	akceByAiIdRodic?: GraphQLTypes["Akce"] | undefined,
	/** Reads a single `User` that is related to this `AkceItem`. */
	userByAiUser?: GraphQLTypes["User"] | undefined
};
	["User"]: {
	__typename: "User",
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	uId: GraphQLTypes["BigInt"],
	uLogin: string,
	uPass: string,
	uJmeno: string,
	uPrijmeni: string,
	uPohlavi: string,
	uEmail: string,
	uTelefon: string,
	uNarozeni: GraphQLTypes["Date"],
	uRodneCislo?: string | undefined,
	uPoznamky: string,
	uTimestamp: GraphQLTypes["Datetime"],
	uLevel: number,
	uGroup: GraphQLTypes["BigInt"],
	uSkupina: GraphQLTypes["BigInt"],
	uDancer: boolean,
	uBan: boolean,
	uLock: boolean,
	uConfirmed: boolean,
	uSystem: boolean,
	uStreet: string,
	uConscriptionNumber: string,
	uOrientationNumber: string,
	uDistrict: string,
	uCity: string,
	uPostalCode: string,
	uNationality: string,
	uMemberSince?: GraphQLTypes["Datetime"] | undefined,
	uMemberUntil?: GraphQLTypes["Datetime"] | undefined,
	uCreatedAt: GraphQLTypes["Datetime"],
	uTeacher: boolean,
	uGdprSignedAt?: GraphQLTypes["Datetime"] | undefined,
	/** Reads a single `Permission` that is related to this `User`. */
	permissionByUGroup?: GraphQLTypes["Permission"] | undefined,
	/** Reads a single `Skupiny` that is related to this `User`. */
	skupinyByUSkupina?: GraphQLTypes["Skupiny"] | undefined,
	/** Reads and enables pagination through a set of `Aktuality`. */
	aktualitiesByAtKdo: GraphQLTypes["AktualitiesConnection"],
	/** Reads and enables pagination through a set of `Nabidka`. */
	nabidkasByNTrener: GraphQLTypes["NabidkasConnection"],
	/** Reads and enables pagination through a set of `Rozpi`. */
	rozpisByRTrener: GraphQLTypes["RozpisConnection"],
	/** Reads and enables pagination through a set of `PlatbyItem`. */
	platbyItemsByPiIdUser: GraphQLTypes["PlatbyItemsConnection"],
	/** Reads and enables pagination through a set of `Pary`. */
	pariesByPIdPartner: GraphQLTypes["PariesConnection"],
	/** Reads and enables pagination through a set of `Session`. */
	sessionsBySsUser: GraphQLTypes["SessionsConnection"],
	/** Reads and enables pagination through a set of `AkceItem`. */
	akceItemsByAiUser: GraphQLTypes["AkceItemsConnection"],
	/** Reads and enables pagination through a set of `Dokumenty`. */
	dokumentiesByDKdo: GraphQLTypes["DokumentiesConnection"],
	/** Reads and enables pagination through a set of `GalerieFoto`. */
	galerieFotosByGfKdo: GraphQLTypes["GalerieFotosConnection"],
	/** Reads and enables pagination through a set of `ParyNavrh`. */
	paryNavrhsByPnNavrhl: GraphQLTypes["ParyNavrhsConnection"],
	/** Reads and enables pagination through a set of `ParyNavrh`. */
	paryNavrhsByPnPartner: GraphQLTypes["ParyNavrhsConnection"],
	/** Reads and enables pagination through a set of `ParyNavrh`. */
	paryNavrhsByPnPartnerka: GraphQLTypes["ParyNavrhsConnection"],
	/** Reads and enables pagination through a set of `Upozorneni`. */
	upozornenisByUpKdo: GraphQLTypes["UpozornenisConnection"]
};
	["Permission"]: {
	__typename: "Permission",
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	peId: GraphQLTypes["BigInt"],
	peName: string,
	peDescription: string,
	peAkce: number,
	peAktuality: number,
	peAnkety: number,
	peDokumenty: number,
	peGalerie: number,
	peInzerce: number,
	peKonzole: number,
	peNabidka: number,
	peNastenka: number,
	peNovinky: number,
	pePary: number,
	pePlatby: number,
	pePermissions: number,
	peRozpis: number,
	peSkupiny: number,
	peUsers: number,
	peMain: number,
	/** Reads and enables pagination through a set of `User`. */
	usersByUGroup: GraphQLTypes["UsersConnection"]
};
	/** A connection to a list of `User` values. */
["UsersConnection"]: {
	__typename: "UsersConnection",
	/** A list of `User` objects. */
	nodes: Array<GraphQLTypes["User"]>,
	/** A list of edges which contains the `User` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["UsersEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: GraphQLTypes["PageInfo"],
	/** The count of *all* `User` you could get from the connection. */
	totalCount: number
};
	/** A `User` edge in the connection. */
["UsersEdge"]: {
	__typename: "UsersEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `User` at the end of the edge. */
	node: GraphQLTypes["User"]
};
	/** A location in a connection that can be used for resuming pagination. */
["Cursor"]: "scalar" & { name: "Cursor" };
	/** Information about pagination in a connection. */
["PageInfo"]: {
	__typename: "PageInfo",
	/** When paginating forwards, are there more items? */
	hasNextPage: boolean,
	/** When paginating backwards, are there more items? */
	hasPreviousPage: boolean,
	/** When paginating backwards, the cursor to continue. */
	startCursor?: GraphQLTypes["Cursor"] | undefined,
	/** When paginating forwards, the cursor to continue. */
	endCursor?: GraphQLTypes["Cursor"] | undefined
};
	/** Methods to use when ordering `User`. */
["UsersOrderBy"]: UsersOrderBy;
	/** A condition to be used against `User` object types. All fields are tested for equality and combined with a logical and. */
["UserCondition"]: {
		/** Checks for equality with the objects `uId` field. */
	uId?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `uLogin` field. */
	uLogin?: string | undefined,
	/** Checks for equality with the objects `uPass` field. */
	uPass?: string | undefined,
	/** Checks for equality with the objects `uJmeno` field. */
	uJmeno?: string | undefined,
	/** Checks for equality with the objects `uPrijmeni` field. */
	uPrijmeni?: string | undefined,
	/** Checks for equality with the objects `uPohlavi` field. */
	uPohlavi?: string | undefined,
	/** Checks for equality with the objects `uEmail` field. */
	uEmail?: string | undefined,
	/** Checks for equality with the objects `uTelefon` field. */
	uTelefon?: string | undefined,
	/** Checks for equality with the objects `uNarozeni` field. */
	uNarozeni?: GraphQLTypes["Date"] | undefined,
	/** Checks for equality with the objects `uRodneCislo` field. */
	uRodneCislo?: string | undefined,
	/** Checks for equality with the objects `uPoznamky` field. */
	uPoznamky?: string | undefined,
	/** Checks for equality with the objects `uTimestamp` field. */
	uTimestamp?: GraphQLTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `uLevel` field. */
	uLevel?: number | undefined,
	/** Checks for equality with the objects `uGroup` field. */
	uGroup?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `uSkupina` field. */
	uSkupina?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `uDancer` field. */
	uDancer?: boolean | undefined,
	/** Checks for equality with the objects `uBan` field. */
	uBan?: boolean | undefined,
	/** Checks for equality with the objects `uLock` field. */
	uLock?: boolean | undefined,
	/** Checks for equality with the objects `uConfirmed` field. */
	uConfirmed?: boolean | undefined,
	/** Checks for equality with the objects `uSystem` field. */
	uSystem?: boolean | undefined,
	/** Checks for equality with the objects `uStreet` field. */
	uStreet?: string | undefined,
	/** Checks for equality with the objects `uConscriptionNumber` field. */
	uConscriptionNumber?: string | undefined,
	/** Checks for equality with the objects `uOrientationNumber` field. */
	uOrientationNumber?: string | undefined,
	/** Checks for equality with the objects `uDistrict` field. */
	uDistrict?: string | undefined,
	/** Checks for equality with the objects `uCity` field. */
	uCity?: string | undefined,
	/** Checks for equality with the objects `uPostalCode` field. */
	uPostalCode?: string | undefined,
	/** Checks for equality with the objects `uNationality` field. */
	uNationality?: string | undefined,
	/** Checks for equality with the objects `uMemberSince` field. */
	uMemberSince?: GraphQLTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `uMemberUntil` field. */
	uMemberUntil?: GraphQLTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `uCreatedAt` field. */
	uCreatedAt?: GraphQLTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `uTeacher` field. */
	uTeacher?: boolean | undefined,
	/** Checks for equality with the objects `uGdprSignedAt` field. */
	uGdprSignedAt?: GraphQLTypes["Datetime"] | undefined
};
	["Skupiny"]: {
	__typename: "Skupiny",
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	sId: GraphQLTypes["BigInt"],
	sName: string,
	sDescription: string,
	sColorRgb: string,
	sColorText: string,
	sLocation: string,
	sVisible: boolean,
	/** Reads and enables pagination through a set of `User`. */
	usersByUSkupina: GraphQLTypes["UsersConnection"],
	/** Reads and enables pagination through a set of `PlatbyGroupSkupina`. */
	platbyGroupSkupinasByPgsIdSkupina: GraphQLTypes["PlatbyGroupSkupinasConnection"],
	/** Reads and enables pagination through a set of `UpozorneniSkupiny`. */
	upozorneniSkupiniesByUpsIdSkupina: GraphQLTypes["UpozorneniSkupiniesConnection"]
};
	/** A connection to a list of `PlatbyGroupSkupina` values. */
["PlatbyGroupSkupinasConnection"]: {
	__typename: "PlatbyGroupSkupinasConnection",
	/** A list of `PlatbyGroupSkupina` objects. */
	nodes: Array<GraphQLTypes["PlatbyGroupSkupina"]>,
	/** A list of edges which contains the `PlatbyGroupSkupina` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["PlatbyGroupSkupinasEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: GraphQLTypes["PageInfo"],
	/** The count of *all* `PlatbyGroupSkupina` you could get from the connection. */
	totalCount: number
};
	["PlatbyGroupSkupina"]: {
	__typename: "PlatbyGroupSkupina",
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	pgsId: GraphQLTypes["BigInt"],
	pgsIdSkupina: GraphQLTypes["BigInt"],
	pgsIdGroup: GraphQLTypes["BigInt"],
	/** Reads a single `Skupiny` that is related to this `PlatbyGroupSkupina`. */
	skupinyByPgsIdSkupina?: GraphQLTypes["Skupiny"] | undefined,
	/** Reads a single `PlatbyGroup` that is related to this `PlatbyGroupSkupina`. */
	platbyGroupByPgsIdGroup?: GraphQLTypes["PlatbyGroup"] | undefined
};
	["PlatbyGroup"]: {
	__typename: "PlatbyGroup",
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	pgId: GraphQLTypes["BigInt"],
	pgType: GraphQLTypes["BigFloat"],
	pgName: string,
	pgDescription: string,
	pgBase: GraphQLTypes["BigInt"],
	/** Reads and enables pagination through a set of `PlatbyCategoryGroup`. */
	platbyCategoryGroupsByPcgIdGroup: GraphQLTypes["PlatbyCategoryGroupsConnection"],
	/** Reads and enables pagination through a set of `PlatbyGroupSkupina`. */
	platbyGroupSkupinasByPgsIdGroup: GraphQLTypes["PlatbyGroupSkupinasConnection"]
};
	/** A floating point number that requires more precision than IEEE 754 binary 64 */
["BigFloat"]: "scalar" & { name: "BigFloat" };
	/** A connection to a list of `PlatbyCategoryGroup` values. */
["PlatbyCategoryGroupsConnection"]: {
	__typename: "PlatbyCategoryGroupsConnection",
	/** A list of `PlatbyCategoryGroup` objects. */
	nodes: Array<GraphQLTypes["PlatbyCategoryGroup"]>,
	/** A list of edges which contains the `PlatbyCategoryGroup` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["PlatbyCategoryGroupsEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: GraphQLTypes["PageInfo"],
	/** The count of *all* `PlatbyCategoryGroup` you could get from the connection. */
	totalCount: number
};
	["PlatbyCategoryGroup"]: {
	__typename: "PlatbyCategoryGroup",
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	pcgId: GraphQLTypes["BigInt"],
	pcgIdGroup: GraphQLTypes["BigInt"],
	pcgIdCategory: GraphQLTypes["BigInt"],
	/** Reads a single `PlatbyGroup` that is related to this `PlatbyCategoryGroup`. */
	platbyGroupByPcgIdGroup?: GraphQLTypes["PlatbyGroup"] | undefined,
	/** Reads a single `PlatbyCategory` that is related to this `PlatbyCategoryGroup`. */
	platbyCategoryByPcgIdCategory?: GraphQLTypes["PlatbyCategory"] | undefined
};
	["PlatbyCategory"]: {
	__typename: "PlatbyCategory",
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	pcId: GraphQLTypes["BigInt"],
	pcName: string,
	pcSymbol: GraphQLTypes["BigInt"],
	pcAmount: GraphQLTypes["BigFloat"],
	pcDateDue: GraphQLTypes["Date"],
	pcValidFrom: GraphQLTypes["Date"],
	pcValidTo: GraphQLTypes["Date"],
	pcUseBase: boolean,
	pcUsePrefix: boolean,
	pcArchive: boolean,
	pcVisible: boolean,
	/** Reads and enables pagination through a set of `PlatbyCategoryGroup`. */
	platbyCategoryGroupsByPcgIdCategory: GraphQLTypes["PlatbyCategoryGroupsConnection"],
	/** Reads and enables pagination through a set of `PlatbyItem`. */
	platbyItemsByPiIdCategory: GraphQLTypes["PlatbyItemsConnection"]
};
	/** Methods to use when ordering `PlatbyCategoryGroup`. */
["PlatbyCategoryGroupsOrderBy"]: PlatbyCategoryGroupsOrderBy;
	/** A condition to be used against `PlatbyCategoryGroup` object types. All fields
are tested for equality and combined with a logical and. */
["PlatbyCategoryGroupCondition"]: {
		/** Checks for equality with the objects `pcgId` field. */
	pcgId?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `pcgIdGroup` field. */
	pcgIdGroup?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `pcgIdCategory` field. */
	pcgIdCategory?: GraphQLTypes["BigInt"] | undefined
};
	/** A connection to a list of `PlatbyItem` values. */
["PlatbyItemsConnection"]: {
	__typename: "PlatbyItemsConnection",
	/** A list of `PlatbyItem` objects. */
	nodes: Array<GraphQLTypes["PlatbyItem"]>,
	/** A list of edges which contains the `PlatbyItem` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["PlatbyItemsEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: GraphQLTypes["PageInfo"],
	/** The count of *all* `PlatbyItem` you could get from the connection. */
	totalCount: number
};
	["PlatbyItem"]: {
	__typename: "PlatbyItem",
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	piId: GraphQLTypes["BigInt"],
	piIdUser?: GraphQLTypes["BigInt"] | undefined,
	piIdCategory: GraphQLTypes["BigInt"],
	piIdRaw?: GraphQLTypes["BigInt"] | undefined,
	piAmount: GraphQLTypes["BigFloat"],
	piDate: GraphQLTypes["Date"],
	piPrefix: number,
	/** Reads a single `User` that is related to this `PlatbyItem`. */
	userByPiIdUser?: GraphQLTypes["User"] | undefined,
	/** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
	platbyCategoryByPiIdCategory?: GraphQLTypes["PlatbyCategory"] | undefined,
	/** Reads a single `PlatbyRaw` that is related to this `PlatbyItem`. */
	platbyRawByPiIdRaw?: GraphQLTypes["PlatbyRaw"] | undefined
};
	["PlatbyRaw"]: {
	__typename: "PlatbyRaw",
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	prId: GraphQLTypes["BigInt"],
	prRaw: string,
	prHash: string,
	prSorted: boolean,
	prDiscarded: boolean,
	/** Reads and enables pagination through a set of `PlatbyItem`. */
	platbyItemsByPiIdRaw: GraphQLTypes["PlatbyItemsConnection"]
};
	/** Methods to use when ordering `PlatbyItem`. */
["PlatbyItemsOrderBy"]: PlatbyItemsOrderBy;
	/** A condition to be used against `PlatbyItem` object types. All fields are tested
for equality and combined with a logical and. */
["PlatbyItemCondition"]: {
		/** Checks for equality with the objects `piId` field. */
	piId?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `piIdUser` field. */
	piIdUser?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `piIdCategory` field. */
	piIdCategory?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `piIdRaw` field. */
	piIdRaw?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `piAmount` field. */
	piAmount?: GraphQLTypes["BigFloat"] | undefined,
	/** Checks for equality with the objects `piDate` field. */
	piDate?: GraphQLTypes["Date"] | undefined,
	/** Checks for equality with the objects `piPrefix` field. */
	piPrefix?: number | undefined
};
	/** A `PlatbyItem` edge in the connection. */
["PlatbyItemsEdge"]: {
	__typename: "PlatbyItemsEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `PlatbyItem` at the end of the edge. */
	node: GraphQLTypes["PlatbyItem"]
};
	/** A `PlatbyCategoryGroup` edge in the connection. */
["PlatbyCategoryGroupsEdge"]: {
	__typename: "PlatbyCategoryGroupsEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `PlatbyCategoryGroup` at the end of the edge. */
	node: GraphQLTypes["PlatbyCategoryGroup"]
};
	/** Methods to use when ordering `PlatbyGroupSkupina`. */
["PlatbyGroupSkupinasOrderBy"]: PlatbyGroupSkupinasOrderBy;
	/** A condition to be used against `PlatbyGroupSkupina` object types. All fields are
tested for equality and combined with a logical and. */
["PlatbyGroupSkupinaCondition"]: {
		/** Checks for equality with the objects `pgsId` field. */
	pgsId?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `pgsIdSkupina` field. */
	pgsIdSkupina?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `pgsIdGroup` field. */
	pgsIdGroup?: GraphQLTypes["BigInt"] | undefined
};
	/** A `PlatbyGroupSkupina` edge in the connection. */
["PlatbyGroupSkupinasEdge"]: {
	__typename: "PlatbyGroupSkupinasEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `PlatbyGroupSkupina` at the end of the edge. */
	node: GraphQLTypes["PlatbyGroupSkupina"]
};
	/** A connection to a list of `UpozorneniSkupiny` values. */
["UpozorneniSkupiniesConnection"]: {
	__typename: "UpozorneniSkupiniesConnection",
	/** A list of `UpozorneniSkupiny` objects. */
	nodes: Array<GraphQLTypes["UpozorneniSkupiny"]>,
	/** A list of edges which contains the `UpozorneniSkupiny` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["UpozorneniSkupiniesEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: GraphQLTypes["PageInfo"],
	/** The count of *all* `UpozorneniSkupiny` you could get from the connection. */
	totalCount: number
};
	["UpozorneniSkupiny"]: {
	__typename: "UpozorneniSkupiny",
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	upsId: GraphQLTypes["BigInt"],
	upsIdRodic: GraphQLTypes["BigInt"],
	upsIdSkupina: GraphQLTypes["BigInt"],
	upsColor: string,
	upsPopis: string,
	/** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
	upozorneniByUpsIdRodic?: GraphQLTypes["Upozorneni"] | undefined,
	/** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
	skupinyByUpsIdSkupina?: GraphQLTypes["Skupiny"] | undefined
};
	["Upozorneni"]: {
	__typename: "Upozorneni",
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	upId: GraphQLTypes["BigInt"],
	upKdo: GraphQLTypes["BigInt"],
	upNadpis: string,
	upText: string,
	upBarvy: GraphQLTypes["BigInt"],
	upLock: boolean,
	upTimestamp?: GraphQLTypes["Datetime"] | undefined,
	upTimestampAdd: GraphQLTypes["Datetime"],
	/** Reads a single `User` that is related to this `Upozorneni`. */
	userByUpKdo?: GraphQLTypes["User"] | undefined,
	/** Reads and enables pagination through a set of `UpozorneniSkupiny`. */
	upozorneniSkupiniesByUpsIdRodic: GraphQLTypes["UpozorneniSkupiniesConnection"]
};
	/** Methods to use when ordering `UpozorneniSkupiny`. */
["UpozorneniSkupiniesOrderBy"]: UpozorneniSkupiniesOrderBy;
	/** A condition to be used against `UpozorneniSkupiny` object types. All fields are
tested for equality and combined with a logical and. */
["UpozorneniSkupinyCondition"]: {
		/** Checks for equality with the objects `upsId` field. */
	upsId?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `upsIdRodic` field. */
	upsIdRodic?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `upsIdSkupina` field. */
	upsIdSkupina?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `upsColor` field. */
	upsColor?: string | undefined,
	/** Checks for equality with the objects `upsPopis` field. */
	upsPopis?: string | undefined
};
	/** A `UpozorneniSkupiny` edge in the connection. */
["UpozorneniSkupiniesEdge"]: {
	__typename: "UpozorneniSkupiniesEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `UpozorneniSkupiny` at the end of the edge. */
	node: GraphQLTypes["UpozorneniSkupiny"]
};
	/** A connection to a list of `Aktuality` values. */
["AktualitiesConnection"]: {
	__typename: "AktualitiesConnection",
	/** A list of `Aktuality` objects. */
	nodes: Array<GraphQLTypes["Aktuality"]>,
	/** A list of edges which contains the `Aktuality` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["AktualitiesEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: GraphQLTypes["PageInfo"],
	/** The count of *all* `Aktuality` you could get from the connection. */
	totalCount: number
};
	["Aktuality"]: {
	__typename: "Aktuality",
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	atId: GraphQLTypes["BigInt"],
	atKdo: GraphQLTypes["BigInt"],
	atKat: string,
	atJmeno: string,
	atText: string,
	atPreview: string,
	atFoto?: GraphQLTypes["BigInt"] | undefined,
	atFotoMain?: GraphQLTypes["BigInt"] | undefined,
	atTimestamp?: GraphQLTypes["Datetime"] | undefined,
	atTimestampAdd?: GraphQLTypes["Datetime"] | undefined,
	/** Reads a single `User` that is related to this `Aktuality`. */
	userByAtKdo?: GraphQLTypes["User"] | undefined,
	/** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
	galerieFotoByAtFotoMain?: GraphQLTypes["GalerieFoto"] | undefined
};
	["GalerieFoto"]: {
	__typename: "GalerieFoto",
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	gfId: GraphQLTypes["BigInt"],
	gfIdRodic: GraphQLTypes["BigInt"],
	gfName: string,
	gfPath: string,
	gfKdo: GraphQLTypes["BigInt"],
	gfTimestamp?: GraphQLTypes["Datetime"] | undefined,
	/** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
	galerieDirByGfIdRodic?: GraphQLTypes["GalerieDir"] | undefined,
	/** Reads a single `User` that is related to this `GalerieFoto`. */
	userByGfKdo?: GraphQLTypes["User"] | undefined,
	/** Reads and enables pagination through a set of `Aktuality`. */
	aktualitiesByAtFotoMain: GraphQLTypes["AktualitiesConnection"]
};
	["GalerieDir"]: {
	__typename: "GalerieDir",
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	gdId: GraphQLTypes["BigInt"],
	gdIdRodic: GraphQLTypes["BigInt"],
	gdName: string,
	gdLevel: number,
	gdPath: string,
	gdHidden: boolean,
	/** Reads and enables pagination through a set of `GalerieFoto`. */
	galerieFotosByGfIdRodic: GraphQLTypes["GalerieFotosConnection"]
};
	/** A connection to a list of `GalerieFoto` values. */
["GalerieFotosConnection"]: {
	__typename: "GalerieFotosConnection",
	/** A list of `GalerieFoto` objects. */
	nodes: Array<GraphQLTypes["GalerieFoto"]>,
	/** A list of edges which contains the `GalerieFoto` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["GalerieFotosEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: GraphQLTypes["PageInfo"],
	/** The count of *all* `GalerieFoto` you could get from the connection. */
	totalCount: number
};
	/** A `GalerieFoto` edge in the connection. */
["GalerieFotosEdge"]: {
	__typename: "GalerieFotosEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `GalerieFoto` at the end of the edge. */
	node: GraphQLTypes["GalerieFoto"]
};
	/** Methods to use when ordering `GalerieFoto`. */
["GalerieFotosOrderBy"]: GalerieFotosOrderBy;
	/** A condition to be used against `GalerieFoto` object types. All fields are tested
for equality and combined with a logical and. */
["GalerieFotoCondition"]: {
		/** Checks for equality with the objects `gfId` field. */
	gfId?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `gfIdRodic` field. */
	gfIdRodic?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `gfName` field. */
	gfName?: string | undefined,
	/** Checks for equality with the objects `gfPath` field. */
	gfPath?: string | undefined,
	/** Checks for equality with the objects `gfKdo` field. */
	gfKdo?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `gfTimestamp` field. */
	gfTimestamp?: GraphQLTypes["Datetime"] | undefined
};
	/** Methods to use when ordering `Aktuality`. */
["AktualitiesOrderBy"]: AktualitiesOrderBy;
	/** A condition to be used against `Aktuality` object types. All fields are tested
for equality and combined with a logical and. */
["AktualityCondition"]: {
		/** Checks for equality with the objects `atId` field. */
	atId?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `atKdo` field. */
	atKdo?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `atKat` field. */
	atKat?: string | undefined,
	/** Checks for equality with the objects `atJmeno` field. */
	atJmeno?: string | undefined,
	/** Checks for equality with the objects `atText` field. */
	atText?: string | undefined,
	/** Checks for equality with the objects `atPreview` field. */
	atPreview?: string | undefined,
	/** Checks for equality with the objects `atFoto` field. */
	atFoto?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `atFotoMain` field. */
	atFotoMain?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `atTimestamp` field. */
	atTimestamp?: GraphQLTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `atTimestampAdd` field. */
	atTimestampAdd?: GraphQLTypes["Datetime"] | undefined
};
	/** A `Aktuality` edge in the connection. */
["AktualitiesEdge"]: {
	__typename: "AktualitiesEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `Aktuality` at the end of the edge. */
	node: GraphQLTypes["Aktuality"]
};
	/** A connection to a list of `Nabidka` values. */
["NabidkasConnection"]: {
	__typename: "NabidkasConnection",
	/** A list of `Nabidka` objects. */
	nodes: Array<GraphQLTypes["Nabidka"]>,
	/** A list of edges which contains the `Nabidka` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["NabidkasEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: GraphQLTypes["PageInfo"],
	/** The count of *all* `Nabidka` you could get from the connection. */
	totalCount: number
};
	["Nabidka"]: {
	__typename: "Nabidka",
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	nId: GraphQLTypes["BigInt"],
	nTrener: GraphQLTypes["BigInt"],
	nPocetHod: number,
	nMaxPocetHod: GraphQLTypes["BigInt"],
	nOd: GraphQLTypes["Date"],
	nDo: GraphQLTypes["Date"],
	nVisible: boolean,
	nLock: boolean,
	nTimestamp?: GraphQLTypes["Datetime"] | undefined,
	/** Reads a single `User` that is related to this `Nabidka`. */
	userByNTrener?: GraphQLTypes["User"] | undefined,
	/** Reads and enables pagination through a set of `NabidkaItem`. */
	nabidkaItemsByNiIdRodic: GraphQLTypes["NabidkaItemsConnection"]
};
	/** A connection to a list of `NabidkaItem` values. */
["NabidkaItemsConnection"]: {
	__typename: "NabidkaItemsConnection",
	/** A list of `NabidkaItem` objects. */
	nodes: Array<GraphQLTypes["NabidkaItem"]>,
	/** A list of edges which contains the `NabidkaItem` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["NabidkaItemsEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: GraphQLTypes["PageInfo"],
	/** The count of *all* `NabidkaItem` you could get from the connection. */
	totalCount: number
};
	["NabidkaItem"]: {
	__typename: "NabidkaItem",
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	niId: GraphQLTypes["BigInt"],
	niIdRodic: GraphQLTypes["BigInt"],
	niPartner: GraphQLTypes["BigInt"],
	niPocetHod: number,
	niLock: boolean,
	/** Reads a single `Nabidka` that is related to this `NabidkaItem`. */
	nabidkaByNiIdRodic?: GraphQLTypes["Nabidka"] | undefined,
	/** Reads a single `Pary` that is related to this `NabidkaItem`. */
	paryByNiPartner?: GraphQLTypes["Pary"] | undefined
};
	["Pary"]: {
	__typename: "Pary",
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	pId: GraphQLTypes["BigInt"],
	pIdPartner: GraphQLTypes["BigInt"],
	pIdPartnerka?: GraphQLTypes["BigInt"] | undefined,
	pSttTrida: GraphQLTypes["ParyPSttTrida"],
	pSttBody: number,
	pSttFinale: boolean,
	pLatTrida: GraphQLTypes["ParyPLatTrida"],
	pLatBody: number,
	pLatFinale: boolean,
	pHodnoceni: number,
	pArchiv: boolean,
	pTimestampAdd: GraphQLTypes["Datetime"],
	pTimestampArchive?: GraphQLTypes["Datetime"] | undefined,
	/** Reads a single `User` that is related to this `Pary`. */
	userByPIdPartner?: GraphQLTypes["User"] | undefined,
	/** Reads and enables pagination through a set of `NabidkaItem`. */
	nabidkaItemsByNiPartner: GraphQLTypes["NabidkaItemsConnection"],
	/** Reads and enables pagination through a set of `RozpisItem`. */
	rozpisItemsByRiPartner: GraphQLTypes["RozpisItemsConnection"]
};
	["ParyPSttTrida"]: ParyPSttTrida;
	["ParyPLatTrida"]: ParyPLatTrida;
	/** Methods to use when ordering `NabidkaItem`. */
["NabidkaItemsOrderBy"]: NabidkaItemsOrderBy;
	/** A condition to be used against `NabidkaItem` object types. All fields are tested
for equality and combined with a logical and. */
["NabidkaItemCondition"]: {
		/** Checks for equality with the objects `niId` field. */
	niId?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `niIdRodic` field. */
	niIdRodic?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `niPartner` field. */
	niPartner?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `niPocetHod` field. */
	niPocetHod?: number | undefined,
	/** Checks for equality with the objects `niLock` field. */
	niLock?: boolean | undefined
};
	/** A connection to a list of `RozpisItem` values. */
["RozpisItemsConnection"]: {
	__typename: "RozpisItemsConnection",
	/** A list of `RozpisItem` objects. */
	nodes: Array<GraphQLTypes["RozpisItem"]>,
	/** A list of edges which contains the `RozpisItem` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["RozpisItemsEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: GraphQLTypes["PageInfo"],
	/** The count of *all* `RozpisItem` you could get from the connection. */
	totalCount: number
};
	["RozpisItem"]: {
	__typename: "RozpisItem",
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	riId: GraphQLTypes["BigInt"],
	riIdRodic: GraphQLTypes["BigInt"],
	riPartner?: GraphQLTypes["BigInt"] | undefined,
	riOd: GraphQLTypes["Time"],
	riDo: GraphQLTypes["Time"],
	riLock: boolean,
	/** Reads a single `Rozpi` that is related to this `RozpisItem`. */
	rozpiByRiIdRodic?: GraphQLTypes["Rozpi"] | undefined,
	/** Reads a single `Pary` that is related to this `RozpisItem`. */
	paryByRiPartner?: GraphQLTypes["Pary"] | undefined
};
	/** The exact time of day, does not include the date. May or may not have a timezone offset. */
["Time"]: "scalar" & { name: "Time" };
	["Rozpi"]: {
	__typename: "Rozpi",
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	rId: GraphQLTypes["BigInt"],
	rTrener: GraphQLTypes["BigInt"],
	rKde: string,
	rDatum: GraphQLTypes["Date"],
	rVisible: boolean,
	rLock: boolean,
	rTimestamp?: GraphQLTypes["Datetime"] | undefined,
	/** Reads a single `User` that is related to this `Rozpi`. */
	userByRTrener?: GraphQLTypes["User"] | undefined,
	/** Reads and enables pagination through a set of `RozpisItem`. */
	rozpisItemsByRiIdRodic: GraphQLTypes["RozpisItemsConnection"]
};
	/** Methods to use when ordering `RozpisItem`. */
["RozpisItemsOrderBy"]: RozpisItemsOrderBy;
	/** A condition to be used against `RozpisItem` object types. All fields are tested
for equality and combined with a logical and. */
["RozpisItemCondition"]: {
		/** Checks for equality with the objects `riId` field. */
	riId?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `riIdRodic` field. */
	riIdRodic?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `riPartner` field. */
	riPartner?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `riOd` field. */
	riOd?: GraphQLTypes["Time"] | undefined,
	/** Checks for equality with the objects `riDo` field. */
	riDo?: GraphQLTypes["Time"] | undefined,
	/** Checks for equality with the objects `riLock` field. */
	riLock?: boolean | undefined
};
	/** A `RozpisItem` edge in the connection. */
["RozpisItemsEdge"]: {
	__typename: "RozpisItemsEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `RozpisItem` at the end of the edge. */
	node: GraphQLTypes["RozpisItem"]
};
	/** A `NabidkaItem` edge in the connection. */
["NabidkaItemsEdge"]: {
	__typename: "NabidkaItemsEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `NabidkaItem` at the end of the edge. */
	node: GraphQLTypes["NabidkaItem"]
};
	/** A `Nabidka` edge in the connection. */
["NabidkasEdge"]: {
	__typename: "NabidkasEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `Nabidka` at the end of the edge. */
	node: GraphQLTypes["Nabidka"]
};
	/** Methods to use when ordering `Nabidka`. */
["NabidkasOrderBy"]: NabidkasOrderBy;
	/** A condition to be used against `Nabidka` object types. All fields are tested for equality and combined with a logical and. */
["NabidkaCondition"]: {
		/** Checks for equality with the objects `nId` field. */
	nId?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `nTrener` field. */
	nTrener?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `nPocetHod` field. */
	nPocetHod?: number | undefined,
	/** Checks for equality with the objects `nMaxPocetHod` field. */
	nMaxPocetHod?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `nOd` field. */
	nOd?: GraphQLTypes["Date"] | undefined,
	/** Checks for equality with the objects `nDo` field. */
	nDo?: GraphQLTypes["Date"] | undefined,
	/** Checks for equality with the objects `nVisible` field. */
	nVisible?: boolean | undefined,
	/** Checks for equality with the objects `nLock` field. */
	nLock?: boolean | undefined,
	/** Checks for equality with the objects `nTimestamp` field. */
	nTimestamp?: GraphQLTypes["Datetime"] | undefined
};
	/** A connection to a list of `Rozpi` values. */
["RozpisConnection"]: {
	__typename: "RozpisConnection",
	/** A list of `Rozpi` objects. */
	nodes: Array<GraphQLTypes["Rozpi"]>,
	/** A list of edges which contains the `Rozpi` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["RozpisEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: GraphQLTypes["PageInfo"],
	/** The count of *all* `Rozpi` you could get from the connection. */
	totalCount: number
};
	/** A `Rozpi` edge in the connection. */
["RozpisEdge"]: {
	__typename: "RozpisEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `Rozpi` at the end of the edge. */
	node: GraphQLTypes["Rozpi"]
};
	/** Methods to use when ordering `Rozpi`. */
["RozpisOrderBy"]: RozpisOrderBy;
	/** A condition to be used against `Rozpi` object types. All fields are tested for equality and combined with a logical and. */
["RozpiCondition"]: {
		/** Checks for equality with the objects `rId` field. */
	rId?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `rTrener` field. */
	rTrener?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `rKde` field. */
	rKde?: string | undefined,
	/** Checks for equality with the objects `rDatum` field. */
	rDatum?: GraphQLTypes["Date"] | undefined,
	/** Checks for equality with the objects `rVisible` field. */
	rVisible?: boolean | undefined,
	/** Checks for equality with the objects `rLock` field. */
	rLock?: boolean | undefined,
	/** Checks for equality with the objects `rTimestamp` field. */
	rTimestamp?: GraphQLTypes["Datetime"] | undefined
};
	/** A connection to a list of `Pary` values. */
["PariesConnection"]: {
	__typename: "PariesConnection",
	/** A list of `Pary` objects. */
	nodes: Array<GraphQLTypes["Pary"]>,
	/** A list of edges which contains the `Pary` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["PariesEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: GraphQLTypes["PageInfo"],
	/** The count of *all* `Pary` you could get from the connection. */
	totalCount: number
};
	/** A `Pary` edge in the connection. */
["PariesEdge"]: {
	__typename: "PariesEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `Pary` at the end of the edge. */
	node: GraphQLTypes["Pary"]
};
	/** Methods to use when ordering `Pary`. */
["PariesOrderBy"]: PariesOrderBy;
	/** A condition to be used against `Pary` object types. All fields are tested for equality and combined with a logical and. */
["ParyCondition"]: {
		/** Checks for equality with the objects `pId` field. */
	pId?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `pIdPartner` field. */
	pIdPartner?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `pIdPartnerka` field. */
	pIdPartnerka?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `pSttTrida` field. */
	pSttTrida?: GraphQLTypes["ParyPSttTrida"] | undefined,
	/** Checks for equality with the objects `pSttBody` field. */
	pSttBody?: number | undefined,
	/** Checks for equality with the objects `pSttFinale` field. */
	pSttFinale?: boolean | undefined,
	/** Checks for equality with the objects `pLatTrida` field. */
	pLatTrida?: GraphQLTypes["ParyPLatTrida"] | undefined,
	/** Checks for equality with the objects `pLatBody` field. */
	pLatBody?: number | undefined,
	/** Checks for equality with the objects `pLatFinale` field. */
	pLatFinale?: boolean | undefined,
	/** Checks for equality with the objects `pHodnoceni` field. */
	pHodnoceni?: number | undefined,
	/** Checks for equality with the objects `pArchiv` field. */
	pArchiv?: boolean | undefined,
	/** Checks for equality with the objects `pTimestampAdd` field. */
	pTimestampAdd?: GraphQLTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `pTimestampArchive` field. */
	pTimestampArchive?: GraphQLTypes["Datetime"] | undefined
};
	/** A connection to a list of `Session` values. */
["SessionsConnection"]: {
	__typename: "SessionsConnection",
	/** A list of `Session` objects. */
	nodes: Array<GraphQLTypes["Session"]>,
	/** A list of edges which contains the `Session` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["SessionsEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: GraphQLTypes["PageInfo"],
	/** The count of *all* `Session` you could get from the connection. */
	totalCount: number
};
	["Session"]: {
	__typename: "Session",
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	ssId: string,
	ssData: string,
	ssUpdatedAt: GraphQLTypes["Datetime"],
	ssLifetime: GraphQLTypes["BigInt"],
	ssUser?: GraphQLTypes["BigInt"] | undefined,
	/** Reads a single `User` that is related to this `Session`. */
	userBySsUser?: GraphQLTypes["User"] | undefined
};
	/** A `Session` edge in the connection. */
["SessionsEdge"]: {
	__typename: "SessionsEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `Session` at the end of the edge. */
	node: GraphQLTypes["Session"]
};
	/** Methods to use when ordering `Session`. */
["SessionsOrderBy"]: SessionsOrderBy;
	/** A condition to be used against `Session` object types. All fields are tested for equality and combined with a logical and. */
["SessionCondition"]: {
		/** Checks for equality with the objects `ssId` field. */
	ssId?: string | undefined,
	/** Checks for equality with the objects `ssData` field. */
	ssData?: string | undefined,
	/** Checks for equality with the objects `ssUpdatedAt` field. */
	ssUpdatedAt?: GraphQLTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `ssLifetime` field. */
	ssLifetime?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `ssUser` field. */
	ssUser?: GraphQLTypes["BigInt"] | undefined
};
	/** Methods to use when ordering `AkceItem`. */
["AkceItemsOrderBy"]: AkceItemsOrderBy;
	/** A condition to be used against `AkceItem` object types. All fields are tested
for equality and combined with a logical and. */
["AkceItemCondition"]: {
		/** Checks for equality with the objects `aiId` field. */
	aiId?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `aiIdRodic` field. */
	aiIdRodic?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `aiUser` field. */
	aiUser?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `aiRokNarozeni` field. */
	aiRokNarozeni?: number | undefined
};
	/** A connection to a list of `Dokumenty` values. */
["DokumentiesConnection"]: {
	__typename: "DokumentiesConnection",
	/** A list of `Dokumenty` objects. */
	nodes: Array<GraphQLTypes["Dokumenty"]>,
	/** A list of edges which contains the `Dokumenty` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["DokumentiesEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: GraphQLTypes["PageInfo"],
	/** The count of *all* `Dokumenty` you could get from the connection. */
	totalCount: number
};
	["Dokumenty"]: {
	__typename: "Dokumenty",
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	dId: GraphQLTypes["BigInt"],
	dPath: string,
	dName: string,
	dFilename: string,
	dKategorie: number,
	dKdo: GraphQLTypes["BigInt"],
	dTimestamp?: GraphQLTypes["Datetime"] | undefined,
	/** Reads a single `User` that is related to this `Dokumenty`. */
	userByDKdo?: GraphQLTypes["User"] | undefined
};
	/** A `Dokumenty` edge in the connection. */
["DokumentiesEdge"]: {
	__typename: "DokumentiesEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `Dokumenty` at the end of the edge. */
	node: GraphQLTypes["Dokumenty"]
};
	/** Methods to use when ordering `Dokumenty`. */
["DokumentiesOrderBy"]: DokumentiesOrderBy;
	/** A condition to be used against `Dokumenty` object types. All fields are tested
for equality and combined with a logical and. */
["DokumentyCondition"]: {
		/** Checks for equality with the objects `dId` field. */
	dId?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `dPath` field. */
	dPath?: string | undefined,
	/** Checks for equality with the objects `dName` field. */
	dName?: string | undefined,
	/** Checks for equality with the objects `dFilename` field. */
	dFilename?: string | undefined,
	/** Checks for equality with the objects `dKategorie` field. */
	dKategorie?: number | undefined,
	/** Checks for equality with the objects `dKdo` field. */
	dKdo?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `dTimestamp` field. */
	dTimestamp?: GraphQLTypes["Datetime"] | undefined
};
	/** A connection to a list of `ParyNavrh` values. */
["ParyNavrhsConnection"]: {
	__typename: "ParyNavrhsConnection",
	/** A list of `ParyNavrh` objects. */
	nodes: Array<GraphQLTypes["ParyNavrh"]>,
	/** A list of edges which contains the `ParyNavrh` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["ParyNavrhsEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: GraphQLTypes["PageInfo"],
	/** The count of *all* `ParyNavrh` you could get from the connection. */
	totalCount: number
};
	["ParyNavrh"]: {
	__typename: "ParyNavrh",
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	pnId: GraphQLTypes["BigInt"],
	pnNavrhl: GraphQLTypes["BigInt"],
	pnPartner: GraphQLTypes["BigInt"],
	pnPartnerka: GraphQLTypes["BigInt"],
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnNavrhl?: GraphQLTypes["User"] | undefined,
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnPartner?: GraphQLTypes["User"] | undefined,
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnPartnerka?: GraphQLTypes["User"] | undefined
};
	/** A `ParyNavrh` edge in the connection. */
["ParyNavrhsEdge"]: {
	__typename: "ParyNavrhsEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `ParyNavrh` at the end of the edge. */
	node: GraphQLTypes["ParyNavrh"]
};
	/** Methods to use when ordering `ParyNavrh`. */
["ParyNavrhsOrderBy"]: ParyNavrhsOrderBy;
	/** A condition to be used against `ParyNavrh` object types. All fields are tested
for equality and combined with a logical and. */
["ParyNavrhCondition"]: {
		/** Checks for equality with the objects `pnId` field. */
	pnId?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `pnNavrhl` field. */
	pnNavrhl?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `pnPartner` field. */
	pnPartner?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `pnPartnerka` field. */
	pnPartnerka?: GraphQLTypes["BigInt"] | undefined
};
	/** A connection to a list of `Upozorneni` values. */
["UpozornenisConnection"]: {
	__typename: "UpozornenisConnection",
	/** A list of `Upozorneni` objects. */
	nodes: Array<GraphQLTypes["Upozorneni"]>,
	/** A list of edges which contains the `Upozorneni` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["UpozornenisEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: GraphQLTypes["PageInfo"],
	/** The count of *all* `Upozorneni` you could get from the connection. */
	totalCount: number
};
	/** A `Upozorneni` edge in the connection. */
["UpozornenisEdge"]: {
	__typename: "UpozornenisEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `Upozorneni` at the end of the edge. */
	node: GraphQLTypes["Upozorneni"]
};
	/** Methods to use when ordering `Upozorneni`. */
["UpozornenisOrderBy"]: UpozornenisOrderBy;
	/** A condition to be used against `Upozorneni` object types. All fields are tested
for equality and combined with a logical and. */
["UpozorneniCondition"]: {
		/** Checks for equality with the objects `upId` field. */
	upId?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `upKdo` field. */
	upKdo?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `upNadpis` field. */
	upNadpis?: string | undefined,
	/** Checks for equality with the objects `upText` field. */
	upText?: string | undefined,
	/** Checks for equality with the objects `upBarvy` field. */
	upBarvy?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `upLock` field. */
	upLock?: boolean | undefined,
	/** Checks for equality with the objects `upTimestamp` field. */
	upTimestamp?: GraphQLTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `upTimestampAdd` field. */
	upTimestampAdd?: GraphQLTypes["Datetime"] | undefined
};
	/** A `AkceItem` edge in the connection. */
["AkceItemsEdge"]: {
	__typename: "AkceItemsEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `AkceItem` at the end of the edge. */
	node: GraphQLTypes["AkceItem"]
};
	/** A `Akce` edge in the connection. */
["AkcesEdge"]: {
	__typename: "AkcesEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `Akce` at the end of the edge. */
	node: GraphQLTypes["Akce"]
};
	/** Methods to use when ordering `Akce`. */
["AkcesOrderBy"]: AkcesOrderBy;
	/** A condition to be used against `Akce` object types. All fields are tested for equality and combined with a logical and. */
["AkceCondition"]: {
		/** Checks for equality with the objects `aId` field. */
	aId?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `aJmeno` field. */
	aJmeno?: string | undefined,
	/** Checks for equality with the objects `aKde` field. */
	aKde?: string | undefined,
	/** Checks for equality with the objects `aInfo` field. */
	aInfo?: string | undefined,
	/** Checks for equality with the objects `aOd` field. */
	aOd?: GraphQLTypes["Date"] | undefined,
	/** Checks for equality with the objects `aDo` field. */
	aDo?: GraphQLTypes["Date"] | undefined,
	/** Checks for equality with the objects `aKapacita` field. */
	aKapacita?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `aDokumenty` field. */
	aDokumenty?: string | undefined,
	/** Checks for equality with the objects `aTimestamp` field. */
	aTimestamp?: GraphQLTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `aLock` field. */
	aLock?: boolean | undefined,
	/** Checks for equality with the objects `aVisible` field. */
	aVisible?: boolean | undefined
};
	/** A connection to a list of `GalerieDir` values. */
["GalerieDirsConnection"]: {
	__typename: "GalerieDirsConnection",
	/** A list of `GalerieDir` objects. */
	nodes: Array<GraphQLTypes["GalerieDir"]>,
	/** A list of edges which contains the `GalerieDir` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["GalerieDirsEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: GraphQLTypes["PageInfo"],
	/** The count of *all* `GalerieDir` you could get from the connection. */
	totalCount: number
};
	/** A `GalerieDir` edge in the connection. */
["GalerieDirsEdge"]: {
	__typename: "GalerieDirsEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `GalerieDir` at the end of the edge. */
	node: GraphQLTypes["GalerieDir"]
};
	/** Methods to use when ordering `GalerieDir`. */
["GalerieDirsOrderBy"]: GalerieDirsOrderBy;
	/** A condition to be used against `GalerieDir` object types. All fields are tested
for equality and combined with a logical and. */
["GalerieDirCondition"]: {
		/** Checks for equality with the objects `gdId` field. */
	gdId?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `gdIdRodic` field. */
	gdIdRodic?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `gdName` field. */
	gdName?: string | undefined,
	/** Checks for equality with the objects `gdLevel` field. */
	gdLevel?: number | undefined,
	/** Checks for equality with the objects `gdPath` field. */
	gdPath?: string | undefined,
	/** Checks for equality with the objects `gdHidden` field. */
	gdHidden?: boolean | undefined
};
	/** A connection to a list of `Member` values. */
["MembersConnection"]: {
	__typename: "MembersConnection",
	/** A list of `Member` objects. */
	nodes: Array<GraphQLTypes["Member"]>,
	/** A list of edges which contains the `Member` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["MembersEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: GraphQLTypes["PageInfo"],
	/** The count of *all* `Member` you could get from the connection. */
	totalCount: number
};
	["Member"]: {
	__typename: "Member",
	uId?: GraphQLTypes["BigInt"] | undefined,
	uLogin?: string | undefined,
	uPass?: string | undefined,
	uJmeno?: string | undefined,
	uPrijmeni?: string | undefined,
	uPohlavi?: string | undefined,
	uEmail?: string | undefined,
	uTelefon?: string | undefined,
	uNarozeni?: GraphQLTypes["Date"] | undefined,
	uRodneCislo?: string | undefined,
	uPoznamky?: string | undefined,
	uTimestamp?: GraphQLTypes["Datetime"] | undefined,
	uLevel?: number | undefined,
	uGroup?: GraphQLTypes["BigInt"] | undefined,
	uSkupina?: GraphQLTypes["BigInt"] | undefined,
	uDancer?: boolean | undefined,
	uBan?: boolean | undefined,
	uLock?: boolean | undefined,
	uConfirmed?: boolean | undefined,
	uSystem?: boolean | undefined,
	uStreet?: string | undefined,
	uConscriptionNumber?: string | undefined,
	uOrientationNumber?: string | undefined,
	uDistrict?: string | undefined,
	uCity?: string | undefined,
	uPostalCode?: string | undefined,
	uNationality?: string | undefined,
	uMemberSince?: GraphQLTypes["Datetime"] | undefined,
	uMemberUntil?: GraphQLTypes["Datetime"] | undefined,
	uCreatedAt?: GraphQLTypes["Datetime"] | undefined,
	uTeacher?: boolean | undefined,
	uGdprSignedAt?: GraphQLTypes["Datetime"] | undefined,
	sId?: GraphQLTypes["BigInt"] | undefined,
	sName?: string | undefined,
	paymentValid?: boolean | undefined
};
	/** A `Member` edge in the connection. */
["MembersEdge"]: {
	__typename: "MembersEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `Member` at the end of the edge. */
	node: GraphQLTypes["Member"]
};
	/** Methods to use when ordering `Member`. */
["MembersOrderBy"]: MembersOrderBy;
	/** A condition to be used against `Member` object types. All fields are tested for equality and combined with a logical and. */
["MemberCondition"]: {
		/** Checks for equality with the objects `uId` field. */
	uId?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `uLogin` field. */
	uLogin?: string | undefined,
	/** Checks for equality with the objects `uPass` field. */
	uPass?: string | undefined,
	/** Checks for equality with the objects `uJmeno` field. */
	uJmeno?: string | undefined,
	/** Checks for equality with the objects `uPrijmeni` field. */
	uPrijmeni?: string | undefined,
	/** Checks for equality with the objects `uPohlavi` field. */
	uPohlavi?: string | undefined,
	/** Checks for equality with the objects `uEmail` field. */
	uEmail?: string | undefined,
	/** Checks for equality with the objects `uTelefon` field. */
	uTelefon?: string | undefined,
	/** Checks for equality with the objects `uNarozeni` field. */
	uNarozeni?: GraphQLTypes["Date"] | undefined,
	/** Checks for equality with the objects `uRodneCislo` field. */
	uRodneCislo?: string | undefined,
	/** Checks for equality with the objects `uPoznamky` field. */
	uPoznamky?: string | undefined,
	/** Checks for equality with the objects `uTimestamp` field. */
	uTimestamp?: GraphQLTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `uLevel` field. */
	uLevel?: number | undefined,
	/** Checks for equality with the objects `uGroup` field. */
	uGroup?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `uSkupina` field. */
	uSkupina?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `uDancer` field. */
	uDancer?: boolean | undefined,
	/** Checks for equality with the objects `uBan` field. */
	uBan?: boolean | undefined,
	/** Checks for equality with the objects `uLock` field. */
	uLock?: boolean | undefined,
	/** Checks for equality with the objects `uConfirmed` field. */
	uConfirmed?: boolean | undefined,
	/** Checks for equality with the objects `uSystem` field. */
	uSystem?: boolean | undefined,
	/** Checks for equality with the objects `uStreet` field. */
	uStreet?: string | undefined,
	/** Checks for equality with the objects `uConscriptionNumber` field. */
	uConscriptionNumber?: string | undefined,
	/** Checks for equality with the objects `uOrientationNumber` field. */
	uOrientationNumber?: string | undefined,
	/** Checks for equality with the objects `uDistrict` field. */
	uDistrict?: string | undefined,
	/** Checks for equality with the objects `uCity` field. */
	uCity?: string | undefined,
	/** Checks for equality with the objects `uPostalCode` field. */
	uPostalCode?: string | undefined,
	/** Checks for equality with the objects `uNationality` field. */
	uNationality?: string | undefined,
	/** Checks for equality with the objects `uMemberSince` field. */
	uMemberSince?: GraphQLTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `uMemberUntil` field. */
	uMemberUntil?: GraphQLTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `uCreatedAt` field. */
	uCreatedAt?: GraphQLTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `uTeacher` field. */
	uTeacher?: boolean | undefined,
	/** Checks for equality with the objects `uGdprSignedAt` field. */
	uGdprSignedAt?: GraphQLTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `sId` field. */
	sId?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `sName` field. */
	sName?: string | undefined,
	/** Checks for equality with the objects `paymentValid` field. */
	paymentValid?: boolean | undefined
};
	/** A connection to a list of `Page` values. */
["PagesConnection"]: {
	__typename: "PagesConnection",
	/** A list of `Page` objects. */
	nodes: Array<GraphQLTypes["Page"]>,
	/** A list of edges which contains the `Page` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["PagesEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: GraphQLTypes["PageInfo"],
	/** The count of *all* `Page` you could get from the connection. */
	totalCount: number
};
	["Page"]: {
	__typename: "Page",
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	id: number,
	url: string,
	content: GraphQLTypes["JSON"],
	createdAt: GraphQLTypes["Datetime"],
	updatedAt: GraphQLTypes["Datetime"],
	title: string
};
	/** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
["JSON"]: "scalar" & { name: "JSON" };
	/** A `Page` edge in the connection. */
["PagesEdge"]: {
	__typename: "PagesEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `Page` at the end of the edge. */
	node: GraphQLTypes["Page"]
};
	/** Methods to use when ordering `Page`. */
["PagesOrderBy"]: PagesOrderBy;
	/** A condition to be used against `Page` object types. All fields are tested for equality and combined with a logical and. */
["PageCondition"]: {
		/** Checks for equality with the objects `id` field. */
	id?: number | undefined,
	/** Checks for equality with the objects `url` field. */
	url?: string | undefined,
	/** Checks for equality with the objects `content` field. */
	content?: GraphQLTypes["JSON"] | undefined,
	/** Checks for equality with the objects `createdAt` field. */
	createdAt?: GraphQLTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `updatedAt` field. */
	updatedAt?: GraphQLTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `title` field. */
	title?: string | undefined
};
	/** A connection to a list of `PageRevision` values. */
["PageRevisionsConnection"]: {
	__typename: "PageRevisionsConnection",
	/** A list of `PageRevision` objects. */
	nodes: Array<GraphQLTypes["PageRevision"]>,
	/** A list of edges which contains the `PageRevision` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["PageRevisionsEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: GraphQLTypes["PageInfo"],
	/** The count of *all* `PageRevision` you could get from the connection. */
	totalCount: number
};
	["PageRevision"]: {
	__typename: "PageRevision",
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	revNumber: number,
	revOperation: string,
	revTimestamp?: GraphQLTypes["Datetime"] | undefined,
	id: number,
	url: string,
	content: GraphQLTypes["JSON"],
	createdAt: GraphQLTypes["Datetime"],
	updatedAt: GraphQLTypes["Datetime"],
	title: string
};
	/** A `PageRevision` edge in the connection. */
["PageRevisionsEdge"]: {
	__typename: "PageRevisionsEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `PageRevision` at the end of the edge. */
	node: GraphQLTypes["PageRevision"]
};
	/** Methods to use when ordering `PageRevision`. */
["PageRevisionsOrderBy"]: PageRevisionsOrderBy;
	/** A condition to be used against `PageRevision` object types. All fields are
tested for equality and combined with a logical and. */
["PageRevisionCondition"]: {
		/** Checks for equality with the objects `revNumber` field. */
	revNumber?: number | undefined,
	/** Checks for equality with the objects `revOperation` field. */
	revOperation?: string | undefined,
	/** Checks for equality with the objects `revTimestamp` field. */
	revTimestamp?: GraphQLTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `id` field. */
	id?: number | undefined,
	/** Checks for equality with the objects `url` field. */
	url?: string | undefined,
	/** Checks for equality with the objects `content` field. */
	content?: GraphQLTypes["JSON"] | undefined,
	/** Checks for equality with the objects `createdAt` field. */
	createdAt?: GraphQLTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `updatedAt` field. */
	updatedAt?: GraphQLTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `title` field. */
	title?: string | undefined
};
	/** A connection to a list of `Parameter` values. */
["ParametersConnection"]: {
	__typename: "ParametersConnection",
	/** A list of `Parameter` objects. */
	nodes: Array<GraphQLTypes["Parameter"]>,
	/** A list of edges which contains the `Parameter` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["ParametersEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: GraphQLTypes["PageInfo"],
	/** The count of *all* `Parameter` you could get from the connection. */
	totalCount: number
};
	["Parameter"]: {
	__typename: "Parameter",
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	paName: string,
	paValue: string
};
	/** A `Parameter` edge in the connection. */
["ParametersEdge"]: {
	__typename: "ParametersEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `Parameter` at the end of the edge. */
	node: GraphQLTypes["Parameter"]
};
	/** Methods to use when ordering `Parameter`. */
["ParametersOrderBy"]: ParametersOrderBy;
	/** A condition to be used against `Parameter` object types. All fields are tested
for equality and combined with a logical and. */
["ParameterCondition"]: {
		/** Checks for equality with the objects `paName` field. */
	paName?: string | undefined,
	/** Checks for equality with the objects `paValue` field. */
	paValue?: string | undefined
};
	/** A connection to a list of `Permission` values. */
["PermissionsConnection"]: {
	__typename: "PermissionsConnection",
	/** A list of `Permission` objects. */
	nodes: Array<GraphQLTypes["Permission"]>,
	/** A list of edges which contains the `Permission` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["PermissionsEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: GraphQLTypes["PageInfo"],
	/** The count of *all* `Permission` you could get from the connection. */
	totalCount: number
};
	/** A `Permission` edge in the connection. */
["PermissionsEdge"]: {
	__typename: "PermissionsEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `Permission` at the end of the edge. */
	node: GraphQLTypes["Permission"]
};
	/** Methods to use when ordering `Permission`. */
["PermissionsOrderBy"]: PermissionsOrderBy;
	/** A condition to be used against `Permission` object types. All fields are tested
for equality and combined with a logical and. */
["PermissionCondition"]: {
		/** Checks for equality with the objects `peId` field. */
	peId?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `peName` field. */
	peName?: string | undefined,
	/** Checks for equality with the objects `peDescription` field. */
	peDescription?: string | undefined,
	/** Checks for equality with the objects `peAkce` field. */
	peAkce?: number | undefined,
	/** Checks for equality with the objects `peAktuality` field. */
	peAktuality?: number | undefined,
	/** Checks for equality with the objects `peAnkety` field. */
	peAnkety?: number | undefined,
	/** Checks for equality with the objects `peDokumenty` field. */
	peDokumenty?: number | undefined,
	/** Checks for equality with the objects `peGalerie` field. */
	peGalerie?: number | undefined,
	/** Checks for equality with the objects `peInzerce` field. */
	peInzerce?: number | undefined,
	/** Checks for equality with the objects `peKonzole` field. */
	peKonzole?: number | undefined,
	/** Checks for equality with the objects `peNabidka` field. */
	peNabidka?: number | undefined,
	/** Checks for equality with the objects `peNastenka` field. */
	peNastenka?: number | undefined,
	/** Checks for equality with the objects `peNovinky` field. */
	peNovinky?: number | undefined,
	/** Checks for equality with the objects `pePary` field. */
	pePary?: number | undefined,
	/** Checks for equality with the objects `pePlatby` field. */
	pePlatby?: number | undefined,
	/** Checks for equality with the objects `pePermissions` field. */
	pePermissions?: number | undefined,
	/** Checks for equality with the objects `peRozpis` field. */
	peRozpis?: number | undefined,
	/** Checks for equality with the objects `peSkupiny` field. */
	peSkupiny?: number | undefined,
	/** Checks for equality with the objects `peUsers` field. */
	peUsers?: number | undefined,
	/** Checks for equality with the objects `peMain` field. */
	peMain?: number | undefined
};
	/** A connection to a list of `PlatbyCategory` values. */
["PlatbyCategoriesConnection"]: {
	__typename: "PlatbyCategoriesConnection",
	/** A list of `PlatbyCategory` objects. */
	nodes: Array<GraphQLTypes["PlatbyCategory"]>,
	/** A list of edges which contains the `PlatbyCategory` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["PlatbyCategoriesEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: GraphQLTypes["PageInfo"],
	/** The count of *all* `PlatbyCategory` you could get from the connection. */
	totalCount: number
};
	/** A `PlatbyCategory` edge in the connection. */
["PlatbyCategoriesEdge"]: {
	__typename: "PlatbyCategoriesEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `PlatbyCategory` at the end of the edge. */
	node: GraphQLTypes["PlatbyCategory"]
};
	/** Methods to use when ordering `PlatbyCategory`. */
["PlatbyCategoriesOrderBy"]: PlatbyCategoriesOrderBy;
	/** A condition to be used against `PlatbyCategory` object types. All fields are
tested for equality and combined with a logical and. */
["PlatbyCategoryCondition"]: {
		/** Checks for equality with the objects `pcId` field. */
	pcId?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `pcName` field. */
	pcName?: string | undefined,
	/** Checks for equality with the objects `pcSymbol` field. */
	pcSymbol?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `pcAmount` field. */
	pcAmount?: GraphQLTypes["BigFloat"] | undefined,
	/** Checks for equality with the objects `pcDateDue` field. */
	pcDateDue?: GraphQLTypes["Date"] | undefined,
	/** Checks for equality with the objects `pcValidFrom` field. */
	pcValidFrom?: GraphQLTypes["Date"] | undefined,
	/** Checks for equality with the objects `pcValidTo` field. */
	pcValidTo?: GraphQLTypes["Date"] | undefined,
	/** Checks for equality with the objects `pcUseBase` field. */
	pcUseBase?: boolean | undefined,
	/** Checks for equality with the objects `pcUsePrefix` field. */
	pcUsePrefix?: boolean | undefined,
	/** Checks for equality with the objects `pcArchive` field. */
	pcArchive?: boolean | undefined,
	/** Checks for equality with the objects `pcVisible` field. */
	pcVisible?: boolean | undefined
};
	/** A connection to a list of `PlatbyGroup` values. */
["PlatbyGroupsConnection"]: {
	__typename: "PlatbyGroupsConnection",
	/** A list of `PlatbyGroup` objects. */
	nodes: Array<GraphQLTypes["PlatbyGroup"]>,
	/** A list of edges which contains the `PlatbyGroup` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["PlatbyGroupsEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: GraphQLTypes["PageInfo"],
	/** The count of *all* `PlatbyGroup` you could get from the connection. */
	totalCount: number
};
	/** A `PlatbyGroup` edge in the connection. */
["PlatbyGroupsEdge"]: {
	__typename: "PlatbyGroupsEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `PlatbyGroup` at the end of the edge. */
	node: GraphQLTypes["PlatbyGroup"]
};
	/** Methods to use when ordering `PlatbyGroup`. */
["PlatbyGroupsOrderBy"]: PlatbyGroupsOrderBy;
	/** A condition to be used against `PlatbyGroup` object types. All fields are tested
for equality and combined with a logical and. */
["PlatbyGroupCondition"]: {
		/** Checks for equality with the objects `pgId` field. */
	pgId?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `pgType` field. */
	pgType?: GraphQLTypes["BigFloat"] | undefined,
	/** Checks for equality with the objects `pgName` field. */
	pgName?: string | undefined,
	/** Checks for equality with the objects `pgDescription` field. */
	pgDescription?: string | undefined,
	/** Checks for equality with the objects `pgBase` field. */
	pgBase?: GraphQLTypes["BigInt"] | undefined
};
	/** A connection to a list of `PlatbyRaw` values. */
["PlatbyRawsConnection"]: {
	__typename: "PlatbyRawsConnection",
	/** A list of `PlatbyRaw` objects. */
	nodes: Array<GraphQLTypes["PlatbyRaw"]>,
	/** A list of edges which contains the `PlatbyRaw` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["PlatbyRawsEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: GraphQLTypes["PageInfo"],
	/** The count of *all* `PlatbyRaw` you could get from the connection. */
	totalCount: number
};
	/** A `PlatbyRaw` edge in the connection. */
["PlatbyRawsEdge"]: {
	__typename: "PlatbyRawsEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `PlatbyRaw` at the end of the edge. */
	node: GraphQLTypes["PlatbyRaw"]
};
	/** Methods to use when ordering `PlatbyRaw`. */
["PlatbyRawsOrderBy"]: PlatbyRawsOrderBy;
	/** A condition to be used against `PlatbyRaw` object types. All fields are tested
for equality and combined with a logical and. */
["PlatbyRawCondition"]: {
		/** Checks for equality with the objects `prId` field. */
	prId?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `prRaw` field. */
	prRaw?: string | undefined,
	/** Checks for equality with the objects `prHash` field. */
	prHash?: string | undefined,
	/** Checks for equality with the objects `prSorted` field. */
	prSorted?: boolean | undefined,
	/** Checks for equality with the objects `prDiscarded` field. */
	prDiscarded?: boolean | undefined
};
	/** A connection to a list of `Skupiny` values. */
["SkupiniesConnection"]: {
	__typename: "SkupiniesConnection",
	/** A list of `Skupiny` objects. */
	nodes: Array<GraphQLTypes["Skupiny"]>,
	/** A list of edges which contains the `Skupiny` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["SkupiniesEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: GraphQLTypes["PageInfo"],
	/** The count of *all* `Skupiny` you could get from the connection. */
	totalCount: number
};
	/** A `Skupiny` edge in the connection. */
["SkupiniesEdge"]: {
	__typename: "SkupiniesEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `Skupiny` at the end of the edge. */
	node: GraphQLTypes["Skupiny"]
};
	/** Methods to use when ordering `Skupiny`. */
["SkupiniesOrderBy"]: SkupiniesOrderBy;
	/** A condition to be used against `Skupiny` object types. All fields are tested for equality and combined with a logical and. */
["SkupinyCondition"]: {
		/** Checks for equality with the objects `sId` field. */
	sId?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `sName` field. */
	sName?: string | undefined,
	/** Checks for equality with the objects `sDescription` field. */
	sDescription?: string | undefined,
	/** Checks for equality with the objects `sColorRgb` field. */
	sColorRgb?: string | undefined,
	/** Checks for equality with the objects `sColorText` field. */
	sColorText?: string | undefined,
	/** Checks for equality with the objects `sLocation` field. */
	sLocation?: string | undefined,
	/** Checks for equality with the objects `sVisible` field. */
	sVisible?: boolean | undefined
};
	/** A connection to a list of `UsersSkupiny` values. */
["UsersSkupiniesConnection"]: {
	__typename: "UsersSkupiniesConnection",
	/** A list of `UsersSkupiny` objects. */
	nodes: Array<GraphQLTypes["UsersSkupiny"]>,
	/** A list of edges which contains the `UsersSkupiny` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["UsersSkupiniesEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: GraphQLTypes["PageInfo"],
	/** The count of *all* `UsersSkupiny` you could get from the connection. */
	totalCount: number
};
	["UsersSkupiny"]: {
	__typename: "UsersSkupiny",
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	usId: GraphQLTypes["BigInt"],
	usColor: string,
	usPlatbaMesic: GraphQLTypes["BigInt"],
	usPlatbaCtvrtrok: GraphQLTypes["BigInt"],
	usPlatbaPulrok: GraphQLTypes["BigInt"],
	usPopis: string
};
	/** A `UsersSkupiny` edge in the connection. */
["UsersSkupiniesEdge"]: {
	__typename: "UsersSkupiniesEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `UsersSkupiny` at the end of the edge. */
	node: GraphQLTypes["UsersSkupiny"]
};
	/** Methods to use when ordering `UsersSkupiny`. */
["UsersSkupiniesOrderBy"]: UsersSkupiniesOrderBy;
	/** A condition to be used against `UsersSkupiny` object types. All fields are
tested for equality and combined with a logical and. */
["UsersSkupinyCondition"]: {
		/** Checks for equality with the objects `usId` field. */
	usId?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `usColor` field. */
	usColor?: string | undefined,
	/** Checks for equality with the objects `usPlatbaMesic` field. */
	usPlatbaMesic?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `usPlatbaCtvrtrok` field. */
	usPlatbaCtvrtrok?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `usPlatbaPulrok` field. */
	usPlatbaPulrok?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `usPopis` field. */
	usPopis?: string | undefined
};
	/** A connection to a list of `Video` values. */
["VideosConnection"]: {
	__typename: "VideosConnection",
	/** A list of `Video` objects. */
	nodes: Array<GraphQLTypes["Video"]>,
	/** A list of edges which contains the `Video` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["VideosEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: GraphQLTypes["PageInfo"],
	/** The count of *all* `Video` you could get from the connection. */
	totalCount: number
};
	["Video"]: {
	__typename: "Video",
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	vId: GraphQLTypes["BigInt"],
	vUri: string,
	vTitle: string,
	vAuthor: string,
	vDescription: string,
	vPlaylist?: string | undefined,
	vCreatedAt: GraphQLTypes["Datetime"],
	vUpdatedAt: GraphQLTypes["Datetime"]
};
	/** A `Video` edge in the connection. */
["VideosEdge"]: {
	__typename: "VideosEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `Video` at the end of the edge. */
	node: GraphQLTypes["Video"]
};
	/** Methods to use when ordering `Video`. */
["VideosOrderBy"]: VideosOrderBy;
	/** A condition to be used against `Video` object types. All fields are tested for equality and combined with a logical and. */
["VideoCondition"]: {
		/** Checks for equality with the objects `vId` field. */
	vId?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `vUri` field. */
	vUri?: string | undefined,
	/** Checks for equality with the objects `vTitle` field. */
	vTitle?: string | undefined,
	/** Checks for equality with the objects `vAuthor` field. */
	vAuthor?: string | undefined,
	/** Checks for equality with the objects `vDescription` field. */
	vDescription?: string | undefined,
	/** Checks for equality with the objects `vPlaylist` field. */
	vPlaylist?: string | undefined,
	/** Checks for equality with the objects `vCreatedAt` field. */
	vCreatedAt?: GraphQLTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `vUpdatedAt` field. */
	vUpdatedAt?: GraphQLTypes["Datetime"] | undefined
};
	/** A connection to a list of `VideoList` values. */
["VideoListsConnection"]: {
	__typename: "VideoListsConnection",
	/** A list of `VideoList` objects. */
	nodes: Array<GraphQLTypes["VideoList"]>,
	/** A list of edges which contains the `VideoList` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["VideoListsEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: GraphQLTypes["PageInfo"],
	/** The count of *all* `VideoList` you could get from the connection. */
	totalCount: number
};
	["VideoList"]: {
	__typename: "VideoList",
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	vlId: GraphQLTypes["BigInt"],
	vlUrl: string,
	vlTitle: string,
	vlDescription: string,
	vlCount: GraphQLTypes["BigInt"],
	vlCreatedAt: GraphQLTypes["Datetime"],
	vlLastChecked?: GraphQLTypes["Datetime"] | undefined
};
	/** A `VideoList` edge in the connection. */
["VideoListsEdge"]: {
	__typename: "VideoListsEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `VideoList` at the end of the edge. */
	node: GraphQLTypes["VideoList"]
};
	/** Methods to use when ordering `VideoList`. */
["VideoListsOrderBy"]: VideoListsOrderBy;
	/** A condition to be used against `VideoList` object types. All fields are tested
for equality and combined with a logical and. */
["VideoListCondition"]: {
		/** Checks for equality with the objects `vlId` field. */
	vlId?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `vlUrl` field. */
	vlUrl?: string | undefined,
	/** Checks for equality with the objects `vlTitle` field. */
	vlTitle?: string | undefined,
	/** Checks for equality with the objects `vlDescription` field. */
	vlDescription?: string | undefined,
	/** Checks for equality with the objects `vlCount` field. */
	vlCount?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `vlCreatedAt` field. */
	vlCreatedAt?: GraphQLTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `vlLastChecked` field. */
	vlLastChecked?: GraphQLTypes["Datetime"] | undefined
};
	/** A connection to a list of `VideoSource` values. */
["VideoSourcesConnection"]: {
	__typename: "VideoSourcesConnection",
	/** A list of `VideoSource` objects. */
	nodes: Array<GraphQLTypes["VideoSource"]>,
	/** A list of edges which contains the `VideoSource` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["VideoSourcesEdge"]>,
	/** Information to aid in pagination. */
	pageInfo: GraphQLTypes["PageInfo"],
	/** The count of *all* `VideoSource` you could get from the connection. */
	totalCount: number
};
	["VideoSource"]: {
	__typename: "VideoSource",
	/** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
	nodeId: string,
	vsId: GraphQLTypes["BigInt"],
	vsUrl: string,
	vsTitle?: string | undefined,
	vsDescription?: string | undefined,
	vsCreatedAt: GraphQLTypes["Datetime"],
	vsLastChecked?: GraphQLTypes["Datetime"] | undefined
};
	/** A `VideoSource` edge in the connection. */
["VideoSourcesEdge"]: {
	__typename: "VideoSourcesEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `VideoSource` at the end of the edge. */
	node: GraphQLTypes["VideoSource"]
};
	/** Methods to use when ordering `VideoSource`. */
["VideoSourcesOrderBy"]: VideoSourcesOrderBy;
	/** A condition to be used against `VideoSource` object types. All fields are tested
for equality and combined with a logical and. */
["VideoSourceCondition"]: {
		/** Checks for equality with the objects `vsId` field. */
	vsId?: GraphQLTypes["BigInt"] | undefined,
	/** Checks for equality with the objects `vsUrl` field. */
	vsUrl?: string | undefined,
	/** Checks for equality with the objects `vsTitle` field. */
	vsTitle?: string | undefined,
	/** Checks for equality with the objects `vsDescription` field. */
	vsDescription?: string | undefined,
	/** Checks for equality with the objects `vsCreatedAt` field. */
	vsCreatedAt?: GraphQLTypes["Datetime"] | undefined,
	/** Checks for equality with the objects `vsLastChecked` field. */
	vsLastChecked?: GraphQLTypes["Datetime"] | undefined
};
	/** A connection to a list of `ActiveProspectsRecord` values. */
["ActiveProspectsConnection"]: {
	__typename: "ActiveProspectsConnection",
	/** A list of `ActiveProspectsRecord` objects. */
	nodes: Array<GraphQLTypes["ActiveProspectsRecord"]>,
	/** A list of edges which contains the `ActiveProspectsRecord` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["ActiveProspectEdge"]>,
	/** The count of *all* `ActiveProspectsRecord` you could get from the connection. */
	totalCount: number
};
	/** The return type of our `activeProspects` query. */
["ActiveProspectsRecord"]: {
	__typename: "ActiveProspectsRecord",
	id?: GraphQLTypes["BigInt"] | undefined,
	data?: GraphQLTypes["ProspectDatum"] | undefined,
	cohort?: GraphQLTypes["CrmCohort"] | undefined,
	updatedAt?: GraphQLTypes["Datetime"] | undefined
};
	["ProspectDatum"]: {
	__typename: "ProspectDatum",
	name?: string | undefined,
	surname?: string | undefined,
	email?: string | undefined,
	phone?: string | undefined,
	yearofbirth?: string | undefined
};
	["CrmCohort"]: CrmCohort;
	/** A `ActiveProspectsRecord` edge in the connection. */
["ActiveProspectEdge"]: {
	__typename: "ActiveProspectEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `ActiveProspectsRecord` at the end of the edge. */
	node: GraphQLTypes["ActiveProspectsRecord"]
};
	/** A connection to a list of `BigInt` values. */
["CurrentCoupleIdsConnection"]: {
	__typename: "CurrentCoupleIdsConnection",
	/** A list of `BigInt` objects. */
	nodes: Array<GraphQLTypes["BigInt"] | undefined>,
	/** A list of edges which contains the `BigInt` and cursor to aid in pagination. */
	edges: Array<GraphQLTypes["CurrentCoupleIdEdge"]>,
	/** The count of *all* `BigInt` you could get from the connection. */
	totalCount: number
};
	/** A `BigInt` edge in the connection. */
["CurrentCoupleIdEdge"]: {
	__typename: "CurrentCoupleIdEdge",
	/** A cursor for use in pagination. */
	cursor?: GraphQLTypes["Cursor"] | undefined,
	/** The `BigInt` at the end of the edge. */
	node?: GraphQLTypes["BigInt"] | undefined
};
	/** The root mutation type which contains root level fields which mutate data. */
["Mutation"]: {
	__typename: "Mutation",
	/** Creates a single `Akce`. */
	createAkce?: GraphQLTypes["CreateAkcePayload"] | undefined,
	/** Creates a single `AkceItem`. */
	createAkceItem?: GraphQLTypes["CreateAkceItemPayload"] | undefined,
	/** Creates a single `Aktuality`. */
	createAktuality?: GraphQLTypes["CreateAktualityPayload"] | undefined,
	/** Creates a single `Dokumenty`. */
	createDokumenty?: GraphQLTypes["CreateDokumentyPayload"] | undefined,
	/** Creates a single `GalerieDir`. */
	createGalerieDir?: GraphQLTypes["CreateGalerieDirPayload"] | undefined,
	/** Creates a single `GalerieFoto`. */
	createGalerieFoto?: GraphQLTypes["CreateGalerieFotoPayload"] | undefined,
	/** Creates a single `Nabidka`. */
	createNabidka?: GraphQLTypes["CreateNabidkaPayload"] | undefined,
	/** Creates a single `NabidkaItem`. */
	createNabidkaItem?: GraphQLTypes["CreateNabidkaItemPayload"] | undefined,
	/** Creates a single `Page`. */
	createPage?: GraphQLTypes["CreatePagePayload"] | undefined,
	/** Creates a single `Parameter`. */
	createParameter?: GraphQLTypes["CreateParameterPayload"] | undefined,
	/** Creates a single `Pary`. */
	createPary?: GraphQLTypes["CreateParyPayload"] | undefined,
	/** Creates a single `ParyNavrh`. */
	createParyNavrh?: GraphQLTypes["CreateParyNavrhPayload"] | undefined,
	/** Creates a single `Permission`. */
	createPermission?: GraphQLTypes["CreatePermissionPayload"] | undefined,
	/** Creates a single `PlatbyCategory`. */
	createPlatbyCategory?: GraphQLTypes["CreatePlatbyCategoryPayload"] | undefined,
	/** Creates a single `PlatbyCategoryGroup`. */
	createPlatbyCategoryGroup?: GraphQLTypes["CreatePlatbyCategoryGroupPayload"] | undefined,
	/** Creates a single `PlatbyGroup`. */
	createPlatbyGroup?: GraphQLTypes["CreatePlatbyGroupPayload"] | undefined,
	/** Creates a single `PlatbyGroupSkupina`. */
	createPlatbyGroupSkupina?: GraphQLTypes["CreatePlatbyGroupSkupinaPayload"] | undefined,
	/** Creates a single `PlatbyItem`. */
	createPlatbyItem?: GraphQLTypes["CreatePlatbyItemPayload"] | undefined,
	/** Creates a single `PlatbyRaw`. */
	createPlatbyRaw?: GraphQLTypes["CreatePlatbyRawPayload"] | undefined,
	/** Creates a single `Rozpi`. */
	createRozpi?: GraphQLTypes["CreateRozpiPayload"] | undefined,
	/** Creates a single `RozpisItem`. */
	createRozpisItem?: GraphQLTypes["CreateRozpisItemPayload"] | undefined,
	/** Creates a single `Session`. */
	createSession?: GraphQLTypes["CreateSessionPayload"] | undefined,
	/** Creates a single `Skupiny`. */
	createSkupiny?: GraphQLTypes["CreateSkupinyPayload"] | undefined,
	/** Creates a single `Upozorneni`. */
	createUpozorneni?: GraphQLTypes["CreateUpozorneniPayload"] | undefined,
	/** Creates a single `UpozorneniSkupiny`. */
	createUpozorneniSkupiny?: GraphQLTypes["CreateUpozorneniSkupinyPayload"] | undefined,
	/** Creates a single `User`. */
	createUser?: GraphQLTypes["CreateUserPayload"] | undefined,
	/** Creates a single `UsersSkupiny`. */
	createUsersSkupiny?: GraphQLTypes["CreateUsersSkupinyPayload"] | undefined,
	/** Creates a single `Video`. */
	createVideo?: GraphQLTypes["CreateVideoPayload"] | undefined,
	/** Creates a single `VideoList`. */
	createVideoList?: GraphQLTypes["CreateVideoListPayload"] | undefined,
	/** Creates a single `VideoSource`. */
	createVideoSource?: GraphQLTypes["CreateVideoSourcePayload"] | undefined,
	/** Updates a single `Akce` using its globally unique id and a patch. */
	updateAkceByNodeId?: GraphQLTypes["UpdateAkcePayload"] | undefined,
	/** Updates a single `Akce` using a unique key and a patch. */
	updateAkce?: GraphQLTypes["UpdateAkcePayload"] | undefined,
	/** Updates a single `AkceItem` using its globally unique id and a patch. */
	updateAkceItemByNodeId?: GraphQLTypes["UpdateAkceItemPayload"] | undefined,
	/** Updates a single `AkceItem` using a unique key and a patch. */
	updateAkceItem?: GraphQLTypes["UpdateAkceItemPayload"] | undefined,
	/** Updates a single `Aktuality` using its globally unique id and a patch. */
	updateAktualityByNodeId?: GraphQLTypes["UpdateAktualityPayload"] | undefined,
	/** Updates a single `Aktuality` using a unique key and a patch. */
	updateAktuality?: GraphQLTypes["UpdateAktualityPayload"] | undefined,
	/** Updates a single `Dokumenty` using its globally unique id and a patch. */
	updateDokumentyByNodeId?: GraphQLTypes["UpdateDokumentyPayload"] | undefined,
	/** Updates a single `Dokumenty` using a unique key and a patch. */
	updateDokumenty?: GraphQLTypes["UpdateDokumentyPayload"] | undefined,
	/** Updates a single `GalerieDir` using its globally unique id and a patch. */
	updateGalerieDirByNodeId?: GraphQLTypes["UpdateGalerieDirPayload"] | undefined,
	/** Updates a single `GalerieDir` using a unique key and a patch. */
	updateGalerieDir?: GraphQLTypes["UpdateGalerieDirPayload"] | undefined,
	/** Updates a single `GalerieFoto` using its globally unique id and a patch. */
	updateGalerieFotoByNodeId?: GraphQLTypes["UpdateGalerieFotoPayload"] | undefined,
	/** Updates a single `GalerieFoto` using a unique key and a patch. */
	updateGalerieFoto?: GraphQLTypes["UpdateGalerieFotoPayload"] | undefined,
	/** Updates a single `Nabidka` using its globally unique id and a patch. */
	updateNabidkaByNodeId?: GraphQLTypes["UpdateNabidkaPayload"] | undefined,
	/** Updates a single `Nabidka` using a unique key and a patch. */
	updateNabidka?: GraphQLTypes["UpdateNabidkaPayload"] | undefined,
	/** Updates a single `NabidkaItem` using its globally unique id and a patch. */
	updateNabidkaItemByNodeId?: GraphQLTypes["UpdateNabidkaItemPayload"] | undefined,
	/** Updates a single `NabidkaItem` using a unique key and a patch. */
	updateNabidkaItem?: GraphQLTypes["UpdateNabidkaItemPayload"] | undefined,
	/** Updates a single `Page` using its globally unique id and a patch. */
	updatePageByNodeId?: GraphQLTypes["UpdatePagePayload"] | undefined,
	/** Updates a single `Page` using a unique key and a patch. */
	updatePage?: GraphQLTypes["UpdatePagePayload"] | undefined,
	/** Updates a single `Page` using a unique key and a patch. */
	updatePageByUrl?: GraphQLTypes["UpdatePagePayload"] | undefined,
	/** Updates a single `Parameter` using its globally unique id and a patch. */
	updateParameterByNodeId?: GraphQLTypes["UpdateParameterPayload"] | undefined,
	/** Updates a single `Parameter` using a unique key and a patch. */
	updateParameter?: GraphQLTypes["UpdateParameterPayload"] | undefined,
	/** Updates a single `Pary` using its globally unique id and a patch. */
	updateParyByNodeId?: GraphQLTypes["UpdateParyPayload"] | undefined,
	/** Updates a single `Pary` using a unique key and a patch. */
	updatePary?: GraphQLTypes["UpdateParyPayload"] | undefined,
	/** Updates a single `ParyNavrh` using its globally unique id and a patch. */
	updateParyNavrhByNodeId?: GraphQLTypes["UpdateParyNavrhPayload"] | undefined,
	/** Updates a single `ParyNavrh` using a unique key and a patch. */
	updateParyNavrh?: GraphQLTypes["UpdateParyNavrhPayload"] | undefined,
	/** Updates a single `Permission` using its globally unique id and a patch. */
	updatePermissionByNodeId?: GraphQLTypes["UpdatePermissionPayload"] | undefined,
	/** Updates a single `Permission` using a unique key and a patch. */
	updatePermission?: GraphQLTypes["UpdatePermissionPayload"] | undefined,
	/** Updates a single `PlatbyCategory` using its globally unique id and a patch. */
	updatePlatbyCategoryByNodeId?: GraphQLTypes["UpdatePlatbyCategoryPayload"] | undefined,
	/** Updates a single `PlatbyCategory` using a unique key and a patch. */
	updatePlatbyCategory?: GraphQLTypes["UpdatePlatbyCategoryPayload"] | undefined,
	/** Updates a single `PlatbyCategoryGroup` using its globally unique id and a patch. */
	updatePlatbyCategoryGroupByNodeId?: GraphQLTypes["UpdatePlatbyCategoryGroupPayload"] | undefined,
	/** Updates a single `PlatbyCategoryGroup` using a unique key and a patch. */
	updatePlatbyCategoryGroup?: GraphQLTypes["UpdatePlatbyCategoryGroupPayload"] | undefined,
	/** Updates a single `PlatbyGroup` using its globally unique id and a patch. */
	updatePlatbyGroupByNodeId?: GraphQLTypes["UpdatePlatbyGroupPayload"] | undefined,
	/** Updates a single `PlatbyGroup` using a unique key and a patch. */
	updatePlatbyGroup?: GraphQLTypes["UpdatePlatbyGroupPayload"] | undefined,
	/** Updates a single `PlatbyGroupSkupina` using its globally unique id and a patch. */
	updatePlatbyGroupSkupinaByNodeId?: GraphQLTypes["UpdatePlatbyGroupSkupinaPayload"] | undefined,
	/** Updates a single `PlatbyGroupSkupina` using a unique key and a patch. */
	updatePlatbyGroupSkupina?: GraphQLTypes["UpdatePlatbyGroupSkupinaPayload"] | undefined,
	/** Updates a single `PlatbyItem` using its globally unique id and a patch. */
	updatePlatbyItemByNodeId?: GraphQLTypes["UpdatePlatbyItemPayload"] | undefined,
	/** Updates a single `PlatbyItem` using a unique key and a patch. */
	updatePlatbyItem?: GraphQLTypes["UpdatePlatbyItemPayload"] | undefined,
	/** Updates a single `PlatbyRaw` using its globally unique id and a patch. */
	updatePlatbyRawByNodeId?: GraphQLTypes["UpdatePlatbyRawPayload"] | undefined,
	/** Updates a single `PlatbyRaw` using a unique key and a patch. */
	updatePlatbyRaw?: GraphQLTypes["UpdatePlatbyRawPayload"] | undefined,
	/** Updates a single `Rozpi` using its globally unique id and a patch. */
	updateRozpiByNodeId?: GraphQLTypes["UpdateRozpiPayload"] | undefined,
	/** Updates a single `Rozpi` using a unique key and a patch. */
	updateRozpi?: GraphQLTypes["UpdateRozpiPayload"] | undefined,
	/** Updates a single `RozpisItem` using its globally unique id and a patch. */
	updateRozpisItemByNodeId?: GraphQLTypes["UpdateRozpisItemPayload"] | undefined,
	/** Updates a single `RozpisItem` using a unique key and a patch. */
	updateRozpisItem?: GraphQLTypes["UpdateRozpisItemPayload"] | undefined,
	/** Updates a single `Session` using its globally unique id and a patch. */
	updateSessionByNodeId?: GraphQLTypes["UpdateSessionPayload"] | undefined,
	/** Updates a single `Session` using a unique key and a patch. */
	updateSession?: GraphQLTypes["UpdateSessionPayload"] | undefined,
	/** Updates a single `Skupiny` using its globally unique id and a patch. */
	updateSkupinyByNodeId?: GraphQLTypes["UpdateSkupinyPayload"] | undefined,
	/** Updates a single `Skupiny` using a unique key and a patch. */
	updateSkupiny?: GraphQLTypes["UpdateSkupinyPayload"] | undefined,
	/** Updates a single `Upozorneni` using its globally unique id and a patch. */
	updateUpozorneniByNodeId?: GraphQLTypes["UpdateUpozorneniPayload"] | undefined,
	/** Updates a single `Upozorneni` using a unique key and a patch. */
	updateUpozorneni?: GraphQLTypes["UpdateUpozorneniPayload"] | undefined,
	/** Updates a single `UpozorneniSkupiny` using its globally unique id and a patch. */
	updateUpozorneniSkupinyByNodeId?: GraphQLTypes["UpdateUpozorneniSkupinyPayload"] | undefined,
	/** Updates a single `UpozorneniSkupiny` using a unique key and a patch. */
	updateUpozorneniSkupiny?: GraphQLTypes["UpdateUpozorneniSkupinyPayload"] | undefined,
	/** Updates a single `User` using its globally unique id and a patch. */
	updateUserByNodeId?: GraphQLTypes["UpdateUserPayload"] | undefined,
	/** Updates a single `User` using a unique key and a patch. */
	updateUser?: GraphQLTypes["UpdateUserPayload"] | undefined,
	/** Updates a single `UsersSkupiny` using its globally unique id and a patch. */
	updateUsersSkupinyByNodeId?: GraphQLTypes["UpdateUsersSkupinyPayload"] | undefined,
	/** Updates a single `UsersSkupiny` using a unique key and a patch. */
	updateUsersSkupiny?: GraphQLTypes["UpdateUsersSkupinyPayload"] | undefined,
	/** Updates a single `Video` using its globally unique id and a patch. */
	updateVideoByNodeId?: GraphQLTypes["UpdateVideoPayload"] | undefined,
	/** Updates a single `Video` using a unique key and a patch. */
	updateVideo?: GraphQLTypes["UpdateVideoPayload"] | undefined,
	/** Updates a single `VideoList` using its globally unique id and a patch. */
	updateVideoListByNodeId?: GraphQLTypes["UpdateVideoListPayload"] | undefined,
	/** Updates a single `VideoList` using a unique key and a patch. */
	updateVideoList?: GraphQLTypes["UpdateVideoListPayload"] | undefined,
	/** Updates a single `VideoSource` using its globally unique id and a patch. */
	updateVideoSourceByNodeId?: GraphQLTypes["UpdateVideoSourcePayload"] | undefined,
	/** Updates a single `VideoSource` using a unique key and a patch. */
	updateVideoSource?: GraphQLTypes["UpdateVideoSourcePayload"] | undefined,
	/** Deletes a single `Akce` using its globally unique id. */
	deleteAkceByNodeId?: GraphQLTypes["DeleteAkcePayload"] | undefined,
	/** Deletes a single `Akce` using a unique key. */
	deleteAkce?: GraphQLTypes["DeleteAkcePayload"] | undefined,
	/** Deletes a single `AkceItem` using its globally unique id. */
	deleteAkceItemByNodeId?: GraphQLTypes["DeleteAkceItemPayload"] | undefined,
	/** Deletes a single `AkceItem` using a unique key. */
	deleteAkceItem?: GraphQLTypes["DeleteAkceItemPayload"] | undefined,
	/** Deletes a single `Aktuality` using its globally unique id. */
	deleteAktualityByNodeId?: GraphQLTypes["DeleteAktualityPayload"] | undefined,
	/** Deletes a single `Aktuality` using a unique key. */
	deleteAktuality?: GraphQLTypes["DeleteAktualityPayload"] | undefined,
	/** Deletes a single `Dokumenty` using its globally unique id. */
	deleteDokumentyByNodeId?: GraphQLTypes["DeleteDokumentyPayload"] | undefined,
	/** Deletes a single `Dokumenty` using a unique key. */
	deleteDokumenty?: GraphQLTypes["DeleteDokumentyPayload"] | undefined,
	/** Deletes a single `GalerieDir` using its globally unique id. */
	deleteGalerieDirByNodeId?: GraphQLTypes["DeleteGalerieDirPayload"] | undefined,
	/** Deletes a single `GalerieDir` using a unique key. */
	deleteGalerieDir?: GraphQLTypes["DeleteGalerieDirPayload"] | undefined,
	/** Deletes a single `GalerieFoto` using its globally unique id. */
	deleteGalerieFotoByNodeId?: GraphQLTypes["DeleteGalerieFotoPayload"] | undefined,
	/** Deletes a single `GalerieFoto` using a unique key. */
	deleteGalerieFoto?: GraphQLTypes["DeleteGalerieFotoPayload"] | undefined,
	/** Deletes a single `Nabidka` using its globally unique id. */
	deleteNabidkaByNodeId?: GraphQLTypes["DeleteNabidkaPayload"] | undefined,
	/** Deletes a single `Nabidka` using a unique key. */
	deleteNabidka?: GraphQLTypes["DeleteNabidkaPayload"] | undefined,
	/** Deletes a single `NabidkaItem` using its globally unique id. */
	deleteNabidkaItemByNodeId?: GraphQLTypes["DeleteNabidkaItemPayload"] | undefined,
	/** Deletes a single `NabidkaItem` using a unique key. */
	deleteNabidkaItem?: GraphQLTypes["DeleteNabidkaItemPayload"] | undefined,
	/** Deletes a single `Parameter` using its globally unique id. */
	deleteParameterByNodeId?: GraphQLTypes["DeleteParameterPayload"] | undefined,
	/** Deletes a single `Parameter` using a unique key. */
	deleteParameter?: GraphQLTypes["DeleteParameterPayload"] | undefined,
	/** Deletes a single `Pary` using its globally unique id. */
	deleteParyByNodeId?: GraphQLTypes["DeleteParyPayload"] | undefined,
	/** Deletes a single `Pary` using a unique key. */
	deletePary?: GraphQLTypes["DeleteParyPayload"] | undefined,
	/** Deletes a single `ParyNavrh` using its globally unique id. */
	deleteParyNavrhByNodeId?: GraphQLTypes["DeleteParyNavrhPayload"] | undefined,
	/** Deletes a single `ParyNavrh` using a unique key. */
	deleteParyNavrh?: GraphQLTypes["DeleteParyNavrhPayload"] | undefined,
	/** Deletes a single `Permission` using its globally unique id. */
	deletePermissionByNodeId?: GraphQLTypes["DeletePermissionPayload"] | undefined,
	/** Deletes a single `Permission` using a unique key. */
	deletePermission?: GraphQLTypes["DeletePermissionPayload"] | undefined,
	/** Deletes a single `PlatbyCategory` using its globally unique id. */
	deletePlatbyCategoryByNodeId?: GraphQLTypes["DeletePlatbyCategoryPayload"] | undefined,
	/** Deletes a single `PlatbyCategory` using a unique key. */
	deletePlatbyCategory?: GraphQLTypes["DeletePlatbyCategoryPayload"] | undefined,
	/** Deletes a single `PlatbyCategoryGroup` using its globally unique id. */
	deletePlatbyCategoryGroupByNodeId?: GraphQLTypes["DeletePlatbyCategoryGroupPayload"] | undefined,
	/** Deletes a single `PlatbyCategoryGroup` using a unique key. */
	deletePlatbyCategoryGroup?: GraphQLTypes["DeletePlatbyCategoryGroupPayload"] | undefined,
	/** Deletes a single `PlatbyGroup` using its globally unique id. */
	deletePlatbyGroupByNodeId?: GraphQLTypes["DeletePlatbyGroupPayload"] | undefined,
	/** Deletes a single `PlatbyGroup` using a unique key. */
	deletePlatbyGroup?: GraphQLTypes["DeletePlatbyGroupPayload"] | undefined,
	/** Deletes a single `PlatbyGroupSkupina` using its globally unique id. */
	deletePlatbyGroupSkupinaByNodeId?: GraphQLTypes["DeletePlatbyGroupSkupinaPayload"] | undefined,
	/** Deletes a single `PlatbyGroupSkupina` using a unique key. */
	deletePlatbyGroupSkupina?: GraphQLTypes["DeletePlatbyGroupSkupinaPayload"] | undefined,
	/** Deletes a single `PlatbyItem` using its globally unique id. */
	deletePlatbyItemByNodeId?: GraphQLTypes["DeletePlatbyItemPayload"] | undefined,
	/** Deletes a single `PlatbyItem` using a unique key. */
	deletePlatbyItem?: GraphQLTypes["DeletePlatbyItemPayload"] | undefined,
	/** Deletes a single `PlatbyRaw` using its globally unique id. */
	deletePlatbyRawByNodeId?: GraphQLTypes["DeletePlatbyRawPayload"] | undefined,
	/** Deletes a single `PlatbyRaw` using a unique key. */
	deletePlatbyRaw?: GraphQLTypes["DeletePlatbyRawPayload"] | undefined,
	/** Deletes a single `Rozpi` using its globally unique id. */
	deleteRozpiByNodeId?: GraphQLTypes["DeleteRozpiPayload"] | undefined,
	/** Deletes a single `Rozpi` using a unique key. */
	deleteRozpi?: GraphQLTypes["DeleteRozpiPayload"] | undefined,
	/** Deletes a single `RozpisItem` using its globally unique id. */
	deleteRozpisItemByNodeId?: GraphQLTypes["DeleteRozpisItemPayload"] | undefined,
	/** Deletes a single `RozpisItem` using a unique key. */
	deleteRozpisItem?: GraphQLTypes["DeleteRozpisItemPayload"] | undefined,
	/** Deletes a single `Session` using its globally unique id. */
	deleteSessionByNodeId?: GraphQLTypes["DeleteSessionPayload"] | undefined,
	/** Deletes a single `Session` using a unique key. */
	deleteSession?: GraphQLTypes["DeleteSessionPayload"] | undefined,
	/** Deletes a single `Skupiny` using its globally unique id. */
	deleteSkupinyByNodeId?: GraphQLTypes["DeleteSkupinyPayload"] | undefined,
	/** Deletes a single `Skupiny` using a unique key. */
	deleteSkupiny?: GraphQLTypes["DeleteSkupinyPayload"] | undefined,
	/** Deletes a single `Upozorneni` using its globally unique id. */
	deleteUpozorneniByNodeId?: GraphQLTypes["DeleteUpozorneniPayload"] | undefined,
	/** Deletes a single `Upozorneni` using a unique key. */
	deleteUpozorneni?: GraphQLTypes["DeleteUpozorneniPayload"] | undefined,
	/** Deletes a single `UpozorneniSkupiny` using its globally unique id. */
	deleteUpozorneniSkupinyByNodeId?: GraphQLTypes["DeleteUpozorneniSkupinyPayload"] | undefined,
	/** Deletes a single `UpozorneniSkupiny` using a unique key. */
	deleteUpozorneniSkupiny?: GraphQLTypes["DeleteUpozorneniSkupinyPayload"] | undefined,
	/** Deletes a single `User` using its globally unique id. */
	deleteUserByNodeId?: GraphQLTypes["DeleteUserPayload"] | undefined,
	/** Deletes a single `User` using a unique key. */
	deleteUser?: GraphQLTypes["DeleteUserPayload"] | undefined,
	/** Deletes a single `UsersSkupiny` using its globally unique id. */
	deleteUsersSkupinyByNodeId?: GraphQLTypes["DeleteUsersSkupinyPayload"] | undefined,
	/** Deletes a single `UsersSkupiny` using a unique key. */
	deleteUsersSkupiny?: GraphQLTypes["DeleteUsersSkupinyPayload"] | undefined,
	/** Deletes a single `Video` using its globally unique id. */
	deleteVideoByNodeId?: GraphQLTypes["DeleteVideoPayload"] | undefined,
	/** Deletes a single `Video` using a unique key. */
	deleteVideo?: GraphQLTypes["DeleteVideoPayload"] | undefined,
	/** Deletes a single `VideoList` using its globally unique id. */
	deleteVideoListByNodeId?: GraphQLTypes["DeleteVideoListPayload"] | undefined,
	/** Deletes a single `VideoList` using a unique key. */
	deleteVideoList?: GraphQLTypes["DeleteVideoListPayload"] | undefined,
	/** Deletes a single `VideoSource` using its globally unique id. */
	deleteVideoSourceByNodeId?: GraphQLTypes["DeleteVideoSourcePayload"] | undefined,
	/** Deletes a single `VideoSource` using a unique key. */
	deleteVideoSource?: GraphQLTypes["DeleteVideoSourcePayload"] | undefined,
	login?: GraphQLTypes["LoginPayload"] | undefined,
	logout?: GraphQLTypes["LogoutPayload"] | undefined,
	prospectFormDancer?: GraphQLTypes["ProspectFormDancerPayload"] | undefined,
	uploadFile: GraphQLTypes["Upload"]
};
	/** The output of our create `Akce` mutation. */
["CreateAkcePayload"]: {
	__typename: "CreateAkcePayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Akce` that was created by this mutation. */
	akce?: GraphQLTypes["Akce"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `Akce`. May be used by Relay 1. */
	akceEdge?: GraphQLTypes["AkcesEdge"] | undefined
};
	/** All input for the create `Akce` mutation. */
["CreateAkceInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `Akce` to be created by this mutation. */
	akce: GraphQLTypes["AkceInput"]
};
	/** An input for mutations affecting `Akce` */
["AkceInput"]: {
		aId?: GraphQLTypes["BigInt"] | undefined,
	aJmeno: string,
	aKde: string,
	aInfo: string,
	aOd: GraphQLTypes["Date"],
	aDo: GraphQLTypes["Date"],
	aKapacita?: GraphQLTypes["BigInt"] | undefined,
	aDokumenty: string,
	aTimestamp?: GraphQLTypes["Datetime"] | undefined,
	aLock?: boolean | undefined,
	aVisible?: boolean | undefined
};
	/** The output of our create `AkceItem` mutation. */
["CreateAkceItemPayload"]: {
	__typename: "CreateAkceItemPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `AkceItem` that was created by this mutation. */
	akceItem?: GraphQLTypes["AkceItem"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `Akce` that is related to this `AkceItem`. */
	akceByAiIdRodic?: GraphQLTypes["Akce"] | undefined,
	/** Reads a single `User` that is related to this `AkceItem`. */
	userByAiUser?: GraphQLTypes["User"] | undefined,
	/** An edge for our `AkceItem`. May be used by Relay 1. */
	akceItemEdge?: GraphQLTypes["AkceItemsEdge"] | undefined
};
	/** All input for the create `AkceItem` mutation. */
["CreateAkceItemInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `AkceItem` to be created by this mutation. */
	akceItem: GraphQLTypes["AkceItemInput"]
};
	/** An input for mutations affecting `AkceItem` */
["AkceItemInput"]: {
		aiId?: GraphQLTypes["BigInt"] | undefined,
	aiIdRodic: GraphQLTypes["BigInt"],
	aiUser: GraphQLTypes["BigInt"],
	aiRokNarozeni: number
};
	/** The output of our create `Aktuality` mutation. */
["CreateAktualityPayload"]: {
	__typename: "CreateAktualityPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Aktuality` that was created by this mutation. */
	aktuality?: GraphQLTypes["Aktuality"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Aktuality`. */
	userByAtKdo?: GraphQLTypes["User"] | undefined,
	/** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
	galerieFotoByAtFotoMain?: GraphQLTypes["GalerieFoto"] | undefined,
	/** An edge for our `Aktuality`. May be used by Relay 1. */
	aktualityEdge?: GraphQLTypes["AktualitiesEdge"] | undefined
};
	/** All input for the create `Aktuality` mutation. */
["CreateAktualityInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `Aktuality` to be created by this mutation. */
	aktuality: GraphQLTypes["AktualityInput"]
};
	/** An input for mutations affecting `Aktuality` */
["AktualityInput"]: {
		atId?: GraphQLTypes["BigInt"] | undefined,
	atKdo: GraphQLTypes["BigInt"],
	atKat: string,
	atJmeno: string,
	atText: string,
	atPreview: string,
	atFoto?: GraphQLTypes["BigInt"] | undefined,
	atFotoMain?: GraphQLTypes["BigInt"] | undefined,
	atTimestamp?: GraphQLTypes["Datetime"] | undefined,
	atTimestampAdd?: GraphQLTypes["Datetime"] | undefined
};
	/** The output of our create `Dokumenty` mutation. */
["CreateDokumentyPayload"]: {
	__typename: "CreateDokumentyPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Dokumenty` that was created by this mutation. */
	dokumenty?: GraphQLTypes["Dokumenty"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Dokumenty`. */
	userByDKdo?: GraphQLTypes["User"] | undefined,
	/** An edge for our `Dokumenty`. May be used by Relay 1. */
	dokumentyEdge?: GraphQLTypes["DokumentiesEdge"] | undefined
};
	/** All input for the create `Dokumenty` mutation. */
["CreateDokumentyInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `Dokumenty` to be created by this mutation. */
	dokumenty: GraphQLTypes["DokumentyInput"]
};
	/** An input for mutations affecting `Dokumenty` */
["DokumentyInput"]: {
		dId?: GraphQLTypes["BigInt"] | undefined,
	dPath: string,
	dName: string,
	dFilename: string,
	dKategorie: number,
	dKdo: GraphQLTypes["BigInt"],
	dTimestamp?: GraphQLTypes["Datetime"] | undefined
};
	/** The output of our create `GalerieDir` mutation. */
["CreateGalerieDirPayload"]: {
	__typename: "CreateGalerieDirPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `GalerieDir` that was created by this mutation. */
	galerieDir?: GraphQLTypes["GalerieDir"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `GalerieDir`. May be used by Relay 1. */
	galerieDirEdge?: GraphQLTypes["GalerieDirsEdge"] | undefined
};
	/** All input for the create `GalerieDir` mutation. */
["CreateGalerieDirInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `GalerieDir` to be created by this mutation. */
	galerieDir: GraphQLTypes["GalerieDirInput"]
};
	/** An input for mutations affecting `GalerieDir` */
["GalerieDirInput"]: {
		gdId?: GraphQLTypes["BigInt"] | undefined,
	gdIdRodic: GraphQLTypes["BigInt"],
	gdName: string,
	gdLevel?: number | undefined,
	gdPath: string,
	gdHidden?: boolean | undefined
};
	/** The output of our create `GalerieFoto` mutation. */
["CreateGalerieFotoPayload"]: {
	__typename: "CreateGalerieFotoPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `GalerieFoto` that was created by this mutation. */
	galerieFoto?: GraphQLTypes["GalerieFoto"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
	galerieDirByGfIdRodic?: GraphQLTypes["GalerieDir"] | undefined,
	/** Reads a single `User` that is related to this `GalerieFoto`. */
	userByGfKdo?: GraphQLTypes["User"] | undefined,
	/** An edge for our `GalerieFoto`. May be used by Relay 1. */
	galerieFotoEdge?: GraphQLTypes["GalerieFotosEdge"] | undefined
};
	/** All input for the create `GalerieFoto` mutation. */
["CreateGalerieFotoInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `GalerieFoto` to be created by this mutation. */
	galerieFoto: GraphQLTypes["GalerieFotoInput"]
};
	/** An input for mutations affecting `GalerieFoto` */
["GalerieFotoInput"]: {
		gfId?: GraphQLTypes["BigInt"] | undefined,
	gfIdRodic: GraphQLTypes["BigInt"],
	gfName: string,
	gfPath: string,
	gfKdo: GraphQLTypes["BigInt"],
	gfTimestamp?: GraphQLTypes["Datetime"] | undefined
};
	/** The output of our create `Nabidka` mutation. */
["CreateNabidkaPayload"]: {
	__typename: "CreateNabidkaPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Nabidka` that was created by this mutation. */
	nabidka?: GraphQLTypes["Nabidka"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Nabidka`. */
	userByNTrener?: GraphQLTypes["User"] | undefined,
	/** An edge for our `Nabidka`. May be used by Relay 1. */
	nabidkaEdge?: GraphQLTypes["NabidkasEdge"] | undefined
};
	/** All input for the create `Nabidka` mutation. */
["CreateNabidkaInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `Nabidka` to be created by this mutation. */
	nabidka: GraphQLTypes["NabidkaInput"]
};
	/** An input for mutations affecting `Nabidka` */
["NabidkaInput"]: {
		nId?: GraphQLTypes["BigInt"] | undefined,
	nTrener: GraphQLTypes["BigInt"],
	nPocetHod?: number | undefined,
	nMaxPocetHod?: GraphQLTypes["BigInt"] | undefined,
	nOd: GraphQLTypes["Date"],
	nDo: GraphQLTypes["Date"],
	nVisible?: boolean | undefined,
	nLock?: boolean | undefined,
	nTimestamp?: GraphQLTypes["Datetime"] | undefined
};
	/** The output of our create `NabidkaItem` mutation. */
["CreateNabidkaItemPayload"]: {
	__typename: "CreateNabidkaItemPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `NabidkaItem` that was created by this mutation. */
	nabidkaItem?: GraphQLTypes["NabidkaItem"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `Nabidka` that is related to this `NabidkaItem`. */
	nabidkaByNiIdRodic?: GraphQLTypes["Nabidka"] | undefined,
	/** Reads a single `Pary` that is related to this `NabidkaItem`. */
	paryByNiPartner?: GraphQLTypes["Pary"] | undefined,
	/** An edge for our `NabidkaItem`. May be used by Relay 1. */
	nabidkaItemEdge?: GraphQLTypes["NabidkaItemsEdge"] | undefined
};
	/** All input for the create `NabidkaItem` mutation. */
["CreateNabidkaItemInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `NabidkaItem` to be created by this mutation. */
	nabidkaItem: GraphQLTypes["NabidkaItemInput"]
};
	/** An input for mutations affecting `NabidkaItem` */
["NabidkaItemInput"]: {
		niId?: GraphQLTypes["BigInt"] | undefined,
	niIdRodic: GraphQLTypes["BigInt"],
	niPartner: GraphQLTypes["BigInt"],
	niPocetHod?: number | undefined,
	niLock?: boolean | undefined
};
	/** The output of our create `Page` mutation. */
["CreatePagePayload"]: {
	__typename: "CreatePagePayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Page` that was created by this mutation. */
	page?: GraphQLTypes["Page"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `Page`. May be used by Relay 1. */
	pageEdge?: GraphQLTypes["PagesEdge"] | undefined
};
	/** All input for the create `Page` mutation. */
["CreatePageInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `Page` to be created by this mutation. */
	page: GraphQLTypes["PageInput"]
};
	/** An input for mutations affecting `Page` */
["PageInput"]: {
		id?: number | undefined,
	url: string,
	content: GraphQLTypes["JSON"],
	createdAt?: GraphQLTypes["Datetime"] | undefined,
	updatedAt?: GraphQLTypes["Datetime"] | undefined,
	title?: string | undefined
};
	/** The output of our create `Parameter` mutation. */
["CreateParameterPayload"]: {
	__typename: "CreateParameterPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Parameter` that was created by this mutation. */
	parameter?: GraphQLTypes["Parameter"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `Parameter`. May be used by Relay 1. */
	parameterEdge?: GraphQLTypes["ParametersEdge"] | undefined
};
	/** All input for the create `Parameter` mutation. */
["CreateParameterInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `Parameter` to be created by this mutation. */
	parameter: GraphQLTypes["ParameterInput"]
};
	/** An input for mutations affecting `Parameter` */
["ParameterInput"]: {
		paName: string,
	paValue: string
};
	/** The output of our create `Pary` mutation. */
["CreateParyPayload"]: {
	__typename: "CreateParyPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Pary` that was created by this mutation. */
	pary?: GraphQLTypes["Pary"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Pary`. */
	userByPIdPartner?: GraphQLTypes["User"] | undefined,
	/** An edge for our `Pary`. May be used by Relay 1. */
	paryEdge?: GraphQLTypes["PariesEdge"] | undefined
};
	/** All input for the create `Pary` mutation. */
["CreateParyInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `Pary` to be created by this mutation. */
	pary: GraphQLTypes["ParyInput"]
};
	/** An input for mutations affecting `Pary` */
["ParyInput"]: {
		pId?: GraphQLTypes["BigInt"] | undefined,
	pIdPartner: GraphQLTypes["BigInt"],
	pIdPartnerka?: GraphQLTypes["BigInt"] | undefined,
	pSttTrida?: GraphQLTypes["ParyPSttTrida"] | undefined,
	pSttBody?: number | undefined,
	pSttFinale?: boolean | undefined,
	pLatTrida?: GraphQLTypes["ParyPLatTrida"] | undefined,
	pLatBody?: number | undefined,
	pLatFinale?: boolean | undefined,
	pHodnoceni?: number | undefined,
	pArchiv?: boolean | undefined,
	pTimestampAdd?: GraphQLTypes["Datetime"] | undefined,
	pTimestampArchive?: GraphQLTypes["Datetime"] | undefined
};
	/** The output of our create `ParyNavrh` mutation. */
["CreateParyNavrhPayload"]: {
	__typename: "CreateParyNavrhPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `ParyNavrh` that was created by this mutation. */
	paryNavrh?: GraphQLTypes["ParyNavrh"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnNavrhl?: GraphQLTypes["User"] | undefined,
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnPartner?: GraphQLTypes["User"] | undefined,
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnPartnerka?: GraphQLTypes["User"] | undefined,
	/** An edge for our `ParyNavrh`. May be used by Relay 1. */
	paryNavrhEdge?: GraphQLTypes["ParyNavrhsEdge"] | undefined
};
	/** All input for the create `ParyNavrh` mutation. */
["CreateParyNavrhInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `ParyNavrh` to be created by this mutation. */
	paryNavrh: GraphQLTypes["ParyNavrhInput"]
};
	/** An input for mutations affecting `ParyNavrh` */
["ParyNavrhInput"]: {
		pnId?: GraphQLTypes["BigInt"] | undefined,
	pnNavrhl: GraphQLTypes["BigInt"],
	pnPartner: GraphQLTypes["BigInt"],
	pnPartnerka: GraphQLTypes["BigInt"]
};
	/** The output of our create `Permission` mutation. */
["CreatePermissionPayload"]: {
	__typename: "CreatePermissionPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Permission` that was created by this mutation. */
	permission?: GraphQLTypes["Permission"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `Permission`. May be used by Relay 1. */
	permissionEdge?: GraphQLTypes["PermissionsEdge"] | undefined
};
	/** All input for the create `Permission` mutation. */
["CreatePermissionInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `Permission` to be created by this mutation. */
	permission: GraphQLTypes["PermissionInput"]
};
	/** An input for mutations affecting `Permission` */
["PermissionInput"]: {
		peId?: GraphQLTypes["BigInt"] | undefined,
	peName: string,
	peDescription: string,
	peAkce: number,
	peAktuality: number,
	peAnkety: number,
	peDokumenty: number,
	peGalerie: number,
	peInzerce: number,
	peKonzole: number,
	peNabidka: number,
	peNastenka: number,
	peNovinky: number,
	pePary: number,
	pePlatby: number,
	pePermissions: number,
	peRozpis: number,
	peSkupiny: number,
	peUsers: number,
	peMain: number
};
	/** The output of our create `PlatbyCategory` mutation. */
["CreatePlatbyCategoryPayload"]: {
	__typename: "CreatePlatbyCategoryPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyCategory` that was created by this mutation. */
	platbyCategory?: GraphQLTypes["PlatbyCategory"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `PlatbyCategory`. May be used by Relay 1. */
	platbyCategoryEdge?: GraphQLTypes["PlatbyCategoriesEdge"] | undefined
};
	/** All input for the create `PlatbyCategory` mutation. */
["CreatePlatbyCategoryInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `PlatbyCategory` to be created by this mutation. */
	platbyCategory: GraphQLTypes["PlatbyCategoryInput"]
};
	/** An input for mutations affecting `PlatbyCategory` */
["PlatbyCategoryInput"]: {
		pcId?: GraphQLTypes["BigInt"] | undefined,
	pcName: string,
	pcSymbol: GraphQLTypes["BigInt"],
	pcAmount: GraphQLTypes["BigFloat"],
	pcDateDue: GraphQLTypes["Date"],
	pcValidFrom: GraphQLTypes["Date"],
	pcValidTo: GraphQLTypes["Date"],
	pcUseBase?: boolean | undefined,
	pcUsePrefix?: boolean | undefined,
	pcArchive?: boolean | undefined,
	pcVisible?: boolean | undefined
};
	/** The output of our create `PlatbyCategoryGroup` mutation. */
["CreatePlatbyCategoryGroupPayload"]: {
	__typename: "CreatePlatbyCategoryGroupPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyCategoryGroup` that was created by this mutation. */
	platbyCategoryGroup?: GraphQLTypes["PlatbyCategoryGroup"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `PlatbyGroup` that is related to this `PlatbyCategoryGroup`. */
	platbyGroupByPcgIdGroup?: GraphQLTypes["PlatbyGroup"] | undefined,
	/** Reads a single `PlatbyCategory` that is related to this `PlatbyCategoryGroup`. */
	platbyCategoryByPcgIdCategory?: GraphQLTypes["PlatbyCategory"] | undefined,
	/** An edge for our `PlatbyCategoryGroup`. May be used by Relay 1. */
	platbyCategoryGroupEdge?: GraphQLTypes["PlatbyCategoryGroupsEdge"] | undefined
};
	/** All input for the create `PlatbyCategoryGroup` mutation. */
["CreatePlatbyCategoryGroupInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `PlatbyCategoryGroup` to be created by this mutation. */
	platbyCategoryGroup: GraphQLTypes["PlatbyCategoryGroupInput"]
};
	/** An input for mutations affecting `PlatbyCategoryGroup` */
["PlatbyCategoryGroupInput"]: {
		pcgId?: GraphQLTypes["BigInt"] | undefined,
	pcgIdGroup: GraphQLTypes["BigInt"],
	pcgIdCategory: GraphQLTypes["BigInt"]
};
	/** The output of our create `PlatbyGroup` mutation. */
["CreatePlatbyGroupPayload"]: {
	__typename: "CreatePlatbyGroupPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyGroup` that was created by this mutation. */
	platbyGroup?: GraphQLTypes["PlatbyGroup"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `PlatbyGroup`. May be used by Relay 1. */
	platbyGroupEdge?: GraphQLTypes["PlatbyGroupsEdge"] | undefined
};
	/** All input for the create `PlatbyGroup` mutation. */
["CreatePlatbyGroupInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `PlatbyGroup` to be created by this mutation. */
	platbyGroup: GraphQLTypes["PlatbyGroupInput"]
};
	/** An input for mutations affecting `PlatbyGroup` */
["PlatbyGroupInput"]: {
		pgId?: GraphQLTypes["BigInt"] | undefined,
	pgType?: GraphQLTypes["BigFloat"] | undefined,
	pgName: string,
	pgDescription: string,
	pgBase?: GraphQLTypes["BigInt"] | undefined
};
	/** The output of our create `PlatbyGroupSkupina` mutation. */
["CreatePlatbyGroupSkupinaPayload"]: {
	__typename: "CreatePlatbyGroupSkupinaPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyGroupSkupina` that was created by this mutation. */
	platbyGroupSkupina?: GraphQLTypes["PlatbyGroupSkupina"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `Skupiny` that is related to this `PlatbyGroupSkupina`. */
	skupinyByPgsIdSkupina?: GraphQLTypes["Skupiny"] | undefined,
	/** Reads a single `PlatbyGroup` that is related to this `PlatbyGroupSkupina`. */
	platbyGroupByPgsIdGroup?: GraphQLTypes["PlatbyGroup"] | undefined,
	/** An edge for our `PlatbyGroupSkupina`. May be used by Relay 1. */
	platbyGroupSkupinaEdge?: GraphQLTypes["PlatbyGroupSkupinasEdge"] | undefined
};
	/** All input for the create `PlatbyGroupSkupina` mutation. */
["CreatePlatbyGroupSkupinaInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `PlatbyGroupSkupina` to be created by this mutation. */
	platbyGroupSkupina: GraphQLTypes["PlatbyGroupSkupinaInput"]
};
	/** An input for mutations affecting `PlatbyGroupSkupina` */
["PlatbyGroupSkupinaInput"]: {
		pgsId?: GraphQLTypes["BigInt"] | undefined,
	pgsIdSkupina: GraphQLTypes["BigInt"],
	pgsIdGroup: GraphQLTypes["BigInt"]
};
	/** The output of our create `PlatbyItem` mutation. */
["CreatePlatbyItemPayload"]: {
	__typename: "CreatePlatbyItemPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyItem` that was created by this mutation. */
	platbyItem?: GraphQLTypes["PlatbyItem"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `PlatbyItem`. */
	userByPiIdUser?: GraphQLTypes["User"] | undefined,
	/** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
	platbyCategoryByPiIdCategory?: GraphQLTypes["PlatbyCategory"] | undefined,
	/** Reads a single `PlatbyRaw` that is related to this `PlatbyItem`. */
	platbyRawByPiIdRaw?: GraphQLTypes["PlatbyRaw"] | undefined,
	/** An edge for our `PlatbyItem`. May be used by Relay 1. */
	platbyItemEdge?: GraphQLTypes["PlatbyItemsEdge"] | undefined
};
	/** All input for the create `PlatbyItem` mutation. */
["CreatePlatbyItemInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `PlatbyItem` to be created by this mutation. */
	platbyItem: GraphQLTypes["PlatbyItemInput"]
};
	/** An input for mutations affecting `PlatbyItem` */
["PlatbyItemInput"]: {
		piId?: GraphQLTypes["BigInt"] | undefined,
	piIdUser?: GraphQLTypes["BigInt"] | undefined,
	piIdCategory: GraphQLTypes["BigInt"],
	piIdRaw?: GraphQLTypes["BigInt"] | undefined,
	piAmount: GraphQLTypes["BigFloat"],
	piDate: GraphQLTypes["Date"],
	piPrefix?: number | undefined
};
	/** The output of our create `PlatbyRaw` mutation. */
["CreatePlatbyRawPayload"]: {
	__typename: "CreatePlatbyRawPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyRaw` that was created by this mutation. */
	platbyRaw?: GraphQLTypes["PlatbyRaw"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `PlatbyRaw`. May be used by Relay 1. */
	platbyRawEdge?: GraphQLTypes["PlatbyRawsEdge"] | undefined
};
	/** All input for the create `PlatbyRaw` mutation. */
["CreatePlatbyRawInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `PlatbyRaw` to be created by this mutation. */
	platbyRaw: GraphQLTypes["PlatbyRawInput"]
};
	/** An input for mutations affecting `PlatbyRaw` */
["PlatbyRawInput"]: {
		prId?: GraphQLTypes["BigInt"] | undefined,
	prRaw: string,
	prHash: string,
	prSorted?: boolean | undefined,
	prDiscarded?: boolean | undefined
};
	/** The output of our create `Rozpi` mutation. */
["CreateRozpiPayload"]: {
	__typename: "CreateRozpiPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Rozpi` that was created by this mutation. */
	rozpi?: GraphQLTypes["Rozpi"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Rozpi`. */
	userByRTrener?: GraphQLTypes["User"] | undefined,
	/** An edge for our `Rozpi`. May be used by Relay 1. */
	rozpiEdge?: GraphQLTypes["RozpisEdge"] | undefined
};
	/** All input for the create `Rozpi` mutation. */
["CreateRozpiInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `Rozpi` to be created by this mutation. */
	rozpi: GraphQLTypes["RozpiInput"]
};
	/** An input for mutations affecting `Rozpi` */
["RozpiInput"]: {
		rId?: GraphQLTypes["BigInt"] | undefined,
	rTrener: GraphQLTypes["BigInt"],
	rKde: string,
	rDatum: GraphQLTypes["Date"],
	rVisible?: boolean | undefined,
	rLock?: boolean | undefined,
	rTimestamp?: GraphQLTypes["Datetime"] | undefined
};
	/** The output of our create `RozpisItem` mutation. */
["CreateRozpisItemPayload"]: {
	__typename: "CreateRozpisItemPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `RozpisItem` that was created by this mutation. */
	rozpisItem?: GraphQLTypes["RozpisItem"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `Rozpi` that is related to this `RozpisItem`. */
	rozpiByRiIdRodic?: GraphQLTypes["Rozpi"] | undefined,
	/** Reads a single `Pary` that is related to this `RozpisItem`. */
	paryByRiPartner?: GraphQLTypes["Pary"] | undefined,
	/** An edge for our `RozpisItem`. May be used by Relay 1. */
	rozpisItemEdge?: GraphQLTypes["RozpisItemsEdge"] | undefined
};
	/** All input for the create `RozpisItem` mutation. */
["CreateRozpisItemInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `RozpisItem` to be created by this mutation. */
	rozpisItem: GraphQLTypes["RozpisItemInput"]
};
	/** An input for mutations affecting `RozpisItem` */
["RozpisItemInput"]: {
		riId?: GraphQLTypes["BigInt"] | undefined,
	riIdRodic: GraphQLTypes["BigInt"],
	riPartner?: GraphQLTypes["BigInt"] | undefined,
	riOd: GraphQLTypes["Time"],
	riDo: GraphQLTypes["Time"],
	riLock?: boolean | undefined
};
	/** The output of our create `Session` mutation. */
["CreateSessionPayload"]: {
	__typename: "CreateSessionPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Session` that was created by this mutation. */
	session?: GraphQLTypes["Session"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Session`. */
	userBySsUser?: GraphQLTypes["User"] | undefined,
	/** An edge for our `Session`. May be used by Relay 1. */
	sessionEdge?: GraphQLTypes["SessionsEdge"] | undefined
};
	/** All input for the create `Session` mutation. */
["CreateSessionInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `Session` to be created by this mutation. */
	session: GraphQLTypes["SessionInput"]
};
	/** An input for mutations affecting `Session` */
["SessionInput"]: {
		ssId: string,
	ssData: string,
	ssUpdatedAt?: GraphQLTypes["Datetime"] | undefined,
	ssLifetime: GraphQLTypes["BigInt"],
	ssUser?: GraphQLTypes["BigInt"] | undefined
};
	/** The output of our create `Skupiny` mutation. */
["CreateSkupinyPayload"]: {
	__typename: "CreateSkupinyPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Skupiny` that was created by this mutation. */
	skupiny?: GraphQLTypes["Skupiny"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `Skupiny`. May be used by Relay 1. */
	skupinyEdge?: GraphQLTypes["SkupiniesEdge"] | undefined
};
	/** All input for the create `Skupiny` mutation. */
["CreateSkupinyInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `Skupiny` to be created by this mutation. */
	skupiny: GraphQLTypes["SkupinyInput"]
};
	/** An input for mutations affecting `Skupiny` */
["SkupinyInput"]: {
		sId?: GraphQLTypes["BigInt"] | undefined,
	sName: string,
	sDescription: string,
	sColorRgb: string,
	sColorText: string,
	sLocation?: string | undefined,
	sVisible?: boolean | undefined
};
	/** The output of our create `Upozorneni` mutation. */
["CreateUpozorneniPayload"]: {
	__typename: "CreateUpozorneniPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Upozorneni` that was created by this mutation. */
	upozorneni?: GraphQLTypes["Upozorneni"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Upozorneni`. */
	userByUpKdo?: GraphQLTypes["User"] | undefined,
	/** An edge for our `Upozorneni`. May be used by Relay 1. */
	upozorneniEdge?: GraphQLTypes["UpozornenisEdge"] | undefined
};
	/** All input for the create `Upozorneni` mutation. */
["CreateUpozorneniInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `Upozorneni` to be created by this mutation. */
	upozorneni: GraphQLTypes["UpozorneniInput"]
};
	/** An input for mutations affecting `Upozorneni` */
["UpozorneniInput"]: {
		upId?: GraphQLTypes["BigInt"] | undefined,
	upKdo: GraphQLTypes["BigInt"],
	upNadpis: string,
	upText: string,
	upBarvy?: GraphQLTypes["BigInt"] | undefined,
	upLock?: boolean | undefined,
	upTimestamp?: GraphQLTypes["Datetime"] | undefined,
	upTimestampAdd?: GraphQLTypes["Datetime"] | undefined
};
	/** The output of our create `UpozorneniSkupiny` mutation. */
["CreateUpozorneniSkupinyPayload"]: {
	__typename: "CreateUpozorneniSkupinyPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `UpozorneniSkupiny` that was created by this mutation. */
	upozorneniSkupiny?: GraphQLTypes["UpozorneniSkupiny"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
	upozorneniByUpsIdRodic?: GraphQLTypes["Upozorneni"] | undefined,
	/** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
	skupinyByUpsIdSkupina?: GraphQLTypes["Skupiny"] | undefined,
	/** An edge for our `UpozorneniSkupiny`. May be used by Relay 1. */
	upozorneniSkupinyEdge?: GraphQLTypes["UpozorneniSkupiniesEdge"] | undefined
};
	/** All input for the create `UpozorneniSkupiny` mutation. */
["CreateUpozorneniSkupinyInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `UpozorneniSkupiny` to be created by this mutation. */
	upozorneniSkupiny: GraphQLTypes["UpozorneniSkupinyInput"]
};
	/** An input for mutations affecting `UpozorneniSkupiny` */
["UpozorneniSkupinyInput"]: {
		upsId?: GraphQLTypes["BigInt"] | undefined,
	upsIdRodic: GraphQLTypes["BigInt"],
	upsIdSkupina: GraphQLTypes["BigInt"],
	upsColor: string,
	upsPopis: string
};
	/** The output of our create `User` mutation. */
["CreateUserPayload"]: {
	__typename: "CreateUserPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `User` that was created by this mutation. */
	user?: GraphQLTypes["User"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `Permission` that is related to this `User`. */
	permissionByUGroup?: GraphQLTypes["Permission"] | undefined,
	/** Reads a single `Skupiny` that is related to this `User`. */
	skupinyByUSkupina?: GraphQLTypes["Skupiny"] | undefined,
	/** An edge for our `User`. May be used by Relay 1. */
	userEdge?: GraphQLTypes["UsersEdge"] | undefined
};
	/** All input for the create `User` mutation. */
["CreateUserInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `User` to be created by this mutation. */
	user: GraphQLTypes["UserInput"]
};
	/** An input for mutations affecting `User` */
["UserInput"]: {
		uId?: GraphQLTypes["BigInt"] | undefined,
	uLogin: string,
	uPass: string,
	uJmeno: string,
	uPrijmeni: string,
	uPohlavi: string,
	uEmail: string,
	uTelefon: string,
	uNarozeni: GraphQLTypes["Date"],
	uRodneCislo?: string | undefined,
	uPoznamky?: string | undefined,
	uTimestamp?: GraphQLTypes["Datetime"] | undefined,
	uLevel?: number | undefined,
	uGroup: GraphQLTypes["BigInt"],
	uSkupina?: GraphQLTypes["BigInt"] | undefined,
	uDancer?: boolean | undefined,
	uBan?: boolean | undefined,
	uLock?: boolean | undefined,
	uConfirmed?: boolean | undefined,
	uSystem?: boolean | undefined,
	uStreet: string,
	uConscriptionNumber?: string | undefined,
	uOrientationNumber?: string | undefined,
	uDistrict?: string | undefined,
	uCity: string,
	uPostalCode: string,
	uNationality: string,
	uMemberSince?: GraphQLTypes["Datetime"] | undefined,
	uMemberUntil?: GraphQLTypes["Datetime"] | undefined,
	uCreatedAt?: GraphQLTypes["Datetime"] | undefined,
	uTeacher?: boolean | undefined,
	uGdprSignedAt?: GraphQLTypes["Datetime"] | undefined
};
	/** The output of our create `UsersSkupiny` mutation. */
["CreateUsersSkupinyPayload"]: {
	__typename: "CreateUsersSkupinyPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `UsersSkupiny` that was created by this mutation. */
	usersSkupiny?: GraphQLTypes["UsersSkupiny"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `UsersSkupiny`. May be used by Relay 1. */
	usersSkupinyEdge?: GraphQLTypes["UsersSkupiniesEdge"] | undefined
};
	/** All input for the create `UsersSkupiny` mutation. */
["CreateUsersSkupinyInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `UsersSkupiny` to be created by this mutation. */
	usersSkupiny: GraphQLTypes["UsersSkupinyInput"]
};
	/** An input for mutations affecting `UsersSkupiny` */
["UsersSkupinyInput"]: {
		usId?: GraphQLTypes["BigInt"] | undefined,
	usColor?: string | undefined,
	usPlatbaMesic?: GraphQLTypes["BigInt"] | undefined,
	usPlatbaCtvrtrok?: GraphQLTypes["BigInt"] | undefined,
	usPlatbaPulrok?: GraphQLTypes["BigInt"] | undefined,
	usPopis: string
};
	/** The output of our create `Video` mutation. */
["CreateVideoPayload"]: {
	__typename: "CreateVideoPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Video` that was created by this mutation. */
	video?: GraphQLTypes["Video"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `Video`. May be used by Relay 1. */
	videoEdge?: GraphQLTypes["VideosEdge"] | undefined
};
	/** All input for the create `Video` mutation. */
["CreateVideoInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `Video` to be created by this mutation. */
	video: GraphQLTypes["VideoInput"]
};
	/** An input for mutations affecting `Video` */
["VideoInput"]: {
		vId?: GraphQLTypes["BigInt"] | undefined,
	vUri: string,
	vTitle: string,
	vAuthor: string,
	vDescription: string,
	vPlaylist?: string | undefined,
	vCreatedAt: GraphQLTypes["Datetime"],
	vUpdatedAt?: GraphQLTypes["Datetime"] | undefined
};
	/** The output of our create `VideoList` mutation. */
["CreateVideoListPayload"]: {
	__typename: "CreateVideoListPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `VideoList` that was created by this mutation. */
	videoList?: GraphQLTypes["VideoList"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `VideoList`. May be used by Relay 1. */
	videoListEdge?: GraphQLTypes["VideoListsEdge"] | undefined
};
	/** All input for the create `VideoList` mutation. */
["CreateVideoListInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `VideoList` to be created by this mutation. */
	videoList: GraphQLTypes["VideoListInput"]
};
	/** An input for mutations affecting `VideoList` */
["VideoListInput"]: {
		vlId?: GraphQLTypes["BigInt"] | undefined,
	vlUrl: string,
	vlTitle: string,
	vlDescription: string,
	vlCount: GraphQLTypes["BigInt"],
	vlCreatedAt: GraphQLTypes["Datetime"],
	vlLastChecked?: GraphQLTypes["Datetime"] | undefined
};
	/** The output of our create `VideoSource` mutation. */
["CreateVideoSourcePayload"]: {
	__typename: "CreateVideoSourcePayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `VideoSource` that was created by this mutation. */
	videoSource?: GraphQLTypes["VideoSource"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `VideoSource`. May be used by Relay 1. */
	videoSourceEdge?: GraphQLTypes["VideoSourcesEdge"] | undefined
};
	/** All input for the create `VideoSource` mutation. */
["CreateVideoSourceInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The `VideoSource` to be created by this mutation. */
	videoSource: GraphQLTypes["VideoSourceInput"]
};
	/** An input for mutations affecting `VideoSource` */
["VideoSourceInput"]: {
		vsId?: GraphQLTypes["BigInt"] | undefined,
	vsUrl: string,
	vsTitle?: string | undefined,
	vsDescription?: string | undefined,
	vsCreatedAt?: GraphQLTypes["Datetime"] | undefined,
	vsLastChecked?: GraphQLTypes["Datetime"] | undefined
};
	/** The output of our update `Akce` mutation. */
["UpdateAkcePayload"]: {
	__typename: "UpdateAkcePayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Akce` that was updated by this mutation. */
	akce?: GraphQLTypes["Akce"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `Akce`. May be used by Relay 1. */
	akceEdge?: GraphQLTypes["AkcesEdge"] | undefined
};
	/** All input for the `updateAkceByNodeId` mutation. */
["UpdateAkceByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Akce` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Akce` being updated. */
	patch: GraphQLTypes["AkcePatch"]
};
	/** Represents an update to a `Akce`. Fields that are set will be updated. */
["AkcePatch"]: {
		aId?: GraphQLTypes["BigInt"] | undefined,
	aJmeno?: string | undefined,
	aKde?: string | undefined,
	aInfo?: string | undefined,
	aOd?: GraphQLTypes["Date"] | undefined,
	aDo?: GraphQLTypes["Date"] | undefined,
	aKapacita?: GraphQLTypes["BigInt"] | undefined,
	aDokumenty?: string | undefined,
	aTimestamp?: GraphQLTypes["Datetime"] | undefined,
	aLock?: boolean | undefined,
	aVisible?: boolean | undefined
};
	/** All input for the `updateAkce` mutation. */
["UpdateAkceInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `Akce` being updated. */
	patch: GraphQLTypes["AkcePatch"],
	aId: GraphQLTypes["BigInt"]
};
	/** The output of our update `AkceItem` mutation. */
["UpdateAkceItemPayload"]: {
	__typename: "UpdateAkceItemPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `AkceItem` that was updated by this mutation. */
	akceItem?: GraphQLTypes["AkceItem"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `Akce` that is related to this `AkceItem`. */
	akceByAiIdRodic?: GraphQLTypes["Akce"] | undefined,
	/** Reads a single `User` that is related to this `AkceItem`. */
	userByAiUser?: GraphQLTypes["User"] | undefined,
	/** An edge for our `AkceItem`. May be used by Relay 1. */
	akceItemEdge?: GraphQLTypes["AkceItemsEdge"] | undefined
};
	/** All input for the `updateAkceItemByNodeId` mutation. */
["UpdateAkceItemByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `AkceItem` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `AkceItem` being updated. */
	patch: GraphQLTypes["AkceItemPatch"]
};
	/** Represents an update to a `AkceItem`. Fields that are set will be updated. */
["AkceItemPatch"]: {
		aiId?: GraphQLTypes["BigInt"] | undefined,
	aiIdRodic?: GraphQLTypes["BigInt"] | undefined,
	aiUser?: GraphQLTypes["BigInt"] | undefined,
	aiRokNarozeni?: number | undefined
};
	/** All input for the `updateAkceItem` mutation. */
["UpdateAkceItemInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `AkceItem` being updated. */
	patch: GraphQLTypes["AkceItemPatch"],
	aiId: GraphQLTypes["BigInt"]
};
	/** The output of our update `Aktuality` mutation. */
["UpdateAktualityPayload"]: {
	__typename: "UpdateAktualityPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Aktuality` that was updated by this mutation. */
	aktuality?: GraphQLTypes["Aktuality"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Aktuality`. */
	userByAtKdo?: GraphQLTypes["User"] | undefined,
	/** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
	galerieFotoByAtFotoMain?: GraphQLTypes["GalerieFoto"] | undefined,
	/** An edge for our `Aktuality`. May be used by Relay 1. */
	aktualityEdge?: GraphQLTypes["AktualitiesEdge"] | undefined
};
	/** All input for the `updateAktualityByNodeId` mutation. */
["UpdateAktualityByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Aktuality` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Aktuality` being updated. */
	patch: GraphQLTypes["AktualityPatch"]
};
	/** Represents an update to a `Aktuality`. Fields that are set will be updated. */
["AktualityPatch"]: {
		atId?: GraphQLTypes["BigInt"] | undefined,
	atKdo?: GraphQLTypes["BigInt"] | undefined,
	atKat?: string | undefined,
	atJmeno?: string | undefined,
	atText?: string | undefined,
	atPreview?: string | undefined,
	atFoto?: GraphQLTypes["BigInt"] | undefined,
	atFotoMain?: GraphQLTypes["BigInt"] | undefined,
	atTimestamp?: GraphQLTypes["Datetime"] | undefined,
	atTimestampAdd?: GraphQLTypes["Datetime"] | undefined
};
	/** All input for the `updateAktuality` mutation. */
["UpdateAktualityInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `Aktuality` being updated. */
	patch: GraphQLTypes["AktualityPatch"],
	atId: GraphQLTypes["BigInt"]
};
	/** The output of our update `Dokumenty` mutation. */
["UpdateDokumentyPayload"]: {
	__typename: "UpdateDokumentyPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Dokumenty` that was updated by this mutation. */
	dokumenty?: GraphQLTypes["Dokumenty"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Dokumenty`. */
	userByDKdo?: GraphQLTypes["User"] | undefined,
	/** An edge for our `Dokumenty`. May be used by Relay 1. */
	dokumentyEdge?: GraphQLTypes["DokumentiesEdge"] | undefined
};
	/** All input for the `updateDokumentyByNodeId` mutation. */
["UpdateDokumentyByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Dokumenty` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Dokumenty` being updated. */
	patch: GraphQLTypes["DokumentyPatch"]
};
	/** Represents an update to a `Dokumenty`. Fields that are set will be updated. */
["DokumentyPatch"]: {
		dId?: GraphQLTypes["BigInt"] | undefined,
	dPath?: string | undefined,
	dName?: string | undefined,
	dFilename?: string | undefined,
	dKategorie?: number | undefined,
	dKdo?: GraphQLTypes["BigInt"] | undefined,
	dTimestamp?: GraphQLTypes["Datetime"] | undefined
};
	/** All input for the `updateDokumenty` mutation. */
["UpdateDokumentyInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `Dokumenty` being updated. */
	patch: GraphQLTypes["DokumentyPatch"],
	dId: GraphQLTypes["BigInt"]
};
	/** The output of our update `GalerieDir` mutation. */
["UpdateGalerieDirPayload"]: {
	__typename: "UpdateGalerieDirPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `GalerieDir` that was updated by this mutation. */
	galerieDir?: GraphQLTypes["GalerieDir"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `GalerieDir`. May be used by Relay 1. */
	galerieDirEdge?: GraphQLTypes["GalerieDirsEdge"] | undefined
};
	/** All input for the `updateGalerieDirByNodeId` mutation. */
["UpdateGalerieDirByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `GalerieDir` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `GalerieDir` being updated. */
	patch: GraphQLTypes["GalerieDirPatch"]
};
	/** Represents an update to a `GalerieDir`. Fields that are set will be updated. */
["GalerieDirPatch"]: {
		gdId?: GraphQLTypes["BigInt"] | undefined,
	gdIdRodic?: GraphQLTypes["BigInt"] | undefined,
	gdName?: string | undefined,
	gdLevel?: number | undefined,
	gdPath?: string | undefined,
	gdHidden?: boolean | undefined
};
	/** All input for the `updateGalerieDir` mutation. */
["UpdateGalerieDirInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `GalerieDir` being updated. */
	patch: GraphQLTypes["GalerieDirPatch"],
	gdId: GraphQLTypes["BigInt"]
};
	/** The output of our update `GalerieFoto` mutation. */
["UpdateGalerieFotoPayload"]: {
	__typename: "UpdateGalerieFotoPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `GalerieFoto` that was updated by this mutation. */
	galerieFoto?: GraphQLTypes["GalerieFoto"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
	galerieDirByGfIdRodic?: GraphQLTypes["GalerieDir"] | undefined,
	/** Reads a single `User` that is related to this `GalerieFoto`. */
	userByGfKdo?: GraphQLTypes["User"] | undefined,
	/** An edge for our `GalerieFoto`. May be used by Relay 1. */
	galerieFotoEdge?: GraphQLTypes["GalerieFotosEdge"] | undefined
};
	/** All input for the `updateGalerieFotoByNodeId` mutation. */
["UpdateGalerieFotoByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `GalerieFoto` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `GalerieFoto` being updated. */
	patch: GraphQLTypes["GalerieFotoPatch"]
};
	/** Represents an update to a `GalerieFoto`. Fields that are set will be updated. */
["GalerieFotoPatch"]: {
		gfId?: GraphQLTypes["BigInt"] | undefined,
	gfIdRodic?: GraphQLTypes["BigInt"] | undefined,
	gfName?: string | undefined,
	gfPath?: string | undefined,
	gfKdo?: GraphQLTypes["BigInt"] | undefined,
	gfTimestamp?: GraphQLTypes["Datetime"] | undefined
};
	/** All input for the `updateGalerieFoto` mutation. */
["UpdateGalerieFotoInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `GalerieFoto` being updated. */
	patch: GraphQLTypes["GalerieFotoPatch"],
	gfId: GraphQLTypes["BigInt"]
};
	/** The output of our update `Nabidka` mutation. */
["UpdateNabidkaPayload"]: {
	__typename: "UpdateNabidkaPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Nabidka` that was updated by this mutation. */
	nabidka?: GraphQLTypes["Nabidka"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Nabidka`. */
	userByNTrener?: GraphQLTypes["User"] | undefined,
	/** An edge for our `Nabidka`. May be used by Relay 1. */
	nabidkaEdge?: GraphQLTypes["NabidkasEdge"] | undefined
};
	/** All input for the `updateNabidkaByNodeId` mutation. */
["UpdateNabidkaByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Nabidka` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Nabidka` being updated. */
	patch: GraphQLTypes["NabidkaPatch"]
};
	/** Represents an update to a `Nabidka`. Fields that are set will be updated. */
["NabidkaPatch"]: {
		nId?: GraphQLTypes["BigInt"] | undefined,
	nTrener?: GraphQLTypes["BigInt"] | undefined,
	nPocetHod?: number | undefined,
	nMaxPocetHod?: GraphQLTypes["BigInt"] | undefined,
	nOd?: GraphQLTypes["Date"] | undefined,
	nDo?: GraphQLTypes["Date"] | undefined,
	nVisible?: boolean | undefined,
	nLock?: boolean | undefined,
	nTimestamp?: GraphQLTypes["Datetime"] | undefined
};
	/** All input for the `updateNabidka` mutation. */
["UpdateNabidkaInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `Nabidka` being updated. */
	patch: GraphQLTypes["NabidkaPatch"],
	nId: GraphQLTypes["BigInt"]
};
	/** The output of our update `NabidkaItem` mutation. */
["UpdateNabidkaItemPayload"]: {
	__typename: "UpdateNabidkaItemPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `NabidkaItem` that was updated by this mutation. */
	nabidkaItem?: GraphQLTypes["NabidkaItem"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `Nabidka` that is related to this `NabidkaItem`. */
	nabidkaByNiIdRodic?: GraphQLTypes["Nabidka"] | undefined,
	/** Reads a single `Pary` that is related to this `NabidkaItem`. */
	paryByNiPartner?: GraphQLTypes["Pary"] | undefined,
	/** An edge for our `NabidkaItem`. May be used by Relay 1. */
	nabidkaItemEdge?: GraphQLTypes["NabidkaItemsEdge"] | undefined
};
	/** All input for the `updateNabidkaItemByNodeId` mutation. */
["UpdateNabidkaItemByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `NabidkaItem` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `NabidkaItem` being updated. */
	patch: GraphQLTypes["NabidkaItemPatch"]
};
	/** Represents an update to a `NabidkaItem`. Fields that are set will be updated. */
["NabidkaItemPatch"]: {
		niId?: GraphQLTypes["BigInt"] | undefined,
	niIdRodic?: GraphQLTypes["BigInt"] | undefined,
	niPartner?: GraphQLTypes["BigInt"] | undefined,
	niPocetHod?: number | undefined,
	niLock?: boolean | undefined
};
	/** All input for the `updateNabidkaItem` mutation. */
["UpdateNabidkaItemInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `NabidkaItem` being updated. */
	patch: GraphQLTypes["NabidkaItemPatch"],
	niId: GraphQLTypes["BigInt"]
};
	/** The output of our update `Page` mutation. */
["UpdatePagePayload"]: {
	__typename: "UpdatePagePayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Page` that was updated by this mutation. */
	page?: GraphQLTypes["Page"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `Page`. May be used by Relay 1. */
	pageEdge?: GraphQLTypes["PagesEdge"] | undefined
};
	/** All input for the `updatePageByNodeId` mutation. */
["UpdatePageByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Page` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Page` being updated. */
	patch: GraphQLTypes["PagePatch"]
};
	/** Represents an update to a `Page`. Fields that are set will be updated. */
["PagePatch"]: {
		id?: number | undefined,
	url?: string | undefined,
	content?: GraphQLTypes["JSON"] | undefined,
	createdAt?: GraphQLTypes["Datetime"] | undefined,
	updatedAt?: GraphQLTypes["Datetime"] | undefined,
	title?: string | undefined
};
	/** All input for the `updatePage` mutation. */
["UpdatePageInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `Page` being updated. */
	patch: GraphQLTypes["PagePatch"],
	id: number
};
	/** All input for the `updatePageByUrl` mutation. */
["UpdatePageByUrlInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `Page` being updated. */
	patch: GraphQLTypes["PagePatch"],
	url: string
};
	/** The output of our update `Parameter` mutation. */
["UpdateParameterPayload"]: {
	__typename: "UpdateParameterPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Parameter` that was updated by this mutation. */
	parameter?: GraphQLTypes["Parameter"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `Parameter`. May be used by Relay 1. */
	parameterEdge?: GraphQLTypes["ParametersEdge"] | undefined
};
	/** All input for the `updateParameterByNodeId` mutation. */
["UpdateParameterByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Parameter` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Parameter` being updated. */
	patch: GraphQLTypes["ParameterPatch"]
};
	/** Represents an update to a `Parameter`. Fields that are set will be updated. */
["ParameterPatch"]: {
		paName?: string | undefined,
	paValue?: string | undefined
};
	/** All input for the `updateParameter` mutation. */
["UpdateParameterInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `Parameter` being updated. */
	patch: GraphQLTypes["ParameterPatch"],
	paName: string
};
	/** The output of our update `Pary` mutation. */
["UpdateParyPayload"]: {
	__typename: "UpdateParyPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Pary` that was updated by this mutation. */
	pary?: GraphQLTypes["Pary"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Pary`. */
	userByPIdPartner?: GraphQLTypes["User"] | undefined,
	/** An edge for our `Pary`. May be used by Relay 1. */
	paryEdge?: GraphQLTypes["PariesEdge"] | undefined
};
	/** All input for the `updateParyByNodeId` mutation. */
["UpdateParyByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Pary` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Pary` being updated. */
	patch: GraphQLTypes["ParyPatch"]
};
	/** Represents an update to a `Pary`. Fields that are set will be updated. */
["ParyPatch"]: {
		pId?: GraphQLTypes["BigInt"] | undefined,
	pIdPartner?: GraphQLTypes["BigInt"] | undefined,
	pIdPartnerka?: GraphQLTypes["BigInt"] | undefined,
	pSttTrida?: GraphQLTypes["ParyPSttTrida"] | undefined,
	pSttBody?: number | undefined,
	pSttFinale?: boolean | undefined,
	pLatTrida?: GraphQLTypes["ParyPLatTrida"] | undefined,
	pLatBody?: number | undefined,
	pLatFinale?: boolean | undefined,
	pHodnoceni?: number | undefined,
	pArchiv?: boolean | undefined,
	pTimestampAdd?: GraphQLTypes["Datetime"] | undefined,
	pTimestampArchive?: GraphQLTypes["Datetime"] | undefined
};
	/** All input for the `updatePary` mutation. */
["UpdateParyInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `Pary` being updated. */
	patch: GraphQLTypes["ParyPatch"],
	pId: GraphQLTypes["BigInt"]
};
	/** The output of our update `ParyNavrh` mutation. */
["UpdateParyNavrhPayload"]: {
	__typename: "UpdateParyNavrhPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `ParyNavrh` that was updated by this mutation. */
	paryNavrh?: GraphQLTypes["ParyNavrh"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnNavrhl?: GraphQLTypes["User"] | undefined,
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnPartner?: GraphQLTypes["User"] | undefined,
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnPartnerka?: GraphQLTypes["User"] | undefined,
	/** An edge for our `ParyNavrh`. May be used by Relay 1. */
	paryNavrhEdge?: GraphQLTypes["ParyNavrhsEdge"] | undefined
};
	/** All input for the `updateParyNavrhByNodeId` mutation. */
["UpdateParyNavrhByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `ParyNavrh` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `ParyNavrh` being updated. */
	patch: GraphQLTypes["ParyNavrhPatch"]
};
	/** Represents an update to a `ParyNavrh`. Fields that are set will be updated. */
["ParyNavrhPatch"]: {
		pnId?: GraphQLTypes["BigInt"] | undefined,
	pnNavrhl?: GraphQLTypes["BigInt"] | undefined,
	pnPartner?: GraphQLTypes["BigInt"] | undefined,
	pnPartnerka?: GraphQLTypes["BigInt"] | undefined
};
	/** All input for the `updateParyNavrh` mutation. */
["UpdateParyNavrhInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `ParyNavrh` being updated. */
	patch: GraphQLTypes["ParyNavrhPatch"],
	pnId: GraphQLTypes["BigInt"]
};
	/** The output of our update `Permission` mutation. */
["UpdatePermissionPayload"]: {
	__typename: "UpdatePermissionPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Permission` that was updated by this mutation. */
	permission?: GraphQLTypes["Permission"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `Permission`. May be used by Relay 1. */
	permissionEdge?: GraphQLTypes["PermissionsEdge"] | undefined
};
	/** All input for the `updatePermissionByNodeId` mutation. */
["UpdatePermissionByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Permission` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Permission` being updated. */
	patch: GraphQLTypes["PermissionPatch"]
};
	/** Represents an update to a `Permission`. Fields that are set will be updated. */
["PermissionPatch"]: {
		peId?: GraphQLTypes["BigInt"] | undefined,
	peName?: string | undefined,
	peDescription?: string | undefined,
	peAkce?: number | undefined,
	peAktuality?: number | undefined,
	peAnkety?: number | undefined,
	peDokumenty?: number | undefined,
	peGalerie?: number | undefined,
	peInzerce?: number | undefined,
	peKonzole?: number | undefined,
	peNabidka?: number | undefined,
	peNastenka?: number | undefined,
	peNovinky?: number | undefined,
	pePary?: number | undefined,
	pePlatby?: number | undefined,
	pePermissions?: number | undefined,
	peRozpis?: number | undefined,
	peSkupiny?: number | undefined,
	peUsers?: number | undefined,
	peMain?: number | undefined
};
	/** All input for the `updatePermission` mutation. */
["UpdatePermissionInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `Permission` being updated. */
	patch: GraphQLTypes["PermissionPatch"],
	peId: GraphQLTypes["BigInt"]
};
	/** The output of our update `PlatbyCategory` mutation. */
["UpdatePlatbyCategoryPayload"]: {
	__typename: "UpdatePlatbyCategoryPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyCategory` that was updated by this mutation. */
	platbyCategory?: GraphQLTypes["PlatbyCategory"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `PlatbyCategory`. May be used by Relay 1. */
	platbyCategoryEdge?: GraphQLTypes["PlatbyCategoriesEdge"] | undefined
};
	/** All input for the `updatePlatbyCategoryByNodeId` mutation. */
["UpdatePlatbyCategoryByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `PlatbyCategory` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `PlatbyCategory` being updated. */
	patch: GraphQLTypes["PlatbyCategoryPatch"]
};
	/** Represents an update to a `PlatbyCategory`. Fields that are set will be updated. */
["PlatbyCategoryPatch"]: {
		pcId?: GraphQLTypes["BigInt"] | undefined,
	pcName?: string | undefined,
	pcSymbol?: GraphQLTypes["BigInt"] | undefined,
	pcAmount?: GraphQLTypes["BigFloat"] | undefined,
	pcDateDue?: GraphQLTypes["Date"] | undefined,
	pcValidFrom?: GraphQLTypes["Date"] | undefined,
	pcValidTo?: GraphQLTypes["Date"] | undefined,
	pcUseBase?: boolean | undefined,
	pcUsePrefix?: boolean | undefined,
	pcArchive?: boolean | undefined,
	pcVisible?: boolean | undefined
};
	/** All input for the `updatePlatbyCategory` mutation. */
["UpdatePlatbyCategoryInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `PlatbyCategory` being updated. */
	patch: GraphQLTypes["PlatbyCategoryPatch"],
	pcId: GraphQLTypes["BigInt"]
};
	/** The output of our update `PlatbyCategoryGroup` mutation. */
["UpdatePlatbyCategoryGroupPayload"]: {
	__typename: "UpdatePlatbyCategoryGroupPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyCategoryGroup` that was updated by this mutation. */
	platbyCategoryGroup?: GraphQLTypes["PlatbyCategoryGroup"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `PlatbyGroup` that is related to this `PlatbyCategoryGroup`. */
	platbyGroupByPcgIdGroup?: GraphQLTypes["PlatbyGroup"] | undefined,
	/** Reads a single `PlatbyCategory` that is related to this `PlatbyCategoryGroup`. */
	platbyCategoryByPcgIdCategory?: GraphQLTypes["PlatbyCategory"] | undefined,
	/** An edge for our `PlatbyCategoryGroup`. May be used by Relay 1. */
	platbyCategoryGroupEdge?: GraphQLTypes["PlatbyCategoryGroupsEdge"] | undefined
};
	/** All input for the `updatePlatbyCategoryGroupByNodeId` mutation. */
["UpdatePlatbyCategoryGroupByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `PlatbyCategoryGroup` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `PlatbyCategoryGroup` being updated. */
	patch: GraphQLTypes["PlatbyCategoryGroupPatch"]
};
	/** Represents an update to a `PlatbyCategoryGroup`. Fields that are set will be updated. */
["PlatbyCategoryGroupPatch"]: {
		pcgId?: GraphQLTypes["BigInt"] | undefined,
	pcgIdGroup?: GraphQLTypes["BigInt"] | undefined,
	pcgIdCategory?: GraphQLTypes["BigInt"] | undefined
};
	/** All input for the `updatePlatbyCategoryGroup` mutation. */
["UpdatePlatbyCategoryGroupInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `PlatbyCategoryGroup` being updated. */
	patch: GraphQLTypes["PlatbyCategoryGroupPatch"],
	pcgId: GraphQLTypes["BigInt"]
};
	/** The output of our update `PlatbyGroup` mutation. */
["UpdatePlatbyGroupPayload"]: {
	__typename: "UpdatePlatbyGroupPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyGroup` that was updated by this mutation. */
	platbyGroup?: GraphQLTypes["PlatbyGroup"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `PlatbyGroup`. May be used by Relay 1. */
	platbyGroupEdge?: GraphQLTypes["PlatbyGroupsEdge"] | undefined
};
	/** All input for the `updatePlatbyGroupByNodeId` mutation. */
["UpdatePlatbyGroupByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `PlatbyGroup` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `PlatbyGroup` being updated. */
	patch: GraphQLTypes["PlatbyGroupPatch"]
};
	/** Represents an update to a `PlatbyGroup`. Fields that are set will be updated. */
["PlatbyGroupPatch"]: {
		pgId?: GraphQLTypes["BigInt"] | undefined,
	pgType?: GraphQLTypes["BigFloat"] | undefined,
	pgName?: string | undefined,
	pgDescription?: string | undefined,
	pgBase?: GraphQLTypes["BigInt"] | undefined
};
	/** All input for the `updatePlatbyGroup` mutation. */
["UpdatePlatbyGroupInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `PlatbyGroup` being updated. */
	patch: GraphQLTypes["PlatbyGroupPatch"],
	pgId: GraphQLTypes["BigInt"]
};
	/** The output of our update `PlatbyGroupSkupina` mutation. */
["UpdatePlatbyGroupSkupinaPayload"]: {
	__typename: "UpdatePlatbyGroupSkupinaPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyGroupSkupina` that was updated by this mutation. */
	platbyGroupSkupina?: GraphQLTypes["PlatbyGroupSkupina"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `Skupiny` that is related to this `PlatbyGroupSkupina`. */
	skupinyByPgsIdSkupina?: GraphQLTypes["Skupiny"] | undefined,
	/** Reads a single `PlatbyGroup` that is related to this `PlatbyGroupSkupina`. */
	platbyGroupByPgsIdGroup?: GraphQLTypes["PlatbyGroup"] | undefined,
	/** An edge for our `PlatbyGroupSkupina`. May be used by Relay 1. */
	platbyGroupSkupinaEdge?: GraphQLTypes["PlatbyGroupSkupinasEdge"] | undefined
};
	/** All input for the `updatePlatbyGroupSkupinaByNodeId` mutation. */
["UpdatePlatbyGroupSkupinaByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `PlatbyGroupSkupina` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `PlatbyGroupSkupina` being updated. */
	patch: GraphQLTypes["PlatbyGroupSkupinaPatch"]
};
	/** Represents an update to a `PlatbyGroupSkupina`. Fields that are set will be updated. */
["PlatbyGroupSkupinaPatch"]: {
		pgsId?: GraphQLTypes["BigInt"] | undefined,
	pgsIdSkupina?: GraphQLTypes["BigInt"] | undefined,
	pgsIdGroup?: GraphQLTypes["BigInt"] | undefined
};
	/** All input for the `updatePlatbyGroupSkupina` mutation. */
["UpdatePlatbyGroupSkupinaInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `PlatbyGroupSkupina` being updated. */
	patch: GraphQLTypes["PlatbyGroupSkupinaPatch"],
	pgsId: GraphQLTypes["BigInt"]
};
	/** The output of our update `PlatbyItem` mutation. */
["UpdatePlatbyItemPayload"]: {
	__typename: "UpdatePlatbyItemPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyItem` that was updated by this mutation. */
	platbyItem?: GraphQLTypes["PlatbyItem"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `PlatbyItem`. */
	userByPiIdUser?: GraphQLTypes["User"] | undefined,
	/** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
	platbyCategoryByPiIdCategory?: GraphQLTypes["PlatbyCategory"] | undefined,
	/** Reads a single `PlatbyRaw` that is related to this `PlatbyItem`. */
	platbyRawByPiIdRaw?: GraphQLTypes["PlatbyRaw"] | undefined,
	/** An edge for our `PlatbyItem`. May be used by Relay 1. */
	platbyItemEdge?: GraphQLTypes["PlatbyItemsEdge"] | undefined
};
	/** All input for the `updatePlatbyItemByNodeId` mutation. */
["UpdatePlatbyItemByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `PlatbyItem` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `PlatbyItem` being updated. */
	patch: GraphQLTypes["PlatbyItemPatch"]
};
	/** Represents an update to a `PlatbyItem`. Fields that are set will be updated. */
["PlatbyItemPatch"]: {
		piId?: GraphQLTypes["BigInt"] | undefined,
	piIdUser?: GraphQLTypes["BigInt"] | undefined,
	piIdCategory?: GraphQLTypes["BigInt"] | undefined,
	piIdRaw?: GraphQLTypes["BigInt"] | undefined,
	piAmount?: GraphQLTypes["BigFloat"] | undefined,
	piDate?: GraphQLTypes["Date"] | undefined,
	piPrefix?: number | undefined
};
	/** All input for the `updatePlatbyItem` mutation. */
["UpdatePlatbyItemInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `PlatbyItem` being updated. */
	patch: GraphQLTypes["PlatbyItemPatch"],
	piId: GraphQLTypes["BigInt"]
};
	/** The output of our update `PlatbyRaw` mutation. */
["UpdatePlatbyRawPayload"]: {
	__typename: "UpdatePlatbyRawPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyRaw` that was updated by this mutation. */
	platbyRaw?: GraphQLTypes["PlatbyRaw"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `PlatbyRaw`. May be used by Relay 1. */
	platbyRawEdge?: GraphQLTypes["PlatbyRawsEdge"] | undefined
};
	/** All input for the `updatePlatbyRawByNodeId` mutation. */
["UpdatePlatbyRawByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `PlatbyRaw` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `PlatbyRaw` being updated. */
	patch: GraphQLTypes["PlatbyRawPatch"]
};
	/** Represents an update to a `PlatbyRaw`. Fields that are set will be updated. */
["PlatbyRawPatch"]: {
		prId?: GraphQLTypes["BigInt"] | undefined,
	prRaw?: string | undefined,
	prHash?: string | undefined,
	prSorted?: boolean | undefined,
	prDiscarded?: boolean | undefined
};
	/** All input for the `updatePlatbyRaw` mutation. */
["UpdatePlatbyRawInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `PlatbyRaw` being updated. */
	patch: GraphQLTypes["PlatbyRawPatch"],
	prId: GraphQLTypes["BigInt"]
};
	/** The output of our update `Rozpi` mutation. */
["UpdateRozpiPayload"]: {
	__typename: "UpdateRozpiPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Rozpi` that was updated by this mutation. */
	rozpi?: GraphQLTypes["Rozpi"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Rozpi`. */
	userByRTrener?: GraphQLTypes["User"] | undefined,
	/** An edge for our `Rozpi`. May be used by Relay 1. */
	rozpiEdge?: GraphQLTypes["RozpisEdge"] | undefined
};
	/** All input for the `updateRozpiByNodeId` mutation. */
["UpdateRozpiByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Rozpi` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Rozpi` being updated. */
	patch: GraphQLTypes["RozpiPatch"]
};
	/** Represents an update to a `Rozpi`. Fields that are set will be updated. */
["RozpiPatch"]: {
		rId?: GraphQLTypes["BigInt"] | undefined,
	rTrener?: GraphQLTypes["BigInt"] | undefined,
	rKde?: string | undefined,
	rDatum?: GraphQLTypes["Date"] | undefined,
	rVisible?: boolean | undefined,
	rLock?: boolean | undefined,
	rTimestamp?: GraphQLTypes["Datetime"] | undefined
};
	/** All input for the `updateRozpi` mutation. */
["UpdateRozpiInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `Rozpi` being updated. */
	patch: GraphQLTypes["RozpiPatch"],
	rId: GraphQLTypes["BigInt"]
};
	/** The output of our update `RozpisItem` mutation. */
["UpdateRozpisItemPayload"]: {
	__typename: "UpdateRozpisItemPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `RozpisItem` that was updated by this mutation. */
	rozpisItem?: GraphQLTypes["RozpisItem"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `Rozpi` that is related to this `RozpisItem`. */
	rozpiByRiIdRodic?: GraphQLTypes["Rozpi"] | undefined,
	/** Reads a single `Pary` that is related to this `RozpisItem`. */
	paryByRiPartner?: GraphQLTypes["Pary"] | undefined,
	/** An edge for our `RozpisItem`. May be used by Relay 1. */
	rozpisItemEdge?: GraphQLTypes["RozpisItemsEdge"] | undefined
};
	/** All input for the `updateRozpisItemByNodeId` mutation. */
["UpdateRozpisItemByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `RozpisItem` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `RozpisItem` being updated. */
	patch: GraphQLTypes["RozpisItemPatch"]
};
	/** Represents an update to a `RozpisItem`. Fields that are set will be updated. */
["RozpisItemPatch"]: {
		riId?: GraphQLTypes["BigInt"] | undefined,
	riIdRodic?: GraphQLTypes["BigInt"] | undefined,
	riPartner?: GraphQLTypes["BigInt"] | undefined,
	riOd?: GraphQLTypes["Time"] | undefined,
	riDo?: GraphQLTypes["Time"] | undefined,
	riLock?: boolean | undefined
};
	/** All input for the `updateRozpisItem` mutation. */
["UpdateRozpisItemInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `RozpisItem` being updated. */
	patch: GraphQLTypes["RozpisItemPatch"],
	riId: GraphQLTypes["BigInt"]
};
	/** The output of our update `Session` mutation. */
["UpdateSessionPayload"]: {
	__typename: "UpdateSessionPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Session` that was updated by this mutation. */
	session?: GraphQLTypes["Session"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Session`. */
	userBySsUser?: GraphQLTypes["User"] | undefined,
	/** An edge for our `Session`. May be used by Relay 1. */
	sessionEdge?: GraphQLTypes["SessionsEdge"] | undefined
};
	/** All input for the `updateSessionByNodeId` mutation. */
["UpdateSessionByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Session` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Session` being updated. */
	patch: GraphQLTypes["SessionPatch"]
};
	/** Represents an update to a `Session`. Fields that are set will be updated. */
["SessionPatch"]: {
		ssId?: string | undefined,
	ssData?: string | undefined,
	ssUpdatedAt?: GraphQLTypes["Datetime"] | undefined,
	ssLifetime?: GraphQLTypes["BigInt"] | undefined,
	ssUser?: GraphQLTypes["BigInt"] | undefined
};
	/** All input for the `updateSession` mutation. */
["UpdateSessionInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `Session` being updated. */
	patch: GraphQLTypes["SessionPatch"],
	ssId: string
};
	/** The output of our update `Skupiny` mutation. */
["UpdateSkupinyPayload"]: {
	__typename: "UpdateSkupinyPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Skupiny` that was updated by this mutation. */
	skupiny?: GraphQLTypes["Skupiny"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `Skupiny`. May be used by Relay 1. */
	skupinyEdge?: GraphQLTypes["SkupiniesEdge"] | undefined
};
	/** All input for the `updateSkupinyByNodeId` mutation. */
["UpdateSkupinyByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Skupiny` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Skupiny` being updated. */
	patch: GraphQLTypes["SkupinyPatch"]
};
	/** Represents an update to a `Skupiny`. Fields that are set will be updated. */
["SkupinyPatch"]: {
		sId?: GraphQLTypes["BigInt"] | undefined,
	sName?: string | undefined,
	sDescription?: string | undefined,
	sColorRgb?: string | undefined,
	sColorText?: string | undefined,
	sLocation?: string | undefined,
	sVisible?: boolean | undefined
};
	/** All input for the `updateSkupiny` mutation. */
["UpdateSkupinyInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `Skupiny` being updated. */
	patch: GraphQLTypes["SkupinyPatch"],
	sId: GraphQLTypes["BigInt"]
};
	/** The output of our update `Upozorneni` mutation. */
["UpdateUpozorneniPayload"]: {
	__typename: "UpdateUpozorneniPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Upozorneni` that was updated by this mutation. */
	upozorneni?: GraphQLTypes["Upozorneni"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Upozorneni`. */
	userByUpKdo?: GraphQLTypes["User"] | undefined,
	/** An edge for our `Upozorneni`. May be used by Relay 1. */
	upozorneniEdge?: GraphQLTypes["UpozornenisEdge"] | undefined
};
	/** All input for the `updateUpozorneniByNodeId` mutation. */
["UpdateUpozorneniByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Upozorneni` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Upozorneni` being updated. */
	patch: GraphQLTypes["UpozorneniPatch"]
};
	/** Represents an update to a `Upozorneni`. Fields that are set will be updated. */
["UpozorneniPatch"]: {
		upId?: GraphQLTypes["BigInt"] | undefined,
	upKdo?: GraphQLTypes["BigInt"] | undefined,
	upNadpis?: string | undefined,
	upText?: string | undefined,
	upBarvy?: GraphQLTypes["BigInt"] | undefined,
	upLock?: boolean | undefined,
	upTimestamp?: GraphQLTypes["Datetime"] | undefined,
	upTimestampAdd?: GraphQLTypes["Datetime"] | undefined
};
	/** All input for the `updateUpozorneni` mutation. */
["UpdateUpozorneniInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `Upozorneni` being updated. */
	patch: GraphQLTypes["UpozorneniPatch"],
	upId: GraphQLTypes["BigInt"]
};
	/** The output of our update `UpozorneniSkupiny` mutation. */
["UpdateUpozorneniSkupinyPayload"]: {
	__typename: "UpdateUpozorneniSkupinyPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `UpozorneniSkupiny` that was updated by this mutation. */
	upozorneniSkupiny?: GraphQLTypes["UpozorneniSkupiny"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
	upozorneniByUpsIdRodic?: GraphQLTypes["Upozorneni"] | undefined,
	/** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
	skupinyByUpsIdSkupina?: GraphQLTypes["Skupiny"] | undefined,
	/** An edge for our `UpozorneniSkupiny`. May be used by Relay 1. */
	upozorneniSkupinyEdge?: GraphQLTypes["UpozorneniSkupiniesEdge"] | undefined
};
	/** All input for the `updateUpozorneniSkupinyByNodeId` mutation. */
["UpdateUpozorneniSkupinyByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `UpozorneniSkupiny` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `UpozorneniSkupiny` being updated. */
	patch: GraphQLTypes["UpozorneniSkupinyPatch"]
};
	/** Represents an update to a `UpozorneniSkupiny`. Fields that are set will be updated. */
["UpozorneniSkupinyPatch"]: {
		upsId?: GraphQLTypes["BigInt"] | undefined,
	upsIdRodic?: GraphQLTypes["BigInt"] | undefined,
	upsIdSkupina?: GraphQLTypes["BigInt"] | undefined,
	upsColor?: string | undefined,
	upsPopis?: string | undefined
};
	/** All input for the `updateUpozorneniSkupiny` mutation. */
["UpdateUpozorneniSkupinyInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `UpozorneniSkupiny` being updated. */
	patch: GraphQLTypes["UpozorneniSkupinyPatch"],
	upsId: GraphQLTypes["BigInt"]
};
	/** The output of our update `User` mutation. */
["UpdateUserPayload"]: {
	__typename: "UpdateUserPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `User` that was updated by this mutation. */
	user?: GraphQLTypes["User"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `Permission` that is related to this `User`. */
	permissionByUGroup?: GraphQLTypes["Permission"] | undefined,
	/** Reads a single `Skupiny` that is related to this `User`. */
	skupinyByUSkupina?: GraphQLTypes["Skupiny"] | undefined,
	/** An edge for our `User`. May be used by Relay 1. */
	userEdge?: GraphQLTypes["UsersEdge"] | undefined
};
	/** All input for the `updateUserByNodeId` mutation. */
["UpdateUserByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `User` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `User` being updated. */
	patch: GraphQLTypes["UserPatch"]
};
	/** Represents an update to a `User`. Fields that are set will be updated. */
["UserPatch"]: {
		uId?: GraphQLTypes["BigInt"] | undefined,
	uLogin?: string | undefined,
	uPass?: string | undefined,
	uJmeno?: string | undefined,
	uPrijmeni?: string | undefined,
	uPohlavi?: string | undefined,
	uEmail?: string | undefined,
	uTelefon?: string | undefined,
	uNarozeni?: GraphQLTypes["Date"] | undefined,
	uRodneCislo?: string | undefined,
	uPoznamky?: string | undefined,
	uTimestamp?: GraphQLTypes["Datetime"] | undefined,
	uLevel?: number | undefined,
	uGroup?: GraphQLTypes["BigInt"] | undefined,
	uSkupina?: GraphQLTypes["BigInt"] | undefined,
	uDancer?: boolean | undefined,
	uBan?: boolean | undefined,
	uLock?: boolean | undefined,
	uConfirmed?: boolean | undefined,
	uSystem?: boolean | undefined,
	uStreet?: string | undefined,
	uConscriptionNumber?: string | undefined,
	uOrientationNumber?: string | undefined,
	uDistrict?: string | undefined,
	uCity?: string | undefined,
	uPostalCode?: string | undefined,
	uNationality?: string | undefined,
	uMemberSince?: GraphQLTypes["Datetime"] | undefined,
	uMemberUntil?: GraphQLTypes["Datetime"] | undefined,
	uCreatedAt?: GraphQLTypes["Datetime"] | undefined,
	uTeacher?: boolean | undefined,
	uGdprSignedAt?: GraphQLTypes["Datetime"] | undefined
};
	/** All input for the `updateUser` mutation. */
["UpdateUserInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `User` being updated. */
	patch: GraphQLTypes["UserPatch"],
	uId: GraphQLTypes["BigInt"]
};
	/** The output of our update `UsersSkupiny` mutation. */
["UpdateUsersSkupinyPayload"]: {
	__typename: "UpdateUsersSkupinyPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `UsersSkupiny` that was updated by this mutation. */
	usersSkupiny?: GraphQLTypes["UsersSkupiny"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `UsersSkupiny`. May be used by Relay 1. */
	usersSkupinyEdge?: GraphQLTypes["UsersSkupiniesEdge"] | undefined
};
	/** All input for the `updateUsersSkupinyByNodeId` mutation. */
["UpdateUsersSkupinyByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `UsersSkupiny` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `UsersSkupiny` being updated. */
	patch: GraphQLTypes["UsersSkupinyPatch"]
};
	/** Represents an update to a `UsersSkupiny`. Fields that are set will be updated. */
["UsersSkupinyPatch"]: {
		usId?: GraphQLTypes["BigInt"] | undefined,
	usColor?: string | undefined,
	usPlatbaMesic?: GraphQLTypes["BigInt"] | undefined,
	usPlatbaCtvrtrok?: GraphQLTypes["BigInt"] | undefined,
	usPlatbaPulrok?: GraphQLTypes["BigInt"] | undefined,
	usPopis?: string | undefined
};
	/** All input for the `updateUsersSkupiny` mutation. */
["UpdateUsersSkupinyInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `UsersSkupiny` being updated. */
	patch: GraphQLTypes["UsersSkupinyPatch"],
	usId: GraphQLTypes["BigInt"]
};
	/** The output of our update `Video` mutation. */
["UpdateVideoPayload"]: {
	__typename: "UpdateVideoPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Video` that was updated by this mutation. */
	video?: GraphQLTypes["Video"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `Video`. May be used by Relay 1. */
	videoEdge?: GraphQLTypes["VideosEdge"] | undefined
};
	/** All input for the `updateVideoByNodeId` mutation. */
["UpdateVideoByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Video` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `Video` being updated. */
	patch: GraphQLTypes["VideoPatch"]
};
	/** Represents an update to a `Video`. Fields that are set will be updated. */
["VideoPatch"]: {
		vId?: GraphQLTypes["BigInt"] | undefined,
	vUri?: string | undefined,
	vTitle?: string | undefined,
	vAuthor?: string | undefined,
	vDescription?: string | undefined,
	vPlaylist?: string | undefined,
	vCreatedAt?: GraphQLTypes["Datetime"] | undefined,
	vUpdatedAt?: GraphQLTypes["Datetime"] | undefined
};
	/** All input for the `updateVideo` mutation. */
["UpdateVideoInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `Video` being updated. */
	patch: GraphQLTypes["VideoPatch"],
	vId: GraphQLTypes["BigInt"]
};
	/** The output of our update `VideoList` mutation. */
["UpdateVideoListPayload"]: {
	__typename: "UpdateVideoListPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `VideoList` that was updated by this mutation. */
	videoList?: GraphQLTypes["VideoList"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `VideoList`. May be used by Relay 1. */
	videoListEdge?: GraphQLTypes["VideoListsEdge"] | undefined
};
	/** All input for the `updateVideoListByNodeId` mutation. */
["UpdateVideoListByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `VideoList` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `VideoList` being updated. */
	patch: GraphQLTypes["VideoListPatch"]
};
	/** Represents an update to a `VideoList`. Fields that are set will be updated. */
["VideoListPatch"]: {
		vlId?: GraphQLTypes["BigInt"] | undefined,
	vlUrl?: string | undefined,
	vlTitle?: string | undefined,
	vlDescription?: string | undefined,
	vlCount?: GraphQLTypes["BigInt"] | undefined,
	vlCreatedAt?: GraphQLTypes["Datetime"] | undefined,
	vlLastChecked?: GraphQLTypes["Datetime"] | undefined
};
	/** All input for the `updateVideoList` mutation. */
["UpdateVideoListInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `VideoList` being updated. */
	patch: GraphQLTypes["VideoListPatch"],
	vlId: GraphQLTypes["BigInt"]
};
	/** The output of our update `VideoSource` mutation. */
["UpdateVideoSourcePayload"]: {
	__typename: "UpdateVideoSourcePayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `VideoSource` that was updated by this mutation. */
	videoSource?: GraphQLTypes["VideoSource"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `VideoSource`. May be used by Relay 1. */
	videoSourceEdge?: GraphQLTypes["VideoSourcesEdge"] | undefined
};
	/** All input for the `updateVideoSourceByNodeId` mutation. */
["UpdateVideoSourceByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `VideoSource` to be updated. */
	nodeId: string,
	/** An object where the defined keys will be set on the `VideoSource` being updated. */
	patch: GraphQLTypes["VideoSourcePatch"]
};
	/** Represents an update to a `VideoSource`. Fields that are set will be updated. */
["VideoSourcePatch"]: {
		vsId?: GraphQLTypes["BigInt"] | undefined,
	vsUrl?: string | undefined,
	vsTitle?: string | undefined,
	vsDescription?: string | undefined,
	vsCreatedAt?: GraphQLTypes["Datetime"] | undefined,
	vsLastChecked?: GraphQLTypes["Datetime"] | undefined
};
	/** All input for the `updateVideoSource` mutation. */
["UpdateVideoSourceInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** An object where the defined keys will be set on the `VideoSource` being updated. */
	patch: GraphQLTypes["VideoSourcePatch"],
	vsId: GraphQLTypes["BigInt"]
};
	/** The output of our delete `Akce` mutation. */
["DeleteAkcePayload"]: {
	__typename: "DeleteAkcePayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Akce` that was deleted by this mutation. */
	akce?: GraphQLTypes["Akce"] | undefined,
	deletedAkceNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `Akce`. May be used by Relay 1. */
	akceEdge?: GraphQLTypes["AkcesEdge"] | undefined
};
	/** All input for the `deleteAkceByNodeId` mutation. */
["DeleteAkceByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Akce` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteAkce` mutation. */
["DeleteAkceInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	aId: GraphQLTypes["BigInt"]
};
	/** The output of our delete `AkceItem` mutation. */
["DeleteAkceItemPayload"]: {
	__typename: "DeleteAkceItemPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `AkceItem` that was deleted by this mutation. */
	akceItem?: GraphQLTypes["AkceItem"] | undefined,
	deletedAkceItemNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `Akce` that is related to this `AkceItem`. */
	akceByAiIdRodic?: GraphQLTypes["Akce"] | undefined,
	/** Reads a single `User` that is related to this `AkceItem`. */
	userByAiUser?: GraphQLTypes["User"] | undefined,
	/** An edge for our `AkceItem`. May be used by Relay 1. */
	akceItemEdge?: GraphQLTypes["AkceItemsEdge"] | undefined
};
	/** All input for the `deleteAkceItemByNodeId` mutation. */
["DeleteAkceItemByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `AkceItem` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteAkceItem` mutation. */
["DeleteAkceItemInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	aiId: GraphQLTypes["BigInt"]
};
	/** The output of our delete `Aktuality` mutation. */
["DeleteAktualityPayload"]: {
	__typename: "DeleteAktualityPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Aktuality` that was deleted by this mutation. */
	aktuality?: GraphQLTypes["Aktuality"] | undefined,
	deletedAktualityNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Aktuality`. */
	userByAtKdo?: GraphQLTypes["User"] | undefined,
	/** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
	galerieFotoByAtFotoMain?: GraphQLTypes["GalerieFoto"] | undefined,
	/** An edge for our `Aktuality`. May be used by Relay 1. */
	aktualityEdge?: GraphQLTypes["AktualitiesEdge"] | undefined
};
	/** All input for the `deleteAktualityByNodeId` mutation. */
["DeleteAktualityByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Aktuality` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteAktuality` mutation. */
["DeleteAktualityInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	atId: GraphQLTypes["BigInt"]
};
	/** The output of our delete `Dokumenty` mutation. */
["DeleteDokumentyPayload"]: {
	__typename: "DeleteDokumentyPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Dokumenty` that was deleted by this mutation. */
	dokumenty?: GraphQLTypes["Dokumenty"] | undefined,
	deletedDokumentyNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Dokumenty`. */
	userByDKdo?: GraphQLTypes["User"] | undefined,
	/** An edge for our `Dokumenty`. May be used by Relay 1. */
	dokumentyEdge?: GraphQLTypes["DokumentiesEdge"] | undefined
};
	/** All input for the `deleteDokumentyByNodeId` mutation. */
["DeleteDokumentyByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Dokumenty` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteDokumenty` mutation. */
["DeleteDokumentyInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	dId: GraphQLTypes["BigInt"]
};
	/** The output of our delete `GalerieDir` mutation. */
["DeleteGalerieDirPayload"]: {
	__typename: "DeleteGalerieDirPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `GalerieDir` that was deleted by this mutation. */
	galerieDir?: GraphQLTypes["GalerieDir"] | undefined,
	deletedGalerieDirNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `GalerieDir`. May be used by Relay 1. */
	galerieDirEdge?: GraphQLTypes["GalerieDirsEdge"] | undefined
};
	/** All input for the `deleteGalerieDirByNodeId` mutation. */
["DeleteGalerieDirByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `GalerieDir` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteGalerieDir` mutation. */
["DeleteGalerieDirInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	gdId: GraphQLTypes["BigInt"]
};
	/** The output of our delete `GalerieFoto` mutation. */
["DeleteGalerieFotoPayload"]: {
	__typename: "DeleteGalerieFotoPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `GalerieFoto` that was deleted by this mutation. */
	galerieFoto?: GraphQLTypes["GalerieFoto"] | undefined,
	deletedGalerieFotoNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
	galerieDirByGfIdRodic?: GraphQLTypes["GalerieDir"] | undefined,
	/** Reads a single `User` that is related to this `GalerieFoto`. */
	userByGfKdo?: GraphQLTypes["User"] | undefined,
	/** An edge for our `GalerieFoto`. May be used by Relay 1. */
	galerieFotoEdge?: GraphQLTypes["GalerieFotosEdge"] | undefined
};
	/** All input for the `deleteGalerieFotoByNodeId` mutation. */
["DeleteGalerieFotoByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `GalerieFoto` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteGalerieFoto` mutation. */
["DeleteGalerieFotoInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	gfId: GraphQLTypes["BigInt"]
};
	/** The output of our delete `Nabidka` mutation. */
["DeleteNabidkaPayload"]: {
	__typename: "DeleteNabidkaPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Nabidka` that was deleted by this mutation. */
	nabidka?: GraphQLTypes["Nabidka"] | undefined,
	deletedNabidkaNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Nabidka`. */
	userByNTrener?: GraphQLTypes["User"] | undefined,
	/** An edge for our `Nabidka`. May be used by Relay 1. */
	nabidkaEdge?: GraphQLTypes["NabidkasEdge"] | undefined
};
	/** All input for the `deleteNabidkaByNodeId` mutation. */
["DeleteNabidkaByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Nabidka` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteNabidka` mutation. */
["DeleteNabidkaInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	nId: GraphQLTypes["BigInt"]
};
	/** The output of our delete `NabidkaItem` mutation. */
["DeleteNabidkaItemPayload"]: {
	__typename: "DeleteNabidkaItemPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `NabidkaItem` that was deleted by this mutation. */
	nabidkaItem?: GraphQLTypes["NabidkaItem"] | undefined,
	deletedNabidkaItemNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `Nabidka` that is related to this `NabidkaItem`. */
	nabidkaByNiIdRodic?: GraphQLTypes["Nabidka"] | undefined,
	/** Reads a single `Pary` that is related to this `NabidkaItem`. */
	paryByNiPartner?: GraphQLTypes["Pary"] | undefined,
	/** An edge for our `NabidkaItem`. May be used by Relay 1. */
	nabidkaItemEdge?: GraphQLTypes["NabidkaItemsEdge"] | undefined
};
	/** All input for the `deleteNabidkaItemByNodeId` mutation. */
["DeleteNabidkaItemByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `NabidkaItem` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteNabidkaItem` mutation. */
["DeleteNabidkaItemInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	niId: GraphQLTypes["BigInt"]
};
	/** The output of our delete `Parameter` mutation. */
["DeleteParameterPayload"]: {
	__typename: "DeleteParameterPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Parameter` that was deleted by this mutation. */
	parameter?: GraphQLTypes["Parameter"] | undefined,
	deletedParameterNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `Parameter`. May be used by Relay 1. */
	parameterEdge?: GraphQLTypes["ParametersEdge"] | undefined
};
	/** All input for the `deleteParameterByNodeId` mutation. */
["DeleteParameterByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Parameter` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteParameter` mutation. */
["DeleteParameterInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	paName: string
};
	/** The output of our delete `Pary` mutation. */
["DeleteParyPayload"]: {
	__typename: "DeleteParyPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Pary` that was deleted by this mutation. */
	pary?: GraphQLTypes["Pary"] | undefined,
	deletedParyNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Pary`. */
	userByPIdPartner?: GraphQLTypes["User"] | undefined,
	/** An edge for our `Pary`. May be used by Relay 1. */
	paryEdge?: GraphQLTypes["PariesEdge"] | undefined
};
	/** All input for the `deleteParyByNodeId` mutation. */
["DeleteParyByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Pary` to be deleted. */
	nodeId: string
};
	/** All input for the `deletePary` mutation. */
["DeleteParyInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	pId: GraphQLTypes["BigInt"]
};
	/** The output of our delete `ParyNavrh` mutation. */
["DeleteParyNavrhPayload"]: {
	__typename: "DeleteParyNavrhPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `ParyNavrh` that was deleted by this mutation. */
	paryNavrh?: GraphQLTypes["ParyNavrh"] | undefined,
	deletedParyNavrhNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnNavrhl?: GraphQLTypes["User"] | undefined,
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnPartner?: GraphQLTypes["User"] | undefined,
	/** Reads a single `User` that is related to this `ParyNavrh`. */
	userByPnPartnerka?: GraphQLTypes["User"] | undefined,
	/** An edge for our `ParyNavrh`. May be used by Relay 1. */
	paryNavrhEdge?: GraphQLTypes["ParyNavrhsEdge"] | undefined
};
	/** All input for the `deleteParyNavrhByNodeId` mutation. */
["DeleteParyNavrhByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `ParyNavrh` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteParyNavrh` mutation. */
["DeleteParyNavrhInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	pnId: GraphQLTypes["BigInt"]
};
	/** The output of our delete `Permission` mutation. */
["DeletePermissionPayload"]: {
	__typename: "DeletePermissionPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Permission` that was deleted by this mutation. */
	permission?: GraphQLTypes["Permission"] | undefined,
	deletedPermissionNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `Permission`. May be used by Relay 1. */
	permissionEdge?: GraphQLTypes["PermissionsEdge"] | undefined
};
	/** All input for the `deletePermissionByNodeId` mutation. */
["DeletePermissionByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Permission` to be deleted. */
	nodeId: string
};
	/** All input for the `deletePermission` mutation. */
["DeletePermissionInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	peId: GraphQLTypes["BigInt"]
};
	/** The output of our delete `PlatbyCategory` mutation. */
["DeletePlatbyCategoryPayload"]: {
	__typename: "DeletePlatbyCategoryPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyCategory` that was deleted by this mutation. */
	platbyCategory?: GraphQLTypes["PlatbyCategory"] | undefined,
	deletedPlatbyCategoryNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `PlatbyCategory`. May be used by Relay 1. */
	platbyCategoryEdge?: GraphQLTypes["PlatbyCategoriesEdge"] | undefined
};
	/** All input for the `deletePlatbyCategoryByNodeId` mutation. */
["DeletePlatbyCategoryByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `PlatbyCategory` to be deleted. */
	nodeId: string
};
	/** All input for the `deletePlatbyCategory` mutation. */
["DeletePlatbyCategoryInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	pcId: GraphQLTypes["BigInt"]
};
	/** The output of our delete `PlatbyCategoryGroup` mutation. */
["DeletePlatbyCategoryGroupPayload"]: {
	__typename: "DeletePlatbyCategoryGroupPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyCategoryGroup` that was deleted by this mutation. */
	platbyCategoryGroup?: GraphQLTypes["PlatbyCategoryGroup"] | undefined,
	deletedPlatbyCategoryGroupNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `PlatbyGroup` that is related to this `PlatbyCategoryGroup`. */
	platbyGroupByPcgIdGroup?: GraphQLTypes["PlatbyGroup"] | undefined,
	/** Reads a single `PlatbyCategory` that is related to this `PlatbyCategoryGroup`. */
	platbyCategoryByPcgIdCategory?: GraphQLTypes["PlatbyCategory"] | undefined,
	/** An edge for our `PlatbyCategoryGroup`. May be used by Relay 1. */
	platbyCategoryGroupEdge?: GraphQLTypes["PlatbyCategoryGroupsEdge"] | undefined
};
	/** All input for the `deletePlatbyCategoryGroupByNodeId` mutation. */
["DeletePlatbyCategoryGroupByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `PlatbyCategoryGroup` to be deleted. */
	nodeId: string
};
	/** All input for the `deletePlatbyCategoryGroup` mutation. */
["DeletePlatbyCategoryGroupInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	pcgId: GraphQLTypes["BigInt"]
};
	/** The output of our delete `PlatbyGroup` mutation. */
["DeletePlatbyGroupPayload"]: {
	__typename: "DeletePlatbyGroupPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyGroup` that was deleted by this mutation. */
	platbyGroup?: GraphQLTypes["PlatbyGroup"] | undefined,
	deletedPlatbyGroupNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `PlatbyGroup`. May be used by Relay 1. */
	platbyGroupEdge?: GraphQLTypes["PlatbyGroupsEdge"] | undefined
};
	/** All input for the `deletePlatbyGroupByNodeId` mutation. */
["DeletePlatbyGroupByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `PlatbyGroup` to be deleted. */
	nodeId: string
};
	/** All input for the `deletePlatbyGroup` mutation. */
["DeletePlatbyGroupInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	pgId: GraphQLTypes["BigInt"]
};
	/** The output of our delete `PlatbyGroupSkupina` mutation. */
["DeletePlatbyGroupSkupinaPayload"]: {
	__typename: "DeletePlatbyGroupSkupinaPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyGroupSkupina` that was deleted by this mutation. */
	platbyGroupSkupina?: GraphQLTypes["PlatbyGroupSkupina"] | undefined,
	deletedPlatbyGroupSkupinaNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `Skupiny` that is related to this `PlatbyGroupSkupina`. */
	skupinyByPgsIdSkupina?: GraphQLTypes["Skupiny"] | undefined,
	/** Reads a single `PlatbyGroup` that is related to this `PlatbyGroupSkupina`. */
	platbyGroupByPgsIdGroup?: GraphQLTypes["PlatbyGroup"] | undefined,
	/** An edge for our `PlatbyGroupSkupina`. May be used by Relay 1. */
	platbyGroupSkupinaEdge?: GraphQLTypes["PlatbyGroupSkupinasEdge"] | undefined
};
	/** All input for the `deletePlatbyGroupSkupinaByNodeId` mutation. */
["DeletePlatbyGroupSkupinaByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `PlatbyGroupSkupina` to be deleted. */
	nodeId: string
};
	/** All input for the `deletePlatbyGroupSkupina` mutation. */
["DeletePlatbyGroupSkupinaInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	pgsId: GraphQLTypes["BigInt"]
};
	/** The output of our delete `PlatbyItem` mutation. */
["DeletePlatbyItemPayload"]: {
	__typename: "DeletePlatbyItemPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyItem` that was deleted by this mutation. */
	platbyItem?: GraphQLTypes["PlatbyItem"] | undefined,
	deletedPlatbyItemNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `PlatbyItem`. */
	userByPiIdUser?: GraphQLTypes["User"] | undefined,
	/** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
	platbyCategoryByPiIdCategory?: GraphQLTypes["PlatbyCategory"] | undefined,
	/** Reads a single `PlatbyRaw` that is related to this `PlatbyItem`. */
	platbyRawByPiIdRaw?: GraphQLTypes["PlatbyRaw"] | undefined,
	/** An edge for our `PlatbyItem`. May be used by Relay 1. */
	platbyItemEdge?: GraphQLTypes["PlatbyItemsEdge"] | undefined
};
	/** All input for the `deletePlatbyItemByNodeId` mutation. */
["DeletePlatbyItemByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `PlatbyItem` to be deleted. */
	nodeId: string
};
	/** All input for the `deletePlatbyItem` mutation. */
["DeletePlatbyItemInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	piId: GraphQLTypes["BigInt"]
};
	/** The output of our delete `PlatbyRaw` mutation. */
["DeletePlatbyRawPayload"]: {
	__typename: "DeletePlatbyRawPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `PlatbyRaw` that was deleted by this mutation. */
	platbyRaw?: GraphQLTypes["PlatbyRaw"] | undefined,
	deletedPlatbyRawNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `PlatbyRaw`. May be used by Relay 1. */
	platbyRawEdge?: GraphQLTypes["PlatbyRawsEdge"] | undefined
};
	/** All input for the `deletePlatbyRawByNodeId` mutation. */
["DeletePlatbyRawByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `PlatbyRaw` to be deleted. */
	nodeId: string
};
	/** All input for the `deletePlatbyRaw` mutation. */
["DeletePlatbyRawInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	prId: GraphQLTypes["BigInt"]
};
	/** The output of our delete `Rozpi` mutation. */
["DeleteRozpiPayload"]: {
	__typename: "DeleteRozpiPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Rozpi` that was deleted by this mutation. */
	rozpi?: GraphQLTypes["Rozpi"] | undefined,
	deletedRozpiNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Rozpi`. */
	userByRTrener?: GraphQLTypes["User"] | undefined,
	/** An edge for our `Rozpi`. May be used by Relay 1. */
	rozpiEdge?: GraphQLTypes["RozpisEdge"] | undefined
};
	/** All input for the `deleteRozpiByNodeId` mutation. */
["DeleteRozpiByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Rozpi` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteRozpi` mutation. */
["DeleteRozpiInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	rId: GraphQLTypes["BigInt"]
};
	/** The output of our delete `RozpisItem` mutation. */
["DeleteRozpisItemPayload"]: {
	__typename: "DeleteRozpisItemPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `RozpisItem` that was deleted by this mutation. */
	rozpisItem?: GraphQLTypes["RozpisItem"] | undefined,
	deletedRozpisItemNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `Rozpi` that is related to this `RozpisItem`. */
	rozpiByRiIdRodic?: GraphQLTypes["Rozpi"] | undefined,
	/** Reads a single `Pary` that is related to this `RozpisItem`. */
	paryByRiPartner?: GraphQLTypes["Pary"] | undefined,
	/** An edge for our `RozpisItem`. May be used by Relay 1. */
	rozpisItemEdge?: GraphQLTypes["RozpisItemsEdge"] | undefined
};
	/** All input for the `deleteRozpisItemByNodeId` mutation. */
["DeleteRozpisItemByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `RozpisItem` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteRozpisItem` mutation. */
["DeleteRozpisItemInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	riId: GraphQLTypes["BigInt"]
};
	/** The output of our delete `Session` mutation. */
["DeleteSessionPayload"]: {
	__typename: "DeleteSessionPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Session` that was deleted by this mutation. */
	session?: GraphQLTypes["Session"] | undefined,
	deletedSessionNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Session`. */
	userBySsUser?: GraphQLTypes["User"] | undefined,
	/** An edge for our `Session`. May be used by Relay 1. */
	sessionEdge?: GraphQLTypes["SessionsEdge"] | undefined
};
	/** All input for the `deleteSessionByNodeId` mutation. */
["DeleteSessionByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Session` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteSession` mutation. */
["DeleteSessionInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	ssId: string
};
	/** The output of our delete `Skupiny` mutation. */
["DeleteSkupinyPayload"]: {
	__typename: "DeleteSkupinyPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Skupiny` that was deleted by this mutation. */
	skupiny?: GraphQLTypes["Skupiny"] | undefined,
	deletedSkupinyNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `Skupiny`. May be used by Relay 1. */
	skupinyEdge?: GraphQLTypes["SkupiniesEdge"] | undefined
};
	/** All input for the `deleteSkupinyByNodeId` mutation. */
["DeleteSkupinyByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Skupiny` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteSkupiny` mutation. */
["DeleteSkupinyInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	sId: GraphQLTypes["BigInt"]
};
	/** The output of our delete `Upozorneni` mutation. */
["DeleteUpozorneniPayload"]: {
	__typename: "DeleteUpozorneniPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Upozorneni` that was deleted by this mutation. */
	upozorneni?: GraphQLTypes["Upozorneni"] | undefined,
	deletedUpozorneniNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `User` that is related to this `Upozorneni`. */
	userByUpKdo?: GraphQLTypes["User"] | undefined,
	/** An edge for our `Upozorneni`. May be used by Relay 1. */
	upozorneniEdge?: GraphQLTypes["UpozornenisEdge"] | undefined
};
	/** All input for the `deleteUpozorneniByNodeId` mutation. */
["DeleteUpozorneniByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Upozorneni` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteUpozorneni` mutation. */
["DeleteUpozorneniInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	upId: GraphQLTypes["BigInt"]
};
	/** The output of our delete `UpozorneniSkupiny` mutation. */
["DeleteUpozorneniSkupinyPayload"]: {
	__typename: "DeleteUpozorneniSkupinyPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `UpozorneniSkupiny` that was deleted by this mutation. */
	upozorneniSkupiny?: GraphQLTypes["UpozorneniSkupiny"] | undefined,
	deletedUpozorneniSkupinyNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
	upozorneniByUpsIdRodic?: GraphQLTypes["Upozorneni"] | undefined,
	/** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
	skupinyByUpsIdSkupina?: GraphQLTypes["Skupiny"] | undefined,
	/** An edge for our `UpozorneniSkupiny`. May be used by Relay 1. */
	upozorneniSkupinyEdge?: GraphQLTypes["UpozorneniSkupiniesEdge"] | undefined
};
	/** All input for the `deleteUpozorneniSkupinyByNodeId` mutation. */
["DeleteUpozorneniSkupinyByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `UpozorneniSkupiny` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteUpozorneniSkupiny` mutation. */
["DeleteUpozorneniSkupinyInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	upsId: GraphQLTypes["BigInt"]
};
	/** The output of our delete `User` mutation. */
["DeleteUserPayload"]: {
	__typename: "DeleteUserPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `User` that was deleted by this mutation. */
	user?: GraphQLTypes["User"] | undefined,
	deletedUserNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** Reads a single `Permission` that is related to this `User`. */
	permissionByUGroup?: GraphQLTypes["Permission"] | undefined,
	/** Reads a single `Skupiny` that is related to this `User`. */
	skupinyByUSkupina?: GraphQLTypes["Skupiny"] | undefined,
	/** An edge for our `User`. May be used by Relay 1. */
	userEdge?: GraphQLTypes["UsersEdge"] | undefined
};
	/** All input for the `deleteUserByNodeId` mutation. */
["DeleteUserByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `User` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteUser` mutation. */
["DeleteUserInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	uId: GraphQLTypes["BigInt"]
};
	/** The output of our delete `UsersSkupiny` mutation. */
["DeleteUsersSkupinyPayload"]: {
	__typename: "DeleteUsersSkupinyPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `UsersSkupiny` that was deleted by this mutation. */
	usersSkupiny?: GraphQLTypes["UsersSkupiny"] | undefined,
	deletedUsersSkupinyNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `UsersSkupiny`. May be used by Relay 1. */
	usersSkupinyEdge?: GraphQLTypes["UsersSkupiniesEdge"] | undefined
};
	/** All input for the `deleteUsersSkupinyByNodeId` mutation. */
["DeleteUsersSkupinyByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `UsersSkupiny` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteUsersSkupiny` mutation. */
["DeleteUsersSkupinyInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	usId: GraphQLTypes["BigInt"]
};
	/** The output of our delete `Video` mutation. */
["DeleteVideoPayload"]: {
	__typename: "DeleteVideoPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `Video` that was deleted by this mutation. */
	video?: GraphQLTypes["Video"] | undefined,
	deletedVideoNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `Video`. May be used by Relay 1. */
	videoEdge?: GraphQLTypes["VideosEdge"] | undefined
};
	/** All input for the `deleteVideoByNodeId` mutation. */
["DeleteVideoByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `Video` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteVideo` mutation. */
["DeleteVideoInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	vId: GraphQLTypes["BigInt"]
};
	/** The output of our delete `VideoList` mutation. */
["DeleteVideoListPayload"]: {
	__typename: "DeleteVideoListPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `VideoList` that was deleted by this mutation. */
	videoList?: GraphQLTypes["VideoList"] | undefined,
	deletedVideoListNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `VideoList`. May be used by Relay 1. */
	videoListEdge?: GraphQLTypes["VideoListsEdge"] | undefined
};
	/** All input for the `deleteVideoListByNodeId` mutation. */
["DeleteVideoListByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `VideoList` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteVideoList` mutation. */
["DeleteVideoListInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	vlId: GraphQLTypes["BigInt"]
};
	/** The output of our delete `VideoSource` mutation. */
["DeleteVideoSourcePayload"]: {
	__typename: "DeleteVideoSourcePayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** The `VideoSource` that was deleted by this mutation. */
	videoSource?: GraphQLTypes["VideoSource"] | undefined,
	deletedVideoSourceNodeId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined,
	/** An edge for our `VideoSource`. May be used by Relay 1. */
	videoSourceEdge?: GraphQLTypes["VideoSourcesEdge"] | undefined
};
	/** All input for the `deleteVideoSourceByNodeId` mutation. */
["DeleteVideoSourceByNodeIdInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	/** The globally unique `ID` which will identify a single `VideoSource` to be deleted. */
	nodeId: string
};
	/** All input for the `deleteVideoSource` mutation. */
["DeleteVideoSourceInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	vsId: GraphQLTypes["BigInt"]
};
	/** The output of our `login` mutation. */
["LoginPayload"]: {
	__typename: "LoginPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	result?: GraphQLTypes["LoginRecord"] | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined
};
	/** The return type of our `login` mutation. */
["LoginRecord"]: {
	__typename: "LoginRecord",
	couple?: GraphQLTypes["Pary"] | undefined,
	sess?: GraphQLTypes["Session"] | undefined,
	usr?: GraphQLTypes["User"] | undefined
};
	/** All input for the `login` mutation. */
["LoginInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	login: string,
	passwd: string
};
	/** The output of our `logout` mutation. */
["LogoutPayload"]: {
	__typename: "LogoutPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined
};
	/** All input for the `logout` mutation. */
["LogoutInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined
};
	/** The output of our `prospectFormDancer` mutation. */
["ProspectFormDancerPayload"]: {
	__typename: "ProspectFormDancerPayload",
	/** The exact same `clientMutationId` that was provided in the mutation input,
unchanged and unused. May be used by a client to track mutations. */
	clientMutationId?: string | undefined,
	/** Our root query field type. Allows us to run any query from our mutation payload. */
	query?: GraphQLTypes["Query"] | undefined
};
	/** All input for the `prospectFormDancer` mutation. */
["ProspectFormDancerInput"]: {
		/** An arbitrary string value with no semantic meaning. Will be included in the
payload verbatim. May be used to track mutations by the client. */
	clientMutationId?: string | undefined,
	cohort: GraphQLTypes["CrmCohort"],
	prospectData: GraphQLTypes["ProspectDatumInput"],
	origin: string,
	note: string
};
	/** An input for mutations affecting `ProspectDatum` */
["ProspectDatumInput"]: {
		name?: string | undefined,
	surname?: string | undefined,
	email?: string | undefined,
	phone?: string | undefined,
	yearofbirth?: string | undefined
};
	["Upload"]: {
	__typename: "Upload",
	uploadUrl: string
};
	["UploadInput"]: {
		directory?: string | undefined,
	filename: string
}
    }
/** Methods to use when ordering `User`. */
export const enum UsersOrderBy {
	NATURAL = "NATURAL",
	U_ID_ASC = "U_ID_ASC",
	U_ID_DESC = "U_ID_DESC",
	U_LOGIN_ASC = "U_LOGIN_ASC",
	U_LOGIN_DESC = "U_LOGIN_DESC",
	U_PASS_ASC = "U_PASS_ASC",
	U_PASS_DESC = "U_PASS_DESC",
	U_JMENO_ASC = "U_JMENO_ASC",
	U_JMENO_DESC = "U_JMENO_DESC",
	U_PRIJMENI_ASC = "U_PRIJMENI_ASC",
	U_PRIJMENI_DESC = "U_PRIJMENI_DESC",
	U_POHLAVI_ASC = "U_POHLAVI_ASC",
	U_POHLAVI_DESC = "U_POHLAVI_DESC",
	U_EMAIL_ASC = "U_EMAIL_ASC",
	U_EMAIL_DESC = "U_EMAIL_DESC",
	U_TELEFON_ASC = "U_TELEFON_ASC",
	U_TELEFON_DESC = "U_TELEFON_DESC",
	U_NAROZENI_ASC = "U_NAROZENI_ASC",
	U_NAROZENI_DESC = "U_NAROZENI_DESC",
	U_RODNE_CISLO_ASC = "U_RODNE_CISLO_ASC",
	U_RODNE_CISLO_DESC = "U_RODNE_CISLO_DESC",
	U_POZNAMKY_ASC = "U_POZNAMKY_ASC",
	U_POZNAMKY_DESC = "U_POZNAMKY_DESC",
	U_TIMESTAMP_ASC = "U_TIMESTAMP_ASC",
	U_TIMESTAMP_DESC = "U_TIMESTAMP_DESC",
	U_LEVEL_ASC = "U_LEVEL_ASC",
	U_LEVEL_DESC = "U_LEVEL_DESC",
	U_GROUP_ASC = "U_GROUP_ASC",
	U_GROUP_DESC = "U_GROUP_DESC",
	U_SKUPINA_ASC = "U_SKUPINA_ASC",
	U_SKUPINA_DESC = "U_SKUPINA_DESC",
	U_DANCER_ASC = "U_DANCER_ASC",
	U_DANCER_DESC = "U_DANCER_DESC",
	U_BAN_ASC = "U_BAN_ASC",
	U_BAN_DESC = "U_BAN_DESC",
	U_LOCK_ASC = "U_LOCK_ASC",
	U_LOCK_DESC = "U_LOCK_DESC",
	U_CONFIRMED_ASC = "U_CONFIRMED_ASC",
	U_CONFIRMED_DESC = "U_CONFIRMED_DESC",
	U_SYSTEM_ASC = "U_SYSTEM_ASC",
	U_SYSTEM_DESC = "U_SYSTEM_DESC",
	U_STREET_ASC = "U_STREET_ASC",
	U_STREET_DESC = "U_STREET_DESC",
	U_CONSCRIPTION_NUMBER_ASC = "U_CONSCRIPTION_NUMBER_ASC",
	U_CONSCRIPTION_NUMBER_DESC = "U_CONSCRIPTION_NUMBER_DESC",
	U_ORIENTATION_NUMBER_ASC = "U_ORIENTATION_NUMBER_ASC",
	U_ORIENTATION_NUMBER_DESC = "U_ORIENTATION_NUMBER_DESC",
	U_DISTRICT_ASC = "U_DISTRICT_ASC",
	U_DISTRICT_DESC = "U_DISTRICT_DESC",
	U_CITY_ASC = "U_CITY_ASC",
	U_CITY_DESC = "U_CITY_DESC",
	U_POSTAL_CODE_ASC = "U_POSTAL_CODE_ASC",
	U_POSTAL_CODE_DESC = "U_POSTAL_CODE_DESC",
	U_NATIONALITY_ASC = "U_NATIONALITY_ASC",
	U_NATIONALITY_DESC = "U_NATIONALITY_DESC",
	U_MEMBER_SINCE_ASC = "U_MEMBER_SINCE_ASC",
	U_MEMBER_SINCE_DESC = "U_MEMBER_SINCE_DESC",
	U_MEMBER_UNTIL_ASC = "U_MEMBER_UNTIL_ASC",
	U_MEMBER_UNTIL_DESC = "U_MEMBER_UNTIL_DESC",
	U_CREATED_AT_ASC = "U_CREATED_AT_ASC",
	U_CREATED_AT_DESC = "U_CREATED_AT_DESC",
	U_TEACHER_ASC = "U_TEACHER_ASC",
	U_TEACHER_DESC = "U_TEACHER_DESC",
	U_GDPR_SIGNED_AT_ASC = "U_GDPR_SIGNED_AT_ASC",
	U_GDPR_SIGNED_AT_DESC = "U_GDPR_SIGNED_AT_DESC",
	PRIMARY_KEY_ASC = "PRIMARY_KEY_ASC",
	PRIMARY_KEY_DESC = "PRIMARY_KEY_DESC"
}
/** Methods to use when ordering `PlatbyCategoryGroup`. */
export const enum PlatbyCategoryGroupsOrderBy {
	NATURAL = "NATURAL",
	PCG_ID_ASC = "PCG_ID_ASC",
	PCG_ID_DESC = "PCG_ID_DESC",
	PCG_ID_GROUP_ASC = "PCG_ID_GROUP_ASC",
	PCG_ID_GROUP_DESC = "PCG_ID_GROUP_DESC",
	PCG_ID_CATEGORY_ASC = "PCG_ID_CATEGORY_ASC",
	PCG_ID_CATEGORY_DESC = "PCG_ID_CATEGORY_DESC",
	PRIMARY_KEY_ASC = "PRIMARY_KEY_ASC",
	PRIMARY_KEY_DESC = "PRIMARY_KEY_DESC"
}
/** Methods to use when ordering `PlatbyItem`. */
export const enum PlatbyItemsOrderBy {
	NATURAL = "NATURAL",
	PI_ID_ASC = "PI_ID_ASC",
	PI_ID_DESC = "PI_ID_DESC",
	PI_ID_USER_ASC = "PI_ID_USER_ASC",
	PI_ID_USER_DESC = "PI_ID_USER_DESC",
	PI_ID_CATEGORY_ASC = "PI_ID_CATEGORY_ASC",
	PI_ID_CATEGORY_DESC = "PI_ID_CATEGORY_DESC",
	PI_ID_RAW_ASC = "PI_ID_RAW_ASC",
	PI_ID_RAW_DESC = "PI_ID_RAW_DESC",
	PI_AMOUNT_ASC = "PI_AMOUNT_ASC",
	PI_AMOUNT_DESC = "PI_AMOUNT_DESC",
	PI_DATE_ASC = "PI_DATE_ASC",
	PI_DATE_DESC = "PI_DATE_DESC",
	PI_PREFIX_ASC = "PI_PREFIX_ASC",
	PI_PREFIX_DESC = "PI_PREFIX_DESC",
	PRIMARY_KEY_ASC = "PRIMARY_KEY_ASC",
	PRIMARY_KEY_DESC = "PRIMARY_KEY_DESC"
}
/** Methods to use when ordering `PlatbyGroupSkupina`. */
export const enum PlatbyGroupSkupinasOrderBy {
	NATURAL = "NATURAL",
	PGS_ID_ASC = "PGS_ID_ASC",
	PGS_ID_DESC = "PGS_ID_DESC",
	PGS_ID_SKUPINA_ASC = "PGS_ID_SKUPINA_ASC",
	PGS_ID_SKUPINA_DESC = "PGS_ID_SKUPINA_DESC",
	PGS_ID_GROUP_ASC = "PGS_ID_GROUP_ASC",
	PGS_ID_GROUP_DESC = "PGS_ID_GROUP_DESC",
	PRIMARY_KEY_ASC = "PRIMARY_KEY_ASC",
	PRIMARY_KEY_DESC = "PRIMARY_KEY_DESC"
}
/** Methods to use when ordering `UpozorneniSkupiny`. */
export const enum UpozorneniSkupiniesOrderBy {
	NATURAL = "NATURAL",
	UPS_ID_ASC = "UPS_ID_ASC",
	UPS_ID_DESC = "UPS_ID_DESC",
	UPS_ID_RODIC_ASC = "UPS_ID_RODIC_ASC",
	UPS_ID_RODIC_DESC = "UPS_ID_RODIC_DESC",
	UPS_ID_SKUPINA_ASC = "UPS_ID_SKUPINA_ASC",
	UPS_ID_SKUPINA_DESC = "UPS_ID_SKUPINA_DESC",
	UPS_COLOR_ASC = "UPS_COLOR_ASC",
	UPS_COLOR_DESC = "UPS_COLOR_DESC",
	UPS_POPIS_ASC = "UPS_POPIS_ASC",
	UPS_POPIS_DESC = "UPS_POPIS_DESC",
	PRIMARY_KEY_ASC = "PRIMARY_KEY_ASC",
	PRIMARY_KEY_DESC = "PRIMARY_KEY_DESC"
}
/** Methods to use when ordering `GalerieFoto`. */
export const enum GalerieFotosOrderBy {
	NATURAL = "NATURAL",
	GF_ID_ASC = "GF_ID_ASC",
	GF_ID_DESC = "GF_ID_DESC",
	GF_ID_RODIC_ASC = "GF_ID_RODIC_ASC",
	GF_ID_RODIC_DESC = "GF_ID_RODIC_DESC",
	GF_NAME_ASC = "GF_NAME_ASC",
	GF_NAME_DESC = "GF_NAME_DESC",
	GF_PATH_ASC = "GF_PATH_ASC",
	GF_PATH_DESC = "GF_PATH_DESC",
	GF_KDO_ASC = "GF_KDO_ASC",
	GF_KDO_DESC = "GF_KDO_DESC",
	GF_TIMESTAMP_ASC = "GF_TIMESTAMP_ASC",
	GF_TIMESTAMP_DESC = "GF_TIMESTAMP_DESC",
	PRIMARY_KEY_ASC = "PRIMARY_KEY_ASC",
	PRIMARY_KEY_DESC = "PRIMARY_KEY_DESC"
}
/** Methods to use when ordering `Aktuality`. */
export const enum AktualitiesOrderBy {
	NATURAL = "NATURAL",
	AT_ID_ASC = "AT_ID_ASC",
	AT_ID_DESC = "AT_ID_DESC",
	AT_KDO_ASC = "AT_KDO_ASC",
	AT_KDO_DESC = "AT_KDO_DESC",
	AT_KAT_ASC = "AT_KAT_ASC",
	AT_KAT_DESC = "AT_KAT_DESC",
	AT_JMENO_ASC = "AT_JMENO_ASC",
	AT_JMENO_DESC = "AT_JMENO_DESC",
	AT_TEXT_ASC = "AT_TEXT_ASC",
	AT_TEXT_DESC = "AT_TEXT_DESC",
	AT_PREVIEW_ASC = "AT_PREVIEW_ASC",
	AT_PREVIEW_DESC = "AT_PREVIEW_DESC",
	AT_FOTO_ASC = "AT_FOTO_ASC",
	AT_FOTO_DESC = "AT_FOTO_DESC",
	AT_FOTO_MAIN_ASC = "AT_FOTO_MAIN_ASC",
	AT_FOTO_MAIN_DESC = "AT_FOTO_MAIN_DESC",
	AT_TIMESTAMP_ASC = "AT_TIMESTAMP_ASC",
	AT_TIMESTAMP_DESC = "AT_TIMESTAMP_DESC",
	AT_TIMESTAMP_ADD_ASC = "AT_TIMESTAMP_ADD_ASC",
	AT_TIMESTAMP_ADD_DESC = "AT_TIMESTAMP_ADD_DESC",
	PRIMARY_KEY_ASC = "PRIMARY_KEY_ASC",
	PRIMARY_KEY_DESC = "PRIMARY_KEY_DESC"
}
export const enum ParyPSttTrida {
	Z = "Z",
	H = "H",
	D = "D",
	C = "C",
	B = "B",
	A = "A",
	M = "M"
}
export const enum ParyPLatTrida {
	Z = "Z",
	H = "H",
	D = "D",
	C = "C",
	B = "B",
	A = "A",
	M = "M"
}
/** Methods to use when ordering `NabidkaItem`. */
export const enum NabidkaItemsOrderBy {
	NATURAL = "NATURAL",
	NI_ID_ASC = "NI_ID_ASC",
	NI_ID_DESC = "NI_ID_DESC",
	NI_ID_RODIC_ASC = "NI_ID_RODIC_ASC",
	NI_ID_RODIC_DESC = "NI_ID_RODIC_DESC",
	NI_PARTNER_ASC = "NI_PARTNER_ASC",
	NI_PARTNER_DESC = "NI_PARTNER_DESC",
	NI_POCET_HOD_ASC = "NI_POCET_HOD_ASC",
	NI_POCET_HOD_DESC = "NI_POCET_HOD_DESC",
	NI_LOCK_ASC = "NI_LOCK_ASC",
	NI_LOCK_DESC = "NI_LOCK_DESC",
	PRIMARY_KEY_ASC = "PRIMARY_KEY_ASC",
	PRIMARY_KEY_DESC = "PRIMARY_KEY_DESC"
}
/** Methods to use when ordering `RozpisItem`. */
export const enum RozpisItemsOrderBy {
	NATURAL = "NATURAL",
	RI_ID_ASC = "RI_ID_ASC",
	RI_ID_DESC = "RI_ID_DESC",
	RI_ID_RODIC_ASC = "RI_ID_RODIC_ASC",
	RI_ID_RODIC_DESC = "RI_ID_RODIC_DESC",
	RI_PARTNER_ASC = "RI_PARTNER_ASC",
	RI_PARTNER_DESC = "RI_PARTNER_DESC",
	RI_OD_ASC = "RI_OD_ASC",
	RI_OD_DESC = "RI_OD_DESC",
	RI_DO_ASC = "RI_DO_ASC",
	RI_DO_DESC = "RI_DO_DESC",
	RI_LOCK_ASC = "RI_LOCK_ASC",
	RI_LOCK_DESC = "RI_LOCK_DESC",
	PRIMARY_KEY_ASC = "PRIMARY_KEY_ASC",
	PRIMARY_KEY_DESC = "PRIMARY_KEY_DESC"
}
/** Methods to use when ordering `Nabidka`. */
export const enum NabidkasOrderBy {
	NATURAL = "NATURAL",
	N_ID_ASC = "N_ID_ASC",
	N_ID_DESC = "N_ID_DESC",
	N_TRENER_ASC = "N_TRENER_ASC",
	N_TRENER_DESC = "N_TRENER_DESC",
	N_POCET_HOD_ASC = "N_POCET_HOD_ASC",
	N_POCET_HOD_DESC = "N_POCET_HOD_DESC",
	N_MAX_POCET_HOD_ASC = "N_MAX_POCET_HOD_ASC",
	N_MAX_POCET_HOD_DESC = "N_MAX_POCET_HOD_DESC",
	N_OD_ASC = "N_OD_ASC",
	N_OD_DESC = "N_OD_DESC",
	N_DO_ASC = "N_DO_ASC",
	N_DO_DESC = "N_DO_DESC",
	N_VISIBLE_ASC = "N_VISIBLE_ASC",
	N_VISIBLE_DESC = "N_VISIBLE_DESC",
	N_LOCK_ASC = "N_LOCK_ASC",
	N_LOCK_DESC = "N_LOCK_DESC",
	N_TIMESTAMP_ASC = "N_TIMESTAMP_ASC",
	N_TIMESTAMP_DESC = "N_TIMESTAMP_DESC",
	PRIMARY_KEY_ASC = "PRIMARY_KEY_ASC",
	PRIMARY_KEY_DESC = "PRIMARY_KEY_DESC"
}
/** Methods to use when ordering `Rozpi`. */
export const enum RozpisOrderBy {
	NATURAL = "NATURAL",
	R_ID_ASC = "R_ID_ASC",
	R_ID_DESC = "R_ID_DESC",
	R_TRENER_ASC = "R_TRENER_ASC",
	R_TRENER_DESC = "R_TRENER_DESC",
	R_KDE_ASC = "R_KDE_ASC",
	R_KDE_DESC = "R_KDE_DESC",
	R_DATUM_ASC = "R_DATUM_ASC",
	R_DATUM_DESC = "R_DATUM_DESC",
	R_VISIBLE_ASC = "R_VISIBLE_ASC",
	R_VISIBLE_DESC = "R_VISIBLE_DESC",
	R_LOCK_ASC = "R_LOCK_ASC",
	R_LOCK_DESC = "R_LOCK_DESC",
	R_TIMESTAMP_ASC = "R_TIMESTAMP_ASC",
	R_TIMESTAMP_DESC = "R_TIMESTAMP_DESC",
	PRIMARY_KEY_ASC = "PRIMARY_KEY_ASC",
	PRIMARY_KEY_DESC = "PRIMARY_KEY_DESC"
}
/** Methods to use when ordering `Pary`. */
export const enum PariesOrderBy {
	NATURAL = "NATURAL",
	P_ID_ASC = "P_ID_ASC",
	P_ID_DESC = "P_ID_DESC",
	P_ID_PARTNER_ASC = "P_ID_PARTNER_ASC",
	P_ID_PARTNER_DESC = "P_ID_PARTNER_DESC",
	P_ID_PARTNERKA_ASC = "P_ID_PARTNERKA_ASC",
	P_ID_PARTNERKA_DESC = "P_ID_PARTNERKA_DESC",
	P_STT_TRIDA_ASC = "P_STT_TRIDA_ASC",
	P_STT_TRIDA_DESC = "P_STT_TRIDA_DESC",
	P_STT_BODY_ASC = "P_STT_BODY_ASC",
	P_STT_BODY_DESC = "P_STT_BODY_DESC",
	P_STT_FINALE_ASC = "P_STT_FINALE_ASC",
	P_STT_FINALE_DESC = "P_STT_FINALE_DESC",
	P_LAT_TRIDA_ASC = "P_LAT_TRIDA_ASC",
	P_LAT_TRIDA_DESC = "P_LAT_TRIDA_DESC",
	P_LAT_BODY_ASC = "P_LAT_BODY_ASC",
	P_LAT_BODY_DESC = "P_LAT_BODY_DESC",
	P_LAT_FINALE_ASC = "P_LAT_FINALE_ASC",
	P_LAT_FINALE_DESC = "P_LAT_FINALE_DESC",
	P_HODNOCENI_ASC = "P_HODNOCENI_ASC",
	P_HODNOCENI_DESC = "P_HODNOCENI_DESC",
	P_ARCHIV_ASC = "P_ARCHIV_ASC",
	P_ARCHIV_DESC = "P_ARCHIV_DESC",
	P_TIMESTAMP_ADD_ASC = "P_TIMESTAMP_ADD_ASC",
	P_TIMESTAMP_ADD_DESC = "P_TIMESTAMP_ADD_DESC",
	P_TIMESTAMP_ARCHIVE_ASC = "P_TIMESTAMP_ARCHIVE_ASC",
	P_TIMESTAMP_ARCHIVE_DESC = "P_TIMESTAMP_ARCHIVE_DESC",
	PRIMARY_KEY_ASC = "PRIMARY_KEY_ASC",
	PRIMARY_KEY_DESC = "PRIMARY_KEY_DESC"
}
/** Methods to use when ordering `Session`. */
export const enum SessionsOrderBy {
	NATURAL = "NATURAL",
	SS_ID_ASC = "SS_ID_ASC",
	SS_ID_DESC = "SS_ID_DESC",
	SS_DATA_ASC = "SS_DATA_ASC",
	SS_DATA_DESC = "SS_DATA_DESC",
	SS_UPDATED_AT_ASC = "SS_UPDATED_AT_ASC",
	SS_UPDATED_AT_DESC = "SS_UPDATED_AT_DESC",
	SS_LIFETIME_ASC = "SS_LIFETIME_ASC",
	SS_LIFETIME_DESC = "SS_LIFETIME_DESC",
	SS_USER_ASC = "SS_USER_ASC",
	SS_USER_DESC = "SS_USER_DESC",
	PRIMARY_KEY_ASC = "PRIMARY_KEY_ASC",
	PRIMARY_KEY_DESC = "PRIMARY_KEY_DESC"
}
/** Methods to use when ordering `AkceItem`. */
export const enum AkceItemsOrderBy {
	NATURAL = "NATURAL",
	AI_ID_ASC = "AI_ID_ASC",
	AI_ID_DESC = "AI_ID_DESC",
	AI_ID_RODIC_ASC = "AI_ID_RODIC_ASC",
	AI_ID_RODIC_DESC = "AI_ID_RODIC_DESC",
	AI_USER_ASC = "AI_USER_ASC",
	AI_USER_DESC = "AI_USER_DESC",
	AI_ROK_NAROZENI_ASC = "AI_ROK_NAROZENI_ASC",
	AI_ROK_NAROZENI_DESC = "AI_ROK_NAROZENI_DESC",
	PRIMARY_KEY_ASC = "PRIMARY_KEY_ASC",
	PRIMARY_KEY_DESC = "PRIMARY_KEY_DESC"
}
/** Methods to use when ordering `Dokumenty`. */
export const enum DokumentiesOrderBy {
	NATURAL = "NATURAL",
	D_ID_ASC = "D_ID_ASC",
	D_ID_DESC = "D_ID_DESC",
	D_PATH_ASC = "D_PATH_ASC",
	D_PATH_DESC = "D_PATH_DESC",
	D_NAME_ASC = "D_NAME_ASC",
	D_NAME_DESC = "D_NAME_DESC",
	D_FILENAME_ASC = "D_FILENAME_ASC",
	D_FILENAME_DESC = "D_FILENAME_DESC",
	D_KATEGORIE_ASC = "D_KATEGORIE_ASC",
	D_KATEGORIE_DESC = "D_KATEGORIE_DESC",
	D_KDO_ASC = "D_KDO_ASC",
	D_KDO_DESC = "D_KDO_DESC",
	D_TIMESTAMP_ASC = "D_TIMESTAMP_ASC",
	D_TIMESTAMP_DESC = "D_TIMESTAMP_DESC",
	PRIMARY_KEY_ASC = "PRIMARY_KEY_ASC",
	PRIMARY_KEY_DESC = "PRIMARY_KEY_DESC"
}
/** Methods to use when ordering `ParyNavrh`. */
export const enum ParyNavrhsOrderBy {
	NATURAL = "NATURAL",
	PN_ID_ASC = "PN_ID_ASC",
	PN_ID_DESC = "PN_ID_DESC",
	PN_NAVRHL_ASC = "PN_NAVRHL_ASC",
	PN_NAVRHL_DESC = "PN_NAVRHL_DESC",
	PN_PARTNER_ASC = "PN_PARTNER_ASC",
	PN_PARTNER_DESC = "PN_PARTNER_DESC",
	PN_PARTNERKA_ASC = "PN_PARTNERKA_ASC",
	PN_PARTNERKA_DESC = "PN_PARTNERKA_DESC",
	PRIMARY_KEY_ASC = "PRIMARY_KEY_ASC",
	PRIMARY_KEY_DESC = "PRIMARY_KEY_DESC"
}
/** Methods to use when ordering `Upozorneni`. */
export const enum UpozornenisOrderBy {
	NATURAL = "NATURAL",
	UP_ID_ASC = "UP_ID_ASC",
	UP_ID_DESC = "UP_ID_DESC",
	UP_KDO_ASC = "UP_KDO_ASC",
	UP_KDO_DESC = "UP_KDO_DESC",
	UP_NADPIS_ASC = "UP_NADPIS_ASC",
	UP_NADPIS_DESC = "UP_NADPIS_DESC",
	UP_TEXT_ASC = "UP_TEXT_ASC",
	UP_TEXT_DESC = "UP_TEXT_DESC",
	UP_BARVY_ASC = "UP_BARVY_ASC",
	UP_BARVY_DESC = "UP_BARVY_DESC",
	UP_LOCK_ASC = "UP_LOCK_ASC",
	UP_LOCK_DESC = "UP_LOCK_DESC",
	UP_TIMESTAMP_ASC = "UP_TIMESTAMP_ASC",
	UP_TIMESTAMP_DESC = "UP_TIMESTAMP_DESC",
	UP_TIMESTAMP_ADD_ASC = "UP_TIMESTAMP_ADD_ASC",
	UP_TIMESTAMP_ADD_DESC = "UP_TIMESTAMP_ADD_DESC",
	PRIMARY_KEY_ASC = "PRIMARY_KEY_ASC",
	PRIMARY_KEY_DESC = "PRIMARY_KEY_DESC"
}
/** Methods to use when ordering `Akce`. */
export const enum AkcesOrderBy {
	NATURAL = "NATURAL",
	A_ID_ASC = "A_ID_ASC",
	A_ID_DESC = "A_ID_DESC",
	A_JMENO_ASC = "A_JMENO_ASC",
	A_JMENO_DESC = "A_JMENO_DESC",
	A_KDE_ASC = "A_KDE_ASC",
	A_KDE_DESC = "A_KDE_DESC",
	A_INFO_ASC = "A_INFO_ASC",
	A_INFO_DESC = "A_INFO_DESC",
	A_OD_ASC = "A_OD_ASC",
	A_OD_DESC = "A_OD_DESC",
	A_DO_ASC = "A_DO_ASC",
	A_DO_DESC = "A_DO_DESC",
	A_KAPACITA_ASC = "A_KAPACITA_ASC",
	A_KAPACITA_DESC = "A_KAPACITA_DESC",
	A_DOKUMENTY_ASC = "A_DOKUMENTY_ASC",
	A_DOKUMENTY_DESC = "A_DOKUMENTY_DESC",
	A_TIMESTAMP_ASC = "A_TIMESTAMP_ASC",
	A_TIMESTAMP_DESC = "A_TIMESTAMP_DESC",
	A_LOCK_ASC = "A_LOCK_ASC",
	A_LOCK_DESC = "A_LOCK_DESC",
	A_VISIBLE_ASC = "A_VISIBLE_ASC",
	A_VISIBLE_DESC = "A_VISIBLE_DESC",
	PRIMARY_KEY_ASC = "PRIMARY_KEY_ASC",
	PRIMARY_KEY_DESC = "PRIMARY_KEY_DESC"
}
/** Methods to use when ordering `GalerieDir`. */
export const enum GalerieDirsOrderBy {
	NATURAL = "NATURAL",
	GD_ID_ASC = "GD_ID_ASC",
	GD_ID_DESC = "GD_ID_DESC",
	GD_ID_RODIC_ASC = "GD_ID_RODIC_ASC",
	GD_ID_RODIC_DESC = "GD_ID_RODIC_DESC",
	GD_NAME_ASC = "GD_NAME_ASC",
	GD_NAME_DESC = "GD_NAME_DESC",
	GD_LEVEL_ASC = "GD_LEVEL_ASC",
	GD_LEVEL_DESC = "GD_LEVEL_DESC",
	GD_PATH_ASC = "GD_PATH_ASC",
	GD_PATH_DESC = "GD_PATH_DESC",
	GD_HIDDEN_ASC = "GD_HIDDEN_ASC",
	GD_HIDDEN_DESC = "GD_HIDDEN_DESC",
	PRIMARY_KEY_ASC = "PRIMARY_KEY_ASC",
	PRIMARY_KEY_DESC = "PRIMARY_KEY_DESC"
}
/** Methods to use when ordering `Member`. */
export const enum MembersOrderBy {
	NATURAL = "NATURAL",
	U_ID_ASC = "U_ID_ASC",
	U_ID_DESC = "U_ID_DESC",
	U_LOGIN_ASC = "U_LOGIN_ASC",
	U_LOGIN_DESC = "U_LOGIN_DESC",
	U_PASS_ASC = "U_PASS_ASC",
	U_PASS_DESC = "U_PASS_DESC",
	U_JMENO_ASC = "U_JMENO_ASC",
	U_JMENO_DESC = "U_JMENO_DESC",
	U_PRIJMENI_ASC = "U_PRIJMENI_ASC",
	U_PRIJMENI_DESC = "U_PRIJMENI_DESC",
	U_POHLAVI_ASC = "U_POHLAVI_ASC",
	U_POHLAVI_DESC = "U_POHLAVI_DESC",
	U_EMAIL_ASC = "U_EMAIL_ASC",
	U_EMAIL_DESC = "U_EMAIL_DESC",
	U_TELEFON_ASC = "U_TELEFON_ASC",
	U_TELEFON_DESC = "U_TELEFON_DESC",
	U_NAROZENI_ASC = "U_NAROZENI_ASC",
	U_NAROZENI_DESC = "U_NAROZENI_DESC",
	U_RODNE_CISLO_ASC = "U_RODNE_CISLO_ASC",
	U_RODNE_CISLO_DESC = "U_RODNE_CISLO_DESC",
	U_POZNAMKY_ASC = "U_POZNAMKY_ASC",
	U_POZNAMKY_DESC = "U_POZNAMKY_DESC",
	U_TIMESTAMP_ASC = "U_TIMESTAMP_ASC",
	U_TIMESTAMP_DESC = "U_TIMESTAMP_DESC",
	U_LEVEL_ASC = "U_LEVEL_ASC",
	U_LEVEL_DESC = "U_LEVEL_DESC",
	U_GROUP_ASC = "U_GROUP_ASC",
	U_GROUP_DESC = "U_GROUP_DESC",
	U_SKUPINA_ASC = "U_SKUPINA_ASC",
	U_SKUPINA_DESC = "U_SKUPINA_DESC",
	U_DANCER_ASC = "U_DANCER_ASC",
	U_DANCER_DESC = "U_DANCER_DESC",
	U_BAN_ASC = "U_BAN_ASC",
	U_BAN_DESC = "U_BAN_DESC",
	U_LOCK_ASC = "U_LOCK_ASC",
	U_LOCK_DESC = "U_LOCK_DESC",
	U_CONFIRMED_ASC = "U_CONFIRMED_ASC",
	U_CONFIRMED_DESC = "U_CONFIRMED_DESC",
	U_SYSTEM_ASC = "U_SYSTEM_ASC",
	U_SYSTEM_DESC = "U_SYSTEM_DESC",
	U_STREET_ASC = "U_STREET_ASC",
	U_STREET_DESC = "U_STREET_DESC",
	U_CONSCRIPTION_NUMBER_ASC = "U_CONSCRIPTION_NUMBER_ASC",
	U_CONSCRIPTION_NUMBER_DESC = "U_CONSCRIPTION_NUMBER_DESC",
	U_ORIENTATION_NUMBER_ASC = "U_ORIENTATION_NUMBER_ASC",
	U_ORIENTATION_NUMBER_DESC = "U_ORIENTATION_NUMBER_DESC",
	U_DISTRICT_ASC = "U_DISTRICT_ASC",
	U_DISTRICT_DESC = "U_DISTRICT_DESC",
	U_CITY_ASC = "U_CITY_ASC",
	U_CITY_DESC = "U_CITY_DESC",
	U_POSTAL_CODE_ASC = "U_POSTAL_CODE_ASC",
	U_POSTAL_CODE_DESC = "U_POSTAL_CODE_DESC",
	U_NATIONALITY_ASC = "U_NATIONALITY_ASC",
	U_NATIONALITY_DESC = "U_NATIONALITY_DESC",
	U_MEMBER_SINCE_ASC = "U_MEMBER_SINCE_ASC",
	U_MEMBER_SINCE_DESC = "U_MEMBER_SINCE_DESC",
	U_MEMBER_UNTIL_ASC = "U_MEMBER_UNTIL_ASC",
	U_MEMBER_UNTIL_DESC = "U_MEMBER_UNTIL_DESC",
	U_CREATED_AT_ASC = "U_CREATED_AT_ASC",
	U_CREATED_AT_DESC = "U_CREATED_AT_DESC",
	U_TEACHER_ASC = "U_TEACHER_ASC",
	U_TEACHER_DESC = "U_TEACHER_DESC",
	U_GDPR_SIGNED_AT_ASC = "U_GDPR_SIGNED_AT_ASC",
	U_GDPR_SIGNED_AT_DESC = "U_GDPR_SIGNED_AT_DESC",
	S_ID_ASC = "S_ID_ASC",
	S_ID_DESC = "S_ID_DESC",
	S_NAME_ASC = "S_NAME_ASC",
	S_NAME_DESC = "S_NAME_DESC",
	PAYMENT_VALID_ASC = "PAYMENT_VALID_ASC",
	PAYMENT_VALID_DESC = "PAYMENT_VALID_DESC"
}
/** Methods to use when ordering `Page`. */
export const enum PagesOrderBy {
	NATURAL = "NATURAL",
	ID_ASC = "ID_ASC",
	ID_DESC = "ID_DESC",
	URL_ASC = "URL_ASC",
	URL_DESC = "URL_DESC",
	CONTENT_ASC = "CONTENT_ASC",
	CONTENT_DESC = "CONTENT_DESC",
	CREATED_AT_ASC = "CREATED_AT_ASC",
	CREATED_AT_DESC = "CREATED_AT_DESC",
	UPDATED_AT_ASC = "UPDATED_AT_ASC",
	UPDATED_AT_DESC = "UPDATED_AT_DESC",
	TITLE_ASC = "TITLE_ASC",
	TITLE_DESC = "TITLE_DESC",
	PRIMARY_KEY_ASC = "PRIMARY_KEY_ASC",
	PRIMARY_KEY_DESC = "PRIMARY_KEY_DESC"
}
/** Methods to use when ordering `PageRevision`. */
export const enum PageRevisionsOrderBy {
	NATURAL = "NATURAL",
	REV_NUMBER_ASC = "REV_NUMBER_ASC",
	REV_NUMBER_DESC = "REV_NUMBER_DESC",
	REV_OPERATION_ASC = "REV_OPERATION_ASC",
	REV_OPERATION_DESC = "REV_OPERATION_DESC",
	REV_TIMESTAMP_ASC = "REV_TIMESTAMP_ASC",
	REV_TIMESTAMP_DESC = "REV_TIMESTAMP_DESC",
	ID_ASC = "ID_ASC",
	ID_DESC = "ID_DESC",
	URL_ASC = "URL_ASC",
	URL_DESC = "URL_DESC",
	CONTENT_ASC = "CONTENT_ASC",
	CONTENT_DESC = "CONTENT_DESC",
	CREATED_AT_ASC = "CREATED_AT_ASC",
	CREATED_AT_DESC = "CREATED_AT_DESC",
	UPDATED_AT_ASC = "UPDATED_AT_ASC",
	UPDATED_AT_DESC = "UPDATED_AT_DESC",
	TITLE_ASC = "TITLE_ASC",
	TITLE_DESC = "TITLE_DESC",
	PRIMARY_KEY_ASC = "PRIMARY_KEY_ASC",
	PRIMARY_KEY_DESC = "PRIMARY_KEY_DESC"
}
/** Methods to use when ordering `Parameter`. */
export const enum ParametersOrderBy {
	NATURAL = "NATURAL",
	PA_NAME_ASC = "PA_NAME_ASC",
	PA_NAME_DESC = "PA_NAME_DESC",
	PA_VALUE_ASC = "PA_VALUE_ASC",
	PA_VALUE_DESC = "PA_VALUE_DESC",
	PRIMARY_KEY_ASC = "PRIMARY_KEY_ASC",
	PRIMARY_KEY_DESC = "PRIMARY_KEY_DESC"
}
/** Methods to use when ordering `Permission`. */
export const enum PermissionsOrderBy {
	NATURAL = "NATURAL",
	PE_ID_ASC = "PE_ID_ASC",
	PE_ID_DESC = "PE_ID_DESC",
	PE_NAME_ASC = "PE_NAME_ASC",
	PE_NAME_DESC = "PE_NAME_DESC",
	PE_DESCRIPTION_ASC = "PE_DESCRIPTION_ASC",
	PE_DESCRIPTION_DESC = "PE_DESCRIPTION_DESC",
	PE_AKCE_ASC = "PE_AKCE_ASC",
	PE_AKCE_DESC = "PE_AKCE_DESC",
	PE_AKTUALITY_ASC = "PE_AKTUALITY_ASC",
	PE_AKTUALITY_DESC = "PE_AKTUALITY_DESC",
	PE_ANKETY_ASC = "PE_ANKETY_ASC",
	PE_ANKETY_DESC = "PE_ANKETY_DESC",
	PE_DOKUMENTY_ASC = "PE_DOKUMENTY_ASC",
	PE_DOKUMENTY_DESC = "PE_DOKUMENTY_DESC",
	PE_GALERIE_ASC = "PE_GALERIE_ASC",
	PE_GALERIE_DESC = "PE_GALERIE_DESC",
	PE_INZERCE_ASC = "PE_INZERCE_ASC",
	PE_INZERCE_DESC = "PE_INZERCE_DESC",
	PE_KONZOLE_ASC = "PE_KONZOLE_ASC",
	PE_KONZOLE_DESC = "PE_KONZOLE_DESC",
	PE_NABIDKA_ASC = "PE_NABIDKA_ASC",
	PE_NABIDKA_DESC = "PE_NABIDKA_DESC",
	PE_NASTENKA_ASC = "PE_NASTENKA_ASC",
	PE_NASTENKA_DESC = "PE_NASTENKA_DESC",
	PE_NOVINKY_ASC = "PE_NOVINKY_ASC",
	PE_NOVINKY_DESC = "PE_NOVINKY_DESC",
	PE_PARY_ASC = "PE_PARY_ASC",
	PE_PARY_DESC = "PE_PARY_DESC",
	PE_PLATBY_ASC = "PE_PLATBY_ASC",
	PE_PLATBY_DESC = "PE_PLATBY_DESC",
	PE_PERMISSIONS_ASC = "PE_PERMISSIONS_ASC",
	PE_PERMISSIONS_DESC = "PE_PERMISSIONS_DESC",
	PE_ROZPIS_ASC = "PE_ROZPIS_ASC",
	PE_ROZPIS_DESC = "PE_ROZPIS_DESC",
	PE_SKUPINY_ASC = "PE_SKUPINY_ASC",
	PE_SKUPINY_DESC = "PE_SKUPINY_DESC",
	PE_USERS_ASC = "PE_USERS_ASC",
	PE_USERS_DESC = "PE_USERS_DESC",
	PE_MAIN_ASC = "PE_MAIN_ASC",
	PE_MAIN_DESC = "PE_MAIN_DESC",
	PRIMARY_KEY_ASC = "PRIMARY_KEY_ASC",
	PRIMARY_KEY_DESC = "PRIMARY_KEY_DESC"
}
/** Methods to use when ordering `PlatbyCategory`. */
export const enum PlatbyCategoriesOrderBy {
	NATURAL = "NATURAL",
	PC_ID_ASC = "PC_ID_ASC",
	PC_ID_DESC = "PC_ID_DESC",
	PC_NAME_ASC = "PC_NAME_ASC",
	PC_NAME_DESC = "PC_NAME_DESC",
	PC_SYMBOL_ASC = "PC_SYMBOL_ASC",
	PC_SYMBOL_DESC = "PC_SYMBOL_DESC",
	PC_AMOUNT_ASC = "PC_AMOUNT_ASC",
	PC_AMOUNT_DESC = "PC_AMOUNT_DESC",
	PC_DATE_DUE_ASC = "PC_DATE_DUE_ASC",
	PC_DATE_DUE_DESC = "PC_DATE_DUE_DESC",
	PC_VALID_FROM_ASC = "PC_VALID_FROM_ASC",
	PC_VALID_FROM_DESC = "PC_VALID_FROM_DESC",
	PC_VALID_TO_ASC = "PC_VALID_TO_ASC",
	PC_VALID_TO_DESC = "PC_VALID_TO_DESC",
	PC_USE_BASE_ASC = "PC_USE_BASE_ASC",
	PC_USE_BASE_DESC = "PC_USE_BASE_DESC",
	PC_USE_PREFIX_ASC = "PC_USE_PREFIX_ASC",
	PC_USE_PREFIX_DESC = "PC_USE_PREFIX_DESC",
	PC_ARCHIVE_ASC = "PC_ARCHIVE_ASC",
	PC_ARCHIVE_DESC = "PC_ARCHIVE_DESC",
	PC_VISIBLE_ASC = "PC_VISIBLE_ASC",
	PC_VISIBLE_DESC = "PC_VISIBLE_DESC",
	PRIMARY_KEY_ASC = "PRIMARY_KEY_ASC",
	PRIMARY_KEY_DESC = "PRIMARY_KEY_DESC"
}
/** Methods to use when ordering `PlatbyGroup`. */
export const enum PlatbyGroupsOrderBy {
	NATURAL = "NATURAL",
	PG_ID_ASC = "PG_ID_ASC",
	PG_ID_DESC = "PG_ID_DESC",
	PG_TYPE_ASC = "PG_TYPE_ASC",
	PG_TYPE_DESC = "PG_TYPE_DESC",
	PG_NAME_ASC = "PG_NAME_ASC",
	PG_NAME_DESC = "PG_NAME_DESC",
	PG_DESCRIPTION_ASC = "PG_DESCRIPTION_ASC",
	PG_DESCRIPTION_DESC = "PG_DESCRIPTION_DESC",
	PG_BASE_ASC = "PG_BASE_ASC",
	PG_BASE_DESC = "PG_BASE_DESC",
	PRIMARY_KEY_ASC = "PRIMARY_KEY_ASC",
	PRIMARY_KEY_DESC = "PRIMARY_KEY_DESC"
}
/** Methods to use when ordering `PlatbyRaw`. */
export const enum PlatbyRawsOrderBy {
	NATURAL = "NATURAL",
	PR_ID_ASC = "PR_ID_ASC",
	PR_ID_DESC = "PR_ID_DESC",
	PR_RAW_ASC = "PR_RAW_ASC",
	PR_RAW_DESC = "PR_RAW_DESC",
	PR_HASH_ASC = "PR_HASH_ASC",
	PR_HASH_DESC = "PR_HASH_DESC",
	PR_SORTED_ASC = "PR_SORTED_ASC",
	PR_SORTED_DESC = "PR_SORTED_DESC",
	PR_DISCARDED_ASC = "PR_DISCARDED_ASC",
	PR_DISCARDED_DESC = "PR_DISCARDED_DESC",
	PRIMARY_KEY_ASC = "PRIMARY_KEY_ASC",
	PRIMARY_KEY_DESC = "PRIMARY_KEY_DESC"
}
/** Methods to use when ordering `Skupiny`. */
export const enum SkupiniesOrderBy {
	NATURAL = "NATURAL",
	S_ID_ASC = "S_ID_ASC",
	S_ID_DESC = "S_ID_DESC",
	S_NAME_ASC = "S_NAME_ASC",
	S_NAME_DESC = "S_NAME_DESC",
	S_DESCRIPTION_ASC = "S_DESCRIPTION_ASC",
	S_DESCRIPTION_DESC = "S_DESCRIPTION_DESC",
	S_COLOR_RGB_ASC = "S_COLOR_RGB_ASC",
	S_COLOR_RGB_DESC = "S_COLOR_RGB_DESC",
	S_COLOR_TEXT_ASC = "S_COLOR_TEXT_ASC",
	S_COLOR_TEXT_DESC = "S_COLOR_TEXT_DESC",
	S_LOCATION_ASC = "S_LOCATION_ASC",
	S_LOCATION_DESC = "S_LOCATION_DESC",
	S_VISIBLE_ASC = "S_VISIBLE_ASC",
	S_VISIBLE_DESC = "S_VISIBLE_DESC",
	PRIMARY_KEY_ASC = "PRIMARY_KEY_ASC",
	PRIMARY_KEY_DESC = "PRIMARY_KEY_DESC"
}
/** Methods to use when ordering `UsersSkupiny`. */
export const enum UsersSkupiniesOrderBy {
	NATURAL = "NATURAL",
	US_ID_ASC = "US_ID_ASC",
	US_ID_DESC = "US_ID_DESC",
	US_COLOR_ASC = "US_COLOR_ASC",
	US_COLOR_DESC = "US_COLOR_DESC",
	US_PLATBA_MESIC_ASC = "US_PLATBA_MESIC_ASC",
	US_PLATBA_MESIC_DESC = "US_PLATBA_MESIC_DESC",
	US_PLATBA_CTVRTROK_ASC = "US_PLATBA_CTVRTROK_ASC",
	US_PLATBA_CTVRTROK_DESC = "US_PLATBA_CTVRTROK_DESC",
	US_PLATBA_PULROK_ASC = "US_PLATBA_PULROK_ASC",
	US_PLATBA_PULROK_DESC = "US_PLATBA_PULROK_DESC",
	US_POPIS_ASC = "US_POPIS_ASC",
	US_POPIS_DESC = "US_POPIS_DESC",
	PRIMARY_KEY_ASC = "PRIMARY_KEY_ASC",
	PRIMARY_KEY_DESC = "PRIMARY_KEY_DESC"
}
/** Methods to use when ordering `Video`. */
export const enum VideosOrderBy {
	NATURAL = "NATURAL",
	V_ID_ASC = "V_ID_ASC",
	V_ID_DESC = "V_ID_DESC",
	V_URI_ASC = "V_URI_ASC",
	V_URI_DESC = "V_URI_DESC",
	V_TITLE_ASC = "V_TITLE_ASC",
	V_TITLE_DESC = "V_TITLE_DESC",
	V_AUTHOR_ASC = "V_AUTHOR_ASC",
	V_AUTHOR_DESC = "V_AUTHOR_DESC",
	V_DESCRIPTION_ASC = "V_DESCRIPTION_ASC",
	V_DESCRIPTION_DESC = "V_DESCRIPTION_DESC",
	V_PLAYLIST_ASC = "V_PLAYLIST_ASC",
	V_PLAYLIST_DESC = "V_PLAYLIST_DESC",
	V_CREATED_AT_ASC = "V_CREATED_AT_ASC",
	V_CREATED_AT_DESC = "V_CREATED_AT_DESC",
	V_UPDATED_AT_ASC = "V_UPDATED_AT_ASC",
	V_UPDATED_AT_DESC = "V_UPDATED_AT_DESC",
	PRIMARY_KEY_ASC = "PRIMARY_KEY_ASC",
	PRIMARY_KEY_DESC = "PRIMARY_KEY_DESC"
}
/** Methods to use when ordering `VideoList`. */
export const enum VideoListsOrderBy {
	NATURAL = "NATURAL",
	VL_ID_ASC = "VL_ID_ASC",
	VL_ID_DESC = "VL_ID_DESC",
	VL_URL_ASC = "VL_URL_ASC",
	VL_URL_DESC = "VL_URL_DESC",
	VL_TITLE_ASC = "VL_TITLE_ASC",
	VL_TITLE_DESC = "VL_TITLE_DESC",
	VL_DESCRIPTION_ASC = "VL_DESCRIPTION_ASC",
	VL_DESCRIPTION_DESC = "VL_DESCRIPTION_DESC",
	VL_COUNT_ASC = "VL_COUNT_ASC",
	VL_COUNT_DESC = "VL_COUNT_DESC",
	VL_CREATED_AT_ASC = "VL_CREATED_AT_ASC",
	VL_CREATED_AT_DESC = "VL_CREATED_AT_DESC",
	VL_LAST_CHECKED_ASC = "VL_LAST_CHECKED_ASC",
	VL_LAST_CHECKED_DESC = "VL_LAST_CHECKED_DESC",
	PRIMARY_KEY_ASC = "PRIMARY_KEY_ASC",
	PRIMARY_KEY_DESC = "PRIMARY_KEY_DESC"
}
/** Methods to use when ordering `VideoSource`. */
export const enum VideoSourcesOrderBy {
	NATURAL = "NATURAL",
	VS_ID_ASC = "VS_ID_ASC",
	VS_ID_DESC = "VS_ID_DESC",
	VS_URL_ASC = "VS_URL_ASC",
	VS_URL_DESC = "VS_URL_DESC",
	VS_TITLE_ASC = "VS_TITLE_ASC",
	VS_TITLE_DESC = "VS_TITLE_DESC",
	VS_DESCRIPTION_ASC = "VS_DESCRIPTION_ASC",
	VS_DESCRIPTION_DESC = "VS_DESCRIPTION_DESC",
	VS_CREATED_AT_ASC = "VS_CREATED_AT_ASC",
	VS_CREATED_AT_DESC = "VS_CREATED_AT_DESC",
	VS_LAST_CHECKED_ASC = "VS_LAST_CHECKED_ASC",
	VS_LAST_CHECKED_DESC = "VS_LAST_CHECKED_DESC",
	PRIMARY_KEY_ASC = "PRIMARY_KEY_ASC",
	PRIMARY_KEY_DESC = "PRIMARY_KEY_DESC"
}
export const enum CrmCohort {
	DANCER = "DANCER",
	HOBBYIST = "HOBBYIST",
	SHOWDANCE = "SHOWDANCE",
	FREE_LESSON = "FREE_LESSON",
	CONTACT_ME_LATER = "CONTACT_ME_LATER"
}

type ZEUS_VARIABLES = {
	["BigInt"]: ValueTypes["BigInt"];
	["Date"]: ValueTypes["Date"];
	["Datetime"]: ValueTypes["Datetime"];
	["Cursor"]: ValueTypes["Cursor"];
	["UsersOrderBy"]: ValueTypes["UsersOrderBy"];
	["UserCondition"]: ValueTypes["UserCondition"];
	["BigFloat"]: ValueTypes["BigFloat"];
	["PlatbyCategoryGroupsOrderBy"]: ValueTypes["PlatbyCategoryGroupsOrderBy"];
	["PlatbyCategoryGroupCondition"]: ValueTypes["PlatbyCategoryGroupCondition"];
	["PlatbyItemsOrderBy"]: ValueTypes["PlatbyItemsOrderBy"];
	["PlatbyItemCondition"]: ValueTypes["PlatbyItemCondition"];
	["PlatbyGroupSkupinasOrderBy"]: ValueTypes["PlatbyGroupSkupinasOrderBy"];
	["PlatbyGroupSkupinaCondition"]: ValueTypes["PlatbyGroupSkupinaCondition"];
	["UpozorneniSkupiniesOrderBy"]: ValueTypes["UpozorneniSkupiniesOrderBy"];
	["UpozorneniSkupinyCondition"]: ValueTypes["UpozorneniSkupinyCondition"];
	["GalerieFotosOrderBy"]: ValueTypes["GalerieFotosOrderBy"];
	["GalerieFotoCondition"]: ValueTypes["GalerieFotoCondition"];
	["AktualitiesOrderBy"]: ValueTypes["AktualitiesOrderBy"];
	["AktualityCondition"]: ValueTypes["AktualityCondition"];
	["ParyPSttTrida"]: ValueTypes["ParyPSttTrida"];
	["ParyPLatTrida"]: ValueTypes["ParyPLatTrida"];
	["NabidkaItemsOrderBy"]: ValueTypes["NabidkaItemsOrderBy"];
	["NabidkaItemCondition"]: ValueTypes["NabidkaItemCondition"];
	["Time"]: ValueTypes["Time"];
	["RozpisItemsOrderBy"]: ValueTypes["RozpisItemsOrderBy"];
	["RozpisItemCondition"]: ValueTypes["RozpisItemCondition"];
	["NabidkasOrderBy"]: ValueTypes["NabidkasOrderBy"];
	["NabidkaCondition"]: ValueTypes["NabidkaCondition"];
	["RozpisOrderBy"]: ValueTypes["RozpisOrderBy"];
	["RozpiCondition"]: ValueTypes["RozpiCondition"];
	["PariesOrderBy"]: ValueTypes["PariesOrderBy"];
	["ParyCondition"]: ValueTypes["ParyCondition"];
	["SessionsOrderBy"]: ValueTypes["SessionsOrderBy"];
	["SessionCondition"]: ValueTypes["SessionCondition"];
	["AkceItemsOrderBy"]: ValueTypes["AkceItemsOrderBy"];
	["AkceItemCondition"]: ValueTypes["AkceItemCondition"];
	["DokumentiesOrderBy"]: ValueTypes["DokumentiesOrderBy"];
	["DokumentyCondition"]: ValueTypes["DokumentyCondition"];
	["ParyNavrhsOrderBy"]: ValueTypes["ParyNavrhsOrderBy"];
	["ParyNavrhCondition"]: ValueTypes["ParyNavrhCondition"];
	["UpozornenisOrderBy"]: ValueTypes["UpozornenisOrderBy"];
	["UpozorneniCondition"]: ValueTypes["UpozorneniCondition"];
	["AkcesOrderBy"]: ValueTypes["AkcesOrderBy"];
	["AkceCondition"]: ValueTypes["AkceCondition"];
	["GalerieDirsOrderBy"]: ValueTypes["GalerieDirsOrderBy"];
	["GalerieDirCondition"]: ValueTypes["GalerieDirCondition"];
	["MembersOrderBy"]: ValueTypes["MembersOrderBy"];
	["MemberCondition"]: ValueTypes["MemberCondition"];
	["JSON"]: ValueTypes["JSON"];
	["PagesOrderBy"]: ValueTypes["PagesOrderBy"];
	["PageCondition"]: ValueTypes["PageCondition"];
	["PageRevisionsOrderBy"]: ValueTypes["PageRevisionsOrderBy"];
	["PageRevisionCondition"]: ValueTypes["PageRevisionCondition"];
	["ParametersOrderBy"]: ValueTypes["ParametersOrderBy"];
	["ParameterCondition"]: ValueTypes["ParameterCondition"];
	["PermissionsOrderBy"]: ValueTypes["PermissionsOrderBy"];
	["PermissionCondition"]: ValueTypes["PermissionCondition"];
	["PlatbyCategoriesOrderBy"]: ValueTypes["PlatbyCategoriesOrderBy"];
	["PlatbyCategoryCondition"]: ValueTypes["PlatbyCategoryCondition"];
	["PlatbyGroupsOrderBy"]: ValueTypes["PlatbyGroupsOrderBy"];
	["PlatbyGroupCondition"]: ValueTypes["PlatbyGroupCondition"];
	["PlatbyRawsOrderBy"]: ValueTypes["PlatbyRawsOrderBy"];
	["PlatbyRawCondition"]: ValueTypes["PlatbyRawCondition"];
	["SkupiniesOrderBy"]: ValueTypes["SkupiniesOrderBy"];
	["SkupinyCondition"]: ValueTypes["SkupinyCondition"];
	["UsersSkupiniesOrderBy"]: ValueTypes["UsersSkupiniesOrderBy"];
	["UsersSkupinyCondition"]: ValueTypes["UsersSkupinyCondition"];
	["VideosOrderBy"]: ValueTypes["VideosOrderBy"];
	["VideoCondition"]: ValueTypes["VideoCondition"];
	["VideoListsOrderBy"]: ValueTypes["VideoListsOrderBy"];
	["VideoListCondition"]: ValueTypes["VideoListCondition"];
	["VideoSourcesOrderBy"]: ValueTypes["VideoSourcesOrderBy"];
	["VideoSourceCondition"]: ValueTypes["VideoSourceCondition"];
	["CrmCohort"]: ValueTypes["CrmCohort"];
	["CreateAkceInput"]: ValueTypes["CreateAkceInput"];
	["AkceInput"]: ValueTypes["AkceInput"];
	["CreateAkceItemInput"]: ValueTypes["CreateAkceItemInput"];
	["AkceItemInput"]: ValueTypes["AkceItemInput"];
	["CreateAktualityInput"]: ValueTypes["CreateAktualityInput"];
	["AktualityInput"]: ValueTypes["AktualityInput"];
	["CreateDokumentyInput"]: ValueTypes["CreateDokumentyInput"];
	["DokumentyInput"]: ValueTypes["DokumentyInput"];
	["CreateGalerieDirInput"]: ValueTypes["CreateGalerieDirInput"];
	["GalerieDirInput"]: ValueTypes["GalerieDirInput"];
	["CreateGalerieFotoInput"]: ValueTypes["CreateGalerieFotoInput"];
	["GalerieFotoInput"]: ValueTypes["GalerieFotoInput"];
	["CreateNabidkaInput"]: ValueTypes["CreateNabidkaInput"];
	["NabidkaInput"]: ValueTypes["NabidkaInput"];
	["CreateNabidkaItemInput"]: ValueTypes["CreateNabidkaItemInput"];
	["NabidkaItemInput"]: ValueTypes["NabidkaItemInput"];
	["CreatePageInput"]: ValueTypes["CreatePageInput"];
	["PageInput"]: ValueTypes["PageInput"];
	["CreateParameterInput"]: ValueTypes["CreateParameterInput"];
	["ParameterInput"]: ValueTypes["ParameterInput"];
	["CreateParyInput"]: ValueTypes["CreateParyInput"];
	["ParyInput"]: ValueTypes["ParyInput"];
	["CreateParyNavrhInput"]: ValueTypes["CreateParyNavrhInput"];
	["ParyNavrhInput"]: ValueTypes["ParyNavrhInput"];
	["CreatePermissionInput"]: ValueTypes["CreatePermissionInput"];
	["PermissionInput"]: ValueTypes["PermissionInput"];
	["CreatePlatbyCategoryInput"]: ValueTypes["CreatePlatbyCategoryInput"];
	["PlatbyCategoryInput"]: ValueTypes["PlatbyCategoryInput"];
	["CreatePlatbyCategoryGroupInput"]: ValueTypes["CreatePlatbyCategoryGroupInput"];
	["PlatbyCategoryGroupInput"]: ValueTypes["PlatbyCategoryGroupInput"];
	["CreatePlatbyGroupInput"]: ValueTypes["CreatePlatbyGroupInput"];
	["PlatbyGroupInput"]: ValueTypes["PlatbyGroupInput"];
	["CreatePlatbyGroupSkupinaInput"]: ValueTypes["CreatePlatbyGroupSkupinaInput"];
	["PlatbyGroupSkupinaInput"]: ValueTypes["PlatbyGroupSkupinaInput"];
	["CreatePlatbyItemInput"]: ValueTypes["CreatePlatbyItemInput"];
	["PlatbyItemInput"]: ValueTypes["PlatbyItemInput"];
	["CreatePlatbyRawInput"]: ValueTypes["CreatePlatbyRawInput"];
	["PlatbyRawInput"]: ValueTypes["PlatbyRawInput"];
	["CreateRozpiInput"]: ValueTypes["CreateRozpiInput"];
	["RozpiInput"]: ValueTypes["RozpiInput"];
	["CreateRozpisItemInput"]: ValueTypes["CreateRozpisItemInput"];
	["RozpisItemInput"]: ValueTypes["RozpisItemInput"];
	["CreateSessionInput"]: ValueTypes["CreateSessionInput"];
	["SessionInput"]: ValueTypes["SessionInput"];
	["CreateSkupinyInput"]: ValueTypes["CreateSkupinyInput"];
	["SkupinyInput"]: ValueTypes["SkupinyInput"];
	["CreateUpozorneniInput"]: ValueTypes["CreateUpozorneniInput"];
	["UpozorneniInput"]: ValueTypes["UpozorneniInput"];
	["CreateUpozorneniSkupinyInput"]: ValueTypes["CreateUpozorneniSkupinyInput"];
	["UpozorneniSkupinyInput"]: ValueTypes["UpozorneniSkupinyInput"];
	["CreateUserInput"]: ValueTypes["CreateUserInput"];
	["UserInput"]: ValueTypes["UserInput"];
	["CreateUsersSkupinyInput"]: ValueTypes["CreateUsersSkupinyInput"];
	["UsersSkupinyInput"]: ValueTypes["UsersSkupinyInput"];
	["CreateVideoInput"]: ValueTypes["CreateVideoInput"];
	["VideoInput"]: ValueTypes["VideoInput"];
	["CreateVideoListInput"]: ValueTypes["CreateVideoListInput"];
	["VideoListInput"]: ValueTypes["VideoListInput"];
	["CreateVideoSourceInput"]: ValueTypes["CreateVideoSourceInput"];
	["VideoSourceInput"]: ValueTypes["VideoSourceInput"];
	["UpdateAkceByNodeIdInput"]: ValueTypes["UpdateAkceByNodeIdInput"];
	["AkcePatch"]: ValueTypes["AkcePatch"];
	["UpdateAkceInput"]: ValueTypes["UpdateAkceInput"];
	["UpdateAkceItemByNodeIdInput"]: ValueTypes["UpdateAkceItemByNodeIdInput"];
	["AkceItemPatch"]: ValueTypes["AkceItemPatch"];
	["UpdateAkceItemInput"]: ValueTypes["UpdateAkceItemInput"];
	["UpdateAktualityByNodeIdInput"]: ValueTypes["UpdateAktualityByNodeIdInput"];
	["AktualityPatch"]: ValueTypes["AktualityPatch"];
	["UpdateAktualityInput"]: ValueTypes["UpdateAktualityInput"];
	["UpdateDokumentyByNodeIdInput"]: ValueTypes["UpdateDokumentyByNodeIdInput"];
	["DokumentyPatch"]: ValueTypes["DokumentyPatch"];
	["UpdateDokumentyInput"]: ValueTypes["UpdateDokumentyInput"];
	["UpdateGalerieDirByNodeIdInput"]: ValueTypes["UpdateGalerieDirByNodeIdInput"];
	["GalerieDirPatch"]: ValueTypes["GalerieDirPatch"];
	["UpdateGalerieDirInput"]: ValueTypes["UpdateGalerieDirInput"];
	["UpdateGalerieFotoByNodeIdInput"]: ValueTypes["UpdateGalerieFotoByNodeIdInput"];
	["GalerieFotoPatch"]: ValueTypes["GalerieFotoPatch"];
	["UpdateGalerieFotoInput"]: ValueTypes["UpdateGalerieFotoInput"];
	["UpdateNabidkaByNodeIdInput"]: ValueTypes["UpdateNabidkaByNodeIdInput"];
	["NabidkaPatch"]: ValueTypes["NabidkaPatch"];
	["UpdateNabidkaInput"]: ValueTypes["UpdateNabidkaInput"];
	["UpdateNabidkaItemByNodeIdInput"]: ValueTypes["UpdateNabidkaItemByNodeIdInput"];
	["NabidkaItemPatch"]: ValueTypes["NabidkaItemPatch"];
	["UpdateNabidkaItemInput"]: ValueTypes["UpdateNabidkaItemInput"];
	["UpdatePageByNodeIdInput"]: ValueTypes["UpdatePageByNodeIdInput"];
	["PagePatch"]: ValueTypes["PagePatch"];
	["UpdatePageInput"]: ValueTypes["UpdatePageInput"];
	["UpdatePageByUrlInput"]: ValueTypes["UpdatePageByUrlInput"];
	["UpdateParameterByNodeIdInput"]: ValueTypes["UpdateParameterByNodeIdInput"];
	["ParameterPatch"]: ValueTypes["ParameterPatch"];
	["UpdateParameterInput"]: ValueTypes["UpdateParameterInput"];
	["UpdateParyByNodeIdInput"]: ValueTypes["UpdateParyByNodeIdInput"];
	["ParyPatch"]: ValueTypes["ParyPatch"];
	["UpdateParyInput"]: ValueTypes["UpdateParyInput"];
	["UpdateParyNavrhByNodeIdInput"]: ValueTypes["UpdateParyNavrhByNodeIdInput"];
	["ParyNavrhPatch"]: ValueTypes["ParyNavrhPatch"];
	["UpdateParyNavrhInput"]: ValueTypes["UpdateParyNavrhInput"];
	["UpdatePermissionByNodeIdInput"]: ValueTypes["UpdatePermissionByNodeIdInput"];
	["PermissionPatch"]: ValueTypes["PermissionPatch"];
	["UpdatePermissionInput"]: ValueTypes["UpdatePermissionInput"];
	["UpdatePlatbyCategoryByNodeIdInput"]: ValueTypes["UpdatePlatbyCategoryByNodeIdInput"];
	["PlatbyCategoryPatch"]: ValueTypes["PlatbyCategoryPatch"];
	["UpdatePlatbyCategoryInput"]: ValueTypes["UpdatePlatbyCategoryInput"];
	["UpdatePlatbyCategoryGroupByNodeIdInput"]: ValueTypes["UpdatePlatbyCategoryGroupByNodeIdInput"];
	["PlatbyCategoryGroupPatch"]: ValueTypes["PlatbyCategoryGroupPatch"];
	["UpdatePlatbyCategoryGroupInput"]: ValueTypes["UpdatePlatbyCategoryGroupInput"];
	["UpdatePlatbyGroupByNodeIdInput"]: ValueTypes["UpdatePlatbyGroupByNodeIdInput"];
	["PlatbyGroupPatch"]: ValueTypes["PlatbyGroupPatch"];
	["UpdatePlatbyGroupInput"]: ValueTypes["UpdatePlatbyGroupInput"];
	["UpdatePlatbyGroupSkupinaByNodeIdInput"]: ValueTypes["UpdatePlatbyGroupSkupinaByNodeIdInput"];
	["PlatbyGroupSkupinaPatch"]: ValueTypes["PlatbyGroupSkupinaPatch"];
	["UpdatePlatbyGroupSkupinaInput"]: ValueTypes["UpdatePlatbyGroupSkupinaInput"];
	["UpdatePlatbyItemByNodeIdInput"]: ValueTypes["UpdatePlatbyItemByNodeIdInput"];
	["PlatbyItemPatch"]: ValueTypes["PlatbyItemPatch"];
	["UpdatePlatbyItemInput"]: ValueTypes["UpdatePlatbyItemInput"];
	["UpdatePlatbyRawByNodeIdInput"]: ValueTypes["UpdatePlatbyRawByNodeIdInput"];
	["PlatbyRawPatch"]: ValueTypes["PlatbyRawPatch"];
	["UpdatePlatbyRawInput"]: ValueTypes["UpdatePlatbyRawInput"];
	["UpdateRozpiByNodeIdInput"]: ValueTypes["UpdateRozpiByNodeIdInput"];
	["RozpiPatch"]: ValueTypes["RozpiPatch"];
	["UpdateRozpiInput"]: ValueTypes["UpdateRozpiInput"];
	["UpdateRozpisItemByNodeIdInput"]: ValueTypes["UpdateRozpisItemByNodeIdInput"];
	["RozpisItemPatch"]: ValueTypes["RozpisItemPatch"];
	["UpdateRozpisItemInput"]: ValueTypes["UpdateRozpisItemInput"];
	["UpdateSessionByNodeIdInput"]: ValueTypes["UpdateSessionByNodeIdInput"];
	["SessionPatch"]: ValueTypes["SessionPatch"];
	["UpdateSessionInput"]: ValueTypes["UpdateSessionInput"];
	["UpdateSkupinyByNodeIdInput"]: ValueTypes["UpdateSkupinyByNodeIdInput"];
	["SkupinyPatch"]: ValueTypes["SkupinyPatch"];
	["UpdateSkupinyInput"]: ValueTypes["UpdateSkupinyInput"];
	["UpdateUpozorneniByNodeIdInput"]: ValueTypes["UpdateUpozorneniByNodeIdInput"];
	["UpozorneniPatch"]: ValueTypes["UpozorneniPatch"];
	["UpdateUpozorneniInput"]: ValueTypes["UpdateUpozorneniInput"];
	["UpdateUpozorneniSkupinyByNodeIdInput"]: ValueTypes["UpdateUpozorneniSkupinyByNodeIdInput"];
	["UpozorneniSkupinyPatch"]: ValueTypes["UpozorneniSkupinyPatch"];
	["UpdateUpozorneniSkupinyInput"]: ValueTypes["UpdateUpozorneniSkupinyInput"];
	["UpdateUserByNodeIdInput"]: ValueTypes["UpdateUserByNodeIdInput"];
	["UserPatch"]: ValueTypes["UserPatch"];
	["UpdateUserInput"]: ValueTypes["UpdateUserInput"];
	["UpdateUsersSkupinyByNodeIdInput"]: ValueTypes["UpdateUsersSkupinyByNodeIdInput"];
	["UsersSkupinyPatch"]: ValueTypes["UsersSkupinyPatch"];
	["UpdateUsersSkupinyInput"]: ValueTypes["UpdateUsersSkupinyInput"];
	["UpdateVideoByNodeIdInput"]: ValueTypes["UpdateVideoByNodeIdInput"];
	["VideoPatch"]: ValueTypes["VideoPatch"];
	["UpdateVideoInput"]: ValueTypes["UpdateVideoInput"];
	["UpdateVideoListByNodeIdInput"]: ValueTypes["UpdateVideoListByNodeIdInput"];
	["VideoListPatch"]: ValueTypes["VideoListPatch"];
	["UpdateVideoListInput"]: ValueTypes["UpdateVideoListInput"];
	["UpdateVideoSourceByNodeIdInput"]: ValueTypes["UpdateVideoSourceByNodeIdInput"];
	["VideoSourcePatch"]: ValueTypes["VideoSourcePatch"];
	["UpdateVideoSourceInput"]: ValueTypes["UpdateVideoSourceInput"];
	["DeleteAkceByNodeIdInput"]: ValueTypes["DeleteAkceByNodeIdInput"];
	["DeleteAkceInput"]: ValueTypes["DeleteAkceInput"];
	["DeleteAkceItemByNodeIdInput"]: ValueTypes["DeleteAkceItemByNodeIdInput"];
	["DeleteAkceItemInput"]: ValueTypes["DeleteAkceItemInput"];
	["DeleteAktualityByNodeIdInput"]: ValueTypes["DeleteAktualityByNodeIdInput"];
	["DeleteAktualityInput"]: ValueTypes["DeleteAktualityInput"];
	["DeleteDokumentyByNodeIdInput"]: ValueTypes["DeleteDokumentyByNodeIdInput"];
	["DeleteDokumentyInput"]: ValueTypes["DeleteDokumentyInput"];
	["DeleteGalerieDirByNodeIdInput"]: ValueTypes["DeleteGalerieDirByNodeIdInput"];
	["DeleteGalerieDirInput"]: ValueTypes["DeleteGalerieDirInput"];
	["DeleteGalerieFotoByNodeIdInput"]: ValueTypes["DeleteGalerieFotoByNodeIdInput"];
	["DeleteGalerieFotoInput"]: ValueTypes["DeleteGalerieFotoInput"];
	["DeleteNabidkaByNodeIdInput"]: ValueTypes["DeleteNabidkaByNodeIdInput"];
	["DeleteNabidkaInput"]: ValueTypes["DeleteNabidkaInput"];
	["DeleteNabidkaItemByNodeIdInput"]: ValueTypes["DeleteNabidkaItemByNodeIdInput"];
	["DeleteNabidkaItemInput"]: ValueTypes["DeleteNabidkaItemInput"];
	["DeleteParameterByNodeIdInput"]: ValueTypes["DeleteParameterByNodeIdInput"];
	["DeleteParameterInput"]: ValueTypes["DeleteParameterInput"];
	["DeleteParyByNodeIdInput"]: ValueTypes["DeleteParyByNodeIdInput"];
	["DeleteParyInput"]: ValueTypes["DeleteParyInput"];
	["DeleteParyNavrhByNodeIdInput"]: ValueTypes["DeleteParyNavrhByNodeIdInput"];
	["DeleteParyNavrhInput"]: ValueTypes["DeleteParyNavrhInput"];
	["DeletePermissionByNodeIdInput"]: ValueTypes["DeletePermissionByNodeIdInput"];
	["DeletePermissionInput"]: ValueTypes["DeletePermissionInput"];
	["DeletePlatbyCategoryByNodeIdInput"]: ValueTypes["DeletePlatbyCategoryByNodeIdInput"];
	["DeletePlatbyCategoryInput"]: ValueTypes["DeletePlatbyCategoryInput"];
	["DeletePlatbyCategoryGroupByNodeIdInput"]: ValueTypes["DeletePlatbyCategoryGroupByNodeIdInput"];
	["DeletePlatbyCategoryGroupInput"]: ValueTypes["DeletePlatbyCategoryGroupInput"];
	["DeletePlatbyGroupByNodeIdInput"]: ValueTypes["DeletePlatbyGroupByNodeIdInput"];
	["DeletePlatbyGroupInput"]: ValueTypes["DeletePlatbyGroupInput"];
	["DeletePlatbyGroupSkupinaByNodeIdInput"]: ValueTypes["DeletePlatbyGroupSkupinaByNodeIdInput"];
	["DeletePlatbyGroupSkupinaInput"]: ValueTypes["DeletePlatbyGroupSkupinaInput"];
	["DeletePlatbyItemByNodeIdInput"]: ValueTypes["DeletePlatbyItemByNodeIdInput"];
	["DeletePlatbyItemInput"]: ValueTypes["DeletePlatbyItemInput"];
	["DeletePlatbyRawByNodeIdInput"]: ValueTypes["DeletePlatbyRawByNodeIdInput"];
	["DeletePlatbyRawInput"]: ValueTypes["DeletePlatbyRawInput"];
	["DeleteRozpiByNodeIdInput"]: ValueTypes["DeleteRozpiByNodeIdInput"];
	["DeleteRozpiInput"]: ValueTypes["DeleteRozpiInput"];
	["DeleteRozpisItemByNodeIdInput"]: ValueTypes["DeleteRozpisItemByNodeIdInput"];
	["DeleteRozpisItemInput"]: ValueTypes["DeleteRozpisItemInput"];
	["DeleteSessionByNodeIdInput"]: ValueTypes["DeleteSessionByNodeIdInput"];
	["DeleteSessionInput"]: ValueTypes["DeleteSessionInput"];
	["DeleteSkupinyByNodeIdInput"]: ValueTypes["DeleteSkupinyByNodeIdInput"];
	["DeleteSkupinyInput"]: ValueTypes["DeleteSkupinyInput"];
	["DeleteUpozorneniByNodeIdInput"]: ValueTypes["DeleteUpozorneniByNodeIdInput"];
	["DeleteUpozorneniInput"]: ValueTypes["DeleteUpozorneniInput"];
	["DeleteUpozorneniSkupinyByNodeIdInput"]: ValueTypes["DeleteUpozorneniSkupinyByNodeIdInput"];
	["DeleteUpozorneniSkupinyInput"]: ValueTypes["DeleteUpozorneniSkupinyInput"];
	["DeleteUserByNodeIdInput"]: ValueTypes["DeleteUserByNodeIdInput"];
	["DeleteUserInput"]: ValueTypes["DeleteUserInput"];
	["DeleteUsersSkupinyByNodeIdInput"]: ValueTypes["DeleteUsersSkupinyByNodeIdInput"];
	["DeleteUsersSkupinyInput"]: ValueTypes["DeleteUsersSkupinyInput"];
	["DeleteVideoByNodeIdInput"]: ValueTypes["DeleteVideoByNodeIdInput"];
	["DeleteVideoInput"]: ValueTypes["DeleteVideoInput"];
	["DeleteVideoListByNodeIdInput"]: ValueTypes["DeleteVideoListByNodeIdInput"];
	["DeleteVideoListInput"]: ValueTypes["DeleteVideoListInput"];
	["DeleteVideoSourceByNodeIdInput"]: ValueTypes["DeleteVideoSourceByNodeIdInput"];
	["DeleteVideoSourceInput"]: ValueTypes["DeleteVideoSourceInput"];
	["LoginInput"]: ValueTypes["LoginInput"];
	["LogoutInput"]: ValueTypes["LogoutInput"];
	["ProspectFormDancerInput"]: ValueTypes["ProspectFormDancerInput"];
	["ProspectDatumInput"]: ValueTypes["ProspectDatumInput"];
	["UploadInput"]: ValueTypes["UploadInput"];
}