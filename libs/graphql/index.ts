/* DO NOT EDIT! This file is auto-generated by graphql-code-generator - see `codegen.yml` */
/* eslint-disable */
import { offlineExchange } from '@urql/exchange-graphcache';
import type { Resolver as GraphCacheResolver, UpdateResolver as GraphCacheUpdateResolver, OptimisticMutationResolver as GraphCacheOptimisticMutationResolver } from '@urql/exchange-graphcache';

export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /** A floating point number that requires more precision than IEEE 754 binary 64 */
  BigFloat: { input: any; output: any; }
  /**
   * A signed eight-byte integer. The upper big integer values are greater than the
   * max value for a JavaScript number. Therefore all big integers will be output as
   * strings and not numbers.
   */
  BigInt: { input: string; output: string; }
  /** A location in a connection that can be used for resuming pagination. */
  Cursor: { input: any; output: any; }
  /** The day, does not include a time. */
  Date: { input: string; output: string; }
  /**
   * A point in time as described by the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
   */
  Datetime: { input: string; output: string; }
  /** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
  JSON: { input: { [key: string]: any }; output: { [key: string]: any }; }
  /** A builtin object identifier type for a relation name */
  RegClass: { input: any; output: any; }
  /** A builtin object identifier type for a function name */
  RegProc: { input: any; output: any; }
  /** The exact time of day, does not include the date. May or may not have a timezone offset. */
  Time: { input: string; output: string; }
};

export type Akce = {
  __typename?: 'Akce';
  aDo: Maybe<Scalars['Date']['output']>;
  aDokumenty: Maybe<Scalars['String']['output']>;
  aId: Maybe<Scalars['BigInt']['output']>;
  aInfo: Maybe<Scalars['String']['output']>;
  aJmeno: Maybe<Scalars['String']['output']>;
  aKapacita: Maybe<Scalars['BigInt']['output']>;
  aKde: Maybe<Scalars['String']['output']>;
  aLock: Maybe<Scalars['Boolean']['output']>;
  aOd: Maybe<Scalars['Date']['output']>;
  aTimestamp: Maybe<Scalars['Datetime']['output']>;
  aVisible: Maybe<Scalars['Boolean']['output']>;
  /** Reads and enables pagination through a set of `AkceItem`. */
  akceItemsByAiIdRodic: AkceItemsConnection;
  enableNotes: Maybe<Scalars['Boolean']['output']>;
  isPublic: Maybe<Scalars['Boolean']['output']>;
  summary: Maybe<Scalars['String']['output']>;
};


export type AkceAkceItemsByAiIdRodicArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AkceItemsOrderBy>>;
};

/** An input for mutations affecting `Akce` */
export type AkceInput = {
  aDo?: InputMaybe<Scalars['Date']['input']>;
  aDokumenty?: InputMaybe<Scalars['String']['input']>;
  aId?: InputMaybe<Scalars['BigInt']['input']>;
  aInfo?: InputMaybe<Scalars['String']['input']>;
  aJmeno?: InputMaybe<Scalars['String']['input']>;
  aKapacita?: InputMaybe<Scalars['BigInt']['input']>;
  aKde?: InputMaybe<Scalars['String']['input']>;
  aLock?: InputMaybe<Scalars['Boolean']['input']>;
  aOd?: InputMaybe<Scalars['Date']['input']>;
  aTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
  aVisible?: InputMaybe<Scalars['Boolean']['input']>;
  enableNotes?: InputMaybe<Scalars['Boolean']['input']>;
  isPublic?: InputMaybe<Scalars['Boolean']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
};

export type AkceItem = {
  __typename?: 'AkceItem';
  aiId: Maybe<Scalars['BigInt']['output']>;
  aiIdRodic: Maybe<Scalars['BigInt']['output']>;
  aiRokNarozeni: Maybe<Scalars['Int']['output']>;
  aiUser: Maybe<Scalars['BigInt']['output']>;
  /** Reads a single `Akce` that is related to this `AkceItem`. */
  akceByAiIdRodic: Maybe<Akce>;
  notes: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `AkceItem`. */
  userByAiUser: Maybe<User>;
};

/** An input for mutations affecting `AkceItem` */
export type AkceItemInput = {
  aiId?: InputMaybe<Scalars['BigInt']['input']>;
  aiIdRodic?: InputMaybe<Scalars['BigInt']['input']>;
  aiRokNarozeni?: InputMaybe<Scalars['Int']['input']>;
  aiUser?: InputMaybe<Scalars['BigInt']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `AkceItem` values. */
export type AkceItemsConnection = {
  __typename?: 'AkceItemsConnection';
  /** A list of edges which contains the `AkceItem` and cursor to aid in pagination. */
  edges: Array<AkceItemsEdge>;
  /** A list of `AkceItem` objects. */
  nodes: Array<AkceItem>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AkceItem` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AkceItem` edge in the connection. */
export type AkceItemsEdge = {
  __typename?: 'AkceItemsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `AkceItem` at the end of the edge. */
  node: AkceItem;
};

/** Methods to use when ordering `AkceItem`. */
export type AkceItemsOrderBy =
  | 'NATURAL'
  | 'USER_BY_AI_USER__U_BAN_ASC'
  | 'USER_BY_AI_USER__U_BAN_DESC'
  | 'USER_BY_AI_USER__U_CONFIRMED_ASC'
  | 'USER_BY_AI_USER__U_CONFIRMED_DESC'
  | 'USER_BY_AI_USER__U_GROUP_ASC'
  | 'USER_BY_AI_USER__U_GROUP_DESC'
  | 'USER_BY_AI_USER__U_ID_ASC'
  | 'USER_BY_AI_USER__U_ID_DESC'
  | 'USER_BY_AI_USER__U_JMENO_ASC'
  | 'USER_BY_AI_USER__U_JMENO_DESC'
  | 'USER_BY_AI_USER__U_LOGIN_ASC'
  | 'USER_BY_AI_USER__U_LOGIN_DESC'
  | 'USER_BY_AI_USER__U_NAROZENI_ASC'
  | 'USER_BY_AI_USER__U_NAROZENI_DESC'
  | 'USER_BY_AI_USER__U_PRIJMENI_ASC'
  | 'USER_BY_AI_USER__U_PRIJMENI_DESC'
  | 'USER_BY_AI_USER__U_SKUPINA_ASC'
  | 'USER_BY_AI_USER__U_SKUPINA_DESC'
  | 'USER_BY_AI_USER__U_SYSTEM_ASC'
  | 'USER_BY_AI_USER__U_SYSTEM_DESC';

/** A connection to a list of `Akce` values. */
export type AkcesConnection = {
  __typename?: 'AkcesConnection';
  /** A list of edges which contains the `Akce` and cursor to aid in pagination. */
  edges: Array<AkcesEdge>;
  /** A list of `Akce` objects. */
  nodes: Array<Akce>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Akce` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Akce` edge in the connection. */
export type AkcesEdge = {
  __typename?: 'AkcesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Akce` at the end of the edge. */
  node: Akce;
};

/** Methods to use when ordering `Akce`. */
export type AkcesOrderBy =
  | 'AKCE_ITEMS_BY_AI_ID_RODIC__COUNT_ASC'
  | 'AKCE_ITEMS_BY_AI_ID_RODIC__COUNT_DESC'
  | 'NATURAL';

/** A connection to a list of `Aktuality` values. */
export type AktualitiesConnection = {
  __typename?: 'AktualitiesConnection';
  /** A list of edges which contains the `Aktuality` and cursor to aid in pagination. */
  edges: Array<AktualitiesEdge>;
  /** A list of `Aktuality` objects. */
  nodes: Array<Aktuality>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Aktuality` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Aktuality` edge in the connection. */
export type AktualitiesEdge = {
  __typename?: 'AktualitiesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Aktuality` at the end of the edge. */
  node: Aktuality;
};

/** Methods to use when ordering `Aktuality`. */
export type AktualitiesOrderBy =
  | 'AT_FOTO_MAIN_ASC'
  | 'AT_FOTO_MAIN_DESC'
  | 'AT_ID_ASC'
  | 'AT_ID_DESC'
  | 'AT_KDO_ASC'
  | 'AT_KDO_DESC'
  | 'AT_TIMESTAMP_ADD_ASC'
  | 'AT_TIMESTAMP_ADD_DESC'
  | 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_ID_ASC'
  | 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_ID_DESC'
  | 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_ID_RODIC_ASC'
  | 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_ID_RODIC_DESC'
  | 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_KDO_ASC'
  | 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_KDO_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TENANT_ID_ASC'
  | 'TENANT_ID_DESC'
  | 'USER_BY_AT_KDO__U_BAN_ASC'
  | 'USER_BY_AT_KDO__U_BAN_DESC'
  | 'USER_BY_AT_KDO__U_CONFIRMED_ASC'
  | 'USER_BY_AT_KDO__U_CONFIRMED_DESC'
  | 'USER_BY_AT_KDO__U_GROUP_ASC'
  | 'USER_BY_AT_KDO__U_GROUP_DESC'
  | 'USER_BY_AT_KDO__U_ID_ASC'
  | 'USER_BY_AT_KDO__U_ID_DESC'
  | 'USER_BY_AT_KDO__U_JMENO_ASC'
  | 'USER_BY_AT_KDO__U_JMENO_DESC'
  | 'USER_BY_AT_KDO__U_LOGIN_ASC'
  | 'USER_BY_AT_KDO__U_LOGIN_DESC'
  | 'USER_BY_AT_KDO__U_NAROZENI_ASC'
  | 'USER_BY_AT_KDO__U_NAROZENI_DESC'
  | 'USER_BY_AT_KDO__U_PRIJMENI_ASC'
  | 'USER_BY_AT_KDO__U_PRIJMENI_DESC'
  | 'USER_BY_AT_KDO__U_SKUPINA_ASC'
  | 'USER_BY_AT_KDO__U_SKUPINA_DESC'
  | 'USER_BY_AT_KDO__U_SYSTEM_ASC'
  | 'USER_BY_AT_KDO__U_SYSTEM_DESC';

export type Aktuality = {
  __typename?: 'Aktuality';
  atFoto: Maybe<Scalars['BigInt']['output']>;
  atFotoMain: Maybe<Scalars['BigInt']['output']>;
  atId: Scalars['BigInt']['output'];
  atJmeno: Scalars['String']['output'];
  atKat: Scalars['String']['output'];
  atKdo: Maybe<Scalars['BigInt']['output']>;
  atPreview: Scalars['String']['output'];
  atText: Scalars['String']['output'];
  atTimestamp: Maybe<Scalars['Datetime']['output']>;
  atTimestampAdd: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
  galerieFotoByAtFotoMain: Maybe<GalerieFoto>;
  id: Maybe<Scalars['BigInt']['output']>;
  tenantId: Scalars['BigInt']['output'];
  /** Reads a single `User` that is related to this `Aktuality`. */
  userByAtKdo: Maybe<User>;
};

/**
 * A condition to be used against `Aktuality` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type AktualityCondition = {
  /** Checks for equality with the object’s `atFotoMain` field. */
  atFotoMain?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `atId` field. */
  atId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `atKdo` field. */
  atKdo?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `atTimestampAdd` field. */
  atTimestampAdd?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `tenantId` field. */
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `Aktuality` */
export type AktualityInput = {
  atFoto?: InputMaybe<Scalars['BigInt']['input']>;
  atFotoMain?: InputMaybe<Scalars['BigInt']['input']>;
  atId?: InputMaybe<Scalars['BigInt']['input']>;
  atJmeno: Scalars['String']['input'];
  atKat?: InputMaybe<Scalars['String']['input']>;
  atKdo?: InputMaybe<Scalars['BigInt']['input']>;
  atPreview: Scalars['String']['input'];
  atText: Scalars['String']['input'];
  atTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
  atTimestampAdd?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Represents an update to a `Aktuality`. Fields that are set will be updated. */
export type AktualityPatch = {
  atFoto?: InputMaybe<Scalars['BigInt']['input']>;
  atFotoMain?: InputMaybe<Scalars['BigInt']['input']>;
  atId?: InputMaybe<Scalars['BigInt']['input']>;
  atJmeno?: InputMaybe<Scalars['String']['input']>;
  atKat?: InputMaybe<Scalars['String']['input']>;
  atKdo?: InputMaybe<Scalars['BigInt']['input']>;
  atPreview?: InputMaybe<Scalars['String']['input']>;
  atText?: InputMaybe<Scalars['String']['input']>;
  atTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
  atTimestampAdd?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

export type Attachment = {
  __typename?: 'Attachment';
  directory: Maybe<Scalars['String']['output']>;
  downloadUrl: Scalars['String']['output'];
  height: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `LocationAttachment`. */
  locationAttachmentsByObjectName: LocationAttachmentsConnection;
  objectName: Scalars['String']['output'];
  previewObjectName: Maybe<Scalars['String']['output']>;
  publicUrl: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `RoomAttachment`. */
  roomAttachmentsByObjectName: RoomAttachmentsConnection;
  /** Reads and enables pagination through a set of `TenantAttachment`. */
  tenantAttachmentsByObjectName: TenantAttachmentsConnection;
  thumbhash: Maybe<Scalars['String']['output']>;
  uploadUrl: Scalars['String']['output'];
  uploadedAt: Scalars['Datetime']['output'];
  uploadedBy: Maybe<Scalars['BigInt']['output']>;
  /** Reads a single `User` that is related to this `Attachment`. */
  userByUploadedBy: Maybe<User>;
  width: Maybe<Scalars['Int']['output']>;
};


export type AttachmentLocationAttachmentsByObjectNameArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LocationAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LocationAttachmentsOrderBy>>;
};


export type AttachmentRoomAttachmentsByObjectNameArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomAttachmentsOrderBy>>;
};


export type AttachmentTenantAttachmentsByObjectNameArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TenantAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TenantAttachmentsOrderBy>>;
};

/**
 * A condition to be used against `Attachment` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type AttachmentCondition = {
  /** Checks for equality with the object’s `directory` field. */
  directory?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `objectName` field. */
  objectName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `uploadedBy` field. */
  uploadedBy?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `String` values. */
export type AttachmentDirectoriesConnection = {
  __typename?: 'AttachmentDirectoriesConnection';
  /** A list of edges which contains the `String` and cursor to aid in pagination. */
  edges: Array<AttachmentDirectoryEdge>;
  /** A list of `String` objects. */
  nodes: Array<Maybe<Scalars['String']['output']>>;
  /** The count of *all* `String` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `String` edge in the connection. */
export type AttachmentDirectoryEdge = {
  __typename?: 'AttachmentDirectoryEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `String` at the end of the edge. */
  node: Maybe<Scalars['String']['output']>;
};

/** An input for mutations affecting `Attachment` */
export type AttachmentInput = {
  height?: InputMaybe<Scalars['Int']['input']>;
  objectName: Scalars['String']['input'];
  previewObjectName?: InputMaybe<Scalars['String']['input']>;
  thumbhash?: InputMaybe<Scalars['String']['input']>;
  uploadedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uploadedBy?: InputMaybe<Scalars['BigInt']['input']>;
  width?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `Attachment`. Fields that are set will be updated. */
export type AttachmentPatch = {
  height?: InputMaybe<Scalars['Int']['input']>;
  objectName?: InputMaybe<Scalars['String']['input']>;
  previewObjectName?: InputMaybe<Scalars['String']['input']>;
  thumbhash?: InputMaybe<Scalars['String']['input']>;
  uploadedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uploadedBy?: InputMaybe<Scalars['BigInt']['input']>;
  width?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `Attachment` values. */
export type AttachmentsConnection = {
  __typename?: 'AttachmentsConnection';
  /** A list of edges which contains the `Attachment` and cursor to aid in pagination. */
  edges: Array<AttachmentsEdge>;
  /** A list of `Attachment` objects. */
  nodes: Array<Attachment>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Attachment` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Attachment` edge in the connection. */
export type AttachmentsEdge = {
  __typename?: 'AttachmentsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Attachment` at the end of the edge. */
  node: Attachment;
};

/** Methods to use when ordering `Attachment`. */
export type AttachmentsOrderBy =
  | 'LOCATION_ATTACHMENTS_BY_OBJECT_NAME__COUNT_ASC'
  | 'LOCATION_ATTACHMENTS_BY_OBJECT_NAME__COUNT_DESC'
  | 'NATURAL'
  | 'OBJECT_NAME_ASC'
  | 'OBJECT_NAME_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'ROOM_ATTACHMENTS_BY_OBJECT_NAME__COUNT_ASC'
  | 'ROOM_ATTACHMENTS_BY_OBJECT_NAME__COUNT_DESC'
  | 'TENANT_ATTACHMENTS_BY_OBJECT_NAME__COUNT_ASC'
  | 'TENANT_ATTACHMENTS_BY_OBJECT_NAME__COUNT_DESC'
  | 'UPLOADED_BY_ASC'
  | 'UPLOADED_BY_DESC'
  | 'USER_BY_UPLOADED_BY__U_BAN_ASC'
  | 'USER_BY_UPLOADED_BY__U_BAN_DESC'
  | 'USER_BY_UPLOADED_BY__U_CONFIRMED_ASC'
  | 'USER_BY_UPLOADED_BY__U_CONFIRMED_DESC'
  | 'USER_BY_UPLOADED_BY__U_GROUP_ASC'
  | 'USER_BY_UPLOADED_BY__U_GROUP_DESC'
  | 'USER_BY_UPLOADED_BY__U_ID_ASC'
  | 'USER_BY_UPLOADED_BY__U_ID_DESC'
  | 'USER_BY_UPLOADED_BY__U_JMENO_ASC'
  | 'USER_BY_UPLOADED_BY__U_JMENO_DESC'
  | 'USER_BY_UPLOADED_BY__U_LOGIN_ASC'
  | 'USER_BY_UPLOADED_BY__U_LOGIN_DESC'
  | 'USER_BY_UPLOADED_BY__U_NAROZENI_ASC'
  | 'USER_BY_UPLOADED_BY__U_NAROZENI_DESC'
  | 'USER_BY_UPLOADED_BY__U_PRIJMENI_ASC'
  | 'USER_BY_UPLOADED_BY__U_PRIJMENI_DESC'
  | 'USER_BY_UPLOADED_BY__U_SKUPINA_ASC'
  | 'USER_BY_UPLOADED_BY__U_SKUPINA_DESC'
  | 'USER_BY_UPLOADED_BY__U_SYSTEM_ASC'
  | 'USER_BY_UPLOADED_BY__U_SYSTEM_DESC';

export type AttendeeCouple = {
  __typename?: 'AttendeeCouple';
  /** Reads a single `Couple` that is related to this `AttendeeCouple`. */
  couple: Maybe<Couple>;
  coupleId: Scalars['BigInt']['output'];
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['BigInt']['output'];
  /** Reads a single `AttendeeList` that is related to this `AttendeeCouple`. */
  list: Maybe<AttendeeList>;
  listId: Scalars['BigInt']['output'];
  /** Reads a single `Tenant` that is related to this `AttendeeCouple`. */
  tenant: Maybe<Tenant>;
  tenantId: Scalars['BigInt']['output'];
  updatedAt: Scalars['Datetime']['output'];
};

/**
 * A condition to be used against `AttendeeCouple` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type AttendeeCoupleCondition = {
  /** Checks for equality with the object’s `coupleId` field. */
  coupleId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `listId` field. */
  listId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `tenantId` field. */
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `AttendeeCouple` values. */
export type AttendeeCouplesConnection = {
  __typename?: 'AttendeeCouplesConnection';
  /** A list of edges which contains the `AttendeeCouple` and cursor to aid in pagination. */
  edges: Array<AttendeeCouplesEdge>;
  /** A list of `AttendeeCouple` objects. */
  nodes: Array<AttendeeCouple>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AttendeeCouple` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AttendeeCouple` edge in the connection. */
export type AttendeeCouplesEdge = {
  __typename?: 'AttendeeCouplesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `AttendeeCouple` at the end of the edge. */
  node: AttendeeCouple;
};

/** Methods to use when ordering `AttendeeCouple`. */
export type AttendeeCouplesOrderBy =
  | 'ATTENDEE_LIST_BY_LIST_ID__ID_ASC'
  | 'ATTENDEE_LIST_BY_LIST_ID__ID_DESC'
  | 'ATTENDEE_LIST_BY_LIST_ID__TENANT_ID_ASC'
  | 'ATTENDEE_LIST_BY_LIST_ID__TENANT_ID_DESC'
  | 'COUPLE_BY_COUPLE_ID__FOLLOWER_ID_ASC'
  | 'COUPLE_BY_COUPLE_ID__FOLLOWER_ID_DESC'
  | 'COUPLE_BY_COUPLE_ID__ID_ASC'
  | 'COUPLE_BY_COUPLE_ID__ID_DESC'
  | 'COUPLE_BY_COUPLE_ID__LEADER_ID_ASC'
  | 'COUPLE_BY_COUPLE_ID__LEADER_ID_DESC'
  | 'COUPLE_BY_COUPLE_ID__TENANT_ID_ASC'
  | 'COUPLE_BY_COUPLE_ID__TENANT_ID_DESC'
  | 'COUPLE_ID_ASC'
  | 'COUPLE_ID_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'LIST_ID_ASC'
  | 'LIST_ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TENANT_BY_TENANT_ID__ID_ASC'
  | 'TENANT_BY_TENANT_ID__ID_DESC'
  | 'TENANT_ID_ASC'
  | 'TENANT_ID_DESC';

export type AttendeeExternal = {
  __typename?: 'AttendeeExternal';
  birthNumber: Maybe<Scalars['String']['output']>;
  confirmedAt: Maybe<Scalars['Datetime']['output']>;
  confirmedBy: Maybe<Scalars['BigInt']['output']>;
  createdAt: Scalars['Datetime']['output'];
  email: Scalars['String']['output'];
  /** Reads a single `Event` that is related to this `AttendeeExternal`. */
  event: Maybe<Event>;
  eventId: Scalars['BigInt']['output'];
  firstName: Scalars['String']['output'];
  guardianName: Scalars['String']['output'];
  id: Scalars['BigInt']['output'];
  lastName: Scalars['String']['output'];
  managedBy: Maybe<Scalars['BigInt']['output']>;
  notes: Scalars['String']['output'];
  phone: Scalars['String']['output'];
  tenantId: Scalars['BigInt']['output'];
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `User` that is related to this `AttendeeExternal`. */
  userByConfirmedBy: Maybe<User>;
  /** Reads a single `User` that is related to this `AttendeeExternal`. */
  userByManagedBy: Maybe<User>;
};

/**
 * A condition to be used against `AttendeeExternal` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type AttendeeExternalCondition = {
  /** Checks for equality with the object’s `confirmedBy` field. */
  confirmedBy?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `eventId` field. */
  eventId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `managedBy` field. */
  managedBy?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `AttendeeExternal` */
export type AttendeeExternalInput = {
  birthNumber?: InputMaybe<Scalars['String']['input']>;
  confirmedAt?: InputMaybe<Scalars['Datetime']['input']>;
  confirmedBy?: InputMaybe<Scalars['BigInt']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  email: Scalars['String']['input'];
  eventId: Scalars['BigInt']['input'];
  firstName: Scalars['String']['input'];
  guardianName?: InputMaybe<Scalars['String']['input']>;
  lastName: Scalars['String']['input'];
  managedBy?: InputMaybe<Scalars['BigInt']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  phone: Scalars['String']['input'];
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `AttendeeExternal`. Fields that are set will be updated. */
export type AttendeeExternalPatch = {
  birthNumber?: InputMaybe<Scalars['String']['input']>;
  confirmedAt?: InputMaybe<Scalars['Datetime']['input']>;
  confirmedBy?: InputMaybe<Scalars['BigInt']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  eventId?: InputMaybe<Scalars['BigInt']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  guardianName?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  managedBy?: InputMaybe<Scalars['BigInt']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `AttendeeExternal` values. */
export type AttendeeExternalsConnection = {
  __typename?: 'AttendeeExternalsConnection';
  /** A list of edges which contains the `AttendeeExternal` and cursor to aid in pagination. */
  edges: Array<AttendeeExternalsEdge>;
  /** A list of `AttendeeExternal` objects. */
  nodes: Array<AttendeeExternal>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AttendeeExternal` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AttendeeExternal` edge in the connection. */
export type AttendeeExternalsEdge = {
  __typename?: 'AttendeeExternalsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `AttendeeExternal` at the end of the edge. */
  node: AttendeeExternal;
};

/** Methods to use when ordering `AttendeeExternal`. */
export type AttendeeExternalsOrderBy =
  | 'CONFIRMED_BY_ASC'
  | 'CONFIRMED_BY_DESC'
  | 'EVENT_BY_EVENT_ID__ID_ASC'
  | 'EVENT_BY_EVENT_ID__ID_DESC'
  | 'EVENT_BY_EVENT_ID__IS_VISIBLE_ASC'
  | 'EVENT_BY_EVENT_ID__IS_VISIBLE_DESC'
  | 'EVENT_BY_EVENT_ID__SINCE_ASC'
  | 'EVENT_BY_EVENT_ID__SINCE_DESC'
  | 'EVENT_ID_ASC'
  | 'EVENT_ID_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'MANAGED_BY_ASC'
  | 'MANAGED_BY_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'USER_BY_CONFIRMED_BY__U_BAN_ASC'
  | 'USER_BY_CONFIRMED_BY__U_BAN_DESC'
  | 'USER_BY_CONFIRMED_BY__U_CONFIRMED_ASC'
  | 'USER_BY_CONFIRMED_BY__U_CONFIRMED_DESC'
  | 'USER_BY_CONFIRMED_BY__U_GROUP_ASC'
  | 'USER_BY_CONFIRMED_BY__U_GROUP_DESC'
  | 'USER_BY_CONFIRMED_BY__U_ID_ASC'
  | 'USER_BY_CONFIRMED_BY__U_ID_DESC'
  | 'USER_BY_CONFIRMED_BY__U_JMENO_ASC'
  | 'USER_BY_CONFIRMED_BY__U_JMENO_DESC'
  | 'USER_BY_CONFIRMED_BY__U_LOGIN_ASC'
  | 'USER_BY_CONFIRMED_BY__U_LOGIN_DESC'
  | 'USER_BY_CONFIRMED_BY__U_NAROZENI_ASC'
  | 'USER_BY_CONFIRMED_BY__U_NAROZENI_DESC'
  | 'USER_BY_CONFIRMED_BY__U_PRIJMENI_ASC'
  | 'USER_BY_CONFIRMED_BY__U_PRIJMENI_DESC'
  | 'USER_BY_CONFIRMED_BY__U_SKUPINA_ASC'
  | 'USER_BY_CONFIRMED_BY__U_SKUPINA_DESC'
  | 'USER_BY_CONFIRMED_BY__U_SYSTEM_ASC'
  | 'USER_BY_CONFIRMED_BY__U_SYSTEM_DESC'
  | 'USER_BY_MANAGED_BY__U_BAN_ASC'
  | 'USER_BY_MANAGED_BY__U_BAN_DESC'
  | 'USER_BY_MANAGED_BY__U_CONFIRMED_ASC'
  | 'USER_BY_MANAGED_BY__U_CONFIRMED_DESC'
  | 'USER_BY_MANAGED_BY__U_GROUP_ASC'
  | 'USER_BY_MANAGED_BY__U_GROUP_DESC'
  | 'USER_BY_MANAGED_BY__U_ID_ASC'
  | 'USER_BY_MANAGED_BY__U_ID_DESC'
  | 'USER_BY_MANAGED_BY__U_JMENO_ASC'
  | 'USER_BY_MANAGED_BY__U_JMENO_DESC'
  | 'USER_BY_MANAGED_BY__U_LOGIN_ASC'
  | 'USER_BY_MANAGED_BY__U_LOGIN_DESC'
  | 'USER_BY_MANAGED_BY__U_NAROZENI_ASC'
  | 'USER_BY_MANAGED_BY__U_NAROZENI_DESC'
  | 'USER_BY_MANAGED_BY__U_PRIJMENI_ASC'
  | 'USER_BY_MANAGED_BY__U_PRIJMENI_DESC'
  | 'USER_BY_MANAGED_BY__U_SKUPINA_ASC'
  | 'USER_BY_MANAGED_BY__U_SKUPINA_DESC'
  | 'USER_BY_MANAGED_BY__U_SYSTEM_ASC'
  | 'USER_BY_MANAGED_BY__U_SYSTEM_DESC';

export type AttendeeList = {
  __typename?: 'AttendeeList';
  /** Reads and enables pagination through a set of `AttendeeCouple`. */
  attendeeCouplesByListId: AttendeeCouplesConnection;
  /** Reads and enables pagination through a set of `AttendeePerson`. */
  attendeePeopleByListId: AttendeePeopleConnection;
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['BigInt']['output'];
  /** Reads a single `Tenant` that is related to this `AttendeeList`. */
  tenant: Maybe<Tenant>;
  tenantId: Scalars['BigInt']['output'];
  updatedAt: Scalars['Datetime']['output'];
};


export type AttendeeListAttendeeCouplesByListIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AttendeeCoupleCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AttendeeCouplesOrderBy>>;
};


export type AttendeeListAttendeePeopleByListIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AttendeePersonCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AttendeePeopleOrderBy>>;
};

/**
 * A condition to be used against `AttendeeList` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type AttendeeListCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `tenantId` field. */
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `AttendeeList` values. */
export type AttendeeListsConnection = {
  __typename?: 'AttendeeListsConnection';
  /** A list of edges which contains the `AttendeeList` and cursor to aid in pagination. */
  edges: Array<AttendeeListsEdge>;
  /** A list of `AttendeeList` objects. */
  nodes: Array<AttendeeList>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AttendeeList` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AttendeeList` edge in the connection. */
export type AttendeeListsEdge = {
  __typename?: 'AttendeeListsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `AttendeeList` at the end of the edge. */
  node: AttendeeList;
};

/** Methods to use when ordering `AttendeeList`. */
export type AttendeeListsOrderBy =
  | 'ATTENDEE_COUPLES_BY_LIST_ID__COUNT_ASC'
  | 'ATTENDEE_COUPLES_BY_LIST_ID__COUNT_DESC'
  | 'ATTENDEE_PEOPLE_BY_LIST_ID__COUNT_ASC'
  | 'ATTENDEE_PEOPLE_BY_LIST_ID__COUNT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TENANT_BY_TENANT_ID__ID_ASC'
  | 'TENANT_BY_TENANT_ID__ID_DESC'
  | 'TENANT_ID_ASC'
  | 'TENANT_ID_DESC';

/** A connection to a list of `AttendeePerson` values. */
export type AttendeePeopleConnection = {
  __typename?: 'AttendeePeopleConnection';
  /** A list of edges which contains the `AttendeePerson` and cursor to aid in pagination. */
  edges: Array<AttendeePeopleEdge>;
  /** A list of `AttendeePerson` objects. */
  nodes: Array<AttendeePerson>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AttendeePerson` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AttendeePerson` edge in the connection. */
export type AttendeePeopleEdge = {
  __typename?: 'AttendeePeopleEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `AttendeePerson` at the end of the edge. */
  node: AttendeePerson;
};

/** Methods to use when ordering `AttendeePerson`. */
export type AttendeePeopleOrderBy =
  | 'ATTENDEE_LIST_BY_LIST_ID__ID_ASC'
  | 'ATTENDEE_LIST_BY_LIST_ID__ID_DESC'
  | 'ATTENDEE_LIST_BY_LIST_ID__TENANT_ID_ASC'
  | 'ATTENDEE_LIST_BY_LIST_ID__TENANT_ID_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'LIST_ID_ASC'
  | 'LIST_ID_DESC'
  | 'NATURAL'
  | 'PERSON_BY_PERSON_ID__ID_ASC'
  | 'PERSON_BY_PERSON_ID__ID_DESC'
  | 'PERSON_ID_ASC'
  | 'PERSON_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TENANT_BY_TENANT_ID__ID_ASC'
  | 'TENANT_BY_TENANT_ID__ID_DESC'
  | 'TENANT_ID_ASC'
  | 'TENANT_ID_DESC';

export type AttendeePerson = {
  __typename?: 'AttendeePerson';
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['BigInt']['output'];
  /** Reads a single `AttendeeList` that is related to this `AttendeePerson`. */
  list: Maybe<AttendeeList>;
  listId: Scalars['BigInt']['output'];
  /** Reads a single `Person` that is related to this `AttendeePerson`. */
  person: Maybe<Person>;
  personId: Scalars['BigInt']['output'];
  /** Reads a single `Tenant` that is related to this `AttendeePerson`. */
  tenant: Maybe<Tenant>;
  tenantId: Scalars['BigInt']['output'];
  updatedAt: Scalars['Datetime']['output'];
};

/**
 * A condition to be used against `AttendeePerson` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type AttendeePersonCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `listId` field. */
  listId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `personId` field. */
  personId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `tenantId` field. */
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

export type AttendeeUser = {
  __typename?: 'AttendeeUser';
  birthYear: Scalars['Int']['output'];
  /** Reads a single `Event` that is related to this `AttendeeUser`. */
  event: Maybe<Event>;
  eventId: Scalars['BigInt']['output'];
  id: Scalars['BigInt']['output'];
  notes: Scalars['String']['output'];
  tenantId: Scalars['BigInt']['output'];
  /** Reads a single `User` that is related to this `AttendeeUser`. */
  user: Maybe<User>;
  userId: Scalars['BigInt']['output'];
};

/**
 * A condition to be used against `AttendeeUser` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type AttendeeUserCondition = {
  /** Checks for equality with the object’s `eventId` field. */
  eventId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `AttendeeUser` */
export type AttendeeUserInput = {
  birthYear: Scalars['Int']['input'];
  eventId: Scalars['BigInt']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
  userId: Scalars['BigInt']['input'];
};

/** Represents an update to a `AttendeeUser`. Fields that are set will be updated. */
export type AttendeeUserPatch = {
  birthYear?: InputMaybe<Scalars['Int']['input']>;
  eventId?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `AttendeeUser` values. */
export type AttendeeUsersConnection = {
  __typename?: 'AttendeeUsersConnection';
  /** A list of edges which contains the `AttendeeUser` and cursor to aid in pagination. */
  edges: Array<AttendeeUsersEdge>;
  /** A list of `AttendeeUser` objects. */
  nodes: Array<AttendeeUser>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AttendeeUser` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AttendeeUser` edge in the connection. */
export type AttendeeUsersEdge = {
  __typename?: 'AttendeeUsersEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `AttendeeUser` at the end of the edge. */
  node: AttendeeUser;
};

/** Methods to use when ordering `AttendeeUser`. */
export type AttendeeUsersOrderBy =
  | 'EVENT_BY_EVENT_ID__ID_ASC'
  | 'EVENT_BY_EVENT_ID__ID_DESC'
  | 'EVENT_BY_EVENT_ID__IS_VISIBLE_ASC'
  | 'EVENT_BY_EVENT_ID__IS_VISIBLE_DESC'
  | 'EVENT_BY_EVENT_ID__SINCE_ASC'
  | 'EVENT_BY_EVENT_ID__SINCE_DESC'
  | 'EVENT_ID_ASC'
  | 'EVENT_ID_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'USER_BY_USER_ID__U_BAN_ASC'
  | 'USER_BY_USER_ID__U_BAN_DESC'
  | 'USER_BY_USER_ID__U_CONFIRMED_ASC'
  | 'USER_BY_USER_ID__U_CONFIRMED_DESC'
  | 'USER_BY_USER_ID__U_GROUP_ASC'
  | 'USER_BY_USER_ID__U_GROUP_DESC'
  | 'USER_BY_USER_ID__U_ID_ASC'
  | 'USER_BY_USER_ID__U_ID_DESC'
  | 'USER_BY_USER_ID__U_JMENO_ASC'
  | 'USER_BY_USER_ID__U_JMENO_DESC'
  | 'USER_BY_USER_ID__U_LOGIN_ASC'
  | 'USER_BY_USER_ID__U_LOGIN_DESC'
  | 'USER_BY_USER_ID__U_NAROZENI_ASC'
  | 'USER_BY_USER_ID__U_NAROZENI_DESC'
  | 'USER_BY_USER_ID__U_PRIJMENI_ASC'
  | 'USER_BY_USER_ID__U_PRIJMENI_DESC'
  | 'USER_BY_USER_ID__U_SKUPINA_ASC'
  | 'USER_BY_USER_ID__U_SKUPINA_DESC'
  | 'USER_BY_USER_ID__U_SYSTEM_ASC'
  | 'USER_BY_USER_ID__U_SYSTEM_DESC'
  | 'USER_ID_ASC'
  | 'USER_ID_DESC';

/** All input for the `bookLesson` mutation. */
export type BookLessonInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  lessonId: Scalars['BigInt']['input'];
};

/** The output of our `bookLesson` mutation. */
export type BookLessonPayload = {
  __typename?: 'BookLessonPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  rozpisItems: Maybe<Array<RozpisItem>>;
};

/** All input for the `cancelLesson` mutation. */
export type CancelLessonInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  lessonId: Scalars['BigInt']['input'];
};

/** The output of our `cancelLesson` mutation. */
export type CancelLessonPayload = {
  __typename?: 'CancelLessonPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  rozpisItems: Maybe<Array<RozpisItem>>;
};

/** All input for the `cancelParticipation` mutation. */
export type CancelParticipationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  eventId: Scalars['BigInt']['input'];
};

/** The output of our `cancelParticipation` mutation. */
export type CancelParticipationPayload = {
  __typename?: 'CancelParticipationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `changePassword` mutation. */
export type ChangePasswordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  newPass: Scalars['String']['input'];
  oldPass: Scalars['String']['input'];
};

/** The output of our `changePassword` mutation. */
export type ChangePasswordPayload = {
  __typename?: 'ChangePasswordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type CohortGroup = {
  __typename?: 'CohortGroup';
  description: Scalars['String']['output'];
  id: Scalars['BigInt']['output'];
  isPublic: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  ordering: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `Skupiny`. */
  skupiniesByCohortGroup: SkupiniesConnection;
  tenant: Maybe<Scalars['BigInt']['output']>;
  /** Reads a single `Tenant` that is related to this `CohortGroup`. */
  tenantByTenant: Maybe<Tenant>;
  tenantId: Scalars['BigInt']['output'];
};


export type CohortGroupSkupiniesByCohortGroupArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SkupinyCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SkupiniesOrderBy>>;
};

/**
 * A condition to be used against `CohortGroup` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type CohortGroupCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `isPublic` field. */
  isPublic?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `ordering` field. */
  ordering?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `tenant` field. */
  tenant?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `CohortGroup` */
export type CohortGroupInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  isPublic?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  ordering?: InputMaybe<Scalars['Int']['input']>;
  tenant?: InputMaybe<Scalars['BigInt']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Represents an update to a `CohortGroup`. Fields that are set will be updated. */
export type CohortGroupPatch = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  isPublic?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ordering?: InputMaybe<Scalars['Int']['input']>;
  tenant?: InputMaybe<Scalars['BigInt']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `CohortGroup` values. */
export type CohortGroupsConnection = {
  __typename?: 'CohortGroupsConnection';
  /** A list of edges which contains the `CohortGroup` and cursor to aid in pagination. */
  edges: Array<CohortGroupsEdge>;
  /** A list of `CohortGroup` objects. */
  nodes: Array<CohortGroup>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CohortGroup` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `CohortGroup` edge in the connection. */
export type CohortGroupsEdge = {
  __typename?: 'CohortGroupsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `CohortGroup` at the end of the edge. */
  node: CohortGroup;
};

/** Methods to use when ordering `CohortGroup`. */
export type CohortGroupsOrderBy =
  | 'ID_ASC'
  | 'ID_DESC'
  | 'IS_PUBLIC_ASC'
  | 'IS_PUBLIC_DESC'
  | 'NATURAL'
  | 'ORDERING_ASC'
  | 'ORDERING_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SKUPINIES_BY_COHORT_GROUP__COUNT_ASC'
  | 'SKUPINIES_BY_COHORT_GROUP__COUNT_DESC'
  | 'TENANT_ASC'
  | 'TENANT_BY_TENANT__ID_ASC'
  | 'TENANT_BY_TENANT__ID_DESC'
  | 'TENANT_DESC';

/** All input for the `confirmUser` mutation. */
export type ConfirmUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  cohort: Scalars['BigInt']['input'];
  grp: Scalars['BigInt']['input'];
  id: Scalars['BigInt']['input'];
};

/** The output of our `confirmUser` mutation. */
export type ConfirmUserPayload = {
  __typename?: 'ConfirmUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type Couple = {
  __typename?: 'Couple';
  /** Reads and enables pagination through a set of `AttendeeCouple`. */
  attendeeCouples: AttendeeCouplesConnection;
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Person` that is related to this `Couple`. */
  follower: Maybe<Person>;
  followerId: Scalars['BigInt']['output'];
  id: Scalars['BigInt']['output'];
  /** Reads a single `Person` that is related to this `Couple`. */
  leader: Maybe<Person>;
  leaderId: Scalars['BigInt']['output'];
  since: Scalars['Datetime']['output'];
  /** Reads a single `Tenant` that is related to this `Couple`. */
  tenant: Maybe<Tenant>;
  tenantId: Scalars['BigInt']['output'];
  until: Scalars['Datetime']['output'];
  updatedAt: Scalars['Datetime']['output'];
};


export type CoupleAttendeeCouplesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AttendeeCoupleCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AttendeeCouplesOrderBy>>;
};

/** A condition to be used against `Couple` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CoupleCondition = {
  /** Checks for equality with the object’s `followerId` field. */
  followerId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `leaderId` field. */
  leaderId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `tenantId` field. */
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `Couple` values. */
export type CouplesConnection = {
  __typename?: 'CouplesConnection';
  /** A list of edges which contains the `Couple` and cursor to aid in pagination. */
  edges: Array<CouplesEdge>;
  /** A list of `Couple` objects. */
  nodes: Array<Couple>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Couple` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Couple` edge in the connection. */
export type CouplesEdge = {
  __typename?: 'CouplesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Couple` at the end of the edge. */
  node: Couple;
};

/** Methods to use when ordering `Couple`. */
export type CouplesOrderBy =
  | 'ATTENDEE_COUPLES_BY_COUPLE_ID__COUNT_ASC'
  | 'ATTENDEE_COUPLES_BY_COUPLE_ID__COUNT_DESC'
  | 'FOLLOWER_ID_ASC'
  | 'FOLLOWER_ID_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'LEADER_ID_ASC'
  | 'LEADER_ID_DESC'
  | 'NATURAL'
  | 'PERSON_BY_FOLLOWER_ID__ID_ASC'
  | 'PERSON_BY_FOLLOWER_ID__ID_DESC'
  | 'PERSON_BY_LEADER_ID__ID_ASC'
  | 'PERSON_BY_LEADER_ID__ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TENANT_BY_TENANT_ID__ID_ASC'
  | 'TENANT_BY_TENANT_ID__ID_DESC'
  | 'TENANT_ID_ASC'
  | 'TENANT_ID_DESC';

/** All input for the create `Akce` mutation. */
export type CreateAkceInput = {
  /** The `Akce` to be created by this mutation. */
  akce: AkceInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** All input for the create `AkceItem` mutation. */
export type CreateAkceItemInput = {
  /** The `AkceItem` to be created by this mutation. */
  akceItem: AkceItemInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `AkceItem` mutation. */
export type CreateAkceItemPayload = {
  __typename?: 'CreateAkceItemPayload';
  /** Reads a single `Akce` that is related to this `AkceItem`. */
  akceByAiIdRodic: Maybe<Akce>;
  /** The `AkceItem` that was created by this mutation. */
  akceItem: Maybe<AkceItem>;
  /** An edge for our `AkceItem`. May be used by Relay 1. */
  akceItemEdge: Maybe<AkceItemsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `AkceItem`. */
  userByAiUser: Maybe<User>;
};


/** The output of our create `AkceItem` mutation. */
export type CreateAkceItemPayloadAkceItemEdgeArgs = {
  orderBy?: InputMaybe<Array<AkceItemsOrderBy>>;
};

/** The output of our create `Akce` mutation. */
export type CreateAkcePayload = {
  __typename?: 'CreateAkcePayload';
  /** The `Akce` that was created by this mutation. */
  akce: Maybe<Akce>;
  /** An edge for our `Akce`. May be used by Relay 1. */
  akceEdge: Maybe<AkcesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Akce` mutation. */
export type CreateAkcePayloadAkceEdgeArgs = {
  orderBy?: InputMaybe<Array<AkcesOrderBy>>;
};

/** All input for the create `Aktuality` mutation. */
export type CreateAktualityInput = {
  /** The `Aktuality` to be created by this mutation. */
  aktuality: AktualityInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `Aktuality` mutation. */
export type CreateAktualityPayload = {
  __typename?: 'CreateAktualityPayload';
  /** The `Aktuality` that was created by this mutation. */
  aktuality: Maybe<Aktuality>;
  /** An edge for our `Aktuality`. May be used by Relay 1. */
  aktualityEdge: Maybe<AktualitiesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
  galerieFotoByAtFotoMain: Maybe<GalerieFoto>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Aktuality`. */
  userByAtKdo: Maybe<User>;
};


/** The output of our create `Aktuality` mutation. */
export type CreateAktualityPayloadAktualityEdgeArgs = {
  orderBy?: InputMaybe<Array<AktualitiesOrderBy>>;
};

/** All input for the create `Attachment` mutation. */
export type CreateAttachmentInput = {
  /** The `Attachment` to be created by this mutation. */
  attachment: AttachmentInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `Attachment` mutation. */
export type CreateAttachmentPayload = {
  __typename?: 'CreateAttachmentPayload';
  /** The `Attachment` that was created by this mutation. */
  attachment: Maybe<Attachment>;
  /** An edge for our `Attachment`. May be used by Relay 1. */
  attachmentEdge: Maybe<AttachmentsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Attachment`. */
  userByUploadedBy: Maybe<User>;
};


/** The output of our create `Attachment` mutation. */
export type CreateAttachmentPayloadAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<AttachmentsOrderBy>>;
};

/** All input for the create `AttendeeExternal` mutation. */
export type CreateAttendeeExternalInput = {
  /** The `AttendeeExternal` to be created by this mutation. */
  attendeeExternal: AttendeeExternalInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `AttendeeExternal` mutation. */
export type CreateAttendeeExternalPayload = {
  __typename?: 'CreateAttendeeExternalPayload';
  /** The `AttendeeExternal` that was created by this mutation. */
  attendeeExternal: Maybe<AttendeeExternal>;
  /** An edge for our `AttendeeExternal`. May be used by Relay 1. */
  attendeeExternalEdge: Maybe<AttendeeExternalsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Event` that is related to this `AttendeeExternal`. */
  event: Maybe<Event>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `AttendeeExternal`. */
  userByConfirmedBy: Maybe<User>;
  /** Reads a single `User` that is related to this `AttendeeExternal`. */
  userByManagedBy: Maybe<User>;
};


/** The output of our create `AttendeeExternal` mutation. */
export type CreateAttendeeExternalPayloadAttendeeExternalEdgeArgs = {
  orderBy?: InputMaybe<Array<AttendeeExternalsOrderBy>>;
};

/** All input for the create `AttendeeUser` mutation. */
export type CreateAttendeeUserInput = {
  /** The `AttendeeUser` to be created by this mutation. */
  attendeeUser: AttendeeUserInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `AttendeeUser` mutation. */
export type CreateAttendeeUserPayload = {
  __typename?: 'CreateAttendeeUserPayload';
  /** The `AttendeeUser` that was created by this mutation. */
  attendeeUser: Maybe<AttendeeUser>;
  /** An edge for our `AttendeeUser`. May be used by Relay 1. */
  attendeeUserEdge: Maybe<AttendeeUsersEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Event` that is related to this `AttendeeUser`. */
  event: Maybe<Event>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `AttendeeUser`. */
  user: Maybe<User>;
};


/** The output of our create `AttendeeUser` mutation. */
export type CreateAttendeeUserPayloadAttendeeUserEdgeArgs = {
  orderBy?: InputMaybe<Array<AttendeeUsersOrderBy>>;
};

/** All input for the create `CohortGroup` mutation. */
export type CreateCohortGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `CohortGroup` to be created by this mutation. */
  cohortGroup: CohortGroupInput;
};

/** The output of our create `CohortGroup` mutation. */
export type CreateCohortGroupPayload = {
  __typename?: 'CreateCohortGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `CohortGroup` that was created by this mutation. */
  cohortGroup: Maybe<CohortGroup>;
  /** An edge for our `CohortGroup`. May be used by Relay 1. */
  cohortGroupEdge: Maybe<CohortGroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `CohortGroup`. */
  tenantByTenant: Maybe<Tenant>;
};


/** The output of our create `CohortGroup` mutation. */
export type CreateCohortGroupPayloadCohortGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<CohortGroupsOrderBy>>;
};

/** All input for the `createCouple` mutation. */
export type CreateCoupleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  man: Scalars['BigInt']['input'];
  woman: Scalars['BigInt']['input'];
};

/** The output of our `createCouple` mutation. */
export type CreateCouplePayload = {
  __typename?: 'CreateCouplePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  paries: Maybe<Array<Pary>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `Dokumenty` mutation. */
export type CreateDokumentyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Dokumenty` to be created by this mutation. */
  dokumenty: DokumentyInput;
};

/** The output of our create `Dokumenty` mutation. */
export type CreateDokumentyPayload = {
  __typename?: 'CreateDokumentyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Dokumenty` that was created by this mutation. */
  dokumenty: Maybe<Dokumenty>;
  /** An edge for our `Dokumenty`. May be used by Relay 1. */
  dokumentyEdge: Maybe<DokumentiesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Dokumenty`. */
  userByDKdo: Maybe<User>;
};


/** The output of our create `Dokumenty` mutation. */
export type CreateDokumentyPayloadDokumentyEdgeArgs = {
  orderBy?: InputMaybe<Array<DokumentiesOrderBy>>;
};

/** All input for the create `Event` mutation. */
export type CreateEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Event` to be created by this mutation. */
  event: EventInput;
};

/** The output of our create `Event` mutation. */
export type CreateEventPayload = {
  __typename?: 'CreateEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Event` that was created by this mutation. */
  event: Maybe<Event>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge: Maybe<EventsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Event` mutation. */
export type CreateEventPayloadEventEdgeArgs = {
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};

/** All input for the create `FormResponse` mutation. */
export type CreateFormResponseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `FormResponse` to be created by this mutation. */
  formResponse: FormResponseInput;
};

/** The output of our create `FormResponse` mutation. */
export type CreateFormResponsePayload = {
  __typename?: 'CreateFormResponsePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `FormResponse` that was created by this mutation. */
  formResponse: Maybe<FormResponse>;
  /** An edge for our `FormResponse`. May be used by Relay 1. */
  formResponseEdge: Maybe<FormResponsesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `FormResponse` mutation. */
export type CreateFormResponsePayloadFormResponseEdgeArgs = {
  orderBy?: InputMaybe<Array<FormResponsesOrderBy>>;
};

/** All input for the create `GalerieDir` mutation. */
export type CreateGalerieDirInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `GalerieDir` to be created by this mutation. */
  galerieDir: GalerieDirInput;
};

/** The output of our create `GalerieDir` mutation. */
export type CreateGalerieDirPayload = {
  __typename?: 'CreateGalerieDirPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `GalerieDir` that was created by this mutation. */
  galerieDir: Maybe<GalerieDir>;
  /** An edge for our `GalerieDir`. May be used by Relay 1. */
  galerieDirEdge: Maybe<GalerieDirsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `GalerieDir` mutation. */
export type CreateGalerieDirPayloadGalerieDirEdgeArgs = {
  orderBy?: InputMaybe<Array<GalerieDirsOrderBy>>;
};

/** All input for the create `GalerieFoto` mutation. */
export type CreateGalerieFotoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `GalerieFoto` to be created by this mutation. */
  galerieFoto: GalerieFotoInput;
};

/** The output of our create `GalerieFoto` mutation. */
export type CreateGalerieFotoPayload = {
  __typename?: 'CreateGalerieFotoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
  galerieDirByGfIdRodic: Maybe<GalerieDir>;
  /** The `GalerieFoto` that was created by this mutation. */
  galerieFoto: Maybe<GalerieFoto>;
  /** An edge for our `GalerieFoto`. May be used by Relay 1. */
  galerieFotoEdge: Maybe<GalerieFotosEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `GalerieFoto`. */
  userByGfKdo: Maybe<User>;
};


/** The output of our create `GalerieFoto` mutation. */
export type CreateGalerieFotoPayloadGalerieFotoEdgeArgs = {
  orderBy?: InputMaybe<Array<GalerieFotosOrderBy>>;
};

/** All input for the create `LocationAttachment` mutation. */
export type CreateLocationAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `LocationAttachment` to be created by this mutation. */
  locationAttachment: LocationAttachmentInput;
};

/** The output of our create `LocationAttachment` mutation. */
export type CreateLocationAttachmentPayload = {
  __typename?: 'CreateLocationAttachmentPayload';
  /** Reads a single `Attachment` that is related to this `LocationAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Location` that is related to this `LocationAttachment`. */
  location: Maybe<Location>;
  /** The `LocationAttachment` that was created by this mutation. */
  locationAttachment: Maybe<LocationAttachment>;
  /** An edge for our `LocationAttachment`. May be used by Relay 1. */
  locationAttachmentEdge: Maybe<LocationAttachmentsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `LocationAttachment` mutation. */
export type CreateLocationAttachmentPayloadLocationAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<LocationAttachmentsOrderBy>>;
};

/** All input for the create `Location` mutation. */
export type CreateLocationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Location` to be created by this mutation. */
  location: LocationInput;
};

/** The output of our create `Location` mutation. */
export type CreateLocationPayload = {
  __typename?: 'CreateLocationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Location` that was created by this mutation. */
  location: Maybe<Location>;
  /** An edge for our `Location`. May be used by Relay 1. */
  locationEdge: Maybe<LocationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Location` mutation. */
export type CreateLocationPayloadLocationEdgeArgs = {
  orderBy?: InputMaybe<Array<LocationsOrderBy>>;
};

/** All input for the create `Nabidka` mutation. */
export type CreateNabidkaInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Nabidka` to be created by this mutation. */
  nabidka: NabidkaInput;
};

/** All input for the create `NabidkaItem` mutation. */
export type CreateNabidkaItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `NabidkaItem` to be created by this mutation. */
  nabidkaItem: NabidkaItemInput;
};

/** The output of our create `NabidkaItem` mutation. */
export type CreateNabidkaItemPayload = {
  __typename?: 'CreateNabidkaItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Nabidka` that is related to this `NabidkaItem`. */
  nabidkaByNiIdRodic: Maybe<Nabidka>;
  /** The `NabidkaItem` that was created by this mutation. */
  nabidkaItem: Maybe<NabidkaItem>;
  /** An edge for our `NabidkaItem`. May be used by Relay 1. */
  nabidkaItemEdge: Maybe<NabidkaItemsEdge>;
  /** Reads a single `Pary` that is related to this `NabidkaItem`. */
  paryByNiPartner: Maybe<Pary>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `NabidkaItem` mutation. */
export type CreateNabidkaItemPayloadNabidkaItemEdgeArgs = {
  orderBy?: InputMaybe<Array<NabidkaItemsOrderBy>>;
};

/** The output of our create `Nabidka` mutation. */
export type CreateNabidkaPayload = {
  __typename?: 'CreateNabidkaPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Nabidka` that was created by this mutation. */
  nabidka: Maybe<Nabidka>;
  /** An edge for our `Nabidka`. May be used by Relay 1. */
  nabidkaEdge: Maybe<NabidkasEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Nabidka`. */
  userByNTrener: Maybe<User>;
};


/** The output of our create `Nabidka` mutation. */
export type CreateNabidkaPayloadNabidkaEdgeArgs = {
  orderBy?: InputMaybe<Array<NabidkasOrderBy>>;
};

/** All input for the create `Page` mutation. */
export type CreatePageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Page` to be created by this mutation. */
  page: PageInput;
};

/** The output of our create `Page` mutation. */
export type CreatePagePayload = {
  __typename?: 'CreatePagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Page` that was created by this mutation. */
  page: Maybe<Page>;
  /** An edge for our `Page`. May be used by Relay 1. */
  pageEdge: Maybe<PagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Page` mutation. */
export type CreatePagePayloadPageEdgeArgs = {
  orderBy?: InputMaybe<Array<PagesOrderBy>>;
};

/** All input for the create `Parameter` mutation. */
export type CreateParameterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Parameter` to be created by this mutation. */
  parameter: ParameterInput;
};

/** The output of our create `Parameter` mutation. */
export type CreateParameterPayload = {
  __typename?: 'CreateParameterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Parameter` that was created by this mutation. */
  parameter: Maybe<Parameter>;
  /** An edge for our `Parameter`. May be used by Relay 1. */
  parameterEdge: Maybe<ParametersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Parameter` mutation. */
export type CreateParameterPayloadParameterEdgeArgs = {
  orderBy?: InputMaybe<Array<ParametersOrderBy>>;
};

/** All input for the `createParticipationExternal` mutation. */
export type CreateParticipationExternalInput = {
  birthNumber: Scalars['String']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  eventId: Scalars['BigInt']['input'];
  firstName: Scalars['String']['input'];
  guardianName: Scalars['String']['input'];
  lastName: Scalars['String']['input'];
  notes: Scalars['String']['input'];
  phone: Scalars['String']['input'];
};

/** The output of our `createParticipationExternal` mutation. */
export type CreateParticipationExternalPayload = {
  __typename?: 'CreateParticipationExternalPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `createParticipation` mutation. */
export type CreateParticipationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  eventId: Scalars['BigInt']['input'];
  myNotes: Scalars['String']['input'];
  yearOfBirth: Scalars['Int']['input'];
};

/** The output of our `createParticipation` mutation. */
export type CreateParticipationPayload = {
  __typename?: 'CreateParticipationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `Pary` mutation. */
export type CreateParyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Pary` to be created by this mutation. */
  pary: ParyInput;
};

/** All input for the create `ParyNavrh` mutation. */
export type CreateParyNavrhInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `ParyNavrh` to be created by this mutation. */
  paryNavrh: ParyNavrhInput;
};

/** The output of our create `ParyNavrh` mutation. */
export type CreateParyNavrhPayload = {
  __typename?: 'CreateParyNavrhPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `ParyNavrh` that was created by this mutation. */
  paryNavrh: Maybe<ParyNavrh>;
  /** An edge for our `ParyNavrh`. May be used by Relay 1. */
  paryNavrhEdge: Maybe<ParyNavrhsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnNavrhl: Maybe<User>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnPartnerka: Maybe<User>;
};


/** The output of our create `ParyNavrh` mutation. */
export type CreateParyNavrhPayloadParyNavrhEdgeArgs = {
  orderBy?: InputMaybe<Array<ParyNavrhsOrderBy>>;
};

/** The output of our create `Pary` mutation. */
export type CreateParyPayload = {
  __typename?: 'CreateParyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Pary` that was created by this mutation. */
  pary: Maybe<Pary>;
  /** An edge for our `Pary`. May be used by Relay 1. */
  paryEdge: Maybe<PariesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartnerka: Maybe<User>;
};


/** The output of our create `Pary` mutation. */
export type CreateParyPayloadParyEdgeArgs = {
  orderBy?: InputMaybe<Array<PariesOrderBy>>;
};

/** All input for the create `Permission` mutation. */
export type CreatePermissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Permission` to be created by this mutation. */
  permission: PermissionInput;
};

/** The output of our create `Permission` mutation. */
export type CreatePermissionPayload = {
  __typename?: 'CreatePermissionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Permission` that was created by this mutation. */
  permission: Maybe<Permission>;
  /** An edge for our `Permission`. May be used by Relay 1. */
  permissionEdge: Maybe<PermissionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Permission` mutation. */
export type CreatePermissionPayloadPermissionEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
};

/** All input for the create `Person` mutation. */
export type CreatePersonInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Person` to be created by this mutation. */
  person: PersonInput;
};

/** The output of our create `Person` mutation. */
export type CreatePersonPayload = {
  __typename?: 'CreatePersonPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Person` that was created by this mutation. */
  person: Maybe<Person>;
  /** An edge for our `Person`. May be used by Relay 1. */
  personEdge: Maybe<PeopleEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Person` mutation. */
export type CreatePersonPayloadPersonEdgeArgs = {
  orderBy?: InputMaybe<Array<PeopleOrderBy>>;
};

/** All input for the create `PlatbyCategoryGroup` mutation. */
export type CreatePlatbyCategoryGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `PlatbyCategoryGroup` to be created by this mutation. */
  platbyCategoryGroup: PlatbyCategoryGroupInput;
};

/** The output of our create `PlatbyCategoryGroup` mutation. */
export type CreatePlatbyCategoryGroupPayload = {
  __typename?: 'CreatePlatbyCategoryGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyCategoryGroup`. */
  platbyCategoryByPcgIdCategory: Maybe<PlatbyCategory>;
  /** The `PlatbyCategoryGroup` that was created by this mutation. */
  platbyCategoryGroup: Maybe<PlatbyCategoryGroup>;
  /** An edge for our `PlatbyCategoryGroup`. May be used by Relay 1. */
  platbyCategoryGroupEdge: Maybe<PlatbyCategoryGroupsEdge>;
  /** Reads a single `PlatbyGroup` that is related to this `PlatbyCategoryGroup`. */
  platbyGroupByPcgIdGroup: Maybe<PlatbyGroup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `PlatbyCategoryGroup` mutation. */
export type CreatePlatbyCategoryGroupPayloadPlatbyCategoryGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyCategoryGroupsOrderBy>>;
};

/** All input for the create `PlatbyCategory` mutation. */
export type CreatePlatbyCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `PlatbyCategory` to be created by this mutation. */
  platbyCategory: PlatbyCategoryInput;
};

/** The output of our create `PlatbyCategory` mutation. */
export type CreatePlatbyCategoryPayload = {
  __typename?: 'CreatePlatbyCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `PlatbyCategory` that was created by this mutation. */
  platbyCategory: Maybe<PlatbyCategory>;
  /** An edge for our `PlatbyCategory`. May be used by Relay 1. */
  platbyCategoryEdge: Maybe<PlatbyCategoriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `PlatbyCategory` mutation. */
export type CreatePlatbyCategoryPayloadPlatbyCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyCategoriesOrderBy>>;
};

/** All input for the create `PlatbyGroup` mutation. */
export type CreatePlatbyGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `PlatbyGroup` to be created by this mutation. */
  platbyGroup: PlatbyGroupInput;
};

/** The output of our create `PlatbyGroup` mutation. */
export type CreatePlatbyGroupPayload = {
  __typename?: 'CreatePlatbyGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `PlatbyGroup` that was created by this mutation. */
  platbyGroup: Maybe<PlatbyGroup>;
  /** An edge for our `PlatbyGroup`. May be used by Relay 1. */
  platbyGroupEdge: Maybe<PlatbyGroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `PlatbyGroup` mutation. */
export type CreatePlatbyGroupPayloadPlatbyGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyGroupsOrderBy>>;
};

/** All input for the create `PlatbyGroupSkupina` mutation. */
export type CreatePlatbyGroupSkupinaInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `PlatbyGroupSkupina` to be created by this mutation. */
  platbyGroupSkupina: PlatbyGroupSkupinaInput;
};

/** The output of our create `PlatbyGroupSkupina` mutation. */
export type CreatePlatbyGroupSkupinaPayload = {
  __typename?: 'CreatePlatbyGroupSkupinaPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `PlatbyGroup` that is related to this `PlatbyGroupSkupina`. */
  platbyGroupByPgsIdGroup: Maybe<PlatbyGroup>;
  /** The `PlatbyGroupSkupina` that was created by this mutation. */
  platbyGroupSkupina: Maybe<PlatbyGroupSkupina>;
  /** An edge for our `PlatbyGroupSkupina`. May be used by Relay 1. */
  platbyGroupSkupinaEdge: Maybe<PlatbyGroupSkupinasEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `PlatbyGroupSkupina`. */
  skupinyByPgsIdSkupina: Maybe<Skupiny>;
};


/** The output of our create `PlatbyGroupSkupina` mutation. */
export type CreatePlatbyGroupSkupinaPayloadPlatbyGroupSkupinaEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyGroupSkupinasOrderBy>>;
};

/** All input for the create `PlatbyItem` mutation. */
export type CreatePlatbyItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `PlatbyItem` to be created by this mutation. */
  platbyItem: PlatbyItemInput;
};

/** The output of our create `PlatbyItem` mutation. */
export type CreatePlatbyItemPayload = {
  __typename?: 'CreatePlatbyItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
  platbyCategoryByPiIdCategory: Maybe<PlatbyCategory>;
  /** The `PlatbyItem` that was created by this mutation. */
  platbyItem: Maybe<PlatbyItem>;
  /** An edge for our `PlatbyItem`. May be used by Relay 1. */
  platbyItemEdge: Maybe<PlatbyItemsEdge>;
  /** Reads a single `PlatbyRaw` that is related to this `PlatbyItem`. */
  platbyRawByPiIdRaw: Maybe<PlatbyRaw>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `PlatbyItem`. */
  userByPiIdUser: Maybe<User>;
};


/** The output of our create `PlatbyItem` mutation. */
export type CreatePlatbyItemPayloadPlatbyItemEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyItemsOrderBy>>;
};

/** All input for the create `PlatbyRaw` mutation. */
export type CreatePlatbyRawInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `PlatbyRaw` to be created by this mutation. */
  platbyRaw: PlatbyRawInput;
};

/** The output of our create `PlatbyRaw` mutation. */
export type CreatePlatbyRawPayload = {
  __typename?: 'CreatePlatbyRawPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `PlatbyRaw` that was created by this mutation. */
  platbyRaw: Maybe<PlatbyRaw>;
  /** An edge for our `PlatbyRaw`. May be used by Relay 1. */
  platbyRawEdge: Maybe<PlatbyRawsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `PlatbyRaw` mutation. */
export type CreatePlatbyRawPayloadPlatbyRawEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyRawsOrderBy>>;
};

/** All input for the create `RoomAttachment` mutation. */
export type CreateRoomAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `RoomAttachment` to be created by this mutation. */
  roomAttachment: RoomAttachmentInput;
};

/** The output of our create `RoomAttachment` mutation. */
export type CreateRoomAttachmentPayload = {
  __typename?: 'CreateRoomAttachmentPayload';
  /** Reads a single `Attachment` that is related to this `RoomAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Room` that is related to this `RoomAttachment`. */
  room: Maybe<Room>;
  /** The `RoomAttachment` that was created by this mutation. */
  roomAttachment: Maybe<RoomAttachment>;
  /** An edge for our `RoomAttachment`. May be used by Relay 1. */
  roomAttachmentEdge: Maybe<RoomAttachmentsEdge>;
};


/** The output of our create `RoomAttachment` mutation. */
export type CreateRoomAttachmentPayloadRoomAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<RoomAttachmentsOrderBy>>;
};

/** All input for the create `Room` mutation. */
export type CreateRoomInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Room` to be created by this mutation. */
  room: RoomInput;
};

/** The output of our create `Room` mutation. */
export type CreateRoomPayload = {
  __typename?: 'CreateRoomPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Location` that is related to this `Room`. */
  locationByLocation: Maybe<Location>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Room` that was created by this mutation. */
  room: Maybe<Room>;
  /** An edge for our `Room`. May be used by Relay 1. */
  roomEdge: Maybe<RoomsEdge>;
};


/** The output of our create `Room` mutation. */
export type CreateRoomPayloadRoomEdgeArgs = {
  orderBy?: InputMaybe<Array<RoomsOrderBy>>;
};

/** All input for the create `Rozpi` mutation. */
export type CreateRozpiInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Rozpi` to be created by this mutation. */
  rozpi: RozpiInput;
};

/** The output of our create `Rozpi` mutation. */
export type CreateRozpiPayload = {
  __typename?: 'CreateRozpiPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Rozpi` that was created by this mutation. */
  rozpi: Maybe<Rozpi>;
  /** An edge for our `Rozpi`. May be used by Relay 1. */
  rozpiEdge: Maybe<RozpisEdge>;
  /** Reads a single `User` that is related to this `Rozpi`. */
  userByRTrener: Maybe<User>;
};


/** The output of our create `Rozpi` mutation. */
export type CreateRozpiPayloadRozpiEdgeArgs = {
  orderBy?: InputMaybe<Array<RozpisOrderBy>>;
};

/** All input for the create `RozpisItem` mutation. */
export type CreateRozpisItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `RozpisItem` to be created by this mutation. */
  rozpisItem: RozpisItemInput;
};

/** The output of our create `RozpisItem` mutation. */
export type CreateRozpisItemPayload = {
  __typename?: 'CreateRozpisItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Pary` that is related to this `RozpisItem`. */
  paryByRiPartner: Maybe<Pary>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Rozpi` that is related to this `RozpisItem`. */
  rozpiByRiIdRodic: Maybe<Rozpi>;
  /** The `RozpisItem` that was created by this mutation. */
  rozpisItem: Maybe<RozpisItem>;
  /** An edge for our `RozpisItem`. May be used by Relay 1. */
  rozpisItemEdge: Maybe<RozpisItemsEdge>;
};


/** The output of our create `RozpisItem` mutation. */
export type CreateRozpisItemPayloadRozpisItemEdgeArgs = {
  orderBy?: InputMaybe<Array<RozpisItemsOrderBy>>;
};

/** All input for the create `Skupiny` mutation. */
export type CreateSkupinyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Skupiny` to be created by this mutation. */
  skupiny: SkupinyInput;
};

/** The output of our create `Skupiny` mutation. */
export type CreateSkupinyPayload = {
  __typename?: 'CreateSkupinyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `CohortGroup` that is related to this `Skupiny`. */
  cohortGroupByCohortGroup: Maybe<CohortGroup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Skupiny` that was created by this mutation. */
  skupiny: Maybe<Skupiny>;
  /** An edge for our `Skupiny`. May be used by Relay 1. */
  skupinyEdge: Maybe<SkupiniesEdge>;
};


/** The output of our create `Skupiny` mutation. */
export type CreateSkupinyPayloadSkupinyEdgeArgs = {
  orderBy?: InputMaybe<Array<SkupiniesOrderBy>>;
};

/** All input for the create `TenantAttachment` mutation. */
export type CreateTenantAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TenantAttachment` to be created by this mutation. */
  tenantAttachment: TenantAttachmentInput;
};

/** The output of our create `TenantAttachment` mutation. */
export type CreateTenantAttachmentPayload = {
  __typename?: 'CreateTenantAttachmentPayload';
  /** Reads a single `Attachment` that is related to this `TenantAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `TenantAttachment`. */
  tenant: Maybe<Tenant>;
  /** The `TenantAttachment` that was created by this mutation. */
  tenantAttachment: Maybe<TenantAttachment>;
  /** An edge for our `TenantAttachment`. May be used by Relay 1. */
  tenantAttachmentEdge: Maybe<TenantAttachmentsEdge>;
};


/** The output of our create `TenantAttachment` mutation. */
export type CreateTenantAttachmentPayloadTenantAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<TenantAttachmentsOrderBy>>;
};

/** All input for the create `Tenant` mutation. */
export type CreateTenantInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Tenant` to be created by this mutation. */
  tenant: TenantInput;
};

/** All input for the create `TenantLocation` mutation. */
export type CreateTenantLocationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TenantLocation` to be created by this mutation. */
  tenantLocation: TenantLocationInput;
};

/** The output of our create `TenantLocation` mutation. */
export type CreateTenantLocationPayload = {
  __typename?: 'CreateTenantLocationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Location` that is related to this `TenantLocation`. */
  location: Maybe<Location>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `TenantLocation`. */
  tenant: Maybe<Tenant>;
  /** The `TenantLocation` that was created by this mutation. */
  tenantLocation: Maybe<TenantLocation>;
  /** An edge for our `TenantLocation`. May be used by Relay 1. */
  tenantLocationEdge: Maybe<TenantLocationsEdge>;
};


/** The output of our create `TenantLocation` mutation. */
export type CreateTenantLocationPayloadTenantLocationEdgeArgs = {
  orderBy?: InputMaybe<Array<TenantLocationsOrderBy>>;
};

/** The output of our create `Tenant` mutation. */
export type CreateTenantPayload = {
  __typename?: 'CreateTenantPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Tenant` that was created by this mutation. */
  tenant: Maybe<Tenant>;
  /** An edge for our `Tenant`. May be used by Relay 1. */
  tenantEdge: Maybe<TenantsEdge>;
};


/** The output of our create `Tenant` mutation. */
export type CreateTenantPayloadTenantEdgeArgs = {
  orderBy?: InputMaybe<Array<TenantsOrderBy>>;
};

/** All input for the create `TenantPerson` mutation. */
export type CreateTenantPersonInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TenantPerson` to be created by this mutation. */
  tenantPerson: TenantPersonInput;
};

/** The output of our create `TenantPerson` mutation. */
export type CreateTenantPersonPayload = {
  __typename?: 'CreateTenantPersonPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Person` that is related to this `TenantPerson`. */
  person: Maybe<Person>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `TenantPerson`. */
  tenant: Maybe<Tenant>;
  /** The `TenantPerson` that was created by this mutation. */
  tenantPerson: Maybe<TenantPerson>;
  /** An edge for our `TenantPerson`. May be used by Relay 1. */
  tenantPersonEdge: Maybe<TenantPeopleEdge>;
};


/** The output of our create `TenantPerson` mutation. */
export type CreateTenantPersonPayloadTenantPersonEdgeArgs = {
  orderBy?: InputMaybe<Array<TenantPeopleOrderBy>>;
};

/** All input for the create `Upozorneni` mutation. */
export type CreateUpozorneniInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Upozorneni` to be created by this mutation. */
  upozorneni: UpozorneniInput;
};

/** The output of our create `Upozorneni` mutation. */
export type CreateUpozorneniPayload = {
  __typename?: 'CreateUpozorneniPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Upozorneni` that was created by this mutation. */
  upozorneni: Maybe<Upozorneni>;
  /** An edge for our `Upozorneni`. May be used by Relay 1. */
  upozorneniEdge: Maybe<UpozornenisEdge>;
  /** Reads a single `User` that is related to this `Upozorneni`. */
  userByUpKdo: Maybe<User>;
};


/** The output of our create `Upozorneni` mutation. */
export type CreateUpozorneniPayloadUpozorneniEdgeArgs = {
  orderBy?: InputMaybe<Array<UpozornenisOrderBy>>;
};

/** All input for the create `UpozorneniSkupiny` mutation. */
export type CreateUpozorneniSkupinyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `UpozorneniSkupiny` to be created by this mutation. */
  upozorneniSkupiny: UpozorneniSkupinyInput;
};

/** The output of our create `UpozorneniSkupiny` mutation. */
export type CreateUpozorneniSkupinyPayload = {
  __typename?: 'CreateUpozorneniSkupinyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
  skupinyByUpsIdSkupina: Maybe<Skupiny>;
  /** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
  upozorneniByUpsIdRodic: Maybe<Upozorneni>;
  /** The `UpozorneniSkupiny` that was created by this mutation. */
  upozorneniSkupiny: Maybe<UpozorneniSkupiny>;
  /** An edge for our `UpozorneniSkupiny`. May be used by Relay 1. */
  upozorneniSkupinyEdge: Maybe<UpozorneniSkupiniesEdge>;
};


/** The output of our create `UpozorneniSkupiny` mutation. */
export type CreateUpozorneniSkupinyPayloadUpozorneniSkupinyEdgeArgs = {
  orderBy?: InputMaybe<Array<UpozorneniSkupiniesOrderBy>>;
};

/** All input for the create `User` mutation. */
export type CreateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `User` to be created by this mutation. */
  user: UserInput;
};

/** The output of our create `User` mutation. */
export type CreateUserPayload = {
  __typename?: 'CreateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Permission` that is related to this `User`. */
  permissionByUGroup: Maybe<Permission>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `User`. */
  skupinyByUSkupina: Maybe<Skupiny>;
  /** The `User` that was created by this mutation. */
  user: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge: Maybe<UsersEdge>;
};


/** The output of our create `User` mutation. */
export type CreateUserPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

export type CrmCohort =
  | 'CONTACT_ME_LATER'
  | 'DANCER'
  | 'FREE_LESSON'
  | 'HOBBYIST'
  | 'SHOWDANCE';

/** A `BigInt` edge in the connection. */
export type CurrentCoupleIdEdge = {
  __typename?: 'CurrentCoupleIdEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `BigInt` at the end of the edge. */
  node: Maybe<Scalars['BigInt']['output']>;
};

/** A connection to a list of `BigInt` values. */
export type CurrentCoupleIdsConnection = {
  __typename?: 'CurrentCoupleIdsConnection';
  /** A list of edges which contains the `BigInt` and cursor to aid in pagination. */
  edges: Array<CurrentCoupleIdEdge>;
  /** A list of `BigInt` objects. */
  nodes: Array<Maybe<Scalars['BigInt']['output']>>;
  /** The count of *all* `BigInt` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** All input for the `deleteAktuality` mutation. */
export type DeleteAktualityInput = {
  atId: Scalars['BigInt']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our delete `Aktuality` mutation. */
export type DeleteAktualityPayload = {
  __typename?: 'DeleteAktualityPayload';
  /** The `Aktuality` that was deleted by this mutation. */
  aktuality: Maybe<Aktuality>;
  /** An edge for our `Aktuality`. May be used by Relay 1. */
  aktualityEdge: Maybe<AktualitiesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedAktualityNodeId: Maybe<Scalars['ID']['output']>;
  /** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
  galerieFotoByAtFotoMain: Maybe<GalerieFoto>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Aktuality`. */
  userByAtKdo: Maybe<User>;
};


/** The output of our delete `Aktuality` mutation. */
export type DeleteAktualityPayloadAktualityEdgeArgs = {
  orderBy?: InputMaybe<Array<AktualitiesOrderBy>>;
};

/** All input for the `deleteAttachment` mutation. */
export type DeleteAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  objectName: Scalars['String']['input'];
};

/** The output of our delete `Attachment` mutation. */
export type DeleteAttachmentPayload = {
  __typename?: 'DeleteAttachmentPayload';
  /** The `Attachment` that was deleted by this mutation. */
  attachment: Maybe<Attachment>;
  /** An edge for our `Attachment`. May be used by Relay 1. */
  attachmentEdge: Maybe<AttachmentsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedAttachmentNodeId: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Attachment`. */
  userByUploadedBy: Maybe<User>;
};


/** The output of our delete `Attachment` mutation. */
export type DeleteAttachmentPayloadAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<AttachmentsOrderBy>>;
};

/** All input for the `deleteAttendeeExternal` mutation. */
export type DeleteAttendeeExternalInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `AttendeeExternal` mutation. */
export type DeleteAttendeeExternalPayload = {
  __typename?: 'DeleteAttendeeExternalPayload';
  /** The `AttendeeExternal` that was deleted by this mutation. */
  attendeeExternal: Maybe<AttendeeExternal>;
  /** An edge for our `AttendeeExternal`. May be used by Relay 1. */
  attendeeExternalEdge: Maybe<AttendeeExternalsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedAttendeeExternalNodeId: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Event` that is related to this `AttendeeExternal`. */
  event: Maybe<Event>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `AttendeeExternal`. */
  userByConfirmedBy: Maybe<User>;
  /** Reads a single `User` that is related to this `AttendeeExternal`. */
  userByManagedBy: Maybe<User>;
};


/** The output of our delete `AttendeeExternal` mutation. */
export type DeleteAttendeeExternalPayloadAttendeeExternalEdgeArgs = {
  orderBy?: InputMaybe<Array<AttendeeExternalsOrderBy>>;
};

/** All input for the `deleteAttendeeUserByUserIdAndEventId` mutation. */
export type DeleteAttendeeUserByUserIdAndEventIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  eventId: Scalars['BigInt']['input'];
  userId: Scalars['BigInt']['input'];
};

/** All input for the `deleteAttendeeUser` mutation. */
export type DeleteAttendeeUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `AttendeeUser` mutation. */
export type DeleteAttendeeUserPayload = {
  __typename?: 'DeleteAttendeeUserPayload';
  /** The `AttendeeUser` that was deleted by this mutation. */
  attendeeUser: Maybe<AttendeeUser>;
  /** An edge for our `AttendeeUser`. May be used by Relay 1. */
  attendeeUserEdge: Maybe<AttendeeUsersEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedAttendeeUserNodeId: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Event` that is related to this `AttendeeUser`. */
  event: Maybe<Event>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `AttendeeUser`. */
  user: Maybe<User>;
};


/** The output of our delete `AttendeeUser` mutation. */
export type DeleteAttendeeUserPayloadAttendeeUserEdgeArgs = {
  orderBy?: InputMaybe<Array<AttendeeUsersOrderBy>>;
};

/** All input for the `deleteCohortGroup` mutation. */
export type DeleteCohortGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `CohortGroup` mutation. */
export type DeleteCohortGroupPayload = {
  __typename?: 'DeleteCohortGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `CohortGroup` that was deleted by this mutation. */
  cohortGroup: Maybe<CohortGroup>;
  /** An edge for our `CohortGroup`. May be used by Relay 1. */
  cohortGroupEdge: Maybe<CohortGroupsEdge>;
  deletedCohortGroupNodeId: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `CohortGroup`. */
  tenantByTenant: Maybe<Tenant>;
};


/** The output of our delete `CohortGroup` mutation. */
export type DeleteCohortGroupPayloadCohortGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<CohortGroupsOrderBy>>;
};

/** All input for the `deleteDokumenty` mutation. */
export type DeleteDokumentyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  dId: Scalars['BigInt']['input'];
};

/** The output of our delete `Dokumenty` mutation. */
export type DeleteDokumentyPayload = {
  __typename?: 'DeleteDokumentyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedDokumentyNodeId: Maybe<Scalars['ID']['output']>;
  /** The `Dokumenty` that was deleted by this mutation. */
  dokumenty: Maybe<Dokumenty>;
  /** An edge for our `Dokumenty`. May be used by Relay 1. */
  dokumentyEdge: Maybe<DokumentiesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Dokumenty`. */
  userByDKdo: Maybe<User>;
};


/** The output of our delete `Dokumenty` mutation. */
export type DeleteDokumentyPayloadDokumentyEdgeArgs = {
  orderBy?: InputMaybe<Array<DokumentiesOrderBy>>;
};

/** All input for the `deleteEvent` mutation. */
export type DeleteEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Event` mutation. */
export type DeleteEventPayload = {
  __typename?: 'DeleteEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedEventNodeId: Maybe<Scalars['ID']['output']>;
  /** The `Event` that was deleted by this mutation. */
  event: Maybe<Event>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge: Maybe<EventsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Event` mutation. */
export type DeleteEventPayloadEventEdgeArgs = {
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};

/** All input for the `deleteFormResponse` mutation. */
export type DeleteFormResponseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `FormResponse` mutation. */
export type DeleteFormResponsePayload = {
  __typename?: 'DeleteFormResponsePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedFormResponseNodeId: Maybe<Scalars['ID']['output']>;
  /** The `FormResponse` that was deleted by this mutation. */
  formResponse: Maybe<FormResponse>;
  /** An edge for our `FormResponse`. May be used by Relay 1. */
  formResponseEdge: Maybe<FormResponsesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `FormResponse` mutation. */
export type DeleteFormResponsePayloadFormResponseEdgeArgs = {
  orderBy?: InputMaybe<Array<FormResponsesOrderBy>>;
};

/** All input for the `deleteGalerieDir` mutation. */
export type DeleteGalerieDirInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  gdId: Scalars['BigInt']['input'];
};

/** The output of our delete `GalerieDir` mutation. */
export type DeleteGalerieDirPayload = {
  __typename?: 'DeleteGalerieDirPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedGalerieDirNodeId: Maybe<Scalars['ID']['output']>;
  /** The `GalerieDir` that was deleted by this mutation. */
  galerieDir: Maybe<GalerieDir>;
  /** An edge for our `GalerieDir`. May be used by Relay 1. */
  galerieDirEdge: Maybe<GalerieDirsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `GalerieDir` mutation. */
export type DeleteGalerieDirPayloadGalerieDirEdgeArgs = {
  orderBy?: InputMaybe<Array<GalerieDirsOrderBy>>;
};

/** All input for the `deleteGalerieFoto` mutation. */
export type DeleteGalerieFotoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  gfId: Scalars['BigInt']['input'];
};

/** The output of our delete `GalerieFoto` mutation. */
export type DeleteGalerieFotoPayload = {
  __typename?: 'DeleteGalerieFotoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedGalerieFotoNodeId: Maybe<Scalars['ID']['output']>;
  /** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
  galerieDirByGfIdRodic: Maybe<GalerieDir>;
  /** The `GalerieFoto` that was deleted by this mutation. */
  galerieFoto: Maybe<GalerieFoto>;
  /** An edge for our `GalerieFoto`. May be used by Relay 1. */
  galerieFotoEdge: Maybe<GalerieFotosEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `GalerieFoto`. */
  userByGfKdo: Maybe<User>;
};


/** The output of our delete `GalerieFoto` mutation. */
export type DeleteGalerieFotoPayloadGalerieFotoEdgeArgs = {
  orderBy?: InputMaybe<Array<GalerieFotosOrderBy>>;
};

/** All input for the `deleteLocationAttachment` mutation. */
export type DeleteLocationAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  locationId: Scalars['BigInt']['input'];
  objectName: Scalars['String']['input'];
};

/** The output of our delete `LocationAttachment` mutation. */
export type DeleteLocationAttachmentPayload = {
  __typename?: 'DeleteLocationAttachmentPayload';
  /** Reads a single `Attachment` that is related to this `LocationAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedLocationAttachmentNodeId: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Location` that is related to this `LocationAttachment`. */
  location: Maybe<Location>;
  /** The `LocationAttachment` that was deleted by this mutation. */
  locationAttachment: Maybe<LocationAttachment>;
  /** An edge for our `LocationAttachment`. May be used by Relay 1. */
  locationAttachmentEdge: Maybe<LocationAttachmentsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `LocationAttachment` mutation. */
export type DeleteLocationAttachmentPayloadLocationAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<LocationAttachmentsOrderBy>>;
};

/** All input for the `deleteLocation` mutation. */
export type DeleteLocationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Location` mutation. */
export type DeleteLocationPayload = {
  __typename?: 'DeleteLocationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedLocationNodeId: Maybe<Scalars['ID']['output']>;
  /** The `Location` that was deleted by this mutation. */
  location: Maybe<Location>;
  /** An edge for our `Location`. May be used by Relay 1. */
  locationEdge: Maybe<LocationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Location` mutation. */
export type DeleteLocationPayloadLocationEdgeArgs = {
  orderBy?: InputMaybe<Array<LocationsOrderBy>>;
};

/** All input for the `deleteNabidka` mutation. */
export type DeleteNabidkaInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  nId: Scalars['BigInt']['input'];
};

/** All input for the `deleteNabidkaItemByNiPartnerAndNiIdRodic` mutation. */
export type DeleteNabidkaItemByNiPartnerAndNiIdRodicInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  niIdRodic: Scalars['BigInt']['input'];
  niPartner: Scalars['BigInt']['input'];
};

/** All input for the `deleteNabidkaItem` mutation. */
export type DeleteNabidkaItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  niId: Scalars['BigInt']['input'];
};

/** The output of our delete `NabidkaItem` mutation. */
export type DeleteNabidkaItemPayload = {
  __typename?: 'DeleteNabidkaItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedNabidkaItemNodeId: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Nabidka` that is related to this `NabidkaItem`. */
  nabidkaByNiIdRodic: Maybe<Nabidka>;
  /** The `NabidkaItem` that was deleted by this mutation. */
  nabidkaItem: Maybe<NabidkaItem>;
  /** An edge for our `NabidkaItem`. May be used by Relay 1. */
  nabidkaItemEdge: Maybe<NabidkaItemsEdge>;
  /** Reads a single `Pary` that is related to this `NabidkaItem`. */
  paryByNiPartner: Maybe<Pary>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `NabidkaItem` mutation. */
export type DeleteNabidkaItemPayloadNabidkaItemEdgeArgs = {
  orderBy?: InputMaybe<Array<NabidkaItemsOrderBy>>;
};

/** The output of our delete `Nabidka` mutation. */
export type DeleteNabidkaPayload = {
  __typename?: 'DeleteNabidkaPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedNabidkaNodeId: Maybe<Scalars['ID']['output']>;
  /** The `Nabidka` that was deleted by this mutation. */
  nabidka: Maybe<Nabidka>;
  /** An edge for our `Nabidka`. May be used by Relay 1. */
  nabidkaEdge: Maybe<NabidkasEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Nabidka`. */
  userByNTrener: Maybe<User>;
};


/** The output of our delete `Nabidka` mutation. */
export type DeleteNabidkaPayloadNabidkaEdgeArgs = {
  orderBy?: InputMaybe<Array<NabidkasOrderBy>>;
};

/** All input for the `deleteParameter` mutation. */
export type DeleteParameterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  paName: Scalars['String']['input'];
};

/** The output of our delete `Parameter` mutation. */
export type DeleteParameterPayload = {
  __typename?: 'DeleteParameterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedParameterNodeId: Maybe<Scalars['ID']['output']>;
  /** The `Parameter` that was deleted by this mutation. */
  parameter: Maybe<Parameter>;
  /** An edge for our `Parameter`. May be used by Relay 1. */
  parameterEdge: Maybe<ParametersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Parameter` mutation. */
export type DeleteParameterPayloadParameterEdgeArgs = {
  orderBy?: InputMaybe<Array<ParametersOrderBy>>;
};

/** All input for the `deletePary` mutation. */
export type DeleteParyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  pId: Scalars['BigInt']['input'];
};

/** All input for the `deleteParyNavrh` mutation. */
export type DeleteParyNavrhInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  pnId: Scalars['BigInt']['input'];
};

/** The output of our delete `ParyNavrh` mutation. */
export type DeleteParyNavrhPayload = {
  __typename?: 'DeleteParyNavrhPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedParyNavrhNodeId: Maybe<Scalars['ID']['output']>;
  /** The `ParyNavrh` that was deleted by this mutation. */
  paryNavrh: Maybe<ParyNavrh>;
  /** An edge for our `ParyNavrh`. May be used by Relay 1. */
  paryNavrhEdge: Maybe<ParyNavrhsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnNavrhl: Maybe<User>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnPartnerka: Maybe<User>;
};


/** The output of our delete `ParyNavrh` mutation. */
export type DeleteParyNavrhPayloadParyNavrhEdgeArgs = {
  orderBy?: InputMaybe<Array<ParyNavrhsOrderBy>>;
};

/** The output of our delete `Pary` mutation. */
export type DeleteParyPayload = {
  __typename?: 'DeleteParyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedParyNodeId: Maybe<Scalars['ID']['output']>;
  /** The `Pary` that was deleted by this mutation. */
  pary: Maybe<Pary>;
  /** An edge for our `Pary`. May be used by Relay 1. */
  paryEdge: Maybe<PariesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartnerka: Maybe<User>;
};


/** The output of our delete `Pary` mutation. */
export type DeleteParyPayloadParyEdgeArgs = {
  orderBy?: InputMaybe<Array<PariesOrderBy>>;
};

/** All input for the `deletePermission` mutation. */
export type DeletePermissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  peId: Scalars['BigInt']['input'];
};

/** The output of our delete `Permission` mutation. */
export type DeletePermissionPayload = {
  __typename?: 'DeletePermissionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedPermissionNodeId: Maybe<Scalars['ID']['output']>;
  /** The `Permission` that was deleted by this mutation. */
  permission: Maybe<Permission>;
  /** An edge for our `Permission`. May be used by Relay 1. */
  permissionEdge: Maybe<PermissionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Permission` mutation. */
export type DeletePermissionPayloadPermissionEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
};

/** All input for the `deletePerson` mutation. */
export type DeletePersonInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Person` mutation. */
export type DeletePersonPayload = {
  __typename?: 'DeletePersonPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedPersonNodeId: Maybe<Scalars['ID']['output']>;
  /** The `Person` that was deleted by this mutation. */
  person: Maybe<Person>;
  /** An edge for our `Person`. May be used by Relay 1. */
  personEdge: Maybe<PeopleEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Person` mutation. */
export type DeletePersonPayloadPersonEdgeArgs = {
  orderBy?: InputMaybe<Array<PeopleOrderBy>>;
};

/** All input for the `deletePlatbyCategoryGroup` mutation. */
export type DeletePlatbyCategoryGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  pcgId: Scalars['BigInt']['input'];
};

/** The output of our delete `PlatbyCategoryGroup` mutation. */
export type DeletePlatbyCategoryGroupPayload = {
  __typename?: 'DeletePlatbyCategoryGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedPlatbyCategoryGroupNodeId: Maybe<Scalars['ID']['output']>;
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyCategoryGroup`. */
  platbyCategoryByPcgIdCategory: Maybe<PlatbyCategory>;
  /** The `PlatbyCategoryGroup` that was deleted by this mutation. */
  platbyCategoryGroup: Maybe<PlatbyCategoryGroup>;
  /** An edge for our `PlatbyCategoryGroup`. May be used by Relay 1. */
  platbyCategoryGroupEdge: Maybe<PlatbyCategoryGroupsEdge>;
  /** Reads a single `PlatbyGroup` that is related to this `PlatbyCategoryGroup`. */
  platbyGroupByPcgIdGroup: Maybe<PlatbyGroup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `PlatbyCategoryGroup` mutation. */
export type DeletePlatbyCategoryGroupPayloadPlatbyCategoryGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyCategoryGroupsOrderBy>>;
};

/** All input for the `deletePlatbyCategory` mutation. */
export type DeletePlatbyCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  pcId: Scalars['BigInt']['input'];
};

/** The output of our delete `PlatbyCategory` mutation. */
export type DeletePlatbyCategoryPayload = {
  __typename?: 'DeletePlatbyCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedPlatbyCategoryNodeId: Maybe<Scalars['ID']['output']>;
  /** The `PlatbyCategory` that was deleted by this mutation. */
  platbyCategory: Maybe<PlatbyCategory>;
  /** An edge for our `PlatbyCategory`. May be used by Relay 1. */
  platbyCategoryEdge: Maybe<PlatbyCategoriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `PlatbyCategory` mutation. */
export type DeletePlatbyCategoryPayloadPlatbyCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyCategoriesOrderBy>>;
};

/** All input for the `deletePlatbyGroup` mutation. */
export type DeletePlatbyGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  pgId: Scalars['BigInt']['input'];
};

/** The output of our delete `PlatbyGroup` mutation. */
export type DeletePlatbyGroupPayload = {
  __typename?: 'DeletePlatbyGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedPlatbyGroupNodeId: Maybe<Scalars['ID']['output']>;
  /** The `PlatbyGroup` that was deleted by this mutation. */
  platbyGroup: Maybe<PlatbyGroup>;
  /** An edge for our `PlatbyGroup`. May be used by Relay 1. */
  platbyGroupEdge: Maybe<PlatbyGroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `PlatbyGroup` mutation. */
export type DeletePlatbyGroupPayloadPlatbyGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyGroupsOrderBy>>;
};

/** All input for the `deletePlatbyGroupSkupina` mutation. */
export type DeletePlatbyGroupSkupinaInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  pgsId: Scalars['BigInt']['input'];
};

/** The output of our delete `PlatbyGroupSkupina` mutation. */
export type DeletePlatbyGroupSkupinaPayload = {
  __typename?: 'DeletePlatbyGroupSkupinaPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedPlatbyGroupSkupinaNodeId: Maybe<Scalars['ID']['output']>;
  /** Reads a single `PlatbyGroup` that is related to this `PlatbyGroupSkupina`. */
  platbyGroupByPgsIdGroup: Maybe<PlatbyGroup>;
  /** The `PlatbyGroupSkupina` that was deleted by this mutation. */
  platbyGroupSkupina: Maybe<PlatbyGroupSkupina>;
  /** An edge for our `PlatbyGroupSkupina`. May be used by Relay 1. */
  platbyGroupSkupinaEdge: Maybe<PlatbyGroupSkupinasEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `PlatbyGroupSkupina`. */
  skupinyByPgsIdSkupina: Maybe<Skupiny>;
};


/** The output of our delete `PlatbyGroupSkupina` mutation. */
export type DeletePlatbyGroupSkupinaPayloadPlatbyGroupSkupinaEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyGroupSkupinasOrderBy>>;
};

/** All input for the `deletePlatbyItem` mutation. */
export type DeletePlatbyItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  piId: Scalars['BigInt']['input'];
};

/** The output of our delete `PlatbyItem` mutation. */
export type DeletePlatbyItemPayload = {
  __typename?: 'DeletePlatbyItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedPlatbyItemNodeId: Maybe<Scalars['ID']['output']>;
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
  platbyCategoryByPiIdCategory: Maybe<PlatbyCategory>;
  /** The `PlatbyItem` that was deleted by this mutation. */
  platbyItem: Maybe<PlatbyItem>;
  /** An edge for our `PlatbyItem`. May be used by Relay 1. */
  platbyItemEdge: Maybe<PlatbyItemsEdge>;
  /** Reads a single `PlatbyRaw` that is related to this `PlatbyItem`. */
  platbyRawByPiIdRaw: Maybe<PlatbyRaw>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `PlatbyItem`. */
  userByPiIdUser: Maybe<User>;
};


/** The output of our delete `PlatbyItem` mutation. */
export type DeletePlatbyItemPayloadPlatbyItemEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyItemsOrderBy>>;
};

/** All input for the `deletePlatbyRaw` mutation. */
export type DeletePlatbyRawInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  prId: Scalars['BigInt']['input'];
};

/** The output of our delete `PlatbyRaw` mutation. */
export type DeletePlatbyRawPayload = {
  __typename?: 'DeletePlatbyRawPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedPlatbyRawNodeId: Maybe<Scalars['ID']['output']>;
  /** The `PlatbyRaw` that was deleted by this mutation. */
  platbyRaw: Maybe<PlatbyRaw>;
  /** An edge for our `PlatbyRaw`. May be used by Relay 1. */
  platbyRawEdge: Maybe<PlatbyRawsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `PlatbyRaw` mutation. */
export type DeletePlatbyRawPayloadPlatbyRawEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyRawsOrderBy>>;
};

/** All input for the `deleteRoomAttachment` mutation. */
export type DeleteRoomAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  objectName: Scalars['String']['input'];
  roomId: Scalars['BigInt']['input'];
};

/** The output of our delete `RoomAttachment` mutation. */
export type DeleteRoomAttachmentPayload = {
  __typename?: 'DeleteRoomAttachmentPayload';
  /** Reads a single `Attachment` that is related to this `RoomAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedRoomAttachmentNodeId: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Room` that is related to this `RoomAttachment`. */
  room: Maybe<Room>;
  /** The `RoomAttachment` that was deleted by this mutation. */
  roomAttachment: Maybe<RoomAttachment>;
  /** An edge for our `RoomAttachment`. May be used by Relay 1. */
  roomAttachmentEdge: Maybe<RoomAttachmentsEdge>;
};


/** The output of our delete `RoomAttachment` mutation. */
export type DeleteRoomAttachmentPayloadRoomAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<RoomAttachmentsOrderBy>>;
};

/** All input for the `deleteRoom` mutation. */
export type DeleteRoomInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Room` mutation. */
export type DeleteRoomPayload = {
  __typename?: 'DeleteRoomPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedRoomNodeId: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Location` that is related to this `Room`. */
  locationByLocation: Maybe<Location>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Room` that was deleted by this mutation. */
  room: Maybe<Room>;
  /** An edge for our `Room`. May be used by Relay 1. */
  roomEdge: Maybe<RoomsEdge>;
};


/** The output of our delete `Room` mutation. */
export type DeleteRoomPayloadRoomEdgeArgs = {
  orderBy?: InputMaybe<Array<RoomsOrderBy>>;
};

/** All input for the `deleteRozpi` mutation. */
export type DeleteRozpiInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  rId: Scalars['BigInt']['input'];
};

/** The output of our delete `Rozpi` mutation. */
export type DeleteRozpiPayload = {
  __typename?: 'DeleteRozpiPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedRozpiNodeId: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Rozpi` that was deleted by this mutation. */
  rozpi: Maybe<Rozpi>;
  /** An edge for our `Rozpi`. May be used by Relay 1. */
  rozpiEdge: Maybe<RozpisEdge>;
  /** Reads a single `User` that is related to this `Rozpi`. */
  userByRTrener: Maybe<User>;
};


/** The output of our delete `Rozpi` mutation. */
export type DeleteRozpiPayloadRozpiEdgeArgs = {
  orderBy?: InputMaybe<Array<RozpisOrderBy>>;
};

/** All input for the `deleteRozpisItem` mutation. */
export type DeleteRozpisItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  riId: Scalars['BigInt']['input'];
};

/** The output of our delete `RozpisItem` mutation. */
export type DeleteRozpisItemPayload = {
  __typename?: 'DeleteRozpisItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedRozpisItemNodeId: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Pary` that is related to this `RozpisItem`. */
  paryByRiPartner: Maybe<Pary>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Rozpi` that is related to this `RozpisItem`. */
  rozpiByRiIdRodic: Maybe<Rozpi>;
  /** The `RozpisItem` that was deleted by this mutation. */
  rozpisItem: Maybe<RozpisItem>;
  /** An edge for our `RozpisItem`. May be used by Relay 1. */
  rozpisItemEdge: Maybe<RozpisItemsEdge>;
};


/** The output of our delete `RozpisItem` mutation. */
export type DeleteRozpisItemPayloadRozpisItemEdgeArgs = {
  orderBy?: InputMaybe<Array<RozpisItemsOrderBy>>;
};

/** All input for the `deleteSkupiny` mutation. */
export type DeleteSkupinyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  sId: Scalars['BigInt']['input'];
};

/** The output of our delete `Skupiny` mutation. */
export type DeleteSkupinyPayload = {
  __typename?: 'DeleteSkupinyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `CohortGroup` that is related to this `Skupiny`. */
  cohortGroupByCohortGroup: Maybe<CohortGroup>;
  deletedSkupinyNodeId: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Skupiny` that was deleted by this mutation. */
  skupiny: Maybe<Skupiny>;
  /** An edge for our `Skupiny`. May be used by Relay 1. */
  skupinyEdge: Maybe<SkupiniesEdge>;
};


/** The output of our delete `Skupiny` mutation. */
export type DeleteSkupinyPayloadSkupinyEdgeArgs = {
  orderBy?: InputMaybe<Array<SkupiniesOrderBy>>;
};

/** All input for the `deleteTenantAttachment` mutation. */
export type DeleteTenantAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  objectName: Scalars['String']['input'];
  tenantId: Scalars['BigInt']['input'];
};

/** The output of our delete `TenantAttachment` mutation. */
export type DeleteTenantAttachmentPayload = {
  __typename?: 'DeleteTenantAttachmentPayload';
  /** Reads a single `Attachment` that is related to this `TenantAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedTenantAttachmentNodeId: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `TenantAttachment`. */
  tenant: Maybe<Tenant>;
  /** The `TenantAttachment` that was deleted by this mutation. */
  tenantAttachment: Maybe<TenantAttachment>;
  /** An edge for our `TenantAttachment`. May be used by Relay 1. */
  tenantAttachmentEdge: Maybe<TenantAttachmentsEdge>;
};


/** The output of our delete `TenantAttachment` mutation. */
export type DeleteTenantAttachmentPayloadTenantAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<TenantAttachmentsOrderBy>>;
};

/** All input for the `deleteTenant` mutation. */
export type DeleteTenantInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** All input for the `deleteTenantLocation` mutation. */
export type DeleteTenantLocationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  locationId: Scalars['BigInt']['input'];
  tenantId: Scalars['BigInt']['input'];
};

/** The output of our delete `TenantLocation` mutation. */
export type DeleteTenantLocationPayload = {
  __typename?: 'DeleteTenantLocationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedTenantLocationNodeId: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Location` that is related to this `TenantLocation`. */
  location: Maybe<Location>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `TenantLocation`. */
  tenant: Maybe<Tenant>;
  /** The `TenantLocation` that was deleted by this mutation. */
  tenantLocation: Maybe<TenantLocation>;
  /** An edge for our `TenantLocation`. May be used by Relay 1. */
  tenantLocationEdge: Maybe<TenantLocationsEdge>;
};


/** The output of our delete `TenantLocation` mutation. */
export type DeleteTenantLocationPayloadTenantLocationEdgeArgs = {
  orderBy?: InputMaybe<Array<TenantLocationsOrderBy>>;
};

/** The output of our delete `Tenant` mutation. */
export type DeleteTenantPayload = {
  __typename?: 'DeleteTenantPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedTenantNodeId: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Tenant` that was deleted by this mutation. */
  tenant: Maybe<Tenant>;
  /** An edge for our `Tenant`. May be used by Relay 1. */
  tenantEdge: Maybe<TenantsEdge>;
};


/** The output of our delete `Tenant` mutation. */
export type DeleteTenantPayloadTenantEdgeArgs = {
  orderBy?: InputMaybe<Array<TenantsOrderBy>>;
};

/** All input for the `deleteTenantPerson` mutation. */
export type DeleteTenantPersonInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  personId: Scalars['BigInt']['input'];
  tenantId: Scalars['BigInt']['input'];
};

/** The output of our delete `TenantPerson` mutation. */
export type DeleteTenantPersonPayload = {
  __typename?: 'DeleteTenantPersonPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedTenantPersonNodeId: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Person` that is related to this `TenantPerson`. */
  person: Maybe<Person>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `TenantPerson`. */
  tenant: Maybe<Tenant>;
  /** The `TenantPerson` that was deleted by this mutation. */
  tenantPerson: Maybe<TenantPerson>;
  /** An edge for our `TenantPerson`. May be used by Relay 1. */
  tenantPersonEdge: Maybe<TenantPeopleEdge>;
};


/** The output of our delete `TenantPerson` mutation. */
export type DeleteTenantPersonPayloadTenantPersonEdgeArgs = {
  orderBy?: InputMaybe<Array<TenantPeopleOrderBy>>;
};

/** All input for the `deleteUpozorneni` mutation. */
export type DeleteUpozorneniInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  upId: Scalars['BigInt']['input'];
};

/** The output of our delete `Upozorneni` mutation. */
export type DeleteUpozorneniPayload = {
  __typename?: 'DeleteUpozorneniPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedUpozorneniNodeId: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Upozorneni` that was deleted by this mutation. */
  upozorneni: Maybe<Upozorneni>;
  /** An edge for our `Upozorneni`. May be used by Relay 1. */
  upozorneniEdge: Maybe<UpozornenisEdge>;
  /** Reads a single `User` that is related to this `Upozorneni`. */
  userByUpKdo: Maybe<User>;
};


/** The output of our delete `Upozorneni` mutation. */
export type DeleteUpozorneniPayloadUpozorneniEdgeArgs = {
  orderBy?: InputMaybe<Array<UpozornenisOrderBy>>;
};

/** All input for the `deleteUpozorneniSkupiny` mutation. */
export type DeleteUpozorneniSkupinyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  upsId: Scalars['BigInt']['input'];
};

/** The output of our delete `UpozorneniSkupiny` mutation. */
export type DeleteUpozorneniSkupinyPayload = {
  __typename?: 'DeleteUpozorneniSkupinyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedUpozorneniSkupinyNodeId: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
  skupinyByUpsIdSkupina: Maybe<Skupiny>;
  /** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
  upozorneniByUpsIdRodic: Maybe<Upozorneni>;
  /** The `UpozorneniSkupiny` that was deleted by this mutation. */
  upozorneniSkupiny: Maybe<UpozorneniSkupiny>;
  /** An edge for our `UpozorneniSkupiny`. May be used by Relay 1. */
  upozorneniSkupinyEdge: Maybe<UpozorneniSkupiniesEdge>;
};


/** The output of our delete `UpozorneniSkupiny` mutation. */
export type DeleteUpozorneniSkupinyPayloadUpozorneniSkupinyEdgeArgs = {
  orderBy?: InputMaybe<Array<UpozorneniSkupiniesOrderBy>>;
};

/** All input for the `deleteUser` mutation. */
export type DeleteUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  uId: Scalars['BigInt']['input'];
};

/** The output of our delete `User` mutation. */
export type DeleteUserPayload = {
  __typename?: 'DeleteUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedUserNodeId: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Permission` that is related to this `User`. */
  permissionByUGroup: Maybe<Permission>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `User`. */
  skupinyByUSkupina: Maybe<Skupiny>;
  /** The `User` that was deleted by this mutation. */
  user: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge: Maybe<UsersEdge>;
};


/** The output of our delete `User` mutation. */
export type DeleteUserPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** A connection to a list of `Dokumenty` values. */
export type DokumentiesConnection = {
  __typename?: 'DokumentiesConnection';
  /** A list of edges which contains the `Dokumenty` and cursor to aid in pagination. */
  edges: Array<DokumentiesEdge>;
  /** A list of `Dokumenty` objects. */
  nodes: Array<Dokumenty>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Dokumenty` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Dokumenty` edge in the connection. */
export type DokumentiesEdge = {
  __typename?: 'DokumentiesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Dokumenty` at the end of the edge. */
  node: Dokumenty;
};

/** Methods to use when ordering `Dokumenty`. */
export type DokumentiesOrderBy =
  | 'D_ID_ASC'
  | 'D_ID_DESC'
  | 'D_KATEGORIE_ASC'
  | 'D_KATEGORIE_DESC'
  | 'D_KDO_ASC'
  | 'D_KDO_DESC'
  | 'D_PATH_ASC'
  | 'D_PATH_DESC'
  | 'D_TIMESTAMP_ASC'
  | 'D_TIMESTAMP_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'USER_BY_D_KDO__U_BAN_ASC'
  | 'USER_BY_D_KDO__U_BAN_DESC'
  | 'USER_BY_D_KDO__U_CONFIRMED_ASC'
  | 'USER_BY_D_KDO__U_CONFIRMED_DESC'
  | 'USER_BY_D_KDO__U_GROUP_ASC'
  | 'USER_BY_D_KDO__U_GROUP_DESC'
  | 'USER_BY_D_KDO__U_ID_ASC'
  | 'USER_BY_D_KDO__U_ID_DESC'
  | 'USER_BY_D_KDO__U_JMENO_ASC'
  | 'USER_BY_D_KDO__U_JMENO_DESC'
  | 'USER_BY_D_KDO__U_LOGIN_ASC'
  | 'USER_BY_D_KDO__U_LOGIN_DESC'
  | 'USER_BY_D_KDO__U_NAROZENI_ASC'
  | 'USER_BY_D_KDO__U_NAROZENI_DESC'
  | 'USER_BY_D_KDO__U_PRIJMENI_ASC'
  | 'USER_BY_D_KDO__U_PRIJMENI_DESC'
  | 'USER_BY_D_KDO__U_SKUPINA_ASC'
  | 'USER_BY_D_KDO__U_SKUPINA_DESC'
  | 'USER_BY_D_KDO__U_SYSTEM_ASC'
  | 'USER_BY_D_KDO__U_SYSTEM_DESC';

export type Dokumenty = {
  __typename?: 'Dokumenty';
  dFilename: Scalars['String']['output'];
  dId: Scalars['BigInt']['output'];
  dKategorie: Scalars['Int']['output'];
  dKdo: Scalars['BigInt']['output'];
  dName: Scalars['String']['output'];
  dPath: Scalars['String']['output'];
  dTimestamp: Maybe<Scalars['Datetime']['output']>;
  id: Maybe<Scalars['BigInt']['output']>;
  tenantId: Scalars['BigInt']['output'];
  /** Reads a single `User` that is related to this `Dokumenty`. */
  userByDKdo: Maybe<User>;
};

/**
 * A condition to be used against `Dokumenty` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type DokumentyCondition = {
  /** Checks for equality with the object’s `dId` field. */
  dId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `dKategorie` field. */
  dKategorie?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `dKdo` field. */
  dKdo?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `dPath` field. */
  dPath?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `dTimestamp` field. */
  dTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An input for mutations affecting `Dokumenty` */
export type DokumentyInput = {
  dFilename: Scalars['String']['input'];
  dId?: InputMaybe<Scalars['BigInt']['input']>;
  dKategorie: Scalars['Int']['input'];
  dKdo: Scalars['BigInt']['input'];
  dName: Scalars['String']['input'];
  dPath: Scalars['String']['input'];
  dTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Represents an update to a `Dokumenty`. Fields that are set will be updated. */
export type DokumentyPatch = {
  dFilename?: InputMaybe<Scalars['String']['input']>;
  dId?: InputMaybe<Scalars['BigInt']['input']>;
  dKategorie?: InputMaybe<Scalars['Int']['input']>;
  dKdo?: InputMaybe<Scalars['BigInt']['input']>;
  dName?: InputMaybe<Scalars['String']['input']>;
  dPath?: InputMaybe<Scalars['String']['input']>;
  dTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

export type Event = {
  __typename?: 'Event';
  /** Reads and enables pagination through a set of `AttendeeExternal`. */
  attendeeExternals: AttendeeExternalsConnection;
  /** Reads and enables pagination through a set of `AttendeeUser`. */
  attendeeUsers: AttendeeUsersConnection;
  capacity: Scalars['BigInt']['output'];
  description: Scalars['String']['output'];
  descriptionMember: Scalars['String']['output'];
  enableNotes: Scalars['Boolean']['output'];
  filesLegacy: Scalars['String']['output'];
  id: Scalars['BigInt']['output'];
  isFuture: Maybe<Scalars['Boolean']['output']>;
  isLocked: Scalars['Boolean']['output'];
  isPublic: Scalars['Boolean']['output'];
  isVisible: Scalars['Boolean']['output'];
  locationText: Scalars['String']['output'];
  name: Scalars['String']['output'];
  remainingSpots: Maybe<Scalars['Int']['output']>;
  since: Scalars['Date']['output'];
  summary: Scalars['String']['output'];
  tenantId: Scalars['BigInt']['output'];
  titleImageLegacy: Maybe<Scalars['String']['output']>;
  type: EventType;
  until: Scalars['Date']['output'];
  updatedAt: Maybe<Scalars['Datetime']['output']>;
};


export type EventAttendeeExternalsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AttendeeExternalCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AttendeeExternalsOrderBy>>;
};


export type EventAttendeeUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AttendeeUserCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AttendeeUsersOrderBy>>;
};

/** A condition to be used against `Event` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type EventCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `isFuture` field. */
  isFuture?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isVisible` field. */
  isVisible?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `since` field. */
  since?: InputMaybe<Scalars['Date']['input']>;
};

/** An input for mutations affecting `Event` */
export type EventInput = {
  capacity?: InputMaybe<Scalars['BigInt']['input']>;
  description: Scalars['String']['input'];
  descriptionMember?: InputMaybe<Scalars['String']['input']>;
  enableNotes?: InputMaybe<Scalars['Boolean']['input']>;
  filesLegacy?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  isLocked?: InputMaybe<Scalars['Boolean']['input']>;
  isPublic?: InputMaybe<Scalars['Boolean']['input']>;
  isVisible?: InputMaybe<Scalars['Boolean']['input']>;
  locationText: Scalars['String']['input'];
  name: Scalars['String']['input'];
  since: Scalars['Date']['input'];
  summary?: InputMaybe<Scalars['String']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
  titleImageLegacy?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<EventType>;
  until: Scalars['Date']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `Event`. Fields that are set will be updated. */
export type EventPatch = {
  capacity?: InputMaybe<Scalars['BigInt']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  descriptionMember?: InputMaybe<Scalars['String']['input']>;
  enableNotes?: InputMaybe<Scalars['Boolean']['input']>;
  filesLegacy?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  isLocked?: InputMaybe<Scalars['Boolean']['input']>;
  isPublic?: InputMaybe<Scalars['Boolean']['input']>;
  isVisible?: InputMaybe<Scalars['Boolean']['input']>;
  locationText?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  since?: InputMaybe<Scalars['Date']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
  titleImageLegacy?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<EventType>;
  until?: InputMaybe<Scalars['Date']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

export type EventType =
  | 'CAMP'
  | 'LESSON'
  | 'RESERVATION';

/** A connection to a list of `Event` values. */
export type EventsConnection = {
  __typename?: 'EventsConnection';
  /** A list of edges which contains the `Event` and cursor to aid in pagination. */
  edges: Array<EventsEdge>;
  /** A list of `Event` objects. */
  nodes: Array<Event>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Event` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Event` edge in the connection. */
export type EventsEdge = {
  __typename?: 'EventsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Event` at the end of the edge. */
  node: Event;
};

/** Methods to use when ordering `Event`. */
export type EventsOrderBy =
  | 'ATTENDEE_EXTERNALS_BY_EVENT_ID__COUNT_ASC'
  | 'ATTENDEE_EXTERNALS_BY_EVENT_ID__COUNT_DESC'
  | 'ATTENDEE_USERS_BY_EVENT_ID__COUNT_ASC'
  | 'ATTENDEE_USERS_BY_EVENT_ID__COUNT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'IS_VISIBLE_ASC'
  | 'IS_VISIBLE_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SINCE_ASC'
  | 'SINCE_DESC';

/** All input for the `fixUnpairedCouples` mutation. */
export type FixUnpairedCouplesInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our `fixUnpairedCouples` mutation. */
export type FixUnpairedCouplesPayload = {
  __typename?: 'FixUnpairedCouplesPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  paries: Maybe<Array<Pary>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type FormResponse = {
  __typename?: 'FormResponse';
  createdAt: Scalars['Datetime']['output'];
  data: Scalars['JSON']['output'];
  id: Scalars['BigInt']['output'];
  tenantId: Scalars['BigInt']['output'];
  type: Scalars['String']['output'];
  updatedAt: Scalars['Datetime']['output'];
  url: Scalars['String']['output'];
};

/**
 * A condition to be used against `FormResponse` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type FormResponseCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An input for mutations affecting `FormResponse` */
export type FormResponseInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  data: Scalars['JSON']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
  type: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  url: Scalars['String']['input'];
};

/** Represents an update to a `FormResponse`. Fields that are set will be updated. */
export type FormResponsePatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `FormResponse` values. */
export type FormResponsesConnection = {
  __typename?: 'FormResponsesConnection';
  /** A list of edges which contains the `FormResponse` and cursor to aid in pagination. */
  edges: Array<FormResponsesEdge>;
  /** A list of `FormResponse` objects. */
  nodes: Array<FormResponse>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FormResponse` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FormResponse` edge in the connection. */
export type FormResponsesEdge = {
  __typename?: 'FormResponsesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `FormResponse` at the end of the edge. */
  node: FormResponse;
};

/** Methods to use when ordering `FormResponse`. */
export type FormResponsesOrderBy =
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC';

export type GalerieDir = {
  __typename?: 'GalerieDir';
  /** Reads and enables pagination through a set of `GalerieFoto`. */
  galerieFotosByGfIdRodic: GalerieFotosConnection;
  gdHidden: Scalars['Boolean']['output'];
  gdId: Scalars['BigInt']['output'];
  gdIdRodic: Scalars['BigInt']['output'];
  gdLevel: Scalars['Int']['output'];
  gdName: Scalars['String']['output'];
  gdPath: Scalars['String']['output'];
  id: Maybe<Scalars['BigInt']['output']>;
  tenantId: Scalars['BigInt']['output'];
};


export type GalerieDirGalerieFotosByGfIdRodicArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GalerieFotoCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GalerieFotosOrderBy>>;
};

/**
 * A condition to be used against `GalerieDir` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type GalerieDirCondition = {
  /** Checks for equality with the object’s `gdId` field. */
  gdId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `gdIdRodic` field. */
  gdIdRodic?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `GalerieDir` */
export type GalerieDirInput = {
  gdHidden?: InputMaybe<Scalars['Boolean']['input']>;
  gdId?: InputMaybe<Scalars['BigInt']['input']>;
  gdIdRodic: Scalars['BigInt']['input'];
  gdLevel?: InputMaybe<Scalars['Int']['input']>;
  gdName: Scalars['String']['input'];
  gdPath: Scalars['String']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Represents an update to a `GalerieDir`. Fields that are set will be updated. */
export type GalerieDirPatch = {
  gdHidden?: InputMaybe<Scalars['Boolean']['input']>;
  gdId?: InputMaybe<Scalars['BigInt']['input']>;
  gdIdRodic?: InputMaybe<Scalars['BigInt']['input']>;
  gdLevel?: InputMaybe<Scalars['Int']['input']>;
  gdName?: InputMaybe<Scalars['String']['input']>;
  gdPath?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `GalerieDir` values. */
export type GalerieDirsConnection = {
  __typename?: 'GalerieDirsConnection';
  /** A list of edges which contains the `GalerieDir` and cursor to aid in pagination. */
  edges: Array<GalerieDirsEdge>;
  /** A list of `GalerieDir` objects. */
  nodes: Array<GalerieDir>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `GalerieDir` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `GalerieDir` edge in the connection. */
export type GalerieDirsEdge = {
  __typename?: 'GalerieDirsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `GalerieDir` at the end of the edge. */
  node: GalerieDir;
};

/** Methods to use when ordering `GalerieDir`. */
export type GalerieDirsOrderBy =
  | 'GALERIE_FOTOS_BY_GF_ID_RODIC__COUNT_ASC'
  | 'GALERIE_FOTOS_BY_GF_ID_RODIC__COUNT_DESC'
  | 'GD_ID_ASC'
  | 'GD_ID_DESC'
  | 'GD_ID_RODIC_ASC'
  | 'GD_ID_RODIC_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

export type GalerieFoto = {
  __typename?: 'GalerieFoto';
  /** Reads and enables pagination through a set of `Aktuality`. */
  aktualitiesByAtFotoMain: AktualitiesConnection;
  /** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
  galerieDirByGfIdRodic: Maybe<GalerieDir>;
  gfId: Scalars['BigInt']['output'];
  gfIdRodic: Scalars['BigInt']['output'];
  gfKdo: Scalars['BigInt']['output'];
  gfName: Scalars['String']['output'];
  gfPath: Scalars['String']['output'];
  gfTimestamp: Maybe<Scalars['Datetime']['output']>;
  id: Maybe<Scalars['BigInt']['output']>;
  tenantId: Scalars['BigInt']['output'];
  /** Reads a single `User` that is related to this `GalerieFoto`. */
  userByGfKdo: Maybe<User>;
};


export type GalerieFotoAktualitiesByAtFotoMainArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AktualityCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AktualitiesOrderBy>>;
};

/**
 * A condition to be used against `GalerieFoto` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type GalerieFotoCondition = {
  /** Checks for equality with the object’s `gfId` field. */
  gfId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `gfIdRodic` field. */
  gfIdRodic?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `gfKdo` field. */
  gfKdo?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `GalerieFoto` */
export type GalerieFotoInput = {
  gfId?: InputMaybe<Scalars['BigInt']['input']>;
  gfIdRodic: Scalars['BigInt']['input'];
  gfKdo: Scalars['BigInt']['input'];
  gfName: Scalars['String']['input'];
  gfPath: Scalars['String']['input'];
  gfTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Represents an update to a `GalerieFoto`. Fields that are set will be updated. */
export type GalerieFotoPatch = {
  gfId?: InputMaybe<Scalars['BigInt']['input']>;
  gfIdRodic?: InputMaybe<Scalars['BigInt']['input']>;
  gfKdo?: InputMaybe<Scalars['BigInt']['input']>;
  gfName?: InputMaybe<Scalars['String']['input']>;
  gfPath?: InputMaybe<Scalars['String']['input']>;
  gfTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `GalerieFoto` values. */
export type GalerieFotosConnection = {
  __typename?: 'GalerieFotosConnection';
  /** A list of edges which contains the `GalerieFoto` and cursor to aid in pagination. */
  edges: Array<GalerieFotosEdge>;
  /** A list of `GalerieFoto` objects. */
  nodes: Array<GalerieFoto>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `GalerieFoto` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `GalerieFoto` edge in the connection. */
export type GalerieFotosEdge = {
  __typename?: 'GalerieFotosEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `GalerieFoto` at the end of the edge. */
  node: GalerieFoto;
};

/** Methods to use when ordering `GalerieFoto`. */
export type GalerieFotosOrderBy =
  | 'AKTUALITIES_BY_AT_FOTO_MAIN__COUNT_ASC'
  | 'AKTUALITIES_BY_AT_FOTO_MAIN__COUNT_DESC'
  | 'GALERIE_DIR_BY_GF_ID_RODIC__GD_ID_ASC'
  | 'GALERIE_DIR_BY_GF_ID_RODIC__GD_ID_DESC'
  | 'GALERIE_DIR_BY_GF_ID_RODIC__GD_ID_RODIC_ASC'
  | 'GALERIE_DIR_BY_GF_ID_RODIC__GD_ID_RODIC_DESC'
  | 'GF_ID_ASC'
  | 'GF_ID_DESC'
  | 'GF_ID_RODIC_ASC'
  | 'GF_ID_RODIC_DESC'
  | 'GF_KDO_ASC'
  | 'GF_KDO_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'USER_BY_GF_KDO__U_BAN_ASC'
  | 'USER_BY_GF_KDO__U_BAN_DESC'
  | 'USER_BY_GF_KDO__U_CONFIRMED_ASC'
  | 'USER_BY_GF_KDO__U_CONFIRMED_DESC'
  | 'USER_BY_GF_KDO__U_GROUP_ASC'
  | 'USER_BY_GF_KDO__U_GROUP_DESC'
  | 'USER_BY_GF_KDO__U_ID_ASC'
  | 'USER_BY_GF_KDO__U_ID_DESC'
  | 'USER_BY_GF_KDO__U_JMENO_ASC'
  | 'USER_BY_GF_KDO__U_JMENO_DESC'
  | 'USER_BY_GF_KDO__U_LOGIN_ASC'
  | 'USER_BY_GF_KDO__U_LOGIN_DESC'
  | 'USER_BY_GF_KDO__U_NAROZENI_ASC'
  | 'USER_BY_GF_KDO__U_NAROZENI_DESC'
  | 'USER_BY_GF_KDO__U_PRIJMENI_ASC'
  | 'USER_BY_GF_KDO__U_PRIJMENI_DESC'
  | 'USER_BY_GF_KDO__U_SKUPINA_ASC'
  | 'USER_BY_GF_KDO__U_SKUPINA_DESC'
  | 'USER_BY_GF_KDO__U_SYSTEM_ASC'
  | 'USER_BY_GF_KDO__U_SYSTEM_DESC';

export type GenderType =
  | 'MEN'
  | 'UNSPECIFIED'
  | 'WOMAN';

export type Location = {
  __typename?: 'Location';
  description: Scalars['JSON']['output'];
  id: Scalars['BigInt']['output'];
  /** Reads and enables pagination through a set of `LocationAttachment`. */
  locationAttachments: LocationAttachmentsConnection;
  name: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Room`. */
  roomsByLocation: RoomsConnection;
  /** Reads and enables pagination through a set of `TenantLocation`. */
  tenantLocations: TenantLocationsConnection;
};


export type LocationLocationAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LocationAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LocationAttachmentsOrderBy>>;
};


export type LocationRoomsByLocationArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomsOrderBy>>;
};


export type LocationTenantLocationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TenantLocationCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TenantLocationsOrderBy>>;
};

export type LocationAttachment = {
  __typename?: 'LocationAttachment';
  /** Reads a single `Attachment` that is related to this `LocationAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /** Reads a single `Location` that is related to this `LocationAttachment`. */
  location: Maybe<Location>;
  locationId: Scalars['BigInt']['output'];
  objectName: Scalars['String']['output'];
};

/**
 * A condition to be used against `LocationAttachment` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type LocationAttachmentCondition = {
  /** Checks for equality with the object’s `locationId` field. */
  locationId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `objectName` field. */
  objectName?: InputMaybe<Scalars['String']['input']>;
};

/** An input for mutations affecting `LocationAttachment` */
export type LocationAttachmentInput = {
  locationId: Scalars['BigInt']['input'];
  objectName: Scalars['String']['input'];
};

/** Represents an update to a `LocationAttachment`. Fields that are set will be updated. */
export type LocationAttachmentPatch = {
  locationId?: InputMaybe<Scalars['BigInt']['input']>;
  objectName?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `LocationAttachment` values. */
export type LocationAttachmentsConnection = {
  __typename?: 'LocationAttachmentsConnection';
  /** A list of edges which contains the `LocationAttachment` and cursor to aid in pagination. */
  edges: Array<LocationAttachmentsEdge>;
  /** A list of `LocationAttachment` objects. */
  nodes: Array<LocationAttachment>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `LocationAttachment` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `LocationAttachment` edge in the connection. */
export type LocationAttachmentsEdge = {
  __typename?: 'LocationAttachmentsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `LocationAttachment` at the end of the edge. */
  node: LocationAttachment;
};

/** Methods to use when ordering `LocationAttachment`. */
export type LocationAttachmentsOrderBy =
  | 'ATTACHMENT_BY_OBJECT_NAME__OBJECT_NAME_ASC'
  | 'ATTACHMENT_BY_OBJECT_NAME__OBJECT_NAME_DESC'
  | 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_BY_ASC'
  | 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_BY_DESC'
  | 'LOCATION_BY_LOCATION_ID__ID_ASC'
  | 'LOCATION_BY_LOCATION_ID__ID_DESC'
  | 'LOCATION_ID_ASC'
  | 'LOCATION_ID_DESC'
  | 'NATURAL'
  | 'OBJECT_NAME_ASC'
  | 'OBJECT_NAME_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Location` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type LocationCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `Location` */
export type LocationInput = {
  description: Scalars['JSON']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  name: Scalars['String']['input'];
};

/** Represents an update to a `Location`. Fields that are set will be updated. */
export type LocationPatch = {
  description?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `Location` values. */
export type LocationsConnection = {
  __typename?: 'LocationsConnection';
  /** A list of edges which contains the `Location` and cursor to aid in pagination. */
  edges: Array<LocationsEdge>;
  /** A list of `Location` objects. */
  nodes: Array<Location>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Location` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Location` edge in the connection. */
export type LocationsEdge = {
  __typename?: 'LocationsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Location` at the end of the edge. */
  node: Location;
};

/** Methods to use when ordering `Location`. */
export type LocationsOrderBy =
  | 'ID_ASC'
  | 'ID_DESC'
  | 'LOCATION_ATTACHMENTS_BY_LOCATION_ID__COUNT_ASC'
  | 'LOCATION_ATTACHMENTS_BY_LOCATION_ID__COUNT_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'ROOMS_BY_LOCATION__COUNT_ASC'
  | 'ROOMS_BY_LOCATION__COUNT_DESC'
  | 'TENANT_LOCATIONS_BY_LOCATION_ID__COUNT_ASC'
  | 'TENANT_LOCATIONS_BY_LOCATION_ID__COUNT_DESC';

/** All input for the `login` mutation. */
export type LoginInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  login: Scalars['String']['input'];
  passwd: Scalars['String']['input'];
};

/** The output of our `login` mutation. */
export type LoginPayload = {
  __typename?: 'LoginPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  result: Maybe<LoginRecord>;
};

/** The return type of our `login` mutation. */
export type LoginRecord = {
  __typename?: 'LoginRecord';
  couple: Maybe<Pary>;
  sess: Maybe<Session>;
  usr: Maybe<User>;
};

/** All input for the `logout` mutation. */
export type LogoutInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our `logout` mutation. */
export type LogoutPayload = {
  __typename?: 'LogoutPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  __typename?: 'Mutation';
  bookLesson: Maybe<BookLessonPayload>;
  cancelLesson: Maybe<CancelLessonPayload>;
  cancelParticipation: Maybe<CancelParticipationPayload>;
  changePassword: Maybe<ChangePasswordPayload>;
  confirmUser: Maybe<ConfirmUserPayload>;
  /** Creates a single `Akce`. */
  createAkce: Maybe<CreateAkcePayload>;
  /** Creates a single `AkceItem`. */
  createAkceItem: Maybe<CreateAkceItemPayload>;
  /** Creates a single `Aktuality`. */
  createAktuality: Maybe<CreateAktualityPayload>;
  /** Creates a single `Attachment`. */
  createAttachment: Maybe<CreateAttachmentPayload>;
  /** Creates a single `AttendeeExternal`. */
  createAttendeeExternal: Maybe<CreateAttendeeExternalPayload>;
  /** Creates a single `AttendeeUser`. */
  createAttendeeUser: Maybe<CreateAttendeeUserPayload>;
  /** Creates a single `CohortGroup`. */
  createCohortGroup: Maybe<CreateCohortGroupPayload>;
  createCouple: Maybe<CreateCouplePayload>;
  /** Creates a single `Dokumenty`. */
  createDokumenty: Maybe<CreateDokumentyPayload>;
  /** Creates a single `Event`. */
  createEvent: Maybe<CreateEventPayload>;
  /** Creates a single `FormResponse`. */
  createFormResponse: Maybe<CreateFormResponsePayload>;
  /** Creates a single `GalerieDir`. */
  createGalerieDir: Maybe<CreateGalerieDirPayload>;
  /** Creates a single `GalerieFoto`. */
  createGalerieFoto: Maybe<CreateGalerieFotoPayload>;
  /** Creates a single `Location`. */
  createLocation: Maybe<CreateLocationPayload>;
  /** Creates a single `LocationAttachment`. */
  createLocationAttachment: Maybe<CreateLocationAttachmentPayload>;
  /** Creates a single `Nabidka`. */
  createNabidka: Maybe<CreateNabidkaPayload>;
  /** Creates a single `NabidkaItem`. */
  createNabidkaItem: Maybe<CreateNabidkaItemPayload>;
  /** Creates a single `Page`. */
  createPage: Maybe<CreatePagePayload>;
  /** Creates a single `Parameter`. */
  createParameter: Maybe<CreateParameterPayload>;
  createParticipation: Maybe<CreateParticipationPayload>;
  createParticipationExternal: Maybe<CreateParticipationExternalPayload>;
  /** Creates a single `Pary`. */
  createPary: Maybe<CreateParyPayload>;
  /** Creates a single `ParyNavrh`. */
  createParyNavrh: Maybe<CreateParyNavrhPayload>;
  /** Creates a single `Permission`. */
  createPermission: Maybe<CreatePermissionPayload>;
  /** Creates a single `Person`. */
  createPerson: Maybe<CreatePersonPayload>;
  /** Creates a single `PlatbyCategory`. */
  createPlatbyCategory: Maybe<CreatePlatbyCategoryPayload>;
  /** Creates a single `PlatbyCategoryGroup`. */
  createPlatbyCategoryGroup: Maybe<CreatePlatbyCategoryGroupPayload>;
  /** Creates a single `PlatbyGroup`. */
  createPlatbyGroup: Maybe<CreatePlatbyGroupPayload>;
  /** Creates a single `PlatbyGroupSkupina`. */
  createPlatbyGroupSkupina: Maybe<CreatePlatbyGroupSkupinaPayload>;
  /** Creates a single `PlatbyItem`. */
  createPlatbyItem: Maybe<CreatePlatbyItemPayload>;
  /** Creates a single `PlatbyRaw`. */
  createPlatbyRaw: Maybe<CreatePlatbyRawPayload>;
  /** Creates a single `Room`. */
  createRoom: Maybe<CreateRoomPayload>;
  /** Creates a single `RoomAttachment`. */
  createRoomAttachment: Maybe<CreateRoomAttachmentPayload>;
  /** Creates a single `Rozpi`. */
  createRozpi: Maybe<CreateRozpiPayload>;
  /** Creates a single `RozpisItem`. */
  createRozpisItem: Maybe<CreateRozpisItemPayload>;
  /** Creates a single `Skupiny`. */
  createSkupiny: Maybe<CreateSkupinyPayload>;
  /** Creates a single `Tenant`. */
  createTenant: Maybe<CreateTenantPayload>;
  /** Creates a single `TenantAttachment`. */
  createTenantAttachment: Maybe<CreateTenantAttachmentPayload>;
  /** Creates a single `TenantLocation`. */
  createTenantLocation: Maybe<CreateTenantLocationPayload>;
  /** Creates a single `TenantPerson`. */
  createTenantPerson: Maybe<CreateTenantPersonPayload>;
  /** Creates a single `Upozorneni`. */
  createUpozorneni: Maybe<CreateUpozorneniPayload>;
  /** Creates a single `UpozorneniSkupiny`. */
  createUpozorneniSkupiny: Maybe<CreateUpozorneniSkupinyPayload>;
  /** Creates a single `User`. */
  createUser: Maybe<CreateUserPayload>;
  /** Deletes a single `Aktuality` using a unique key. */
  deleteAktuality: Maybe<DeleteAktualityPayload>;
  /** Deletes a single `Attachment` using a unique key. */
  deleteAttachment: Maybe<DeleteAttachmentPayload>;
  /** Deletes a single `AttendeeExternal` using a unique key. */
  deleteAttendeeExternal: Maybe<DeleteAttendeeExternalPayload>;
  /** Deletes a single `AttendeeUser` using a unique key. */
  deleteAttendeeUser: Maybe<DeleteAttendeeUserPayload>;
  /** Deletes a single `AttendeeUser` using a unique key. */
  deleteAttendeeUserByUserIdAndEventId: Maybe<DeleteAttendeeUserPayload>;
  /** Deletes a single `CohortGroup` using a unique key. */
  deleteCohortGroup: Maybe<DeleteCohortGroupPayload>;
  /** Deletes a single `Dokumenty` using a unique key. */
  deleteDokumenty: Maybe<DeleteDokumentyPayload>;
  /** Deletes a single `Event` using a unique key. */
  deleteEvent: Maybe<DeleteEventPayload>;
  /** Deletes a single `FormResponse` using a unique key. */
  deleteFormResponse: Maybe<DeleteFormResponsePayload>;
  /** Deletes a single `GalerieDir` using a unique key. */
  deleteGalerieDir: Maybe<DeleteGalerieDirPayload>;
  /** Deletes a single `GalerieFoto` using a unique key. */
  deleteGalerieFoto: Maybe<DeleteGalerieFotoPayload>;
  /** Deletes a single `Location` using a unique key. */
  deleteLocation: Maybe<DeleteLocationPayload>;
  /** Deletes a single `LocationAttachment` using a unique key. */
  deleteLocationAttachment: Maybe<DeleteLocationAttachmentPayload>;
  /** Deletes a single `Nabidka` using a unique key. */
  deleteNabidka: Maybe<DeleteNabidkaPayload>;
  /** Deletes a single `NabidkaItem` using a unique key. */
  deleteNabidkaItem: Maybe<DeleteNabidkaItemPayload>;
  /** Deletes a single `NabidkaItem` using a unique key. */
  deleteNabidkaItemByNiPartnerAndNiIdRodic: Maybe<DeleteNabidkaItemPayload>;
  /** Deletes a single `Parameter` using a unique key. */
  deleteParameter: Maybe<DeleteParameterPayload>;
  /** Deletes a single `Pary` using a unique key. */
  deletePary: Maybe<DeleteParyPayload>;
  /** Deletes a single `ParyNavrh` using a unique key. */
  deleteParyNavrh: Maybe<DeleteParyNavrhPayload>;
  /** Deletes a single `Permission` using a unique key. */
  deletePermission: Maybe<DeletePermissionPayload>;
  /** Deletes a single `Person` using a unique key. */
  deletePerson: Maybe<DeletePersonPayload>;
  /** Deletes a single `PlatbyCategory` using a unique key. */
  deletePlatbyCategory: Maybe<DeletePlatbyCategoryPayload>;
  /** Deletes a single `PlatbyCategoryGroup` using a unique key. */
  deletePlatbyCategoryGroup: Maybe<DeletePlatbyCategoryGroupPayload>;
  /** Deletes a single `PlatbyGroup` using a unique key. */
  deletePlatbyGroup: Maybe<DeletePlatbyGroupPayload>;
  /** Deletes a single `PlatbyGroupSkupina` using a unique key. */
  deletePlatbyGroupSkupina: Maybe<DeletePlatbyGroupSkupinaPayload>;
  /** Deletes a single `PlatbyItem` using a unique key. */
  deletePlatbyItem: Maybe<DeletePlatbyItemPayload>;
  /** Deletes a single `PlatbyRaw` using a unique key. */
  deletePlatbyRaw: Maybe<DeletePlatbyRawPayload>;
  /** Deletes a single `Room` using a unique key. */
  deleteRoom: Maybe<DeleteRoomPayload>;
  /** Deletes a single `RoomAttachment` using a unique key. */
  deleteRoomAttachment: Maybe<DeleteRoomAttachmentPayload>;
  /** Deletes a single `Rozpi` using a unique key. */
  deleteRozpi: Maybe<DeleteRozpiPayload>;
  /** Deletes a single `RozpisItem` using a unique key. */
  deleteRozpisItem: Maybe<DeleteRozpisItemPayload>;
  /** Deletes a single `Skupiny` using a unique key. */
  deleteSkupiny: Maybe<DeleteSkupinyPayload>;
  /** Deletes a single `Tenant` using a unique key. */
  deleteTenant: Maybe<DeleteTenantPayload>;
  /** Deletes a single `TenantAttachment` using a unique key. */
  deleteTenantAttachment: Maybe<DeleteTenantAttachmentPayload>;
  /** Deletes a single `TenantLocation` using a unique key. */
  deleteTenantLocation: Maybe<DeleteTenantLocationPayload>;
  /** Deletes a single `TenantPerson` using a unique key. */
  deleteTenantPerson: Maybe<DeleteTenantPersonPayload>;
  /** Deletes a single `Upozorneni` using a unique key. */
  deleteUpozorneni: Maybe<DeleteUpozorneniPayload>;
  /** Deletes a single `UpozorneniSkupiny` using a unique key. */
  deleteUpozorneniSkupiny: Maybe<DeleteUpozorneniSkupinyPayload>;
  /** Deletes a single `User` using a unique key. */
  deleteUser: Maybe<DeleteUserPayload>;
  fixUnpairedCouples: Maybe<FixUnpairedCouplesPayload>;
  login: Maybe<LoginPayload>;
  logout: Maybe<LogoutPayload>;
  prospectFormDancer: Maybe<ProspectFormDancerPayload>;
  reservationSetDesiredLessons: Maybe<ReservationSetDesiredLessonsPayload>;
  resetPassword: Maybe<ResetPasswordPayload>;
  submitForm: Maybe<SubmitFormPayload>;
  /** Updates a single `Aktuality` using a unique key and a patch. */
  updateAktuality: Maybe<UpdateAktualityPayload>;
  /** Updates a single `Attachment` using a unique key and a patch. */
  updateAttachment: Maybe<UpdateAttachmentPayload>;
  /** Updates a single `AttendeeExternal` using a unique key and a patch. */
  updateAttendeeExternal: Maybe<UpdateAttendeeExternalPayload>;
  /** Updates a single `AttendeeUser` using a unique key and a patch. */
  updateAttendeeUser: Maybe<UpdateAttendeeUserPayload>;
  /** Updates a single `AttendeeUser` using a unique key and a patch. */
  updateAttendeeUserByUserIdAndEventId: Maybe<UpdateAttendeeUserPayload>;
  /** Updates a single `CohortGroup` using a unique key and a patch. */
  updateCohortGroup: Maybe<UpdateCohortGroupPayload>;
  /** Updates a single `Dokumenty` using a unique key and a patch. */
  updateDokumenty: Maybe<UpdateDokumentyPayload>;
  /** Updates a single `Event` using a unique key and a patch. */
  updateEvent: Maybe<UpdateEventPayload>;
  /** Updates a single `FormResponse` using a unique key and a patch. */
  updateFormResponse: Maybe<UpdateFormResponsePayload>;
  /** Updates a single `GalerieDir` using a unique key and a patch. */
  updateGalerieDir: Maybe<UpdateGalerieDirPayload>;
  /** Updates a single `GalerieFoto` using a unique key and a patch. */
  updateGalerieFoto: Maybe<UpdateGalerieFotoPayload>;
  /** Updates a single `Location` using a unique key and a patch. */
  updateLocation: Maybe<UpdateLocationPayload>;
  /** Updates a single `LocationAttachment` using a unique key and a patch. */
  updateLocationAttachment: Maybe<UpdateLocationAttachmentPayload>;
  /** Updates a single `Nabidka` using a unique key and a patch. */
  updateNabidka: Maybe<UpdateNabidkaPayload>;
  /** Updates a single `NabidkaItem` using a unique key and a patch. */
  updateNabidkaItem: Maybe<UpdateNabidkaItemPayload>;
  /** Updates a single `NabidkaItem` using a unique key and a patch. */
  updateNabidkaItemByNiPartnerAndNiIdRodic: Maybe<UpdateNabidkaItemPayload>;
  /** Updates a single `Page` using a unique key and a patch. */
  updatePage: Maybe<UpdatePagePayload>;
  /** Updates a single `Page` using a unique key and a patch. */
  updatePageByUrl: Maybe<UpdatePagePayload>;
  /** Updates a single `Parameter` using a unique key and a patch. */
  updateParameter: Maybe<UpdateParameterPayload>;
  /** Updates a single `Pary` using a unique key and a patch. */
  updatePary: Maybe<UpdateParyPayload>;
  /** Updates a single `ParyNavrh` using a unique key and a patch. */
  updateParyNavrh: Maybe<UpdateParyNavrhPayload>;
  /** Updates a single `Permission` using a unique key and a patch. */
  updatePermission: Maybe<UpdatePermissionPayload>;
  /** Updates a single `Person` using a unique key and a patch. */
  updatePerson: Maybe<UpdatePersonPayload>;
  /** Updates a single `PlatbyCategory` using a unique key and a patch. */
  updatePlatbyCategory: Maybe<UpdatePlatbyCategoryPayload>;
  /** Updates a single `PlatbyCategoryGroup` using a unique key and a patch. */
  updatePlatbyCategoryGroup: Maybe<UpdatePlatbyCategoryGroupPayload>;
  /** Updates a single `PlatbyGroup` using a unique key and a patch. */
  updatePlatbyGroup: Maybe<UpdatePlatbyGroupPayload>;
  /** Updates a single `PlatbyGroupSkupina` using a unique key and a patch. */
  updatePlatbyGroupSkupina: Maybe<UpdatePlatbyGroupSkupinaPayload>;
  /** Updates a single `PlatbyItem` using a unique key and a patch. */
  updatePlatbyItem: Maybe<UpdatePlatbyItemPayload>;
  /** Updates a single `PlatbyRaw` using a unique key and a patch. */
  updatePlatbyRaw: Maybe<UpdatePlatbyRawPayload>;
  /** Updates a single `Room` using a unique key and a patch. */
  updateRoom: Maybe<UpdateRoomPayload>;
  /** Updates a single `RoomAttachment` using a unique key and a patch. */
  updateRoomAttachment: Maybe<UpdateRoomAttachmentPayload>;
  /** Updates a single `Rozpi` using a unique key and a patch. */
  updateRozpi: Maybe<UpdateRozpiPayload>;
  /** Updates a single `RozpisItem` using a unique key and a patch. */
  updateRozpisItem: Maybe<UpdateRozpisItemPayload>;
  /** Updates a single `Skupiny` using a unique key and a patch. */
  updateSkupiny: Maybe<UpdateSkupinyPayload>;
  /** Updates a single `Tenant` using a unique key and a patch. */
  updateTenant: Maybe<UpdateTenantPayload>;
  /** Updates a single `TenantAttachment` using a unique key and a patch. */
  updateTenantAttachment: Maybe<UpdateTenantAttachmentPayload>;
  /** Updates a single `TenantLocation` using a unique key and a patch. */
  updateTenantLocation: Maybe<UpdateTenantLocationPayload>;
  /** Updates a single `TenantPerson` using a unique key and a patch. */
  updateTenantPerson: Maybe<UpdateTenantPersonPayload>;
  /** Updates a single `Upozorneni` using a unique key and a patch. */
  updateUpozorneni: Maybe<UpdateUpozorneniPayload>;
  /** Updates a single `UpozorneniSkupiny` using a unique key and a patch. */
  updateUpozorneniSkupiny: Maybe<UpdateUpozorneniSkupinyPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUser: Maybe<UpdateUserPayload>;
  verifyFunction: Maybe<VerifyFunctionPayload>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBookLessonArgs = {
  input: BookLessonInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCancelLessonArgs = {
  input: CancelLessonInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCancelParticipationArgs = {
  input: CancelParticipationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationChangePasswordArgs = {
  input: ChangePasswordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationConfirmUserArgs = {
  input: ConfirmUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAkceArgs = {
  input: CreateAkceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAkceItemArgs = {
  input: CreateAkceItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAktualityArgs = {
  input: CreateAktualityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAttachmentArgs = {
  input: CreateAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAttendeeExternalArgs = {
  input: CreateAttendeeExternalInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAttendeeUserArgs = {
  input: CreateAttendeeUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCohortGroupArgs = {
  input: CreateCohortGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCoupleArgs = {
  input: CreateCoupleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDokumentyArgs = {
  input: CreateDokumentyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEventArgs = {
  input: CreateEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFormResponseArgs = {
  input: CreateFormResponseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGalerieDirArgs = {
  input: CreateGalerieDirInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGalerieFotoArgs = {
  input: CreateGalerieFotoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLocationArgs = {
  input: CreateLocationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLocationAttachmentArgs = {
  input: CreateLocationAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateNabidkaArgs = {
  input: CreateNabidkaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateNabidkaItemArgs = {
  input: CreateNabidkaItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePageArgs = {
  input: CreatePageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateParameterArgs = {
  input: CreateParameterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateParticipationArgs = {
  input: CreateParticipationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateParticipationExternalArgs = {
  input: CreateParticipationExternalInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateParyArgs = {
  input: CreateParyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateParyNavrhArgs = {
  input: CreateParyNavrhInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePermissionArgs = {
  input: CreatePermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePersonArgs = {
  input: CreatePersonInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlatbyCategoryArgs = {
  input: CreatePlatbyCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlatbyCategoryGroupArgs = {
  input: CreatePlatbyCategoryGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlatbyGroupArgs = {
  input: CreatePlatbyGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlatbyGroupSkupinaArgs = {
  input: CreatePlatbyGroupSkupinaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlatbyItemArgs = {
  input: CreatePlatbyItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlatbyRawArgs = {
  input: CreatePlatbyRawInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRoomArgs = {
  input: CreateRoomInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRoomAttachmentArgs = {
  input: CreateRoomAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRozpiArgs = {
  input: CreateRozpiInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRozpisItemArgs = {
  input: CreateRozpisItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSkupinyArgs = {
  input: CreateSkupinyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTenantArgs = {
  input: CreateTenantInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTenantAttachmentArgs = {
  input: CreateTenantAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTenantLocationArgs = {
  input: CreateTenantLocationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTenantPersonArgs = {
  input: CreateTenantPersonInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUpozorneniArgs = {
  input: CreateUpozorneniInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUpozorneniSkupinyArgs = {
  input: CreateUpozorneniSkupinyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserArgs = {
  input: CreateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAktualityArgs = {
  input: DeleteAktualityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAttachmentArgs = {
  input: DeleteAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAttendeeExternalArgs = {
  input: DeleteAttendeeExternalInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAttendeeUserArgs = {
  input: DeleteAttendeeUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAttendeeUserByUserIdAndEventIdArgs = {
  input: DeleteAttendeeUserByUserIdAndEventIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCohortGroupArgs = {
  input: DeleteCohortGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDokumentyArgs = {
  input: DeleteDokumentyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEventArgs = {
  input: DeleteEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFormResponseArgs = {
  input: DeleteFormResponseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGalerieDirArgs = {
  input: DeleteGalerieDirInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGalerieFotoArgs = {
  input: DeleteGalerieFotoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLocationArgs = {
  input: DeleteLocationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLocationAttachmentArgs = {
  input: DeleteLocationAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNabidkaArgs = {
  input: DeleteNabidkaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNabidkaItemArgs = {
  input: DeleteNabidkaItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNabidkaItemByNiPartnerAndNiIdRodicArgs = {
  input: DeleteNabidkaItemByNiPartnerAndNiIdRodicInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteParameterArgs = {
  input: DeleteParameterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteParyArgs = {
  input: DeleteParyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteParyNavrhArgs = {
  input: DeleteParyNavrhInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePermissionArgs = {
  input: DeletePermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePersonArgs = {
  input: DeletePersonInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyCategoryArgs = {
  input: DeletePlatbyCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyCategoryGroupArgs = {
  input: DeletePlatbyCategoryGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyGroupArgs = {
  input: DeletePlatbyGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyGroupSkupinaArgs = {
  input: DeletePlatbyGroupSkupinaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyItemArgs = {
  input: DeletePlatbyItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlatbyRawArgs = {
  input: DeletePlatbyRawInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoomArgs = {
  input: DeleteRoomInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoomAttachmentArgs = {
  input: DeleteRoomAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRozpiArgs = {
  input: DeleteRozpiInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRozpisItemArgs = {
  input: DeleteRozpisItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSkupinyArgs = {
  input: DeleteSkupinyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTenantArgs = {
  input: DeleteTenantInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTenantAttachmentArgs = {
  input: DeleteTenantAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTenantLocationArgs = {
  input: DeleteTenantLocationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTenantPersonArgs = {
  input: DeleteTenantPersonInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUpozorneniArgs = {
  input: DeleteUpozorneniInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUpozorneniSkupinyArgs = {
  input: DeleteUpozorneniSkupinyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserArgs = {
  input: DeleteUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationFixUnpairedCouplesArgs = {
  input: FixUnpairedCouplesInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationLoginArgs = {
  input: LoginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationLogoutArgs = {
  input: LogoutInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationProspectFormDancerArgs = {
  input: ProspectFormDancerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationReservationSetDesiredLessonsArgs = {
  input: ReservationSetDesiredLessonsInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationResetPasswordArgs = {
  input: ResetPasswordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationSubmitFormArgs = {
  input: SubmitFormInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAktualityArgs = {
  input: UpdateAktualityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAttachmentArgs = {
  input: UpdateAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAttendeeExternalArgs = {
  input: UpdateAttendeeExternalInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAttendeeUserArgs = {
  input: UpdateAttendeeUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAttendeeUserByUserIdAndEventIdArgs = {
  input: UpdateAttendeeUserByUserIdAndEventIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCohortGroupArgs = {
  input: UpdateCohortGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDokumentyArgs = {
  input: UpdateDokumentyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEventArgs = {
  input: UpdateEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFormResponseArgs = {
  input: UpdateFormResponseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGalerieDirArgs = {
  input: UpdateGalerieDirInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGalerieFotoArgs = {
  input: UpdateGalerieFotoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLocationArgs = {
  input: UpdateLocationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLocationAttachmentArgs = {
  input: UpdateLocationAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNabidkaArgs = {
  input: UpdateNabidkaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNabidkaItemArgs = {
  input: UpdateNabidkaItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNabidkaItemByNiPartnerAndNiIdRodicArgs = {
  input: UpdateNabidkaItemByNiPartnerAndNiIdRodicInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePageArgs = {
  input: UpdatePageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePageByUrlArgs = {
  input: UpdatePageByUrlInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateParameterArgs = {
  input: UpdateParameterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateParyArgs = {
  input: UpdateParyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateParyNavrhArgs = {
  input: UpdateParyNavrhInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePermissionArgs = {
  input: UpdatePermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePersonArgs = {
  input: UpdatePersonInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyCategoryArgs = {
  input: UpdatePlatbyCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyCategoryGroupArgs = {
  input: UpdatePlatbyCategoryGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyGroupArgs = {
  input: UpdatePlatbyGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyGroupSkupinaArgs = {
  input: UpdatePlatbyGroupSkupinaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyItemArgs = {
  input: UpdatePlatbyItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlatbyRawArgs = {
  input: UpdatePlatbyRawInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoomArgs = {
  input: UpdateRoomInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoomAttachmentArgs = {
  input: UpdateRoomAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRozpiArgs = {
  input: UpdateRozpiInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRozpisItemArgs = {
  input: UpdateRozpisItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSkupinyArgs = {
  input: UpdateSkupinyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTenantArgs = {
  input: UpdateTenantInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTenantAttachmentArgs = {
  input: UpdateTenantAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTenantLocationArgs = {
  input: UpdateTenantLocationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTenantPersonArgs = {
  input: UpdateTenantPersonInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUpozorneniArgs = {
  input: UpdateUpozorneniInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUpozorneniSkupinyArgs = {
  input: UpdateUpozorneniSkupinyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserArgs = {
  input: UpdateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationVerifyFunctionArgs = {
  input: VerifyFunctionInput;
};

export type Nabidka = {
  __typename?: 'Nabidka';
  freeLessons: Maybe<Scalars['Int']['output']>;
  id: Maybe<Scalars['BigInt']['output']>;
  myLessons: Maybe<Scalars['Int']['output']>;
  nDo: Scalars['Date']['output'];
  nId: Scalars['BigInt']['output'];
  nLock: Scalars['Boolean']['output'];
  nMaxPocetHod: Scalars['Int']['output'];
  nOd: Scalars['Date']['output'];
  nPocetHod: Scalars['Int']['output'];
  nTimestamp: Maybe<Scalars['Datetime']['output']>;
  nTrener: Scalars['BigInt']['output'];
  nVisible: Scalars['Boolean']['output'];
  /** Reads and enables pagination through a set of `NabidkaItem`. */
  nabidkaItemsByNiIdRodic: NabidkaItemsConnection;
  tenantId: Scalars['BigInt']['output'];
  /** Reads a single `User` that is related to this `Nabidka`. */
  userByNTrener: Maybe<User>;
};


export type NabidkaNabidkaItemsByNiIdRodicArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<NabidkaItemCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NabidkaItemsOrderBy>>;
};

/** A condition to be used against `Nabidka` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type NabidkaCondition = {
  /** Checks for equality with the object’s `nId` field. */
  nId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `nOd` field. */
  nOd?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `nTrener` field. */
  nTrener?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `Nabidka` */
export type NabidkaInput = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  nDo: Scalars['Date']['input'];
  nId?: InputMaybe<Scalars['BigInt']['input']>;
  nLock?: InputMaybe<Scalars['Boolean']['input']>;
  nMaxPocetHod?: InputMaybe<Scalars['Int']['input']>;
  nOd: Scalars['Date']['input'];
  nPocetHod?: InputMaybe<Scalars['Int']['input']>;
  nTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
  nTrener: Scalars['BigInt']['input'];
  nVisible?: InputMaybe<Scalars['Boolean']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

export type NabidkaItem = {
  __typename?: 'NabidkaItem';
  id: Maybe<Scalars['BigInt']['output']>;
  /** Reads a single `Nabidka` that is related to this `NabidkaItem`. */
  nabidkaByNiIdRodic: Maybe<Nabidka>;
  niId: Scalars['BigInt']['output'];
  niIdRodic: Scalars['BigInt']['output'];
  niLock: Scalars['Boolean']['output'];
  niPartner: Scalars['BigInt']['output'];
  niPocetHod: Scalars['Int']['output'];
  /** Reads a single `Pary` that is related to this `NabidkaItem`. */
  paryByNiPartner: Maybe<Pary>;
  tenantId: Scalars['BigInt']['output'];
};

/**
 * A condition to be used against `NabidkaItem` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type NabidkaItemCondition = {
  /** Checks for equality with the object’s `niId` field. */
  niId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `niIdRodic` field. */
  niIdRodic?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `niPartner` field. */
  niPartner?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `NabidkaItem` */
export type NabidkaItemInput = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  niId?: InputMaybe<Scalars['BigInt']['input']>;
  niIdRodic: Scalars['BigInt']['input'];
  niLock?: InputMaybe<Scalars['Boolean']['input']>;
  niPartner: Scalars['BigInt']['input'];
  niPocetHod?: InputMaybe<Scalars['Int']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Represents an update to a `NabidkaItem`. Fields that are set will be updated. */
export type NabidkaItemPatch = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  niId?: InputMaybe<Scalars['BigInt']['input']>;
  niIdRodic?: InputMaybe<Scalars['BigInt']['input']>;
  niLock?: InputMaybe<Scalars['Boolean']['input']>;
  niPartner?: InputMaybe<Scalars['BigInt']['input']>;
  niPocetHod?: InputMaybe<Scalars['Int']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `NabidkaItem` values. */
export type NabidkaItemsConnection = {
  __typename?: 'NabidkaItemsConnection';
  /** A list of edges which contains the `NabidkaItem` and cursor to aid in pagination. */
  edges: Array<NabidkaItemsEdge>;
  /** A list of `NabidkaItem` objects. */
  nodes: Array<NabidkaItem>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `NabidkaItem` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `NabidkaItem` edge in the connection. */
export type NabidkaItemsEdge = {
  __typename?: 'NabidkaItemsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `NabidkaItem` at the end of the edge. */
  node: NabidkaItem;
};

/** Methods to use when ordering `NabidkaItem`. */
export type NabidkaItemsOrderBy =
  | 'NABIDKA_BY_NI_ID_RODIC__N_ID_ASC'
  | 'NABIDKA_BY_NI_ID_RODIC__N_ID_DESC'
  | 'NABIDKA_BY_NI_ID_RODIC__N_OD_ASC'
  | 'NABIDKA_BY_NI_ID_RODIC__N_OD_DESC'
  | 'NABIDKA_BY_NI_ID_RODIC__N_TRENER_ASC'
  | 'NABIDKA_BY_NI_ID_RODIC__N_TRENER_DESC'
  | 'NATURAL'
  | 'NI_ID_ASC'
  | 'NI_ID_DESC'
  | 'NI_ID_RODIC_ASC'
  | 'NI_ID_RODIC_DESC'
  | 'NI_PARTNER_ASC'
  | 'NI_PARTNER_DESC'
  | 'PARY_BY_NI_PARTNER__P_HODNOCENI_ASC'
  | 'PARY_BY_NI_PARTNER__P_HODNOCENI_DESC'
  | 'PARY_BY_NI_PARTNER__P_ID_ASC'
  | 'PARY_BY_NI_PARTNER__P_ID_DESC'
  | 'PARY_BY_NI_PARTNER__P_ID_PARTNERKA_ASC'
  | 'PARY_BY_NI_PARTNER__P_ID_PARTNERKA_DESC'
  | 'PARY_BY_NI_PARTNER__P_ID_PARTNER_ASC'
  | 'PARY_BY_NI_PARTNER__P_ID_PARTNER_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** Represents an update to a `Nabidka`. Fields that are set will be updated. */
export type NabidkaPatch = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  nDo?: InputMaybe<Scalars['Date']['input']>;
  nId?: InputMaybe<Scalars['BigInt']['input']>;
  nLock?: InputMaybe<Scalars['Boolean']['input']>;
  nMaxPocetHod?: InputMaybe<Scalars['Int']['input']>;
  nOd?: InputMaybe<Scalars['Date']['input']>;
  nPocetHod?: InputMaybe<Scalars['Int']['input']>;
  nTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
  nTrener?: InputMaybe<Scalars['BigInt']['input']>;
  nVisible?: InputMaybe<Scalars['Boolean']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `Nabidka` values. */
export type NabidkasConnection = {
  __typename?: 'NabidkasConnection';
  /** A list of edges which contains the `Nabidka` and cursor to aid in pagination. */
  edges: Array<NabidkasEdge>;
  /** A list of `Nabidka` objects. */
  nodes: Array<Nabidka>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Nabidka` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Nabidka` edge in the connection. */
export type NabidkasEdge = {
  __typename?: 'NabidkasEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Nabidka` at the end of the edge. */
  node: Nabidka;
};

/** Methods to use when ordering `Nabidka`. */
export type NabidkasOrderBy =
  | 'NABIDKA_ITEMS_BY_NI_ID_RODIC__COUNT_ASC'
  | 'NABIDKA_ITEMS_BY_NI_ID_RODIC__COUNT_DESC'
  | 'NATURAL'
  | 'N_ID_ASC'
  | 'N_ID_DESC'
  | 'N_OD_ASC'
  | 'N_OD_DESC'
  | 'N_TRENER_ASC'
  | 'N_TRENER_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'USER_BY_N_TRENER__U_BAN_ASC'
  | 'USER_BY_N_TRENER__U_BAN_DESC'
  | 'USER_BY_N_TRENER__U_CONFIRMED_ASC'
  | 'USER_BY_N_TRENER__U_CONFIRMED_DESC'
  | 'USER_BY_N_TRENER__U_GROUP_ASC'
  | 'USER_BY_N_TRENER__U_GROUP_DESC'
  | 'USER_BY_N_TRENER__U_ID_ASC'
  | 'USER_BY_N_TRENER__U_ID_DESC'
  | 'USER_BY_N_TRENER__U_JMENO_ASC'
  | 'USER_BY_N_TRENER__U_JMENO_DESC'
  | 'USER_BY_N_TRENER__U_LOGIN_ASC'
  | 'USER_BY_N_TRENER__U_LOGIN_DESC'
  | 'USER_BY_N_TRENER__U_NAROZENI_ASC'
  | 'USER_BY_N_TRENER__U_NAROZENI_DESC'
  | 'USER_BY_N_TRENER__U_PRIJMENI_ASC'
  | 'USER_BY_N_TRENER__U_PRIJMENI_DESC'
  | 'USER_BY_N_TRENER__U_SKUPINA_ASC'
  | 'USER_BY_N_TRENER__U_SKUPINA_DESC'
  | 'USER_BY_N_TRENER__U_SYSTEM_ASC'
  | 'USER_BY_N_TRENER__U_SYSTEM_DESC';

export type Page = {
  __typename?: 'Page';
  content: Scalars['JSON']['output'];
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['Int']['output'];
  title: Scalars['String']['output'];
  updatedAt: Scalars['Datetime']['output'];
  url: Scalars['String']['output'];
};

/** A condition to be used against `Page` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PageCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `url` field. */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor: Maybe<Scalars['Cursor']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor: Maybe<Scalars['Cursor']['output']>;
};

/** An input for mutations affecting `Page` */
export type PageInput = {
  content: Scalars['JSON']['input'];
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  url: Scalars['String']['input'];
};

/** Represents an update to a `Page`. Fields that are set will be updated. */
export type PagePatch = {
  content?: InputMaybe<Scalars['JSON']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

export type PageRevision = {
  __typename?: 'PageRevision';
  content: Scalars['JSON']['output'];
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['Int']['output'];
  revNumber: Scalars['Int']['output'];
  revOperation: Scalars['String']['output'];
  revTimestamp: Maybe<Scalars['Datetime']['output']>;
  title: Scalars['String']['output'];
  updatedAt: Scalars['Datetime']['output'];
  url: Scalars['String']['output'];
};

/**
 * A condition to be used against `PageRevision` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PageRevisionCondition = {
  /** Checks for equality with the object’s `revNumber` field. */
  revNumber?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `PageRevision` values. */
export type PageRevisionsConnection = {
  __typename?: 'PageRevisionsConnection';
  /** A list of edges which contains the `PageRevision` and cursor to aid in pagination. */
  edges: Array<PageRevisionsEdge>;
  /** A list of `PageRevision` objects. */
  nodes: Array<PageRevision>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PageRevision` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PageRevision` edge in the connection. */
export type PageRevisionsEdge = {
  __typename?: 'PageRevisionsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `PageRevision` at the end of the edge. */
  node: PageRevision;
};

/** Methods to use when ordering `PageRevision`. */
export type PageRevisionsOrderBy =
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'REV_NUMBER_ASC'
  | 'REV_NUMBER_DESC';

/** A connection to a list of `Page` values. */
export type PagesConnection = {
  __typename?: 'PagesConnection';
  /** A list of edges which contains the `Page` and cursor to aid in pagination. */
  edges: Array<PagesEdge>;
  /** A list of `Page` objects. */
  nodes: Array<Page>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Page` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Page` edge in the connection. */
export type PagesEdge = {
  __typename?: 'PagesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Page` at the end of the edge. */
  node: Page;
};

/** Methods to use when ordering `Page`. */
export type PagesOrderBy =
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'URL_ASC'
  | 'URL_DESC';

export type Parameter = {
  __typename?: 'Parameter';
  paName: Scalars['String']['output'];
  paValue: Scalars['String']['output'];
};

/**
 * A condition to be used against `Parameter` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ParameterCondition = {
  /** Checks for equality with the object’s `paName` field. */
  paName?: InputMaybe<Scalars['String']['input']>;
};

/** An input for mutations affecting `Parameter` */
export type ParameterInput = {
  paName: Scalars['String']['input'];
  paValue: Scalars['String']['input'];
};

/** Represents an update to a `Parameter`. Fields that are set will be updated. */
export type ParameterPatch = {
  paName?: InputMaybe<Scalars['String']['input']>;
  paValue?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `Parameter` values. */
export type ParametersConnection = {
  __typename?: 'ParametersConnection';
  /** A list of edges which contains the `Parameter` and cursor to aid in pagination. */
  edges: Array<ParametersEdge>;
  /** A list of `Parameter` objects. */
  nodes: Array<Parameter>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Parameter` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Parameter` edge in the connection. */
export type ParametersEdge = {
  __typename?: 'ParametersEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Parameter` at the end of the edge. */
  node: Parameter;
};

/** Methods to use when ordering `Parameter`. */
export type ParametersOrderBy =
  | 'NATURAL'
  | 'PA_NAME_ASC'
  | 'PA_NAME_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A connection to a list of `Pary` values. */
export type PariesConnection = {
  __typename?: 'PariesConnection';
  /** A list of edges which contains the `Pary` and cursor to aid in pagination. */
  edges: Array<PariesEdge>;
  /** A list of `Pary` objects. */
  nodes: Array<Pary>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Pary` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Pary` edge in the connection. */
export type PariesEdge = {
  __typename?: 'PariesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Pary` at the end of the edge. */
  node: Pary;
};

/** Methods to use when ordering `Pary`. */
export type PariesOrderBy =
  | 'NABIDKA_ITEMS_BY_NI_PARTNER__COUNT_ASC'
  | 'NABIDKA_ITEMS_BY_NI_PARTNER__COUNT_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'P_HODNOCENI_ASC'
  | 'P_HODNOCENI_DESC'
  | 'P_ID_ASC'
  | 'P_ID_DESC'
  | 'P_ID_PARTNERKA_ASC'
  | 'P_ID_PARTNERKA_DESC'
  | 'P_ID_PARTNER_ASC'
  | 'P_ID_PARTNER_DESC'
  | 'ROZPIS_ITEMS_BY_RI_PARTNER__COUNT_ASC'
  | 'ROZPIS_ITEMS_BY_RI_PARTNER__COUNT_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_BAN_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_BAN_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_CONFIRMED_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_CONFIRMED_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_GROUP_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_GROUP_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_ID_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_ID_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_JMENO_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_JMENO_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_LOGIN_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_LOGIN_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_NAROZENI_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_NAROZENI_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_PRIJMENI_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_PRIJMENI_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_SKUPINA_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_SKUPINA_DESC'
  | 'USER_BY_P_ID_PARTNERKA__U_SYSTEM_ASC'
  | 'USER_BY_P_ID_PARTNERKA__U_SYSTEM_DESC'
  | 'USER_BY_P_ID_PARTNER__U_BAN_ASC'
  | 'USER_BY_P_ID_PARTNER__U_BAN_DESC'
  | 'USER_BY_P_ID_PARTNER__U_CONFIRMED_ASC'
  | 'USER_BY_P_ID_PARTNER__U_CONFIRMED_DESC'
  | 'USER_BY_P_ID_PARTNER__U_GROUP_ASC'
  | 'USER_BY_P_ID_PARTNER__U_GROUP_DESC'
  | 'USER_BY_P_ID_PARTNER__U_ID_ASC'
  | 'USER_BY_P_ID_PARTNER__U_ID_DESC'
  | 'USER_BY_P_ID_PARTNER__U_JMENO_ASC'
  | 'USER_BY_P_ID_PARTNER__U_JMENO_DESC'
  | 'USER_BY_P_ID_PARTNER__U_LOGIN_ASC'
  | 'USER_BY_P_ID_PARTNER__U_LOGIN_DESC'
  | 'USER_BY_P_ID_PARTNER__U_NAROZENI_ASC'
  | 'USER_BY_P_ID_PARTNER__U_NAROZENI_DESC'
  | 'USER_BY_P_ID_PARTNER__U_PRIJMENI_ASC'
  | 'USER_BY_P_ID_PARTNER__U_PRIJMENI_DESC'
  | 'USER_BY_P_ID_PARTNER__U_SKUPINA_ASC'
  | 'USER_BY_P_ID_PARTNER__U_SKUPINA_DESC'
  | 'USER_BY_P_ID_PARTNER__U_SYSTEM_ASC'
  | 'USER_BY_P_ID_PARTNER__U_SYSTEM_DESC';

export type Pary = {
  __typename?: 'Pary';
  id: Maybe<Scalars['BigInt']['output']>;
  /** Reads and enables pagination through a set of `NabidkaItem`. */
  nabidkaItemsByNiPartner: NabidkaItemsConnection;
  pArchiv: Scalars['Boolean']['output'];
  pHodnoceni: Scalars['Int']['output'];
  pId: Scalars['BigInt']['output'];
  pIdPartner: Scalars['BigInt']['output'];
  pIdPartnerka: Maybe<Scalars['BigInt']['output']>;
  pLatBody: Scalars['Int']['output'];
  pLatFinale: Scalars['Boolean']['output'];
  pLatTrida: ParyPLatTrida;
  pSttBody: Scalars['Int']['output'];
  pSttFinale: Scalars['Boolean']['output'];
  pSttTrida: ParyPSttTrida;
  pTimestampAdd: Scalars['Datetime']['output'];
  pTimestampArchive: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `RozpisItem`. */
  rozpisItemsByRiPartner: RozpisItemsConnection;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartnerka: Maybe<User>;
};


export type ParyNabidkaItemsByNiPartnerArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<NabidkaItemCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NabidkaItemsOrderBy>>;
};


export type ParyRozpisItemsByRiPartnerArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RozpisItemCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RozpisItemsOrderBy>>;
};

/** A condition to be used against `Pary` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ParyCondition = {
  /** Checks for equality with the object’s `pHodnoceni` field. */
  pHodnoceni?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `pId` field. */
  pId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `pIdPartner` field. */
  pIdPartner?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `pIdPartnerka` field. */
  pIdPartnerka?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `Pary` */
export type ParyInput = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  pArchiv?: InputMaybe<Scalars['Boolean']['input']>;
  pHodnoceni?: InputMaybe<Scalars['Int']['input']>;
  pId?: InputMaybe<Scalars['BigInt']['input']>;
  pIdPartner: Scalars['BigInt']['input'];
  pIdPartnerka?: InputMaybe<Scalars['BigInt']['input']>;
  pLatBody?: InputMaybe<Scalars['Int']['input']>;
  pLatFinale?: InputMaybe<Scalars['Boolean']['input']>;
  pLatTrida?: InputMaybe<ParyPLatTrida>;
  pSttBody?: InputMaybe<Scalars['Int']['input']>;
  pSttFinale?: InputMaybe<Scalars['Boolean']['input']>;
  pSttTrida?: InputMaybe<ParyPSttTrida>;
  pTimestampAdd?: InputMaybe<Scalars['Datetime']['input']>;
  pTimestampArchive?: InputMaybe<Scalars['Datetime']['input']>;
};

export type ParyNavrh = {
  __typename?: 'ParyNavrh';
  id: Maybe<Scalars['BigInt']['output']>;
  pnId: Scalars['BigInt']['output'];
  pnNavrhl: Scalars['BigInt']['output'];
  pnPartner: Scalars['BigInt']['output'];
  pnPartnerka: Scalars['BigInt']['output'];
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnNavrhl: Maybe<User>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnPartnerka: Maybe<User>;
};

/**
 * A condition to be used against `ParyNavrh` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ParyNavrhCondition = {
  /** Checks for equality with the object’s `pnId` field. */
  pnId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `pnNavrhl` field. */
  pnNavrhl?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `pnPartner` field. */
  pnPartner?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `pnPartnerka` field. */
  pnPartnerka?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `ParyNavrh` */
export type ParyNavrhInput = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  pnId?: InputMaybe<Scalars['BigInt']['input']>;
  pnNavrhl: Scalars['BigInt']['input'];
  pnPartner: Scalars['BigInt']['input'];
  pnPartnerka: Scalars['BigInt']['input'];
};

/** Represents an update to a `ParyNavrh`. Fields that are set will be updated. */
export type ParyNavrhPatch = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  pnId?: InputMaybe<Scalars['BigInt']['input']>;
  pnNavrhl?: InputMaybe<Scalars['BigInt']['input']>;
  pnPartner?: InputMaybe<Scalars['BigInt']['input']>;
  pnPartnerka?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `ParyNavrh` values. */
export type ParyNavrhsConnection = {
  __typename?: 'ParyNavrhsConnection';
  /** A list of edges which contains the `ParyNavrh` and cursor to aid in pagination. */
  edges: Array<ParyNavrhsEdge>;
  /** A list of `ParyNavrh` objects. */
  nodes: Array<ParyNavrh>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ParyNavrh` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ParyNavrh` edge in the connection. */
export type ParyNavrhsEdge = {
  __typename?: 'ParyNavrhsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `ParyNavrh` at the end of the edge. */
  node: ParyNavrh;
};

/** Methods to use when ordering `ParyNavrh`. */
export type ParyNavrhsOrderBy =
  | 'NATURAL'
  | 'PN_ID_ASC'
  | 'PN_ID_DESC'
  | 'PN_NAVRHL_ASC'
  | 'PN_NAVRHL_DESC'
  | 'PN_PARTNERKA_ASC'
  | 'PN_PARTNERKA_DESC'
  | 'PN_PARTNER_ASC'
  | 'PN_PARTNER_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'USER_BY_PN_NAVRHL__U_BAN_ASC'
  | 'USER_BY_PN_NAVRHL__U_BAN_DESC'
  | 'USER_BY_PN_NAVRHL__U_CONFIRMED_ASC'
  | 'USER_BY_PN_NAVRHL__U_CONFIRMED_DESC'
  | 'USER_BY_PN_NAVRHL__U_GROUP_ASC'
  | 'USER_BY_PN_NAVRHL__U_GROUP_DESC'
  | 'USER_BY_PN_NAVRHL__U_ID_ASC'
  | 'USER_BY_PN_NAVRHL__U_ID_DESC'
  | 'USER_BY_PN_NAVRHL__U_JMENO_ASC'
  | 'USER_BY_PN_NAVRHL__U_JMENO_DESC'
  | 'USER_BY_PN_NAVRHL__U_LOGIN_ASC'
  | 'USER_BY_PN_NAVRHL__U_LOGIN_DESC'
  | 'USER_BY_PN_NAVRHL__U_NAROZENI_ASC'
  | 'USER_BY_PN_NAVRHL__U_NAROZENI_DESC'
  | 'USER_BY_PN_NAVRHL__U_PRIJMENI_ASC'
  | 'USER_BY_PN_NAVRHL__U_PRIJMENI_DESC'
  | 'USER_BY_PN_NAVRHL__U_SKUPINA_ASC'
  | 'USER_BY_PN_NAVRHL__U_SKUPINA_DESC'
  | 'USER_BY_PN_NAVRHL__U_SYSTEM_ASC'
  | 'USER_BY_PN_NAVRHL__U_SYSTEM_DESC'
  | 'USER_BY_PN_PARTNERKA__U_BAN_ASC'
  | 'USER_BY_PN_PARTNERKA__U_BAN_DESC'
  | 'USER_BY_PN_PARTNERKA__U_CONFIRMED_ASC'
  | 'USER_BY_PN_PARTNERKA__U_CONFIRMED_DESC'
  | 'USER_BY_PN_PARTNERKA__U_GROUP_ASC'
  | 'USER_BY_PN_PARTNERKA__U_GROUP_DESC'
  | 'USER_BY_PN_PARTNERKA__U_ID_ASC'
  | 'USER_BY_PN_PARTNERKA__U_ID_DESC'
  | 'USER_BY_PN_PARTNERKA__U_JMENO_ASC'
  | 'USER_BY_PN_PARTNERKA__U_JMENO_DESC'
  | 'USER_BY_PN_PARTNERKA__U_LOGIN_ASC'
  | 'USER_BY_PN_PARTNERKA__U_LOGIN_DESC'
  | 'USER_BY_PN_PARTNERKA__U_NAROZENI_ASC'
  | 'USER_BY_PN_PARTNERKA__U_NAROZENI_DESC'
  | 'USER_BY_PN_PARTNERKA__U_PRIJMENI_ASC'
  | 'USER_BY_PN_PARTNERKA__U_PRIJMENI_DESC'
  | 'USER_BY_PN_PARTNERKA__U_SKUPINA_ASC'
  | 'USER_BY_PN_PARTNERKA__U_SKUPINA_DESC'
  | 'USER_BY_PN_PARTNERKA__U_SYSTEM_ASC'
  | 'USER_BY_PN_PARTNERKA__U_SYSTEM_DESC'
  | 'USER_BY_PN_PARTNER__U_BAN_ASC'
  | 'USER_BY_PN_PARTNER__U_BAN_DESC'
  | 'USER_BY_PN_PARTNER__U_CONFIRMED_ASC'
  | 'USER_BY_PN_PARTNER__U_CONFIRMED_DESC'
  | 'USER_BY_PN_PARTNER__U_GROUP_ASC'
  | 'USER_BY_PN_PARTNER__U_GROUP_DESC'
  | 'USER_BY_PN_PARTNER__U_ID_ASC'
  | 'USER_BY_PN_PARTNER__U_ID_DESC'
  | 'USER_BY_PN_PARTNER__U_JMENO_ASC'
  | 'USER_BY_PN_PARTNER__U_JMENO_DESC'
  | 'USER_BY_PN_PARTNER__U_LOGIN_ASC'
  | 'USER_BY_PN_PARTNER__U_LOGIN_DESC'
  | 'USER_BY_PN_PARTNER__U_NAROZENI_ASC'
  | 'USER_BY_PN_PARTNER__U_NAROZENI_DESC'
  | 'USER_BY_PN_PARTNER__U_PRIJMENI_ASC'
  | 'USER_BY_PN_PARTNER__U_PRIJMENI_DESC'
  | 'USER_BY_PN_PARTNER__U_SKUPINA_ASC'
  | 'USER_BY_PN_PARTNER__U_SKUPINA_DESC'
  | 'USER_BY_PN_PARTNER__U_SYSTEM_ASC'
  | 'USER_BY_PN_PARTNER__U_SYSTEM_DESC';

export type ParyPLatTrida =
  | 'A'
  | 'B'
  | 'C'
  | 'D'
  | 'H'
  | 'M'
  | 'Z';

export type ParyPSttTrida =
  | 'A'
  | 'B'
  | 'C'
  | 'D'
  | 'H'
  | 'M'
  | 'Z';

/** Represents an update to a `Pary`. Fields that are set will be updated. */
export type ParyPatch = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  pArchiv?: InputMaybe<Scalars['Boolean']['input']>;
  pHodnoceni?: InputMaybe<Scalars['Int']['input']>;
  pId?: InputMaybe<Scalars['BigInt']['input']>;
  pIdPartner?: InputMaybe<Scalars['BigInt']['input']>;
  pIdPartnerka?: InputMaybe<Scalars['BigInt']['input']>;
  pLatBody?: InputMaybe<Scalars['Int']['input']>;
  pLatFinale?: InputMaybe<Scalars['Boolean']['input']>;
  pLatTrida?: InputMaybe<ParyPLatTrida>;
  pSttBody?: InputMaybe<Scalars['Int']['input']>;
  pSttFinale?: InputMaybe<Scalars['Boolean']['input']>;
  pSttTrida?: InputMaybe<ParyPSttTrida>;
  pTimestampAdd?: InputMaybe<Scalars['Datetime']['input']>;
  pTimestampArchive?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `Person` values. */
export type PeopleConnection = {
  __typename?: 'PeopleConnection';
  /** A list of edges which contains the `Person` and cursor to aid in pagination. */
  edges: Array<PeopleEdge>;
  /** A list of `Person` objects. */
  nodes: Array<Person>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Person` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Person` edge in the connection. */
export type PeopleEdge = {
  __typename?: 'PeopleEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Person` at the end of the edge. */
  node: Person;
};

/** Methods to use when ordering `Person`. */
export type PeopleOrderBy =
  | 'ATTENDEE_PEOPLE_BY_PERSON_ID__COUNT_ASC'
  | 'ATTENDEE_PEOPLE_BY_PERSON_ID__COUNT_DESC'
  | 'COUPLES_BY_FOLLOWER_ID__COUNT_ASC'
  | 'COUPLES_BY_FOLLOWER_ID__COUNT_DESC'
  | 'COUPLES_BY_LEADER_ID__COUNT_ASC'
  | 'COUPLES_BY_LEADER_ID__COUNT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TENANT_PEOPLE_BY_PERSON_ID__COUNT_ASC'
  | 'TENANT_PEOPLE_BY_PERSON_ID__COUNT_DESC';

export type Permission = {
  __typename?: 'Permission';
  id: Maybe<Scalars['BigInt']['output']>;
  peAkce: Scalars['Int']['output'];
  peAktuality: Scalars['Int']['output'];
  peAnkety: Scalars['Int']['output'];
  peDescription: Scalars['String']['output'];
  peDokumenty: Scalars['Int']['output'];
  peGalerie: Scalars['Int']['output'];
  peId: Scalars['BigInt']['output'];
  peInzerce: Scalars['Int']['output'];
  peKonzole: Scalars['Int']['output'];
  peMain: Scalars['Int']['output'];
  peNabidka: Scalars['Int']['output'];
  peName: Scalars['String']['output'];
  peNastenka: Scalars['Int']['output'];
  peNovinky: Scalars['Int']['output'];
  pePary: Scalars['Int']['output'];
  pePermissions: Scalars['Int']['output'];
  pePlatby: Scalars['Int']['output'];
  peRozpis: Scalars['Int']['output'];
  peSkupiny: Scalars['Int']['output'];
  peUsers: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `User`. */
  usersByUGroup: UsersConnection;
};


export type PermissionUsersByUGroupArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/**
 * A condition to be used against `Permission` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PermissionCondition = {
  /** Checks for equality with the object’s `peId` field. */
  peId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `Permission` */
export type PermissionInput = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  peAkce: Scalars['Int']['input'];
  peAktuality: Scalars['Int']['input'];
  peAnkety: Scalars['Int']['input'];
  peDescription: Scalars['String']['input'];
  peDokumenty: Scalars['Int']['input'];
  peGalerie: Scalars['Int']['input'];
  peId?: InputMaybe<Scalars['BigInt']['input']>;
  peInzerce: Scalars['Int']['input'];
  peKonzole: Scalars['Int']['input'];
  peMain: Scalars['Int']['input'];
  peNabidka: Scalars['Int']['input'];
  peName: Scalars['String']['input'];
  peNastenka: Scalars['Int']['input'];
  peNovinky: Scalars['Int']['input'];
  pePary: Scalars['Int']['input'];
  pePermissions: Scalars['Int']['input'];
  pePlatby: Scalars['Int']['input'];
  peRozpis: Scalars['Int']['input'];
  peSkupiny: Scalars['Int']['input'];
  peUsers: Scalars['Int']['input'];
};

/** Represents an update to a `Permission`. Fields that are set will be updated. */
export type PermissionPatch = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  peAkce?: InputMaybe<Scalars['Int']['input']>;
  peAktuality?: InputMaybe<Scalars['Int']['input']>;
  peAnkety?: InputMaybe<Scalars['Int']['input']>;
  peDescription?: InputMaybe<Scalars['String']['input']>;
  peDokumenty?: InputMaybe<Scalars['Int']['input']>;
  peGalerie?: InputMaybe<Scalars['Int']['input']>;
  peId?: InputMaybe<Scalars['BigInt']['input']>;
  peInzerce?: InputMaybe<Scalars['Int']['input']>;
  peKonzole?: InputMaybe<Scalars['Int']['input']>;
  peMain?: InputMaybe<Scalars['Int']['input']>;
  peNabidka?: InputMaybe<Scalars['Int']['input']>;
  peName?: InputMaybe<Scalars['String']['input']>;
  peNastenka?: InputMaybe<Scalars['Int']['input']>;
  peNovinky?: InputMaybe<Scalars['Int']['input']>;
  pePary?: InputMaybe<Scalars['Int']['input']>;
  pePermissions?: InputMaybe<Scalars['Int']['input']>;
  pePlatby?: InputMaybe<Scalars['Int']['input']>;
  peRozpis?: InputMaybe<Scalars['Int']['input']>;
  peSkupiny?: InputMaybe<Scalars['Int']['input']>;
  peUsers?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `Permission` values. */
export type PermissionsConnection = {
  __typename?: 'PermissionsConnection';
  /** A list of edges which contains the `Permission` and cursor to aid in pagination. */
  edges: Array<PermissionsEdge>;
  /** A list of `Permission` objects. */
  nodes: Array<Permission>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Permission` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Permission` edge in the connection. */
export type PermissionsEdge = {
  __typename?: 'PermissionsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Permission` at the end of the edge. */
  node: Permission;
};

/** Methods to use when ordering `Permission`. */
export type PermissionsOrderBy =
  | 'NATURAL'
  | 'PE_ID_ASC'
  | 'PE_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'USERS_BY_U_GROUP__COUNT_ASC'
  | 'USERS_BY_U_GROUP__COUNT_DESC';

export type Person = {
  __typename?: 'Person';
  /** Reads and enables pagination through a set of `AttendeePerson`. */
  attendeePeople: AttendeePeopleConnection;
  /** Reads and enables pagination through a set of `Couple`. */
  couplesByFollowerId: CouplesConnection;
  /** Reads and enables pagination through a set of `Couple`. */
  couplesByLeaderId: CouplesConnection;
  firstName: Scalars['String']['output'];
  gender: GenderType;
  id: Scalars['BigInt']['output'];
  lastName: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `TenantPerson`. */
  tenantPeople: TenantPeopleConnection;
  userId: Maybe<Scalars['BigInt']['output']>;
};


export type PersonAttendeePeopleArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AttendeePersonCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AttendeePeopleOrderBy>>;
};


export type PersonCouplesByFollowerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CoupleCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CouplesOrderBy>>;
};


export type PersonCouplesByLeaderIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CoupleCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CouplesOrderBy>>;
};


export type PersonTenantPeopleArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TenantPersonCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TenantPeopleOrderBy>>;
};

/** A condition to be used against `Person` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PersonCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `Person` */
export type PersonInput = {
  firstName: Scalars['String']['input'];
  gender: GenderType;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  lastName: Scalars['String']['input'];
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Represents an update to a `Person`. Fields that are set will be updated. */
export type PersonPatch = {
  firstName?: InputMaybe<Scalars['String']['input']>;
  gender?: InputMaybe<GenderType>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `PlatbyCategory` values. */
export type PlatbyCategoriesConnection = {
  __typename?: 'PlatbyCategoriesConnection';
  /** A list of edges which contains the `PlatbyCategory` and cursor to aid in pagination. */
  edges: Array<PlatbyCategoriesEdge>;
  /** A list of `PlatbyCategory` objects. */
  nodes: Array<PlatbyCategory>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PlatbyCategory` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PlatbyCategory` edge in the connection. */
export type PlatbyCategoriesEdge = {
  __typename?: 'PlatbyCategoriesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `PlatbyCategory` at the end of the edge. */
  node: PlatbyCategory;
};

/** Methods to use when ordering `PlatbyCategory`. */
export type PlatbyCategoriesOrderBy =
  | 'NATURAL'
  | 'PC_ID_ASC'
  | 'PC_ID_DESC'
  | 'PC_SYMBOL_ASC'
  | 'PC_SYMBOL_DESC'
  | 'PLATBY_CATEGORY_GROUPS_BY_PCG_ID_CATEGORY__COUNT_ASC'
  | 'PLATBY_CATEGORY_GROUPS_BY_PCG_ID_CATEGORY__COUNT_DESC'
  | 'PLATBY_ITEMS_BY_PI_ID_CATEGORY__COUNT_ASC'
  | 'PLATBY_ITEMS_BY_PI_ID_CATEGORY__COUNT_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

export type PlatbyCategory = {
  __typename?: 'PlatbyCategory';
  id: Maybe<Scalars['BigInt']['output']>;
  pcAmount: Scalars['BigFloat']['output'];
  pcArchive: Scalars['Boolean']['output'];
  pcDateDue: Scalars['Date']['output'];
  pcId: Scalars['BigInt']['output'];
  pcName: Scalars['String']['output'];
  pcSymbol: Scalars['BigInt']['output'];
  pcUseBase: Scalars['Boolean']['output'];
  pcUsePrefix: Scalars['Boolean']['output'];
  pcValidFrom: Scalars['Date']['output'];
  pcValidTo: Scalars['Date']['output'];
  pcVisible: Scalars['Boolean']['output'];
  /** Reads and enables pagination through a set of `PlatbyCategoryGroup`. */
  platbyCategoryGroupsByPcgIdCategory: PlatbyCategoryGroupsConnection;
  /** Reads and enables pagination through a set of `PlatbyItem`. */
  platbyItemsByPiIdCategory: PlatbyItemsConnection;
  tenantId: Scalars['BigInt']['output'];
};


export type PlatbyCategoryPlatbyCategoryGroupsByPcgIdCategoryArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PlatbyCategoryGroupCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PlatbyCategoryGroupsOrderBy>>;
};


export type PlatbyCategoryPlatbyItemsByPiIdCategoryArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PlatbyItemCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PlatbyItemsOrderBy>>;
};

/**
 * A condition to be used against `PlatbyCategory` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PlatbyCategoryCondition = {
  /** Checks for equality with the object’s `pcId` field. */
  pcId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `pcSymbol` field. */
  pcSymbol?: InputMaybe<Scalars['BigInt']['input']>;
};

export type PlatbyCategoryGroup = {
  __typename?: 'PlatbyCategoryGroup';
  id: Maybe<Scalars['BigInt']['output']>;
  pcgId: Scalars['BigInt']['output'];
  pcgIdCategory: Scalars['BigInt']['output'];
  pcgIdGroup: Scalars['BigInt']['output'];
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyCategoryGroup`. */
  platbyCategoryByPcgIdCategory: Maybe<PlatbyCategory>;
  /** Reads a single `PlatbyGroup` that is related to this `PlatbyCategoryGroup`. */
  platbyGroupByPcgIdGroup: Maybe<PlatbyGroup>;
  tenantId: Scalars['BigInt']['output'];
};

/**
 * A condition to be used against `PlatbyCategoryGroup` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type PlatbyCategoryGroupCondition = {
  /** Checks for equality with the object’s `pcgId` field. */
  pcgId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `pcgIdCategory` field. */
  pcgIdCategory?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `pcgIdGroup` field. */
  pcgIdGroup?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `PlatbyCategoryGroup` */
export type PlatbyCategoryGroupInput = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  pcgId?: InputMaybe<Scalars['BigInt']['input']>;
  pcgIdCategory: Scalars['BigInt']['input'];
  pcgIdGroup: Scalars['BigInt']['input'];
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Represents an update to a `PlatbyCategoryGroup`. Fields that are set will be updated. */
export type PlatbyCategoryGroupPatch = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  pcgId?: InputMaybe<Scalars['BigInt']['input']>;
  pcgIdCategory?: InputMaybe<Scalars['BigInt']['input']>;
  pcgIdGroup?: InputMaybe<Scalars['BigInt']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `PlatbyCategoryGroup` values. */
export type PlatbyCategoryGroupsConnection = {
  __typename?: 'PlatbyCategoryGroupsConnection';
  /** A list of edges which contains the `PlatbyCategoryGroup` and cursor to aid in pagination. */
  edges: Array<PlatbyCategoryGroupsEdge>;
  /** A list of `PlatbyCategoryGroup` objects. */
  nodes: Array<PlatbyCategoryGroup>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PlatbyCategoryGroup` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PlatbyCategoryGroup` edge in the connection. */
export type PlatbyCategoryGroupsEdge = {
  __typename?: 'PlatbyCategoryGroupsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `PlatbyCategoryGroup` at the end of the edge. */
  node: PlatbyCategoryGroup;
};

/** Methods to use when ordering `PlatbyCategoryGroup`. */
export type PlatbyCategoryGroupsOrderBy =
  | 'NATURAL'
  | 'PCG_ID_ASC'
  | 'PCG_ID_CATEGORY_ASC'
  | 'PCG_ID_CATEGORY_DESC'
  | 'PCG_ID_DESC'
  | 'PCG_ID_GROUP_ASC'
  | 'PCG_ID_GROUP_DESC'
  | 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_ID_ASC'
  | 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_ID_DESC'
  | 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_SYMBOL_ASC'
  | 'PLATBY_CATEGORY_BY_PCG_ID_CATEGORY__PC_SYMBOL_DESC'
  | 'PLATBY_GROUP_BY_PCG_ID_GROUP__PG_ID_ASC'
  | 'PLATBY_GROUP_BY_PCG_ID_GROUP__PG_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** An input for mutations affecting `PlatbyCategory` */
export type PlatbyCategoryInput = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  pcAmount: Scalars['BigFloat']['input'];
  pcArchive?: InputMaybe<Scalars['Boolean']['input']>;
  pcDateDue: Scalars['Date']['input'];
  pcId?: InputMaybe<Scalars['BigInt']['input']>;
  pcName: Scalars['String']['input'];
  pcSymbol: Scalars['BigInt']['input'];
  pcUseBase?: InputMaybe<Scalars['Boolean']['input']>;
  pcUsePrefix?: InputMaybe<Scalars['Boolean']['input']>;
  pcValidFrom: Scalars['Date']['input'];
  pcValidTo: Scalars['Date']['input'];
  pcVisible?: InputMaybe<Scalars['Boolean']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Represents an update to a `PlatbyCategory`. Fields that are set will be updated. */
export type PlatbyCategoryPatch = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  pcAmount?: InputMaybe<Scalars['BigFloat']['input']>;
  pcArchive?: InputMaybe<Scalars['Boolean']['input']>;
  pcDateDue?: InputMaybe<Scalars['Date']['input']>;
  pcId?: InputMaybe<Scalars['BigInt']['input']>;
  pcName?: InputMaybe<Scalars['String']['input']>;
  pcSymbol?: InputMaybe<Scalars['BigInt']['input']>;
  pcUseBase?: InputMaybe<Scalars['Boolean']['input']>;
  pcUsePrefix?: InputMaybe<Scalars['Boolean']['input']>;
  pcValidFrom?: InputMaybe<Scalars['Date']['input']>;
  pcValidTo?: InputMaybe<Scalars['Date']['input']>;
  pcVisible?: InputMaybe<Scalars['Boolean']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

export type PlatbyGroup = {
  __typename?: 'PlatbyGroup';
  id: Maybe<Scalars['BigInt']['output']>;
  pgBase: Scalars['BigInt']['output'];
  pgDescription: Scalars['String']['output'];
  pgId: Scalars['BigInt']['output'];
  pgName: Scalars['String']['output'];
  pgType: Scalars['BigFloat']['output'];
  /** Reads and enables pagination through a set of `PlatbyCategoryGroup`. */
  platbyCategoryGroupsByPcgIdGroup: PlatbyCategoryGroupsConnection;
  /** Reads and enables pagination through a set of `PlatbyGroupSkupina`. */
  platbyGroupSkupinasByPgsIdGroup: PlatbyGroupSkupinasConnection;
  tenantId: Scalars['BigInt']['output'];
};


export type PlatbyGroupPlatbyCategoryGroupsByPcgIdGroupArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PlatbyCategoryGroupCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PlatbyCategoryGroupsOrderBy>>;
};


export type PlatbyGroupPlatbyGroupSkupinasByPgsIdGroupArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PlatbyGroupSkupinaCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PlatbyGroupSkupinasOrderBy>>;
};

/**
 * A condition to be used against `PlatbyGroup` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PlatbyGroupCondition = {
  /** Checks for equality with the object’s `pgId` field. */
  pgId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `PlatbyGroup` */
export type PlatbyGroupInput = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  pgBase?: InputMaybe<Scalars['BigInt']['input']>;
  pgDescription: Scalars['String']['input'];
  pgId?: InputMaybe<Scalars['BigInt']['input']>;
  pgName: Scalars['String']['input'];
  pgType?: InputMaybe<Scalars['BigFloat']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Represents an update to a `PlatbyGroup`. Fields that are set will be updated. */
export type PlatbyGroupPatch = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  pgBase?: InputMaybe<Scalars['BigInt']['input']>;
  pgDescription?: InputMaybe<Scalars['String']['input']>;
  pgId?: InputMaybe<Scalars['BigInt']['input']>;
  pgName?: InputMaybe<Scalars['String']['input']>;
  pgType?: InputMaybe<Scalars['BigFloat']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

export type PlatbyGroupSkupina = {
  __typename?: 'PlatbyGroupSkupina';
  id: Maybe<Scalars['BigInt']['output']>;
  pgsId: Scalars['BigInt']['output'];
  pgsIdGroup: Scalars['BigInt']['output'];
  pgsIdSkupina: Scalars['BigInt']['output'];
  /** Reads a single `PlatbyGroup` that is related to this `PlatbyGroupSkupina`. */
  platbyGroupByPgsIdGroup: Maybe<PlatbyGroup>;
  /** Reads a single `Skupiny` that is related to this `PlatbyGroupSkupina`. */
  skupinyByPgsIdSkupina: Maybe<Skupiny>;
  tenantId: Scalars['BigInt']['output'];
};

/**
 * A condition to be used against `PlatbyGroupSkupina` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PlatbyGroupSkupinaCondition = {
  /** Checks for equality with the object’s `pgsId` field. */
  pgsId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `pgsIdGroup` field. */
  pgsIdGroup?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `pgsIdSkupina` field. */
  pgsIdSkupina?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `PlatbyGroupSkupina` */
export type PlatbyGroupSkupinaInput = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  pgsId?: InputMaybe<Scalars['BigInt']['input']>;
  pgsIdGroup: Scalars['BigInt']['input'];
  pgsIdSkupina: Scalars['BigInt']['input'];
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Represents an update to a `PlatbyGroupSkupina`. Fields that are set will be updated. */
export type PlatbyGroupSkupinaPatch = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  pgsId?: InputMaybe<Scalars['BigInt']['input']>;
  pgsIdGroup?: InputMaybe<Scalars['BigInt']['input']>;
  pgsIdSkupina?: InputMaybe<Scalars['BigInt']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `PlatbyGroupSkupina` values. */
export type PlatbyGroupSkupinasConnection = {
  __typename?: 'PlatbyGroupSkupinasConnection';
  /** A list of edges which contains the `PlatbyGroupSkupina` and cursor to aid in pagination. */
  edges: Array<PlatbyGroupSkupinasEdge>;
  /** A list of `PlatbyGroupSkupina` objects. */
  nodes: Array<PlatbyGroupSkupina>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PlatbyGroupSkupina` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PlatbyGroupSkupina` edge in the connection. */
export type PlatbyGroupSkupinasEdge = {
  __typename?: 'PlatbyGroupSkupinasEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `PlatbyGroupSkupina` at the end of the edge. */
  node: PlatbyGroupSkupina;
};

/** Methods to use when ordering `PlatbyGroupSkupina`. */
export type PlatbyGroupSkupinasOrderBy =
  | 'NATURAL'
  | 'PGS_ID_ASC'
  | 'PGS_ID_DESC'
  | 'PGS_ID_GROUP_ASC'
  | 'PGS_ID_GROUP_DESC'
  | 'PGS_ID_SKUPINA_ASC'
  | 'PGS_ID_SKUPINA_DESC'
  | 'PLATBY_GROUP_BY_PGS_ID_GROUP__PG_ID_ASC'
  | 'PLATBY_GROUP_BY_PGS_ID_GROUP__PG_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SKUPINY_BY_PGS_ID_SKUPINA__COHORT_GROUP_ASC'
  | 'SKUPINY_BY_PGS_ID_SKUPINA__COHORT_GROUP_DESC'
  | 'SKUPINY_BY_PGS_ID_SKUPINA__ORDERING_ASC'
  | 'SKUPINY_BY_PGS_ID_SKUPINA__ORDERING_DESC'
  | 'SKUPINY_BY_PGS_ID_SKUPINA__S_ID_ASC'
  | 'SKUPINY_BY_PGS_ID_SKUPINA__S_ID_DESC'
  | 'SKUPINY_BY_PGS_ID_SKUPINA__S_VISIBLE_ASC'
  | 'SKUPINY_BY_PGS_ID_SKUPINA__S_VISIBLE_DESC';

/** A connection to a list of `PlatbyGroup` values. */
export type PlatbyGroupsConnection = {
  __typename?: 'PlatbyGroupsConnection';
  /** A list of edges which contains the `PlatbyGroup` and cursor to aid in pagination. */
  edges: Array<PlatbyGroupsEdge>;
  /** A list of `PlatbyGroup` objects. */
  nodes: Array<PlatbyGroup>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PlatbyGroup` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PlatbyGroup` edge in the connection. */
export type PlatbyGroupsEdge = {
  __typename?: 'PlatbyGroupsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `PlatbyGroup` at the end of the edge. */
  node: PlatbyGroup;
};

/** Methods to use when ordering `PlatbyGroup`. */
export type PlatbyGroupsOrderBy =
  | 'NATURAL'
  | 'PG_ID_ASC'
  | 'PG_ID_DESC'
  | 'PLATBY_CATEGORY_GROUPS_BY_PCG_ID_GROUP__COUNT_ASC'
  | 'PLATBY_CATEGORY_GROUPS_BY_PCG_ID_GROUP__COUNT_DESC'
  | 'PLATBY_GROUP_SKUPINAS_BY_PGS_ID_GROUP__COUNT_ASC'
  | 'PLATBY_GROUP_SKUPINAS_BY_PGS_ID_GROUP__COUNT_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

export type PlatbyItem = {
  __typename?: 'PlatbyItem';
  id: Maybe<Scalars['BigInt']['output']>;
  piAmount: Scalars['BigFloat']['output'];
  piDate: Scalars['Date']['output'];
  piId: Scalars['BigInt']['output'];
  piIdCategory: Scalars['BigInt']['output'];
  piIdRaw: Maybe<Scalars['BigInt']['output']>;
  piIdUser: Maybe<Scalars['BigInt']['output']>;
  piPrefix: Scalars['Int']['output'];
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
  platbyCategoryByPiIdCategory: Maybe<PlatbyCategory>;
  /** Reads a single `PlatbyRaw` that is related to this `PlatbyItem`. */
  platbyRawByPiIdRaw: Maybe<PlatbyRaw>;
  tenantId: Scalars['BigInt']['output'];
  /** Reads a single `User` that is related to this `PlatbyItem`. */
  userByPiIdUser: Maybe<User>;
};

/**
 * A condition to be used against `PlatbyItem` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PlatbyItemCondition = {
  /** Checks for equality with the object’s `piId` field. */
  piId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `piIdCategory` field. */
  piIdCategory?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `piIdRaw` field. */
  piIdRaw?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `piIdUser` field. */
  piIdUser?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `PlatbyItem` */
export type PlatbyItemInput = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  piAmount: Scalars['BigFloat']['input'];
  piDate: Scalars['Date']['input'];
  piId?: InputMaybe<Scalars['BigInt']['input']>;
  piIdCategory: Scalars['BigInt']['input'];
  piIdRaw?: InputMaybe<Scalars['BigInt']['input']>;
  piIdUser?: InputMaybe<Scalars['BigInt']['input']>;
  piPrefix?: InputMaybe<Scalars['Int']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Represents an update to a `PlatbyItem`. Fields that are set will be updated. */
export type PlatbyItemPatch = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  piAmount?: InputMaybe<Scalars['BigFloat']['input']>;
  piDate?: InputMaybe<Scalars['Date']['input']>;
  piId?: InputMaybe<Scalars['BigInt']['input']>;
  piIdCategory?: InputMaybe<Scalars['BigInt']['input']>;
  piIdRaw?: InputMaybe<Scalars['BigInt']['input']>;
  piIdUser?: InputMaybe<Scalars['BigInt']['input']>;
  piPrefix?: InputMaybe<Scalars['Int']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `PlatbyItem` values. */
export type PlatbyItemsConnection = {
  __typename?: 'PlatbyItemsConnection';
  /** A list of edges which contains the `PlatbyItem` and cursor to aid in pagination. */
  edges: Array<PlatbyItemsEdge>;
  /** A list of `PlatbyItem` objects. */
  nodes: Array<PlatbyItem>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PlatbyItem` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PlatbyItem` edge in the connection. */
export type PlatbyItemsEdge = {
  __typename?: 'PlatbyItemsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `PlatbyItem` at the end of the edge. */
  node: PlatbyItem;
};

/** Methods to use when ordering `PlatbyItem`. */
export type PlatbyItemsOrderBy =
  | 'NATURAL'
  | 'PI_ID_ASC'
  | 'PI_ID_CATEGORY_ASC'
  | 'PI_ID_CATEGORY_DESC'
  | 'PI_ID_DESC'
  | 'PI_ID_RAW_ASC'
  | 'PI_ID_RAW_DESC'
  | 'PI_ID_USER_ASC'
  | 'PI_ID_USER_DESC'
  | 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_ID_ASC'
  | 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_ID_DESC'
  | 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_SYMBOL_ASC'
  | 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_SYMBOL_DESC'
  | 'PLATBY_RAW_BY_PI_ID_RAW__PR_HASH_ASC'
  | 'PLATBY_RAW_BY_PI_ID_RAW__PR_HASH_DESC'
  | 'PLATBY_RAW_BY_PI_ID_RAW__PR_ID_ASC'
  | 'PLATBY_RAW_BY_PI_ID_RAW__PR_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'USER_BY_PI_ID_USER__U_BAN_ASC'
  | 'USER_BY_PI_ID_USER__U_BAN_DESC'
  | 'USER_BY_PI_ID_USER__U_CONFIRMED_ASC'
  | 'USER_BY_PI_ID_USER__U_CONFIRMED_DESC'
  | 'USER_BY_PI_ID_USER__U_GROUP_ASC'
  | 'USER_BY_PI_ID_USER__U_GROUP_DESC'
  | 'USER_BY_PI_ID_USER__U_ID_ASC'
  | 'USER_BY_PI_ID_USER__U_ID_DESC'
  | 'USER_BY_PI_ID_USER__U_JMENO_ASC'
  | 'USER_BY_PI_ID_USER__U_JMENO_DESC'
  | 'USER_BY_PI_ID_USER__U_LOGIN_ASC'
  | 'USER_BY_PI_ID_USER__U_LOGIN_DESC'
  | 'USER_BY_PI_ID_USER__U_NAROZENI_ASC'
  | 'USER_BY_PI_ID_USER__U_NAROZENI_DESC'
  | 'USER_BY_PI_ID_USER__U_PRIJMENI_ASC'
  | 'USER_BY_PI_ID_USER__U_PRIJMENI_DESC'
  | 'USER_BY_PI_ID_USER__U_SKUPINA_ASC'
  | 'USER_BY_PI_ID_USER__U_SKUPINA_DESC'
  | 'USER_BY_PI_ID_USER__U_SYSTEM_ASC'
  | 'USER_BY_PI_ID_USER__U_SYSTEM_DESC';

export type PlatbyRaw = {
  __typename?: 'PlatbyRaw';
  id: Maybe<Scalars['BigInt']['output']>;
  /** Reads and enables pagination through a set of `PlatbyItem`. */
  platbyItemsByPiIdRaw: PlatbyItemsConnection;
  prDiscarded: Scalars['Boolean']['output'];
  prHash: Scalars['String']['output'];
  prId: Scalars['BigInt']['output'];
  prRaw: Scalars['String']['output'];
  prSorted: Scalars['Boolean']['output'];
  tenantId: Scalars['BigInt']['output'];
};


export type PlatbyRawPlatbyItemsByPiIdRawArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PlatbyItemCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PlatbyItemsOrderBy>>;
};

/**
 * A condition to be used against `PlatbyRaw` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PlatbyRawCondition = {
  /** Checks for equality with the object’s `prHash` field. */
  prHash?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `prId` field. */
  prId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `PlatbyRaw` */
export type PlatbyRawInput = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  prDiscarded?: InputMaybe<Scalars['Boolean']['input']>;
  prHash: Scalars['String']['input'];
  prId?: InputMaybe<Scalars['BigInt']['input']>;
  prRaw: Scalars['String']['input'];
  prSorted?: InputMaybe<Scalars['Boolean']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Represents an update to a `PlatbyRaw`. Fields that are set will be updated. */
export type PlatbyRawPatch = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  prDiscarded?: InputMaybe<Scalars['Boolean']['input']>;
  prHash?: InputMaybe<Scalars['String']['input']>;
  prId?: InputMaybe<Scalars['BigInt']['input']>;
  prRaw?: InputMaybe<Scalars['String']['input']>;
  prSorted?: InputMaybe<Scalars['Boolean']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `PlatbyRaw` values. */
export type PlatbyRawsConnection = {
  __typename?: 'PlatbyRawsConnection';
  /** A list of edges which contains the `PlatbyRaw` and cursor to aid in pagination. */
  edges: Array<PlatbyRawsEdge>;
  /** A list of `PlatbyRaw` objects. */
  nodes: Array<PlatbyRaw>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PlatbyRaw` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PlatbyRaw` edge in the connection. */
export type PlatbyRawsEdge = {
  __typename?: 'PlatbyRawsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `PlatbyRaw` at the end of the edge. */
  node: PlatbyRaw;
};

/** Methods to use when ordering `PlatbyRaw`. */
export type PlatbyRawsOrderBy =
  | 'NATURAL'
  | 'PLATBY_ITEMS_BY_PI_ID_RAW__COUNT_ASC'
  | 'PLATBY_ITEMS_BY_PI_ID_RAW__COUNT_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'PR_HASH_ASC'
  | 'PR_HASH_DESC'
  | 'PR_ID_ASC'
  | 'PR_ID_DESC';

/** An input for mutations affecting `ProspectDatum` */
export type ProspectDatumInput = {
  email?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  surname?: InputMaybe<Scalars['String']['input']>;
  yearofbirth?: InputMaybe<Scalars['String']['input']>;
};

/** All input for the `prospectFormDancer` mutation. */
export type ProspectFormDancerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  cohort: CrmCohort;
  note: Scalars['String']['input'];
  origin: Scalars['String']['input'];
  prospectData: ProspectDatumInput;
};

/** The output of our `prospectFormDancer` mutation. */
export type ProspectFormDancerPayload = {
  __typename?: 'ProspectFormDancerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** The root query type which gives access points into the data universe. */
export type Query = {
  __typename?: 'Query';
  /** Reads and enables pagination through a set of `Pary`. */
  activeCouples: Maybe<PariesConnection>;
  /** Reads and enables pagination through a set of `AkceItem`. */
  akceItems: Maybe<AkceItemsConnection>;
  /** Reads and enables pagination through a set of `Akce`. */
  akces: Maybe<AkcesConnection>;
  /** Reads and enables pagination through a set of `Aktuality`. */
  aktualities: Maybe<AktualitiesConnection>;
  aktuality: Maybe<Aktuality>;
  /** Reads and enables pagination through a set of `Upozorneni`. */
  archivedAnnouncements: Maybe<UpozornenisConnection>;
  attachment: Maybe<Attachment>;
  attachmentDirectories: Maybe<AttachmentDirectoriesConnection>;
  /** Reads and enables pagination through a set of `Attachment`. */
  attachments: Maybe<AttachmentsConnection>;
  attendeeCouple: Maybe<AttendeeCouple>;
  /** Reads and enables pagination through a set of `AttendeeCouple`. */
  attendeeCouples: Maybe<AttendeeCouplesConnection>;
  attendeeExternal: Maybe<AttendeeExternal>;
  /** Reads and enables pagination through a set of `AttendeeExternal`. */
  attendeeExternals: Maybe<AttendeeExternalsConnection>;
  attendeeList: Maybe<AttendeeList>;
  /** Reads and enables pagination through a set of `AttendeeList`. */
  attendeeLists: Maybe<AttendeeListsConnection>;
  /** Reads and enables pagination through a set of `AttendeePerson`. */
  attendeePeople: Maybe<AttendeePeopleConnection>;
  attendeePerson: Maybe<AttendeePerson>;
  attendeeUser: Maybe<AttendeeUser>;
  attendeeUserByUserIdAndEventId: Maybe<AttendeeUser>;
  /** Reads and enables pagination through a set of `AttendeeUser`. */
  attendeeUsers: Maybe<AttendeeUsersConnection>;
  cohortGroup: Maybe<CohortGroup>;
  /** Reads and enables pagination through a set of `CohortGroup`. */
  cohortGroups: Maybe<CohortGroupsConnection>;
  couple: Maybe<Couple>;
  /** Reads and enables pagination through a set of `Couple`. */
  couples: Maybe<CouplesConnection>;
  currentCoupleIds: Maybe<CurrentCoupleIdsConnection>;
  /** Reads and enables pagination through a set of `Permission`. */
  currentPermissions: Maybe<PermissionsConnection>;
  currentSessionId: Maybe<Scalars['String']['output']>;
  currentTenantId: Maybe<Scalars['BigInt']['output']>;
  currentUserId: Maybe<Scalars['BigInt']['output']>;
  /** Reads and enables pagination through a set of `Dokumenty`. */
  dokumenties: Maybe<DokumentiesConnection>;
  dokumenty: Maybe<Dokumenty>;
  event: Maybe<Event>;
  /** Reads and enables pagination through a set of `Event`. */
  events: Maybe<EventsConnection>;
  formResponse: Maybe<FormResponse>;
  /** Reads and enables pagination through a set of `FormResponse`. */
  formResponses: Maybe<FormResponsesConnection>;
  galerieDir: Maybe<GalerieDir>;
  /** Reads and enables pagination through a set of `GalerieDir`. */
  galerieDirs: Maybe<GalerieDirsConnection>;
  galerieFoto: Maybe<GalerieFoto>;
  /** Reads and enables pagination through a set of `GalerieFoto`. */
  galerieFotos: Maybe<GalerieFotosConnection>;
  getCurrentCouple: Maybe<Pary>;
  getCurrentTenant: Maybe<Tenant>;
  getCurrentUser: Maybe<User>;
  location: Maybe<Location>;
  locationAttachment: Maybe<LocationAttachment>;
  /** Reads and enables pagination through a set of `LocationAttachment`. */
  locationAttachments: Maybe<LocationAttachmentsConnection>;
  /** Reads and enables pagination through a set of `Location`. */
  locations: Maybe<LocationsConnection>;
  /** Reads and enables pagination through a set of `Upozorneni`. */
  myAnnouncements: Maybe<UpozornenisConnection>;
  /** Reads and enables pagination through a set of `RozpisItem`. */
  myLessons: Maybe<RozpisItemsConnection>;
  nabidka: Maybe<Nabidka>;
  nabidkaItem: Maybe<NabidkaItem>;
  nabidkaItemByNiPartnerAndNiIdRodic: Maybe<NabidkaItem>;
  /** Reads and enables pagination through a set of `NabidkaItem`. */
  nabidkaItems: Maybe<NabidkaItemsConnection>;
  /** Reads and enables pagination through a set of `Nabidka`. */
  nabidkas: Maybe<NabidkasConnection>;
  page: Maybe<Page>;
  pageByUrl: Maybe<Page>;
  pageRevision: Maybe<PageRevision>;
  /** Reads and enables pagination through a set of `PageRevision`. */
  pageRevisions: Maybe<PageRevisionsConnection>;
  /** Reads and enables pagination through a set of `Page`. */
  pages: Maybe<PagesConnection>;
  parameter: Maybe<Parameter>;
  /** Reads and enables pagination through a set of `Parameter`. */
  parameters: Maybe<ParametersConnection>;
  /** Reads and enables pagination through a set of `Pary`. */
  paries: Maybe<PariesConnection>;
  pary: Maybe<Pary>;
  paryNavrh: Maybe<ParyNavrh>;
  /** Reads and enables pagination through a set of `ParyNavrh`. */
  paryNavrhs: Maybe<ParyNavrhsConnection>;
  /** Reads and enables pagination through a set of `Person`. */
  people: Maybe<PeopleConnection>;
  permission: Maybe<Permission>;
  /** Reads and enables pagination through a set of `Permission`. */
  permissions: Maybe<PermissionsConnection>;
  person: Maybe<Person>;
  /** Reads and enables pagination through a set of `PlatbyCategory`. */
  platbyCategories: Maybe<PlatbyCategoriesConnection>;
  platbyCategory: Maybe<PlatbyCategory>;
  platbyCategoryGroup: Maybe<PlatbyCategoryGroup>;
  /** Reads and enables pagination through a set of `PlatbyCategoryGroup`. */
  platbyCategoryGroups: Maybe<PlatbyCategoryGroupsConnection>;
  platbyGroup: Maybe<PlatbyGroup>;
  platbyGroupSkupina: Maybe<PlatbyGroupSkupina>;
  /** Reads and enables pagination through a set of `PlatbyGroupSkupina`. */
  platbyGroupSkupinas: Maybe<PlatbyGroupSkupinasConnection>;
  /** Reads and enables pagination through a set of `PlatbyGroup`. */
  platbyGroups: Maybe<PlatbyGroupsConnection>;
  platbyItem: Maybe<PlatbyItem>;
  /** Reads and enables pagination through a set of `PlatbyItem`. */
  platbyItems: Maybe<PlatbyItemsConnection>;
  platbyRaw: Maybe<PlatbyRaw>;
  /** Reads and enables pagination through a set of `PlatbyRaw`. */
  platbyRaws: Maybe<PlatbyRawsConnection>;
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
  /** Reads and enables pagination through a set of `Nabidka`. */
  reservationsForRange: Maybe<NabidkasConnection>;
  room: Maybe<Room>;
  roomAttachment: Maybe<RoomAttachment>;
  /** Reads and enables pagination through a set of `RoomAttachment`. */
  roomAttachments: Maybe<RoomAttachmentsConnection>;
  /** Reads and enables pagination through a set of `Room`. */
  rooms: Maybe<RoomsConnection>;
  rozpi: Maybe<Rozpi>;
  /** Reads and enables pagination through a set of `Rozpi`. */
  rozpis: Maybe<RozpisConnection>;
  rozpisItem: Maybe<RozpisItem>;
  /** Reads and enables pagination through a set of `RozpisItem`. */
  rozpisItems: Maybe<RozpisItemsConnection>;
  /** Reads and enables pagination through a set of `Rozpi`. */
  schedulesForRange: Maybe<RozpisConnection>;
  session: Maybe<Session>;
  /** Reads and enables pagination through a set of `Session`. */
  sessions: Maybe<SessionsConnection>;
  /** Reads and enables pagination through a set of `Skupiny`. */
  skupinies: Maybe<SkupiniesConnection>;
  skupiny: Maybe<Skupiny>;
  /** Reads and enables pagination through a set of `Upozorneni`. */
  stickyAnnouncements: Maybe<UpozornenisConnection>;
  tenant: Maybe<Tenant>;
  tenantAttachment: Maybe<TenantAttachment>;
  /** Reads and enables pagination through a set of `TenantAttachment`. */
  tenantAttachments: Maybe<TenantAttachmentsConnection>;
  tenantLocation: Maybe<TenantLocation>;
  /** Reads and enables pagination through a set of `TenantLocation`. */
  tenantLocations: Maybe<TenantLocationsConnection>;
  /** Reads and enables pagination through a set of `TenantPerson`. */
  tenantPeople: Maybe<TenantPeopleConnection>;
  tenantPerson: Maybe<TenantPerson>;
  /** Reads and enables pagination through a set of `Tenant`. */
  tenants: Maybe<TenantsConnection>;
  /** Reads and enables pagination through a set of `Video`. */
  titleVideos: Maybe<VideosConnection>;
  /** Reads and enables pagination through a set of `User`. */
  trainers: Maybe<UsersConnection>;
  upozorneni: Maybe<Upozorneni>;
  /** Reads and enables pagination through a set of `UpozorneniSkupiny`. */
  upozorneniSkupinies: Maybe<UpozorneniSkupiniesConnection>;
  upozorneniSkupiny: Maybe<UpozorneniSkupiny>;
  /** Reads and enables pagination through a set of `Upozorneni`. */
  upozornenis: Maybe<UpozornenisConnection>;
  user: Maybe<User>;
  /** Reads and enables pagination through a set of `User`. */
  users: Maybe<UsersConnection>;
};


/** The root query type which gives access points into the data universe. */
export type QueryActiveCouplesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAkceItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AkceItemsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAkcesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AkcesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAktualitiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AktualityCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AktualitiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAktualityArgs = {
  atId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryArchivedAnnouncementsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAttachmentArgs = {
  objectName: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAttachmentDirectoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AttachmentCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AttachmentsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAttendeeCoupleArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAttendeeCouplesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AttendeeCoupleCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AttendeeCouplesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAttendeeExternalArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAttendeeExternalsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AttendeeExternalCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AttendeeExternalsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAttendeeListArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAttendeeListsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AttendeeListCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AttendeeListsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAttendeePeopleArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AttendeePersonCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AttendeePeopleOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAttendeePersonArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAttendeeUserArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAttendeeUserByUserIdAndEventIdArgs = {
  eventId: Scalars['BigInt']['input'];
  userId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAttendeeUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AttendeeUserCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AttendeeUsersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCohortGroupArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCohortGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CohortGroupCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CohortGroupsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCoupleArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCouplesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CoupleCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CouplesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCurrentCoupleIdsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCurrentPermissionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDokumentiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DokumentyCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DokumentiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDokumentyArgs = {
  dId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFormResponseArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFormResponsesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormResponseCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormResponsesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGalerieDirArgs = {
  gdId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGalerieDirsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GalerieDirCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GalerieDirsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGalerieFotoArgs = {
  gfId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGalerieFotosArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GalerieFotoCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GalerieFotosOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLocationArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLocationAttachmentArgs = {
  locationId: Scalars['BigInt']['input'];
  objectName: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLocationAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LocationAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LocationAttachmentsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLocationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LocationCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LocationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMyAnnouncementsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  archive?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMyLessonsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  endDate?: InputMaybe<Scalars['Date']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  startDate?: InputMaybe<Scalars['Date']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNabidkaArgs = {
  nId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNabidkaItemArgs = {
  niId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNabidkaItemByNiPartnerAndNiIdRodicArgs = {
  niIdRodic: Scalars['BigInt']['input'];
  niPartner: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNabidkaItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<NabidkaItemCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NabidkaItemsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNabidkasArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<NabidkaCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NabidkasOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPageArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPageByUrlArgs = {
  url: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPageRevisionArgs = {
  id: Scalars['Int']['input'];
  revNumber: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPageRevisionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PageRevisionCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PageRevisionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPagesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PageCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PagesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryParameterArgs = {
  paName: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryParametersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ParameterCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ParametersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPariesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ParyCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PariesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryParyArgs = {
  pId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryParyNavrhArgs = {
  pnId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryParyNavrhsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ParyNavrhCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ParyNavrhsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPeopleArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PersonCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PeopleOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionArgs = {
  peId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PermissionCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPersonArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyCategoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PlatbyCategoryCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PlatbyCategoriesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyCategoryArgs = {
  pcId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyCategoryGroupArgs = {
  pcgId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyCategoryGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PlatbyCategoryGroupCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PlatbyCategoryGroupsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyGroupArgs = {
  pgId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyGroupSkupinaArgs = {
  pgsId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyGroupSkupinasArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PlatbyGroupSkupinaCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PlatbyGroupSkupinasOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PlatbyGroupCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PlatbyGroupsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyItemArgs = {
  piId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PlatbyItemCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PlatbyItemsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyRawArgs = {
  prId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyRawsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PlatbyRawCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PlatbyRawsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReservationsForRangeArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  endDate?: InputMaybe<Scalars['Date']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  startDate?: InputMaybe<Scalars['Date']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomAttachmentArgs = {
  objectName: Scalars['String']['input'];
  roomId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomAttachmentsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRozpiArgs = {
  rId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRozpisArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RozpiCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RozpisOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRozpisItemArgs = {
  riId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRozpisItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RozpisItemCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RozpisItemsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySchedulesForRangeArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  endDate?: InputMaybe<Scalars['Date']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  startDate?: InputMaybe<Scalars['Date']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySessionArgs = {
  ssId: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySessionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SessionCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SessionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySkupiniesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SkupinyCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SkupiniesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySkupinyArgs = {
  sId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStickyAnnouncementsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantAttachmentArgs = {
  objectName: Scalars['String']['input'];
  tenantId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TenantAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TenantAttachmentsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantLocationArgs = {
  locationId: Scalars['BigInt']['input'];
  tenantId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantLocationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TenantLocationCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TenantLocationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantPeopleArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TenantPersonCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TenantPeopleOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantPersonArgs = {
  personId: Scalars['BigInt']['input'];
  tenantId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TenantCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TenantsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTitleVideosArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTrainersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUpozorneniArgs = {
  upId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUpozorneniSkupiniesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UpozorneniSkupinyCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UpozorneniSkupiniesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUpozorneniSkupinyArgs = {
  upsId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUpozornenisArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UpozorneniCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UpozornenisOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserArgs = {
  uId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the `reservationSetDesiredLessons` mutation. */
export type ReservationSetDesiredLessonsInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  lessonCount: Scalars['Int']['input'];
  reservationId: Scalars['BigInt']['input'];
};

/** The output of our `reservationSetDesiredLessons` mutation. */
export type ReservationSetDesiredLessonsPayload = {
  __typename?: 'ReservationSetDesiredLessonsPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** An edge for our `Nabidka`. May be used by Relay 1. */
  nabidkaEdge: Maybe<NabidkasEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  reservation: Maybe<Nabidka>;
  /** Reads a single `User` that is related to this `Nabidka`. */
  userByNTrener: Maybe<User>;
};


/** The output of our `reservationSetDesiredLessons` mutation. */
export type ReservationSetDesiredLessonsPayloadNabidkaEdgeArgs = {
  orderBy?: InputMaybe<Array<NabidkasOrderBy>>;
};

/** All input for the `resetPassword` mutation. */
export type ResetPasswordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  login: Scalars['String']['input'];
};

/** The output of our `resetPassword` mutation. */
export type ResetPasswordPayload = {
  __typename?: 'ResetPasswordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type Room = {
  __typename?: 'Room';
  description: Scalars['JSON']['output'];
  id: Scalars['BigInt']['output'];
  location: Maybe<Scalars['BigInt']['output']>;
  /** Reads a single `Location` that is related to this `Room`. */
  locationByLocation: Maybe<Location>;
  name: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `RoomAttachment`. */
  roomAttachments: RoomAttachmentsConnection;
};


export type RoomRoomAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomAttachmentsOrderBy>>;
};

export type RoomAttachment = {
  __typename?: 'RoomAttachment';
  /** Reads a single `Attachment` that is related to this `RoomAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  objectName: Scalars['String']['output'];
  /** Reads a single `Room` that is related to this `RoomAttachment`. */
  room: Maybe<Room>;
  roomId: Scalars['BigInt']['output'];
};

/**
 * A condition to be used against `RoomAttachment` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type RoomAttachmentCondition = {
  /** Checks for equality with the object’s `objectName` field. */
  objectName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `roomId` field. */
  roomId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `RoomAttachment` */
export type RoomAttachmentInput = {
  objectName: Scalars['String']['input'];
  roomId: Scalars['BigInt']['input'];
};

/** Represents an update to a `RoomAttachment`. Fields that are set will be updated. */
export type RoomAttachmentPatch = {
  objectName?: InputMaybe<Scalars['String']['input']>;
  roomId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `RoomAttachment` values. */
export type RoomAttachmentsConnection = {
  __typename?: 'RoomAttachmentsConnection';
  /** A list of edges which contains the `RoomAttachment` and cursor to aid in pagination. */
  edges: Array<RoomAttachmentsEdge>;
  /** A list of `RoomAttachment` objects. */
  nodes: Array<RoomAttachment>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `RoomAttachment` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `RoomAttachment` edge in the connection. */
export type RoomAttachmentsEdge = {
  __typename?: 'RoomAttachmentsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `RoomAttachment` at the end of the edge. */
  node: RoomAttachment;
};

/** Methods to use when ordering `RoomAttachment`. */
export type RoomAttachmentsOrderBy =
  | 'ATTACHMENT_BY_OBJECT_NAME__OBJECT_NAME_ASC'
  | 'ATTACHMENT_BY_OBJECT_NAME__OBJECT_NAME_DESC'
  | 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_BY_ASC'
  | 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_BY_DESC'
  | 'NATURAL'
  | 'OBJECT_NAME_ASC'
  | 'OBJECT_NAME_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'ROOM_BY_ROOM_ID__ID_ASC'
  | 'ROOM_BY_ROOM_ID__ID_DESC'
  | 'ROOM_BY_ROOM_ID__LOCATION_ASC'
  | 'ROOM_BY_ROOM_ID__LOCATION_DESC'
  | 'ROOM_ID_ASC'
  | 'ROOM_ID_DESC';

/** A condition to be used against `Room` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type RoomCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `location` field. */
  location?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `Room` */
export type RoomInput = {
  description: Scalars['JSON']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  location?: InputMaybe<Scalars['BigInt']['input']>;
  name: Scalars['String']['input'];
};

/** Represents an update to a `Room`. Fields that are set will be updated. */
export type RoomPatch = {
  description?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  location?: InputMaybe<Scalars['BigInt']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `Room` values. */
export type RoomsConnection = {
  __typename?: 'RoomsConnection';
  /** A list of edges which contains the `Room` and cursor to aid in pagination. */
  edges: Array<RoomsEdge>;
  /** A list of `Room` objects. */
  nodes: Array<Room>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Room` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Room` edge in the connection. */
export type RoomsEdge = {
  __typename?: 'RoomsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Room` at the end of the edge. */
  node: Room;
};

/** Methods to use when ordering `Room`. */
export type RoomsOrderBy =
  | 'ID_ASC'
  | 'ID_DESC'
  | 'LOCATION_ASC'
  | 'LOCATION_BY_LOCATION__ID_ASC'
  | 'LOCATION_BY_LOCATION__ID_DESC'
  | 'LOCATION_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'ROOM_ATTACHMENTS_BY_ROOM_ID__COUNT_ASC'
  | 'ROOM_ATTACHMENTS_BY_ROOM_ID__COUNT_DESC';

export type Rozpi = {
  __typename?: 'Rozpi';
  id: Maybe<Scalars['BigInt']['output']>;
  rDatum: Scalars['Date']['output'];
  rId: Scalars['BigInt']['output'];
  rKde: Scalars['String']['output'];
  rLock: Scalars['Boolean']['output'];
  rTimestamp: Maybe<Scalars['Datetime']['output']>;
  rTrener: Scalars['BigInt']['output'];
  rVisible: Scalars['Boolean']['output'];
  /** Reads and enables pagination through a set of `RozpisItem`. */
  rozpisItemsByRiIdRodic: RozpisItemsConnection;
  tenantId: Scalars['BigInt']['output'];
  /** Reads a single `User` that is related to this `Rozpi`. */
  userByRTrener: Maybe<User>;
};


export type RozpiRozpisItemsByRiIdRodicArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RozpisItemCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RozpisItemsOrderBy>>;
};

/** A condition to be used against `Rozpi` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type RozpiCondition = {
  /** Checks for equality with the object’s `rDatum` field. */
  rDatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `rId` field. */
  rId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `rTrener` field. */
  rTrener?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `Rozpi` */
export type RozpiInput = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  rDatum: Scalars['Date']['input'];
  rId?: InputMaybe<Scalars['BigInt']['input']>;
  rKde: Scalars['String']['input'];
  rLock?: InputMaybe<Scalars['Boolean']['input']>;
  rTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
  rTrener: Scalars['BigInt']['input'];
  rVisible?: InputMaybe<Scalars['Boolean']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Represents an update to a `Rozpi`. Fields that are set will be updated. */
export type RozpiPatch = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  rDatum?: InputMaybe<Scalars['Date']['input']>;
  rId?: InputMaybe<Scalars['BigInt']['input']>;
  rKde?: InputMaybe<Scalars['String']['input']>;
  rLock?: InputMaybe<Scalars['Boolean']['input']>;
  rTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
  rTrener?: InputMaybe<Scalars['BigInt']['input']>;
  rVisible?: InputMaybe<Scalars['Boolean']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `Rozpi` values. */
export type RozpisConnection = {
  __typename?: 'RozpisConnection';
  /** A list of edges which contains the `Rozpi` and cursor to aid in pagination. */
  edges: Array<RozpisEdge>;
  /** A list of `Rozpi` objects. */
  nodes: Array<Rozpi>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Rozpi` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Rozpi` edge in the connection. */
export type RozpisEdge = {
  __typename?: 'RozpisEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Rozpi` at the end of the edge. */
  node: Rozpi;
};

export type RozpisItem = {
  __typename?: 'RozpisItem';
  id: Maybe<Scalars['BigInt']['output']>;
  /** Reads a single `Pary` that is related to this `RozpisItem`. */
  paryByRiPartner: Maybe<Pary>;
  riDo: Scalars['Time']['output'];
  riId: Scalars['BigInt']['output'];
  riIdRodic: Scalars['BigInt']['output'];
  riLock: Scalars['Boolean']['output'];
  riOd: Scalars['Time']['output'];
  riPartner: Maybe<Scalars['BigInt']['output']>;
  /** Reads a single `Rozpi` that is related to this `RozpisItem`. */
  rozpiByRiIdRodic: Maybe<Rozpi>;
  tenantId: Scalars['BigInt']['output'];
};

/**
 * A condition to be used against `RozpisItem` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type RozpisItemCondition = {
  /** Checks for equality with the object’s `riId` field. */
  riId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `riIdRodic` field. */
  riIdRodic?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `riOd` field. */
  riOd?: InputMaybe<Scalars['Time']['input']>;
  /** Checks for equality with the object’s `riPartner` field. */
  riPartner?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `RozpisItem` */
export type RozpisItemInput = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  riDo: Scalars['Time']['input'];
  riId?: InputMaybe<Scalars['BigInt']['input']>;
  riIdRodic: Scalars['BigInt']['input'];
  riLock?: InputMaybe<Scalars['Boolean']['input']>;
  riOd: Scalars['Time']['input'];
  riPartner?: InputMaybe<Scalars['BigInt']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Represents an update to a `RozpisItem`. Fields that are set will be updated. */
export type RozpisItemPatch = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  riDo?: InputMaybe<Scalars['Time']['input']>;
  riId?: InputMaybe<Scalars['BigInt']['input']>;
  riIdRodic?: InputMaybe<Scalars['BigInt']['input']>;
  riLock?: InputMaybe<Scalars['Boolean']['input']>;
  riOd?: InputMaybe<Scalars['Time']['input']>;
  riPartner?: InputMaybe<Scalars['BigInt']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `RozpisItem` values. */
export type RozpisItemsConnection = {
  __typename?: 'RozpisItemsConnection';
  /** A list of edges which contains the `RozpisItem` and cursor to aid in pagination. */
  edges: Array<RozpisItemsEdge>;
  /** A list of `RozpisItem` objects. */
  nodes: Array<RozpisItem>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `RozpisItem` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `RozpisItem` edge in the connection. */
export type RozpisItemsEdge = {
  __typename?: 'RozpisItemsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `RozpisItem` at the end of the edge. */
  node: RozpisItem;
};

/** Methods to use when ordering `RozpisItem`. */
export type RozpisItemsOrderBy =
  | 'NATURAL'
  | 'PARY_BY_RI_PARTNER__P_HODNOCENI_ASC'
  | 'PARY_BY_RI_PARTNER__P_HODNOCENI_DESC'
  | 'PARY_BY_RI_PARTNER__P_ID_ASC'
  | 'PARY_BY_RI_PARTNER__P_ID_DESC'
  | 'PARY_BY_RI_PARTNER__P_ID_PARTNERKA_ASC'
  | 'PARY_BY_RI_PARTNER__P_ID_PARTNERKA_DESC'
  | 'PARY_BY_RI_PARTNER__P_ID_PARTNER_ASC'
  | 'PARY_BY_RI_PARTNER__P_ID_PARTNER_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'RI_ID_ASC'
  | 'RI_ID_DESC'
  | 'RI_ID_RODIC_ASC'
  | 'RI_ID_RODIC_DESC'
  | 'RI_OD_ASC'
  | 'RI_OD_DESC'
  | 'RI_PARTNER_ASC'
  | 'RI_PARTNER_DESC'
  | 'ROZPI_BY_RI_ID_RODIC__R_DATUM_ASC'
  | 'ROZPI_BY_RI_ID_RODIC__R_DATUM_DESC'
  | 'ROZPI_BY_RI_ID_RODIC__R_ID_ASC'
  | 'ROZPI_BY_RI_ID_RODIC__R_ID_DESC'
  | 'ROZPI_BY_RI_ID_RODIC__R_TRENER_ASC'
  | 'ROZPI_BY_RI_ID_RODIC__R_TRENER_DESC';

/** Methods to use when ordering `Rozpi`. */
export type RozpisOrderBy =
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'ROZPIS_ITEMS_BY_RI_ID_RODIC__COUNT_ASC'
  | 'ROZPIS_ITEMS_BY_RI_ID_RODIC__COUNT_DESC'
  | 'R_DATUM_ASC'
  | 'R_DATUM_DESC'
  | 'R_ID_ASC'
  | 'R_ID_DESC'
  | 'R_TRENER_ASC'
  | 'R_TRENER_DESC'
  | 'USER_BY_R_TRENER__U_BAN_ASC'
  | 'USER_BY_R_TRENER__U_BAN_DESC'
  | 'USER_BY_R_TRENER__U_CONFIRMED_ASC'
  | 'USER_BY_R_TRENER__U_CONFIRMED_DESC'
  | 'USER_BY_R_TRENER__U_GROUP_ASC'
  | 'USER_BY_R_TRENER__U_GROUP_DESC'
  | 'USER_BY_R_TRENER__U_ID_ASC'
  | 'USER_BY_R_TRENER__U_ID_DESC'
  | 'USER_BY_R_TRENER__U_JMENO_ASC'
  | 'USER_BY_R_TRENER__U_JMENO_DESC'
  | 'USER_BY_R_TRENER__U_LOGIN_ASC'
  | 'USER_BY_R_TRENER__U_LOGIN_DESC'
  | 'USER_BY_R_TRENER__U_NAROZENI_ASC'
  | 'USER_BY_R_TRENER__U_NAROZENI_DESC'
  | 'USER_BY_R_TRENER__U_PRIJMENI_ASC'
  | 'USER_BY_R_TRENER__U_PRIJMENI_DESC'
  | 'USER_BY_R_TRENER__U_SKUPINA_ASC'
  | 'USER_BY_R_TRENER__U_SKUPINA_DESC'
  | 'USER_BY_R_TRENER__U_SYSTEM_ASC'
  | 'USER_BY_R_TRENER__U_SYSTEM_DESC';

export type Session = {
  __typename?: 'Session';
  ssId: Scalars['String']['output'];
  ssLifetime: Scalars['BigInt']['output'];
  ssUpdatedAt: Scalars['Datetime']['output'];
  ssUser: Maybe<Scalars['BigInt']['output']>;
  /** Reads a single `User` that is related to this `Session`. */
  userBySsUser: Maybe<User>;
};

/** A condition to be used against `Session` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type SessionCondition = {
  /** Checks for equality with the object’s `ssId` field. */
  ssId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ssUser` field. */
  ssUser?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `Session` values. */
export type SessionsConnection = {
  __typename?: 'SessionsConnection';
  /** A list of edges which contains the `Session` and cursor to aid in pagination. */
  edges: Array<SessionsEdge>;
  /** A list of `Session` objects. */
  nodes: Array<Session>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Session` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Session` edge in the connection. */
export type SessionsEdge = {
  __typename?: 'SessionsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Session` at the end of the edge. */
  node: Session;
};

/** Methods to use when ordering `Session`. */
export type SessionsOrderBy =
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SS_ID_ASC'
  | 'SS_ID_DESC'
  | 'SS_USER_ASC'
  | 'SS_USER_DESC'
  | 'USER_BY_SS_USER__U_BAN_ASC'
  | 'USER_BY_SS_USER__U_BAN_DESC'
  | 'USER_BY_SS_USER__U_CONFIRMED_ASC'
  | 'USER_BY_SS_USER__U_CONFIRMED_DESC'
  | 'USER_BY_SS_USER__U_GROUP_ASC'
  | 'USER_BY_SS_USER__U_GROUP_DESC'
  | 'USER_BY_SS_USER__U_ID_ASC'
  | 'USER_BY_SS_USER__U_ID_DESC'
  | 'USER_BY_SS_USER__U_JMENO_ASC'
  | 'USER_BY_SS_USER__U_JMENO_DESC'
  | 'USER_BY_SS_USER__U_LOGIN_ASC'
  | 'USER_BY_SS_USER__U_LOGIN_DESC'
  | 'USER_BY_SS_USER__U_NAROZENI_ASC'
  | 'USER_BY_SS_USER__U_NAROZENI_DESC'
  | 'USER_BY_SS_USER__U_PRIJMENI_ASC'
  | 'USER_BY_SS_USER__U_PRIJMENI_DESC'
  | 'USER_BY_SS_USER__U_SKUPINA_ASC'
  | 'USER_BY_SS_USER__U_SKUPINA_DESC'
  | 'USER_BY_SS_USER__U_SYSTEM_ASC'
  | 'USER_BY_SS_USER__U_SYSTEM_DESC';

/** A connection to a list of `Skupiny` values. */
export type SkupiniesConnection = {
  __typename?: 'SkupiniesConnection';
  /** A list of edges which contains the `Skupiny` and cursor to aid in pagination. */
  edges: Array<SkupiniesEdge>;
  /** A list of `Skupiny` objects. */
  nodes: Array<Skupiny>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Skupiny` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Skupiny` edge in the connection. */
export type SkupiniesEdge = {
  __typename?: 'SkupiniesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Skupiny` at the end of the edge. */
  node: Skupiny;
};

/** Methods to use when ordering `Skupiny`. */
export type SkupiniesOrderBy =
  | 'COHORT_GROUP_ASC'
  | 'COHORT_GROUP_BY_COHORT_GROUP__ID_ASC'
  | 'COHORT_GROUP_BY_COHORT_GROUP__ID_DESC'
  | 'COHORT_GROUP_BY_COHORT_GROUP__IS_PUBLIC_ASC'
  | 'COHORT_GROUP_BY_COHORT_GROUP__IS_PUBLIC_DESC'
  | 'COHORT_GROUP_BY_COHORT_GROUP__ORDERING_ASC'
  | 'COHORT_GROUP_BY_COHORT_GROUP__ORDERING_DESC'
  | 'COHORT_GROUP_BY_COHORT_GROUP__TENANT_ASC'
  | 'COHORT_GROUP_BY_COHORT_GROUP__TENANT_DESC'
  | 'COHORT_GROUP_DESC'
  | 'NATURAL'
  | 'ORDERING_ASC'
  | 'ORDERING_DESC'
  | 'PLATBY_GROUP_SKUPINAS_BY_PGS_ID_SKUPINA__COUNT_ASC'
  | 'PLATBY_GROUP_SKUPINAS_BY_PGS_ID_SKUPINA__COUNT_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'S_ID_ASC'
  | 'S_ID_DESC'
  | 'S_VISIBLE_ASC'
  | 'S_VISIBLE_DESC'
  | 'UPOZORNENI_SKUPINIES_BY_UPS_ID_SKUPINA__COUNT_ASC'
  | 'UPOZORNENI_SKUPINIES_BY_UPS_ID_SKUPINA__COUNT_DESC'
  | 'USERS_BY_U_SKUPINA__COUNT_ASC'
  | 'USERS_BY_U_SKUPINA__COUNT_DESC';

export type Skupiny = {
  __typename?: 'Skupiny';
  cohortGroup: Maybe<Scalars['BigInt']['output']>;
  /** Reads a single `CohortGroup` that is related to this `Skupiny`. */
  cohortGroupByCohortGroup: Maybe<CohortGroup>;
  id: Maybe<Scalars['BigInt']['output']>;
  internalInfo: Scalars['String']['output'];
  ordering: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `PlatbyGroupSkupina`. */
  platbyGroupSkupinasByPgsIdSkupina: PlatbyGroupSkupinasConnection;
  sColorRgb: Scalars['String']['output'];
  sColorText: Scalars['String']['output'];
  sDescription: Scalars['String']['output'];
  sId: Scalars['BigInt']['output'];
  sLocation: Scalars['String']['output'];
  sName: Scalars['String']['output'];
  sVisible: Scalars['Boolean']['output'];
  tenantId: Scalars['BigInt']['output'];
  /** Reads and enables pagination through a set of `UpozorneniSkupiny`. */
  upozorneniSkupiniesByUpsIdSkupina: UpozorneniSkupiniesConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByUSkupina: UsersConnection;
};


export type SkupinyPlatbyGroupSkupinasByPgsIdSkupinaArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PlatbyGroupSkupinaCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PlatbyGroupSkupinasOrderBy>>;
};


export type SkupinyUpozorneniSkupiniesByUpsIdSkupinaArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UpozorneniSkupinyCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UpozorneniSkupiniesOrderBy>>;
};


export type SkupinyUsersByUSkupinaArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** A condition to be used against `Skupiny` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type SkupinyCondition = {
  /** Checks for equality with the object’s `cohortGroup` field. */
  cohortGroup?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `ordering` field. */
  ordering?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sId` field. */
  sId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `sVisible` field. */
  sVisible?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `Skupiny` */
export type SkupinyInput = {
  cohortGroup?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  internalInfo?: InputMaybe<Scalars['String']['input']>;
  ordering?: InputMaybe<Scalars['Int']['input']>;
  sColorRgb: Scalars['String']['input'];
  sColorText?: InputMaybe<Scalars['String']['input']>;
  sDescription: Scalars['String']['input'];
  sId?: InputMaybe<Scalars['BigInt']['input']>;
  sLocation?: InputMaybe<Scalars['String']['input']>;
  sName: Scalars['String']['input'];
  sVisible?: InputMaybe<Scalars['Boolean']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Represents an update to a `Skupiny`. Fields that are set will be updated. */
export type SkupinyPatch = {
  cohortGroup?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  internalInfo?: InputMaybe<Scalars['String']['input']>;
  ordering?: InputMaybe<Scalars['Int']['input']>;
  sColorRgb?: InputMaybe<Scalars['String']['input']>;
  sColorText?: InputMaybe<Scalars['String']['input']>;
  sDescription?: InputMaybe<Scalars['String']['input']>;
  sId?: InputMaybe<Scalars['BigInt']['input']>;
  sLocation?: InputMaybe<Scalars['String']['input']>;
  sName?: InputMaybe<Scalars['String']['input']>;
  sVisible?: InputMaybe<Scalars['Boolean']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** All input for the `submitForm` mutation. */
export type SubmitFormInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  data: Scalars['JSON']['input'];
  type: Scalars['String']['input'];
  url: Scalars['String']['input'];
};

/** The output of our `submitForm` mutation. */
export type SubmitFormPayload = {
  __typename?: 'SubmitFormPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type Tenant = {
  __typename?: 'Tenant';
  /** Reads and enables pagination through a set of `AttendeeCouple`. */
  attendeeCouples: AttendeeCouplesConnection;
  /** Reads and enables pagination through a set of `AttendeeList`. */
  attendeeLists: AttendeeListsConnection;
  /** Reads and enables pagination through a set of `AttendeePerson`. */
  attendeePeople: AttendeePeopleConnection;
  /** Reads and enables pagination through a set of `CohortGroup`. */
  cohortGroupsByTenant: CohortGroupsConnection;
  /** Reads and enables pagination through a set of `Couple`. */
  couples: CouplesConnection;
  id: Scalars['BigInt']['output'];
  memberInfo: Scalars['String']['output'];
  name: Scalars['String']['output'];
  origins: Array<Maybe<Scalars['String']['output']>>;
  /** Reads and enables pagination through a set of `TenantAttachment`. */
  tenantAttachments: TenantAttachmentsConnection;
  /** Reads and enables pagination through a set of `TenantLocation`. */
  tenantLocations: TenantLocationsConnection;
  /** Reads and enables pagination through a set of `TenantPerson`. */
  tenantPeople: TenantPeopleConnection;
};


export type TenantAttendeeCouplesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AttendeeCoupleCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AttendeeCouplesOrderBy>>;
};


export type TenantAttendeeListsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AttendeeListCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AttendeeListsOrderBy>>;
};


export type TenantAttendeePeopleArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AttendeePersonCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AttendeePeopleOrderBy>>;
};


export type TenantCohortGroupsByTenantArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CohortGroupCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CohortGroupsOrderBy>>;
};


export type TenantCouplesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CoupleCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CouplesOrderBy>>;
};


export type TenantTenantAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TenantAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TenantAttachmentsOrderBy>>;
};


export type TenantTenantLocationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TenantLocationCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TenantLocationsOrderBy>>;
};


export type TenantTenantPeopleArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TenantPersonCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TenantPeopleOrderBy>>;
};

export type TenantAttachment = {
  __typename?: 'TenantAttachment';
  /** Reads a single `Attachment` that is related to this `TenantAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  objectName: Scalars['String']['output'];
  /** Reads a single `Tenant` that is related to this `TenantAttachment`. */
  tenant: Maybe<Tenant>;
  tenantId: Scalars['BigInt']['output'];
  type: Maybe<TenantAttachmentType>;
};

/**
 * A condition to be used against `TenantAttachment` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TenantAttachmentCondition = {
  /** Checks for equality with the object’s `objectName` field. */
  objectName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `tenantId` field. */
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `TenantAttachment` */
export type TenantAttachmentInput = {
  objectName: Scalars['String']['input'];
  tenantId: Scalars['BigInt']['input'];
  type?: InputMaybe<TenantAttachmentType>;
};

/** Represents an update to a `TenantAttachment`. Fields that are set will be updated. */
export type TenantAttachmentPatch = {
  objectName?: InputMaybe<Scalars['String']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
  type?: InputMaybe<TenantAttachmentType>;
};

export type TenantAttachmentType =
  | 'LOGO'
  | 'MAP'
  | 'PHOTO';

/** A connection to a list of `TenantAttachment` values. */
export type TenantAttachmentsConnection = {
  __typename?: 'TenantAttachmentsConnection';
  /** A list of edges which contains the `TenantAttachment` and cursor to aid in pagination. */
  edges: Array<TenantAttachmentsEdge>;
  /** A list of `TenantAttachment` objects. */
  nodes: Array<TenantAttachment>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TenantAttachment` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TenantAttachment` edge in the connection. */
export type TenantAttachmentsEdge = {
  __typename?: 'TenantAttachmentsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `TenantAttachment` at the end of the edge. */
  node: TenantAttachment;
};

/** Methods to use when ordering `TenantAttachment`. */
export type TenantAttachmentsOrderBy =
  | 'ATTACHMENT_BY_OBJECT_NAME__OBJECT_NAME_ASC'
  | 'ATTACHMENT_BY_OBJECT_NAME__OBJECT_NAME_DESC'
  | 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_BY_ASC'
  | 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_BY_DESC'
  | 'NATURAL'
  | 'OBJECT_NAME_ASC'
  | 'OBJECT_NAME_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TENANT_BY_TENANT_ID__ID_ASC'
  | 'TENANT_BY_TENANT_ID__ID_DESC'
  | 'TENANT_ID_ASC'
  | 'TENANT_ID_DESC';

/** A condition to be used against `Tenant` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TenantCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `Tenant` */
export type TenantInput = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  memberInfo: Scalars['String']['input'];
  name: Scalars['String']['input'];
  origins?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export type TenantLocation = {
  __typename?: 'TenantLocation';
  /** Reads a single `Location` that is related to this `TenantLocation`. */
  location: Maybe<Location>;
  locationId: Scalars['BigInt']['output'];
  /** Reads a single `Tenant` that is related to this `TenantLocation`. */
  tenant: Maybe<Tenant>;
  tenantId: Scalars['BigInt']['output'];
};

/**
 * A condition to be used against `TenantLocation` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TenantLocationCondition = {
  /** Checks for equality with the object’s `locationId` field. */
  locationId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `tenantId` field. */
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `TenantLocation` */
export type TenantLocationInput = {
  locationId: Scalars['BigInt']['input'];
  tenantId: Scalars['BigInt']['input'];
};

/** Represents an update to a `TenantLocation`. Fields that are set will be updated. */
export type TenantLocationPatch = {
  locationId?: InputMaybe<Scalars['BigInt']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `TenantLocation` values. */
export type TenantLocationsConnection = {
  __typename?: 'TenantLocationsConnection';
  /** A list of edges which contains the `TenantLocation` and cursor to aid in pagination. */
  edges: Array<TenantLocationsEdge>;
  /** A list of `TenantLocation` objects. */
  nodes: Array<TenantLocation>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TenantLocation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TenantLocation` edge in the connection. */
export type TenantLocationsEdge = {
  __typename?: 'TenantLocationsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `TenantLocation` at the end of the edge. */
  node: TenantLocation;
};

/** Methods to use when ordering `TenantLocation`. */
export type TenantLocationsOrderBy =
  | 'LOCATION_BY_LOCATION_ID__ID_ASC'
  | 'LOCATION_BY_LOCATION_ID__ID_DESC'
  | 'LOCATION_ID_ASC'
  | 'LOCATION_ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TENANT_BY_TENANT_ID__ID_ASC'
  | 'TENANT_BY_TENANT_ID__ID_DESC'
  | 'TENANT_ID_ASC'
  | 'TENANT_ID_DESC';

/** Represents an update to a `Tenant`. Fields that are set will be updated. */
export type TenantPatch = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  memberInfo?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  origins?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** A connection to a list of `TenantPerson` values. */
export type TenantPeopleConnection = {
  __typename?: 'TenantPeopleConnection';
  /** A list of edges which contains the `TenantPerson` and cursor to aid in pagination. */
  edges: Array<TenantPeopleEdge>;
  /** A list of `TenantPerson` objects. */
  nodes: Array<TenantPerson>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TenantPerson` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TenantPerson` edge in the connection. */
export type TenantPeopleEdge = {
  __typename?: 'TenantPeopleEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `TenantPerson` at the end of the edge. */
  node: TenantPerson;
};

/** Methods to use when ordering `TenantPerson`. */
export type TenantPeopleOrderBy =
  | 'NATURAL'
  | 'PERSON_BY_PERSON_ID__ID_ASC'
  | 'PERSON_BY_PERSON_ID__ID_DESC'
  | 'PERSON_ID_ASC'
  | 'PERSON_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TENANT_BY_TENANT_ID__ID_ASC'
  | 'TENANT_BY_TENANT_ID__ID_DESC'
  | 'TENANT_ID_ASC'
  | 'TENANT_ID_DESC';

export type TenantPerson = {
  __typename?: 'TenantPerson';
  /** Reads a single `Person` that is related to this `TenantPerson`. */
  person: Maybe<Person>;
  personId: Scalars['BigInt']['output'];
  /** Reads a single `Tenant` that is related to this `TenantPerson`. */
  tenant: Maybe<Tenant>;
  tenantId: Scalars['BigInt']['output'];
};

/**
 * A condition to be used against `TenantPerson` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TenantPersonCondition = {
  /** Checks for equality with the object’s `personId` field. */
  personId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `tenantId` field. */
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `TenantPerson` */
export type TenantPersonInput = {
  personId: Scalars['BigInt']['input'];
  tenantId: Scalars['BigInt']['input'];
};

/** Represents an update to a `TenantPerson`. Fields that are set will be updated. */
export type TenantPersonPatch = {
  personId?: InputMaybe<Scalars['BigInt']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `Tenant` values. */
export type TenantsConnection = {
  __typename?: 'TenantsConnection';
  /** A list of edges which contains the `Tenant` and cursor to aid in pagination. */
  edges: Array<TenantsEdge>;
  /** A list of `Tenant` objects. */
  nodes: Array<Tenant>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Tenant` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Tenant` edge in the connection. */
export type TenantsEdge = {
  __typename?: 'TenantsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Tenant` at the end of the edge. */
  node: Tenant;
};

/** Methods to use when ordering `Tenant`. */
export type TenantsOrderBy =
  | 'ATTENDEE_COUPLES_BY_TENANT_ID__COUNT_ASC'
  | 'ATTENDEE_COUPLES_BY_TENANT_ID__COUNT_DESC'
  | 'ATTENDEE_LISTS_BY_TENANT_ID__COUNT_ASC'
  | 'ATTENDEE_LISTS_BY_TENANT_ID__COUNT_DESC'
  | 'ATTENDEE_PEOPLE_BY_TENANT_ID__COUNT_ASC'
  | 'ATTENDEE_PEOPLE_BY_TENANT_ID__COUNT_DESC'
  | 'COHORT_GROUPS_BY_TENANT__COUNT_ASC'
  | 'COHORT_GROUPS_BY_TENANT__COUNT_DESC'
  | 'COUPLES_BY_TENANT_ID__COUNT_ASC'
  | 'COUPLES_BY_TENANT_ID__COUNT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TENANT_ATTACHMENTS_BY_TENANT_ID__COUNT_ASC'
  | 'TENANT_ATTACHMENTS_BY_TENANT_ID__COUNT_DESC'
  | 'TENANT_LOCATIONS_BY_TENANT_ID__COUNT_ASC'
  | 'TENANT_LOCATIONS_BY_TENANT_ID__COUNT_DESC'
  | 'TENANT_PEOPLE_BY_TENANT_ID__COUNT_ASC'
  | 'TENANT_PEOPLE_BY_TENANT_ID__COUNT_DESC';

/** All input for the `updateAktuality` mutation. */
export type UpdateAktualityInput = {
  atId: Scalars['BigInt']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Aktuality` being updated. */
  patch: AktualityPatch;
};

/** The output of our update `Aktuality` mutation. */
export type UpdateAktualityPayload = {
  __typename?: 'UpdateAktualityPayload';
  /** The `Aktuality` that was updated by this mutation. */
  aktuality: Maybe<Aktuality>;
  /** An edge for our `Aktuality`. May be used by Relay 1. */
  aktualityEdge: Maybe<AktualitiesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
  galerieFotoByAtFotoMain: Maybe<GalerieFoto>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Aktuality`. */
  userByAtKdo: Maybe<User>;
};


/** The output of our update `Aktuality` mutation. */
export type UpdateAktualityPayloadAktualityEdgeArgs = {
  orderBy?: InputMaybe<Array<AktualitiesOrderBy>>;
};

/** All input for the `updateAttachment` mutation. */
export type UpdateAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  objectName: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `Attachment` being updated. */
  patch: AttachmentPatch;
};

/** The output of our update `Attachment` mutation. */
export type UpdateAttachmentPayload = {
  __typename?: 'UpdateAttachmentPayload';
  /** The `Attachment` that was updated by this mutation. */
  attachment: Maybe<Attachment>;
  /** An edge for our `Attachment`. May be used by Relay 1. */
  attachmentEdge: Maybe<AttachmentsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Attachment`. */
  userByUploadedBy: Maybe<User>;
};


/** The output of our update `Attachment` mutation. */
export type UpdateAttachmentPayloadAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<AttachmentsOrderBy>>;
};

/** All input for the `updateAttendeeExternal` mutation. */
export type UpdateAttendeeExternalInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `AttendeeExternal` being updated. */
  patch: AttendeeExternalPatch;
};

/** The output of our update `AttendeeExternal` mutation. */
export type UpdateAttendeeExternalPayload = {
  __typename?: 'UpdateAttendeeExternalPayload';
  /** The `AttendeeExternal` that was updated by this mutation. */
  attendeeExternal: Maybe<AttendeeExternal>;
  /** An edge for our `AttendeeExternal`. May be used by Relay 1. */
  attendeeExternalEdge: Maybe<AttendeeExternalsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Event` that is related to this `AttendeeExternal`. */
  event: Maybe<Event>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `AttendeeExternal`. */
  userByConfirmedBy: Maybe<User>;
  /** Reads a single `User` that is related to this `AttendeeExternal`. */
  userByManagedBy: Maybe<User>;
};


/** The output of our update `AttendeeExternal` mutation. */
export type UpdateAttendeeExternalPayloadAttendeeExternalEdgeArgs = {
  orderBy?: InputMaybe<Array<AttendeeExternalsOrderBy>>;
};

/** All input for the `updateAttendeeUserByUserIdAndEventId` mutation. */
export type UpdateAttendeeUserByUserIdAndEventIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  eventId: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `AttendeeUser` being updated. */
  patch: AttendeeUserPatch;
  userId: Scalars['BigInt']['input'];
};

/** All input for the `updateAttendeeUser` mutation. */
export type UpdateAttendeeUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `AttendeeUser` being updated. */
  patch: AttendeeUserPatch;
};

/** The output of our update `AttendeeUser` mutation. */
export type UpdateAttendeeUserPayload = {
  __typename?: 'UpdateAttendeeUserPayload';
  /** The `AttendeeUser` that was updated by this mutation. */
  attendeeUser: Maybe<AttendeeUser>;
  /** An edge for our `AttendeeUser`. May be used by Relay 1. */
  attendeeUserEdge: Maybe<AttendeeUsersEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Event` that is related to this `AttendeeUser`. */
  event: Maybe<Event>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `AttendeeUser`. */
  user: Maybe<User>;
};


/** The output of our update `AttendeeUser` mutation. */
export type UpdateAttendeeUserPayloadAttendeeUserEdgeArgs = {
  orderBy?: InputMaybe<Array<AttendeeUsersOrderBy>>;
};

/** All input for the `updateCohortGroup` mutation. */
export type UpdateCohortGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `CohortGroup` being updated. */
  patch: CohortGroupPatch;
};

/** The output of our update `CohortGroup` mutation. */
export type UpdateCohortGroupPayload = {
  __typename?: 'UpdateCohortGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `CohortGroup` that was updated by this mutation. */
  cohortGroup: Maybe<CohortGroup>;
  /** An edge for our `CohortGroup`. May be used by Relay 1. */
  cohortGroupEdge: Maybe<CohortGroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `CohortGroup`. */
  tenantByTenant: Maybe<Tenant>;
};


/** The output of our update `CohortGroup` mutation. */
export type UpdateCohortGroupPayloadCohortGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<CohortGroupsOrderBy>>;
};

/** All input for the `updateDokumenty` mutation. */
export type UpdateDokumentyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  dId: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Dokumenty` being updated. */
  patch: DokumentyPatch;
};

/** The output of our update `Dokumenty` mutation. */
export type UpdateDokumentyPayload = {
  __typename?: 'UpdateDokumentyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Dokumenty` that was updated by this mutation. */
  dokumenty: Maybe<Dokumenty>;
  /** An edge for our `Dokumenty`. May be used by Relay 1. */
  dokumentyEdge: Maybe<DokumentiesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Dokumenty`. */
  userByDKdo: Maybe<User>;
};


/** The output of our update `Dokumenty` mutation. */
export type UpdateDokumentyPayloadDokumentyEdgeArgs = {
  orderBy?: InputMaybe<Array<DokumentiesOrderBy>>;
};

/** All input for the `updateEvent` mutation. */
export type UpdateEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Event` being updated. */
  patch: EventPatch;
};

/** The output of our update `Event` mutation. */
export type UpdateEventPayload = {
  __typename?: 'UpdateEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Event` that was updated by this mutation. */
  event: Maybe<Event>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge: Maybe<EventsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Event` mutation. */
export type UpdateEventPayloadEventEdgeArgs = {
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};

/** All input for the `updateFormResponse` mutation. */
export type UpdateFormResponseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `FormResponse` being updated. */
  patch: FormResponsePatch;
};

/** The output of our update `FormResponse` mutation. */
export type UpdateFormResponsePayload = {
  __typename?: 'UpdateFormResponsePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `FormResponse` that was updated by this mutation. */
  formResponse: Maybe<FormResponse>;
  /** An edge for our `FormResponse`. May be used by Relay 1. */
  formResponseEdge: Maybe<FormResponsesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `FormResponse` mutation. */
export type UpdateFormResponsePayloadFormResponseEdgeArgs = {
  orderBy?: InputMaybe<Array<FormResponsesOrderBy>>;
};

/** All input for the `updateGalerieDir` mutation. */
export type UpdateGalerieDirInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  gdId: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `GalerieDir` being updated. */
  patch: GalerieDirPatch;
};

/** The output of our update `GalerieDir` mutation. */
export type UpdateGalerieDirPayload = {
  __typename?: 'UpdateGalerieDirPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `GalerieDir` that was updated by this mutation. */
  galerieDir: Maybe<GalerieDir>;
  /** An edge for our `GalerieDir`. May be used by Relay 1. */
  galerieDirEdge: Maybe<GalerieDirsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `GalerieDir` mutation. */
export type UpdateGalerieDirPayloadGalerieDirEdgeArgs = {
  orderBy?: InputMaybe<Array<GalerieDirsOrderBy>>;
};

/** All input for the `updateGalerieFoto` mutation. */
export type UpdateGalerieFotoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  gfId: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `GalerieFoto` being updated. */
  patch: GalerieFotoPatch;
};

/** The output of our update `GalerieFoto` mutation. */
export type UpdateGalerieFotoPayload = {
  __typename?: 'UpdateGalerieFotoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
  galerieDirByGfIdRodic: Maybe<GalerieDir>;
  /** The `GalerieFoto` that was updated by this mutation. */
  galerieFoto: Maybe<GalerieFoto>;
  /** An edge for our `GalerieFoto`. May be used by Relay 1. */
  galerieFotoEdge: Maybe<GalerieFotosEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `GalerieFoto`. */
  userByGfKdo: Maybe<User>;
};


/** The output of our update `GalerieFoto` mutation. */
export type UpdateGalerieFotoPayloadGalerieFotoEdgeArgs = {
  orderBy?: InputMaybe<Array<GalerieFotosOrderBy>>;
};

/** All input for the `updateLocationAttachment` mutation. */
export type UpdateLocationAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  locationId: Scalars['BigInt']['input'];
  objectName: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `LocationAttachment` being updated. */
  patch: LocationAttachmentPatch;
};

/** The output of our update `LocationAttachment` mutation. */
export type UpdateLocationAttachmentPayload = {
  __typename?: 'UpdateLocationAttachmentPayload';
  /** Reads a single `Attachment` that is related to this `LocationAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Location` that is related to this `LocationAttachment`. */
  location: Maybe<Location>;
  /** The `LocationAttachment` that was updated by this mutation. */
  locationAttachment: Maybe<LocationAttachment>;
  /** An edge for our `LocationAttachment`. May be used by Relay 1. */
  locationAttachmentEdge: Maybe<LocationAttachmentsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `LocationAttachment` mutation. */
export type UpdateLocationAttachmentPayloadLocationAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<LocationAttachmentsOrderBy>>;
};

/** All input for the `updateLocation` mutation. */
export type UpdateLocationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Location` being updated. */
  patch: LocationPatch;
};

/** The output of our update `Location` mutation. */
export type UpdateLocationPayload = {
  __typename?: 'UpdateLocationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Location` that was updated by this mutation. */
  location: Maybe<Location>;
  /** An edge for our `Location`. May be used by Relay 1. */
  locationEdge: Maybe<LocationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Location` mutation. */
export type UpdateLocationPayloadLocationEdgeArgs = {
  orderBy?: InputMaybe<Array<LocationsOrderBy>>;
};

/** All input for the `updateNabidka` mutation. */
export type UpdateNabidkaInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  nId: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Nabidka` being updated. */
  patch: NabidkaPatch;
};

/** All input for the `updateNabidkaItemByNiPartnerAndNiIdRodic` mutation. */
export type UpdateNabidkaItemByNiPartnerAndNiIdRodicInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  niIdRodic: Scalars['BigInt']['input'];
  niPartner: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `NabidkaItem` being updated. */
  patch: NabidkaItemPatch;
};

/** All input for the `updateNabidkaItem` mutation. */
export type UpdateNabidkaItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  niId: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `NabidkaItem` being updated. */
  patch: NabidkaItemPatch;
};

/** The output of our update `NabidkaItem` mutation. */
export type UpdateNabidkaItemPayload = {
  __typename?: 'UpdateNabidkaItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Nabidka` that is related to this `NabidkaItem`. */
  nabidkaByNiIdRodic: Maybe<Nabidka>;
  /** The `NabidkaItem` that was updated by this mutation. */
  nabidkaItem: Maybe<NabidkaItem>;
  /** An edge for our `NabidkaItem`. May be used by Relay 1. */
  nabidkaItemEdge: Maybe<NabidkaItemsEdge>;
  /** Reads a single `Pary` that is related to this `NabidkaItem`. */
  paryByNiPartner: Maybe<Pary>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `NabidkaItem` mutation. */
export type UpdateNabidkaItemPayloadNabidkaItemEdgeArgs = {
  orderBy?: InputMaybe<Array<NabidkaItemsOrderBy>>;
};

/** The output of our update `Nabidka` mutation. */
export type UpdateNabidkaPayload = {
  __typename?: 'UpdateNabidkaPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Nabidka` that was updated by this mutation. */
  nabidka: Maybe<Nabidka>;
  /** An edge for our `Nabidka`. May be used by Relay 1. */
  nabidkaEdge: Maybe<NabidkasEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Nabidka`. */
  userByNTrener: Maybe<User>;
};


/** The output of our update `Nabidka` mutation. */
export type UpdateNabidkaPayloadNabidkaEdgeArgs = {
  orderBy?: InputMaybe<Array<NabidkasOrderBy>>;
};

/** All input for the `updatePageByUrl` mutation. */
export type UpdatePageByUrlInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Page` being updated. */
  patch: PagePatch;
  url: Scalars['String']['input'];
};

/** All input for the `updatePage` mutation. */
export type UpdatePageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Page` being updated. */
  patch: PagePatch;
};

/** The output of our update `Page` mutation. */
export type UpdatePagePayload = {
  __typename?: 'UpdatePagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Page` that was updated by this mutation. */
  page: Maybe<Page>;
  /** An edge for our `Page`. May be used by Relay 1. */
  pageEdge: Maybe<PagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Page` mutation. */
export type UpdatePagePayloadPageEdgeArgs = {
  orderBy?: InputMaybe<Array<PagesOrderBy>>;
};

/** All input for the `updateParameter` mutation. */
export type UpdateParameterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  paName: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `Parameter` being updated. */
  patch: ParameterPatch;
};

/** The output of our update `Parameter` mutation. */
export type UpdateParameterPayload = {
  __typename?: 'UpdateParameterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Parameter` that was updated by this mutation. */
  parameter: Maybe<Parameter>;
  /** An edge for our `Parameter`. May be used by Relay 1. */
  parameterEdge: Maybe<ParametersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Parameter` mutation. */
export type UpdateParameterPayloadParameterEdgeArgs = {
  orderBy?: InputMaybe<Array<ParametersOrderBy>>;
};

/** All input for the `updatePary` mutation. */
export type UpdateParyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  pId: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Pary` being updated. */
  patch: ParyPatch;
};

/** All input for the `updateParyNavrh` mutation. */
export type UpdateParyNavrhInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `ParyNavrh` being updated. */
  patch: ParyNavrhPatch;
  pnId: Scalars['BigInt']['input'];
};

/** The output of our update `ParyNavrh` mutation. */
export type UpdateParyNavrhPayload = {
  __typename?: 'UpdateParyNavrhPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `ParyNavrh` that was updated by this mutation. */
  paryNavrh: Maybe<ParyNavrh>;
  /** An edge for our `ParyNavrh`. May be used by Relay 1. */
  paryNavrhEdge: Maybe<ParyNavrhsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnNavrhl: Maybe<User>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `ParyNavrh`. */
  userByPnPartnerka: Maybe<User>;
};


/** The output of our update `ParyNavrh` mutation. */
export type UpdateParyNavrhPayloadParyNavrhEdgeArgs = {
  orderBy?: InputMaybe<Array<ParyNavrhsOrderBy>>;
};

/** The output of our update `Pary` mutation. */
export type UpdateParyPayload = {
  __typename?: 'UpdateParyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Pary` that was updated by this mutation. */
  pary: Maybe<Pary>;
  /** An edge for our `Pary`. May be used by Relay 1. */
  paryEdge: Maybe<PariesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartnerka: Maybe<User>;
};


/** The output of our update `Pary` mutation. */
export type UpdateParyPayloadParyEdgeArgs = {
  orderBy?: InputMaybe<Array<PariesOrderBy>>;
};

/** All input for the `updatePermission` mutation. */
export type UpdatePermissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Permission` being updated. */
  patch: PermissionPatch;
  peId: Scalars['BigInt']['input'];
};

/** The output of our update `Permission` mutation. */
export type UpdatePermissionPayload = {
  __typename?: 'UpdatePermissionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Permission` that was updated by this mutation. */
  permission: Maybe<Permission>;
  /** An edge for our `Permission`. May be used by Relay 1. */
  permissionEdge: Maybe<PermissionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Permission` mutation. */
export type UpdatePermissionPayloadPermissionEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
};

/** All input for the `updatePerson` mutation. */
export type UpdatePersonInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Person` being updated. */
  patch: PersonPatch;
};

/** The output of our update `Person` mutation. */
export type UpdatePersonPayload = {
  __typename?: 'UpdatePersonPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Person` that was updated by this mutation. */
  person: Maybe<Person>;
  /** An edge for our `Person`. May be used by Relay 1. */
  personEdge: Maybe<PeopleEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Person` mutation. */
export type UpdatePersonPayloadPersonEdgeArgs = {
  orderBy?: InputMaybe<Array<PeopleOrderBy>>;
};

/** All input for the `updatePlatbyCategoryGroup` mutation. */
export type UpdatePlatbyCategoryGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `PlatbyCategoryGroup` being updated. */
  patch: PlatbyCategoryGroupPatch;
  pcgId: Scalars['BigInt']['input'];
};

/** The output of our update `PlatbyCategoryGroup` mutation. */
export type UpdatePlatbyCategoryGroupPayload = {
  __typename?: 'UpdatePlatbyCategoryGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyCategoryGroup`. */
  platbyCategoryByPcgIdCategory: Maybe<PlatbyCategory>;
  /** The `PlatbyCategoryGroup` that was updated by this mutation. */
  platbyCategoryGroup: Maybe<PlatbyCategoryGroup>;
  /** An edge for our `PlatbyCategoryGroup`. May be used by Relay 1. */
  platbyCategoryGroupEdge: Maybe<PlatbyCategoryGroupsEdge>;
  /** Reads a single `PlatbyGroup` that is related to this `PlatbyCategoryGroup`. */
  platbyGroupByPcgIdGroup: Maybe<PlatbyGroup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `PlatbyCategoryGroup` mutation. */
export type UpdatePlatbyCategoryGroupPayloadPlatbyCategoryGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyCategoryGroupsOrderBy>>;
};

/** All input for the `updatePlatbyCategory` mutation. */
export type UpdatePlatbyCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `PlatbyCategory` being updated. */
  patch: PlatbyCategoryPatch;
  pcId: Scalars['BigInt']['input'];
};

/** The output of our update `PlatbyCategory` mutation. */
export type UpdatePlatbyCategoryPayload = {
  __typename?: 'UpdatePlatbyCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `PlatbyCategory` that was updated by this mutation. */
  platbyCategory: Maybe<PlatbyCategory>;
  /** An edge for our `PlatbyCategory`. May be used by Relay 1. */
  platbyCategoryEdge: Maybe<PlatbyCategoriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `PlatbyCategory` mutation. */
export type UpdatePlatbyCategoryPayloadPlatbyCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyCategoriesOrderBy>>;
};

/** All input for the `updatePlatbyGroup` mutation. */
export type UpdatePlatbyGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `PlatbyGroup` being updated. */
  patch: PlatbyGroupPatch;
  pgId: Scalars['BigInt']['input'];
};

/** The output of our update `PlatbyGroup` mutation. */
export type UpdatePlatbyGroupPayload = {
  __typename?: 'UpdatePlatbyGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `PlatbyGroup` that was updated by this mutation. */
  platbyGroup: Maybe<PlatbyGroup>;
  /** An edge for our `PlatbyGroup`. May be used by Relay 1. */
  platbyGroupEdge: Maybe<PlatbyGroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `PlatbyGroup` mutation. */
export type UpdatePlatbyGroupPayloadPlatbyGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyGroupsOrderBy>>;
};

/** All input for the `updatePlatbyGroupSkupina` mutation. */
export type UpdatePlatbyGroupSkupinaInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `PlatbyGroupSkupina` being updated. */
  patch: PlatbyGroupSkupinaPatch;
  pgsId: Scalars['BigInt']['input'];
};

/** The output of our update `PlatbyGroupSkupina` mutation. */
export type UpdatePlatbyGroupSkupinaPayload = {
  __typename?: 'UpdatePlatbyGroupSkupinaPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `PlatbyGroup` that is related to this `PlatbyGroupSkupina`. */
  platbyGroupByPgsIdGroup: Maybe<PlatbyGroup>;
  /** The `PlatbyGroupSkupina` that was updated by this mutation. */
  platbyGroupSkupina: Maybe<PlatbyGroupSkupina>;
  /** An edge for our `PlatbyGroupSkupina`. May be used by Relay 1. */
  platbyGroupSkupinaEdge: Maybe<PlatbyGroupSkupinasEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `PlatbyGroupSkupina`. */
  skupinyByPgsIdSkupina: Maybe<Skupiny>;
};


/** The output of our update `PlatbyGroupSkupina` mutation. */
export type UpdatePlatbyGroupSkupinaPayloadPlatbyGroupSkupinaEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyGroupSkupinasOrderBy>>;
};

/** All input for the `updatePlatbyItem` mutation. */
export type UpdatePlatbyItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `PlatbyItem` being updated. */
  patch: PlatbyItemPatch;
  piId: Scalars['BigInt']['input'];
};

/** The output of our update `PlatbyItem` mutation. */
export type UpdatePlatbyItemPayload = {
  __typename?: 'UpdatePlatbyItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
  platbyCategoryByPiIdCategory: Maybe<PlatbyCategory>;
  /** The `PlatbyItem` that was updated by this mutation. */
  platbyItem: Maybe<PlatbyItem>;
  /** An edge for our `PlatbyItem`. May be used by Relay 1. */
  platbyItemEdge: Maybe<PlatbyItemsEdge>;
  /** Reads a single `PlatbyRaw` that is related to this `PlatbyItem`. */
  platbyRawByPiIdRaw: Maybe<PlatbyRaw>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `PlatbyItem`. */
  userByPiIdUser: Maybe<User>;
};


/** The output of our update `PlatbyItem` mutation. */
export type UpdatePlatbyItemPayloadPlatbyItemEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyItemsOrderBy>>;
};

/** All input for the `updatePlatbyRaw` mutation. */
export type UpdatePlatbyRawInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `PlatbyRaw` being updated. */
  patch: PlatbyRawPatch;
  prId: Scalars['BigInt']['input'];
};

/** The output of our update `PlatbyRaw` mutation. */
export type UpdatePlatbyRawPayload = {
  __typename?: 'UpdatePlatbyRawPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `PlatbyRaw` that was updated by this mutation. */
  platbyRaw: Maybe<PlatbyRaw>;
  /** An edge for our `PlatbyRaw`. May be used by Relay 1. */
  platbyRawEdge: Maybe<PlatbyRawsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `PlatbyRaw` mutation. */
export type UpdatePlatbyRawPayloadPlatbyRawEdgeArgs = {
  orderBy?: InputMaybe<Array<PlatbyRawsOrderBy>>;
};

/** All input for the `updateRoomAttachment` mutation. */
export type UpdateRoomAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  objectName: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `RoomAttachment` being updated. */
  patch: RoomAttachmentPatch;
  roomId: Scalars['BigInt']['input'];
};

/** The output of our update `RoomAttachment` mutation. */
export type UpdateRoomAttachmentPayload = {
  __typename?: 'UpdateRoomAttachmentPayload';
  /** Reads a single `Attachment` that is related to this `RoomAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Room` that is related to this `RoomAttachment`. */
  room: Maybe<Room>;
  /** The `RoomAttachment` that was updated by this mutation. */
  roomAttachment: Maybe<RoomAttachment>;
  /** An edge for our `RoomAttachment`. May be used by Relay 1. */
  roomAttachmentEdge: Maybe<RoomAttachmentsEdge>;
};


/** The output of our update `RoomAttachment` mutation. */
export type UpdateRoomAttachmentPayloadRoomAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<RoomAttachmentsOrderBy>>;
};

/** All input for the `updateRoom` mutation. */
export type UpdateRoomInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Room` being updated. */
  patch: RoomPatch;
};

/** The output of our update `Room` mutation. */
export type UpdateRoomPayload = {
  __typename?: 'UpdateRoomPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Location` that is related to this `Room`. */
  locationByLocation: Maybe<Location>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Room` that was updated by this mutation. */
  room: Maybe<Room>;
  /** An edge for our `Room`. May be used by Relay 1. */
  roomEdge: Maybe<RoomsEdge>;
};


/** The output of our update `Room` mutation. */
export type UpdateRoomPayloadRoomEdgeArgs = {
  orderBy?: InputMaybe<Array<RoomsOrderBy>>;
};

/** All input for the `updateRozpi` mutation. */
export type UpdateRozpiInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Rozpi` being updated. */
  patch: RozpiPatch;
  rId: Scalars['BigInt']['input'];
};

/** The output of our update `Rozpi` mutation. */
export type UpdateRozpiPayload = {
  __typename?: 'UpdateRozpiPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Rozpi` that was updated by this mutation. */
  rozpi: Maybe<Rozpi>;
  /** An edge for our `Rozpi`. May be used by Relay 1. */
  rozpiEdge: Maybe<RozpisEdge>;
  /** Reads a single `User` that is related to this `Rozpi`. */
  userByRTrener: Maybe<User>;
};


/** The output of our update `Rozpi` mutation. */
export type UpdateRozpiPayloadRozpiEdgeArgs = {
  orderBy?: InputMaybe<Array<RozpisOrderBy>>;
};

/** All input for the `updateRozpisItem` mutation. */
export type UpdateRozpisItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `RozpisItem` being updated. */
  patch: RozpisItemPatch;
  riId: Scalars['BigInt']['input'];
};

/** The output of our update `RozpisItem` mutation. */
export type UpdateRozpisItemPayload = {
  __typename?: 'UpdateRozpisItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Pary` that is related to this `RozpisItem`. */
  paryByRiPartner: Maybe<Pary>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Rozpi` that is related to this `RozpisItem`. */
  rozpiByRiIdRodic: Maybe<Rozpi>;
  /** The `RozpisItem` that was updated by this mutation. */
  rozpisItem: Maybe<RozpisItem>;
  /** An edge for our `RozpisItem`. May be used by Relay 1. */
  rozpisItemEdge: Maybe<RozpisItemsEdge>;
};


/** The output of our update `RozpisItem` mutation. */
export type UpdateRozpisItemPayloadRozpisItemEdgeArgs = {
  orderBy?: InputMaybe<Array<RozpisItemsOrderBy>>;
};

/** All input for the `updateSkupiny` mutation. */
export type UpdateSkupinyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Skupiny` being updated. */
  patch: SkupinyPatch;
  sId: Scalars['BigInt']['input'];
};

/** The output of our update `Skupiny` mutation. */
export type UpdateSkupinyPayload = {
  __typename?: 'UpdateSkupinyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `CohortGroup` that is related to this `Skupiny`. */
  cohortGroupByCohortGroup: Maybe<CohortGroup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Skupiny` that was updated by this mutation. */
  skupiny: Maybe<Skupiny>;
  /** An edge for our `Skupiny`. May be used by Relay 1. */
  skupinyEdge: Maybe<SkupiniesEdge>;
};


/** The output of our update `Skupiny` mutation. */
export type UpdateSkupinyPayloadSkupinyEdgeArgs = {
  orderBy?: InputMaybe<Array<SkupiniesOrderBy>>;
};

/** All input for the `updateTenantAttachment` mutation. */
export type UpdateTenantAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  objectName: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `TenantAttachment` being updated. */
  patch: TenantAttachmentPatch;
  tenantId: Scalars['BigInt']['input'];
};

/** The output of our update `TenantAttachment` mutation. */
export type UpdateTenantAttachmentPayload = {
  __typename?: 'UpdateTenantAttachmentPayload';
  /** Reads a single `Attachment` that is related to this `TenantAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `TenantAttachment`. */
  tenant: Maybe<Tenant>;
  /** The `TenantAttachment` that was updated by this mutation. */
  tenantAttachment: Maybe<TenantAttachment>;
  /** An edge for our `TenantAttachment`. May be used by Relay 1. */
  tenantAttachmentEdge: Maybe<TenantAttachmentsEdge>;
};


/** The output of our update `TenantAttachment` mutation. */
export type UpdateTenantAttachmentPayloadTenantAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<TenantAttachmentsOrderBy>>;
};

/** All input for the `updateTenant` mutation. */
export type UpdateTenantInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Tenant` being updated. */
  patch: TenantPatch;
};

/** All input for the `updateTenantLocation` mutation. */
export type UpdateTenantLocationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  locationId: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `TenantLocation` being updated. */
  patch: TenantLocationPatch;
  tenantId: Scalars['BigInt']['input'];
};

/** The output of our update `TenantLocation` mutation. */
export type UpdateTenantLocationPayload = {
  __typename?: 'UpdateTenantLocationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Location` that is related to this `TenantLocation`. */
  location: Maybe<Location>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `TenantLocation`. */
  tenant: Maybe<Tenant>;
  /** The `TenantLocation` that was updated by this mutation. */
  tenantLocation: Maybe<TenantLocation>;
  /** An edge for our `TenantLocation`. May be used by Relay 1. */
  tenantLocationEdge: Maybe<TenantLocationsEdge>;
};


/** The output of our update `TenantLocation` mutation. */
export type UpdateTenantLocationPayloadTenantLocationEdgeArgs = {
  orderBy?: InputMaybe<Array<TenantLocationsOrderBy>>;
};

/** The output of our update `Tenant` mutation. */
export type UpdateTenantPayload = {
  __typename?: 'UpdateTenantPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Tenant` that was updated by this mutation. */
  tenant: Maybe<Tenant>;
  /** An edge for our `Tenant`. May be used by Relay 1. */
  tenantEdge: Maybe<TenantsEdge>;
};


/** The output of our update `Tenant` mutation. */
export type UpdateTenantPayloadTenantEdgeArgs = {
  orderBy?: InputMaybe<Array<TenantsOrderBy>>;
};

/** All input for the `updateTenantPerson` mutation. */
export type UpdateTenantPersonInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `TenantPerson` being updated. */
  patch: TenantPersonPatch;
  personId: Scalars['BigInt']['input'];
  tenantId: Scalars['BigInt']['input'];
};

/** The output of our update `TenantPerson` mutation. */
export type UpdateTenantPersonPayload = {
  __typename?: 'UpdateTenantPersonPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Person` that is related to this `TenantPerson`. */
  person: Maybe<Person>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `TenantPerson`. */
  tenant: Maybe<Tenant>;
  /** The `TenantPerson` that was updated by this mutation. */
  tenantPerson: Maybe<TenantPerson>;
  /** An edge for our `TenantPerson`. May be used by Relay 1. */
  tenantPersonEdge: Maybe<TenantPeopleEdge>;
};


/** The output of our update `TenantPerson` mutation. */
export type UpdateTenantPersonPayloadTenantPersonEdgeArgs = {
  orderBy?: InputMaybe<Array<TenantPeopleOrderBy>>;
};

/** All input for the `updateUpozorneni` mutation. */
export type UpdateUpozorneniInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Upozorneni` being updated. */
  patch: UpozorneniPatch;
  upId: Scalars['BigInt']['input'];
};

/** The output of our update `Upozorneni` mutation. */
export type UpdateUpozorneniPayload = {
  __typename?: 'UpdateUpozorneniPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Upozorneni` that was updated by this mutation. */
  upozorneni: Maybe<Upozorneni>;
  /** An edge for our `Upozorneni`. May be used by Relay 1. */
  upozorneniEdge: Maybe<UpozornenisEdge>;
  /** Reads a single `User` that is related to this `Upozorneni`. */
  userByUpKdo: Maybe<User>;
};


/** The output of our update `Upozorneni` mutation. */
export type UpdateUpozorneniPayloadUpozorneniEdgeArgs = {
  orderBy?: InputMaybe<Array<UpozornenisOrderBy>>;
};

/** All input for the `updateUpozorneniSkupiny` mutation. */
export type UpdateUpozorneniSkupinyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `UpozorneniSkupiny` being updated. */
  patch: UpozorneniSkupinyPatch;
  upsId: Scalars['BigInt']['input'];
};

/** The output of our update `UpozorneniSkupiny` mutation. */
export type UpdateUpozorneniSkupinyPayload = {
  __typename?: 'UpdateUpozorneniSkupinyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
  skupinyByUpsIdSkupina: Maybe<Skupiny>;
  /** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
  upozorneniByUpsIdRodic: Maybe<Upozorneni>;
  /** The `UpozorneniSkupiny` that was updated by this mutation. */
  upozorneniSkupiny: Maybe<UpozorneniSkupiny>;
  /** An edge for our `UpozorneniSkupiny`. May be used by Relay 1. */
  upozorneniSkupinyEdge: Maybe<UpozorneniSkupiniesEdge>;
};


/** The output of our update `UpozorneniSkupiny` mutation. */
export type UpdateUpozorneniSkupinyPayloadUpozorneniSkupinyEdgeArgs = {
  orderBy?: InputMaybe<Array<UpozorneniSkupiniesOrderBy>>;
};

/** All input for the `updateUser` mutation. */
export type UpdateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
  uId: Scalars['BigInt']['input'];
};

/** The output of our update `User` mutation. */
export type UpdateUserPayload = {
  __typename?: 'UpdateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Permission` that is related to this `User`. */
  permissionByUGroup: Maybe<Permission>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Skupiny` that is related to this `User`. */
  skupinyByUSkupina: Maybe<Skupiny>;
  /** The `User` that was updated by this mutation. */
  user: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge: Maybe<UsersEdge>;
};


/** The output of our update `User` mutation. */
export type UpdateUserPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

export type Upozorneni = {
  __typename?: 'Upozorneni';
  id: Maybe<Scalars['BigInt']['output']>;
  isVisible: Maybe<Scalars['Boolean']['output']>;
  scheduledSince: Maybe<Scalars['Datetime']['output']>;
  scheduledUntil: Maybe<Scalars['Datetime']['output']>;
  sticky: Scalars['Boolean']['output'];
  tenantId: Scalars['BigInt']['output'];
  upBarvy: Scalars['BigInt']['output'];
  upId: Scalars['BigInt']['output'];
  upKdo: Maybe<Scalars['BigInt']['output']>;
  upLock: Scalars['Boolean']['output'];
  upNadpis: Scalars['String']['output'];
  upText: Scalars['String']['output'];
  upTimestamp: Maybe<Scalars['Datetime']['output']>;
  upTimestampAdd: Scalars['Datetime']['output'];
  /** Reads and enables pagination through a set of `UpozorneniSkupiny`. */
  upozorneniSkupiniesByUpsIdRodic: UpozorneniSkupiniesConnection;
  /** Reads a single `User` that is related to this `Upozorneni`. */
  userByUpKdo: Maybe<User>;
};


export type UpozorneniUpozorneniSkupiniesByUpsIdRodicArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UpozorneniSkupinyCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UpozorneniSkupiniesOrderBy>>;
};

/**
 * A condition to be used against `Upozorneni` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type UpozorneniCondition = {
  /** Checks for equality with the object’s `upId` field. */
  upId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `upKdo` field. */
  upKdo?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `upTimestampAdd` field. */
  upTimestampAdd?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An input for mutations affecting `Upozorneni` */
export type UpozorneniInput = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  isVisible?: InputMaybe<Scalars['Boolean']['input']>;
  scheduledSince?: InputMaybe<Scalars['Datetime']['input']>;
  scheduledUntil?: InputMaybe<Scalars['Datetime']['input']>;
  sticky?: InputMaybe<Scalars['Boolean']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
  upBarvy?: InputMaybe<Scalars['BigInt']['input']>;
  upId?: InputMaybe<Scalars['BigInt']['input']>;
  upKdo?: InputMaybe<Scalars['BigInt']['input']>;
  upLock?: InputMaybe<Scalars['Boolean']['input']>;
  upNadpis: Scalars['String']['input'];
  upText: Scalars['String']['input'];
  upTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
  upTimestampAdd?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `Upozorneni`. Fields that are set will be updated. */
export type UpozorneniPatch = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  isVisible?: InputMaybe<Scalars['Boolean']['input']>;
  scheduledSince?: InputMaybe<Scalars['Datetime']['input']>;
  scheduledUntil?: InputMaybe<Scalars['Datetime']['input']>;
  sticky?: InputMaybe<Scalars['Boolean']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
  upBarvy?: InputMaybe<Scalars['BigInt']['input']>;
  upId?: InputMaybe<Scalars['BigInt']['input']>;
  upKdo?: InputMaybe<Scalars['BigInt']['input']>;
  upLock?: InputMaybe<Scalars['Boolean']['input']>;
  upNadpis?: InputMaybe<Scalars['String']['input']>;
  upText?: InputMaybe<Scalars['String']['input']>;
  upTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
  upTimestampAdd?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `UpozorneniSkupiny` values. */
export type UpozorneniSkupiniesConnection = {
  __typename?: 'UpozorneniSkupiniesConnection';
  /** A list of edges which contains the `UpozorneniSkupiny` and cursor to aid in pagination. */
  edges: Array<UpozorneniSkupiniesEdge>;
  /** A list of `UpozorneniSkupiny` objects. */
  nodes: Array<UpozorneniSkupiny>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UpozorneniSkupiny` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UpozorneniSkupiny` edge in the connection. */
export type UpozorneniSkupiniesEdge = {
  __typename?: 'UpozorneniSkupiniesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `UpozorneniSkupiny` at the end of the edge. */
  node: UpozorneniSkupiny;
};

/** Methods to use when ordering `UpozorneniSkupiny`. */
export type UpozorneniSkupiniesOrderBy =
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__COHORT_GROUP_ASC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__COHORT_GROUP_DESC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__ORDERING_ASC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__ORDERING_DESC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__S_ID_ASC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__S_ID_DESC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__S_VISIBLE_ASC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__S_VISIBLE_DESC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__UP_ID_ASC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__UP_ID_DESC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__UP_KDO_ASC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__UP_KDO_DESC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__UP_TIMESTAMP_ADD_ASC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__UP_TIMESTAMP_ADD_DESC'
  | 'UPS_ID_ASC'
  | 'UPS_ID_DESC'
  | 'UPS_ID_RODIC_ASC'
  | 'UPS_ID_RODIC_DESC'
  | 'UPS_ID_SKUPINA_ASC'
  | 'UPS_ID_SKUPINA_DESC';

export type UpozorneniSkupiny = {
  __typename?: 'UpozorneniSkupiny';
  id: Maybe<Scalars['BigInt']['output']>;
  /** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
  skupinyByUpsIdSkupina: Maybe<Skupiny>;
  tenantId: Scalars['BigInt']['output'];
  /** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
  upozorneniByUpsIdRodic: Maybe<Upozorneni>;
  upsColor: Scalars['String']['output'];
  upsId: Scalars['BigInt']['output'];
  upsIdRodic: Scalars['BigInt']['output'];
  upsIdSkupina: Scalars['BigInt']['output'];
};

/**
 * A condition to be used against `UpozorneniSkupiny` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type UpozorneniSkupinyCondition = {
  /** Checks for equality with the object’s `upsId` field. */
  upsId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `upsIdRodic` field. */
  upsIdRodic?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `upsIdSkupina` field. */
  upsIdSkupina?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `UpozorneniSkupiny` */
export type UpozorneniSkupinyInput = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
  upsColor: Scalars['String']['input'];
  upsId?: InputMaybe<Scalars['BigInt']['input']>;
  upsIdRodic: Scalars['BigInt']['input'];
  upsIdSkupina: Scalars['BigInt']['input'];
};

/** Represents an update to a `UpozorneniSkupiny`. Fields that are set will be updated. */
export type UpozorneniSkupinyPatch = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
  upsColor?: InputMaybe<Scalars['String']['input']>;
  upsId?: InputMaybe<Scalars['BigInt']['input']>;
  upsIdRodic?: InputMaybe<Scalars['BigInt']['input']>;
  upsIdSkupina?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `Upozorneni` values. */
export type UpozornenisConnection = {
  __typename?: 'UpozornenisConnection';
  /** A list of edges which contains the `Upozorneni` and cursor to aid in pagination. */
  edges: Array<UpozornenisEdge>;
  /** A list of `Upozorneni` objects. */
  nodes: Array<Upozorneni>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Upozorneni` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Upozorneni` edge in the connection. */
export type UpozornenisEdge = {
  __typename?: 'UpozornenisEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Upozorneni` at the end of the edge. */
  node: Upozorneni;
};

/** Methods to use when ordering `Upozorneni`. */
export type UpozornenisOrderBy =
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'UPOZORNENI_SKUPINIES_BY_UPS_ID_RODIC__COUNT_ASC'
  | 'UPOZORNENI_SKUPINIES_BY_UPS_ID_RODIC__COUNT_DESC'
  | 'UP_ID_ASC'
  | 'UP_ID_DESC'
  | 'UP_KDO_ASC'
  | 'UP_KDO_DESC'
  | 'UP_TIMESTAMP_ADD_ASC'
  | 'UP_TIMESTAMP_ADD_DESC'
  | 'USER_BY_UP_KDO__U_BAN_ASC'
  | 'USER_BY_UP_KDO__U_BAN_DESC'
  | 'USER_BY_UP_KDO__U_CONFIRMED_ASC'
  | 'USER_BY_UP_KDO__U_CONFIRMED_DESC'
  | 'USER_BY_UP_KDO__U_GROUP_ASC'
  | 'USER_BY_UP_KDO__U_GROUP_DESC'
  | 'USER_BY_UP_KDO__U_ID_ASC'
  | 'USER_BY_UP_KDO__U_ID_DESC'
  | 'USER_BY_UP_KDO__U_JMENO_ASC'
  | 'USER_BY_UP_KDO__U_JMENO_DESC'
  | 'USER_BY_UP_KDO__U_LOGIN_ASC'
  | 'USER_BY_UP_KDO__U_LOGIN_DESC'
  | 'USER_BY_UP_KDO__U_NAROZENI_ASC'
  | 'USER_BY_UP_KDO__U_NAROZENI_DESC'
  | 'USER_BY_UP_KDO__U_PRIJMENI_ASC'
  | 'USER_BY_UP_KDO__U_PRIJMENI_DESC'
  | 'USER_BY_UP_KDO__U_SKUPINA_ASC'
  | 'USER_BY_UP_KDO__U_SKUPINA_DESC'
  | 'USER_BY_UP_KDO__U_SYSTEM_ASC'
  | 'USER_BY_UP_KDO__U_SYSTEM_DESC';

export type User = {
  __typename?: 'User';
  /** Reads and enables pagination through a set of `AkceItem`. */
  akceItemsByAiUser: AkceItemsConnection;
  /** Reads and enables pagination through a set of `Aktuality`. */
  aktualitiesByAtKdo: AktualitiesConnection;
  /** Reads and enables pagination through a set of `Attachment`. */
  attachmentsByUploadedBy: AttachmentsConnection;
  /** Reads and enables pagination through a set of `AttendeeExternal`. */
  attendeeExternalsByConfirmedBy: AttendeeExternalsConnection;
  /** Reads and enables pagination through a set of `AttendeeExternal`. */
  attendeeExternalsByManagedBy: AttendeeExternalsConnection;
  /** Reads and enables pagination through a set of `AttendeeUser`. */
  attendeeUsers: AttendeeUsersConnection;
  dateOfNewestPayment: Maybe<Scalars['Date']['output']>;
  dateOfOldestPayment: Maybe<Scalars['Date']['output']>;
  /** Reads and enables pagination through a set of `Dokumenty`. */
  dokumentiesByDKdo: DokumentiesConnection;
  fullName: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `GalerieFoto`. */
  galerieFotosByGfKdo: GalerieFotosConnection;
  hasValidPayment: Maybe<Scalars['Boolean']['output']>;
  id: Maybe<Scalars['BigInt']['output']>;
  inPublicCohort: Maybe<Scalars['Boolean']['output']>;
  /** Reads and enables pagination through a set of `Nabidka`. */
  nabidkasByNTrener: NabidkasConnection;
  /** Reads and enables pagination through a set of `Pary`. */
  pariesByPIdPartner: PariesConnection;
  /** Reads and enables pagination through a set of `Pary`. */
  pariesByPIdPartnerka: PariesConnection;
  /** Reads and enables pagination through a set of `ParyNavrh`. */
  paryNavrhsByPnNavrhl: ParyNavrhsConnection;
  /** Reads and enables pagination through a set of `ParyNavrh`. */
  paryNavrhsByPnPartner: ParyNavrhsConnection;
  /** Reads and enables pagination through a set of `ParyNavrh`. */
  paryNavrhsByPnPartnerka: ParyNavrhsConnection;
  /** Reads a single `Permission` that is related to this `User`. */
  permissionByUGroup: Maybe<Permission>;
  /** Reads and enables pagination through a set of `PlatbyItem`. */
  platbyItemsByPiIdUser: PlatbyItemsConnection;
  /** Reads and enables pagination through a set of `Rozpi`. */
  rozpisByRTrener: RozpisConnection;
  /** Reads and enables pagination through a set of `Session`. */
  sessionsBySsUser: SessionsConnection;
  /** Reads a single `Skupiny` that is related to this `User`. */
  skupinyByUSkupina: Maybe<Skupiny>;
  tenantId: Scalars['BigInt']['output'];
  uBan: Scalars['Boolean']['output'];
  uCity: Scalars['String']['output'];
  uConfirmed: Scalars['Boolean']['output'];
  uConscriptionNumber: Scalars['String']['output'];
  uCreatedAt: Scalars['Datetime']['output'];
  uDancer: Scalars['Boolean']['output'];
  uDistrict: Scalars['String']['output'];
  uEmail: Scalars['String']['output'];
  uGdprSignedAt: Maybe<Scalars['Datetime']['output']>;
  uGroup: Scalars['BigInt']['output'];
  uId: Scalars['BigInt']['output'];
  uJmeno: Scalars['String']['output'];
  uLevel: Scalars['Int']['output'];
  uLock: Scalars['Boolean']['output'];
  uLogin: Scalars['String']['output'];
  uMemberSince: Maybe<Scalars['Datetime']['output']>;
  uMemberUntil: Maybe<Scalars['Datetime']['output']>;
  uNarozeni: Scalars['Date']['output'];
  uNationality: Scalars['String']['output'];
  uOrientationNumber: Scalars['String']['output'];
  uPass: Scalars['String']['output'];
  uPohlavi: Scalars['String']['output'];
  uPostalCode: Scalars['String']['output'];
  uPoznamky: Scalars['String']['output'];
  uPrijmeni: Scalars['String']['output'];
  uRodneCislo: Maybe<Scalars['String']['output']>;
  uSkupina: Scalars['BigInt']['output'];
  uStreet: Scalars['String']['output'];
  uSystem: Scalars['Boolean']['output'];
  uTeacher: Scalars['Boolean']['output'];
  uTelefon: Scalars['String']['output'];
  uTimestamp: Scalars['Datetime']['output'];
  /** Reads and enables pagination through a set of `Upozorneni`. */
  upozornenisByUpKdo: UpozornenisConnection;
};


export type UserAkceItemsByAiUserArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AkceItemsOrderBy>>;
};


export type UserAktualitiesByAtKdoArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AktualityCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AktualitiesOrderBy>>;
};


export type UserAttachmentsByUploadedByArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AttachmentCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AttachmentsOrderBy>>;
};


export type UserAttendeeExternalsByConfirmedByArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AttendeeExternalCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AttendeeExternalsOrderBy>>;
};


export type UserAttendeeExternalsByManagedByArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AttendeeExternalCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AttendeeExternalsOrderBy>>;
};


export type UserAttendeeUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AttendeeUserCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AttendeeUsersOrderBy>>;
};


export type UserDokumentiesByDKdoArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DokumentyCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DokumentiesOrderBy>>;
};


export type UserGalerieFotosByGfKdoArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GalerieFotoCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GalerieFotosOrderBy>>;
};


export type UserNabidkasByNTrenerArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<NabidkaCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NabidkasOrderBy>>;
};


export type UserPariesByPIdPartnerArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ParyCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PariesOrderBy>>;
};


export type UserPariesByPIdPartnerkaArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ParyCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PariesOrderBy>>;
};


export type UserParyNavrhsByPnNavrhlArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ParyNavrhCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ParyNavrhsOrderBy>>;
};


export type UserParyNavrhsByPnPartnerArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ParyNavrhCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ParyNavrhsOrderBy>>;
};


export type UserParyNavrhsByPnPartnerkaArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ParyNavrhCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ParyNavrhsOrderBy>>;
};


export type UserPlatbyItemsByPiIdUserArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PlatbyItemCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PlatbyItemsOrderBy>>;
};


export type UserRozpisByRTrenerArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RozpiCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RozpisOrderBy>>;
};


export type UserSessionsBySsUserArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SessionCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SessionsOrderBy>>;
};


export type UserUpozornenisByUpKdoArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UpozorneniCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UpozornenisOrderBy>>;
};

/** A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UserCondition = {
  /** Checks for equality with the object’s `inPublicCohort` field. */
  inPublicCohort?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `uBan` field. */
  uBan?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `uConfirmed` field. */
  uConfirmed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `uGroup` field. */
  uGroup?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `uId` field. */
  uId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `uJmeno` field. */
  uJmeno?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `uLogin` field. */
  uLogin?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `uNarozeni` field. */
  uNarozeni?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `uPrijmeni` field. */
  uPrijmeni?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `uSkupina` field. */
  uSkupina?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `uSystem` field. */
  uSystem?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `User` */
export type UserInput = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
  uBan?: InputMaybe<Scalars['Boolean']['input']>;
  uCity: Scalars['String']['input'];
  uConfirmed?: InputMaybe<Scalars['Boolean']['input']>;
  uConscriptionNumber?: InputMaybe<Scalars['String']['input']>;
  uCreatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uDancer?: InputMaybe<Scalars['Boolean']['input']>;
  uDistrict?: InputMaybe<Scalars['String']['input']>;
  uEmail: Scalars['String']['input'];
  uGdprSignedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uGroup?: InputMaybe<Scalars['BigInt']['input']>;
  uId?: InputMaybe<Scalars['BigInt']['input']>;
  uJmeno: Scalars['String']['input'];
  uLevel?: InputMaybe<Scalars['Int']['input']>;
  uLock?: InputMaybe<Scalars['Boolean']['input']>;
  uLogin: Scalars['String']['input'];
  uMemberSince?: InputMaybe<Scalars['Datetime']['input']>;
  uMemberUntil?: InputMaybe<Scalars['Datetime']['input']>;
  uNarozeni: Scalars['Date']['input'];
  uNationality: Scalars['String']['input'];
  uOrientationNumber?: InputMaybe<Scalars['String']['input']>;
  uPass: Scalars['String']['input'];
  uPohlavi: Scalars['String']['input'];
  uPostalCode: Scalars['String']['input'];
  uPoznamky?: InputMaybe<Scalars['String']['input']>;
  uPrijmeni: Scalars['String']['input'];
  uRodneCislo?: InputMaybe<Scalars['String']['input']>;
  uSkupina?: InputMaybe<Scalars['BigInt']['input']>;
  uStreet: Scalars['String']['input'];
  uSystem?: InputMaybe<Scalars['Boolean']['input']>;
  uTeacher?: InputMaybe<Scalars['Boolean']['input']>;
  uTelefon: Scalars['String']['input'];
  uTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `User`. Fields that are set will be updated. */
export type UserPatch = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
  uBan?: InputMaybe<Scalars['Boolean']['input']>;
  uCity?: InputMaybe<Scalars['String']['input']>;
  uConfirmed?: InputMaybe<Scalars['Boolean']['input']>;
  uConscriptionNumber?: InputMaybe<Scalars['String']['input']>;
  uCreatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uDancer?: InputMaybe<Scalars['Boolean']['input']>;
  uDistrict?: InputMaybe<Scalars['String']['input']>;
  uEmail?: InputMaybe<Scalars['String']['input']>;
  uGdprSignedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uGroup?: InputMaybe<Scalars['BigInt']['input']>;
  uId?: InputMaybe<Scalars['BigInt']['input']>;
  uJmeno?: InputMaybe<Scalars['String']['input']>;
  uLevel?: InputMaybe<Scalars['Int']['input']>;
  uLock?: InputMaybe<Scalars['Boolean']['input']>;
  uLogin?: InputMaybe<Scalars['String']['input']>;
  uMemberSince?: InputMaybe<Scalars['Datetime']['input']>;
  uMemberUntil?: InputMaybe<Scalars['Datetime']['input']>;
  uNarozeni?: InputMaybe<Scalars['Date']['input']>;
  uNationality?: InputMaybe<Scalars['String']['input']>;
  uOrientationNumber?: InputMaybe<Scalars['String']['input']>;
  uPass?: InputMaybe<Scalars['String']['input']>;
  uPohlavi?: InputMaybe<Scalars['String']['input']>;
  uPostalCode?: InputMaybe<Scalars['String']['input']>;
  uPoznamky?: InputMaybe<Scalars['String']['input']>;
  uPrijmeni?: InputMaybe<Scalars['String']['input']>;
  uRodneCislo?: InputMaybe<Scalars['String']['input']>;
  uSkupina?: InputMaybe<Scalars['BigInt']['input']>;
  uStreet?: InputMaybe<Scalars['String']['input']>;
  uSystem?: InputMaybe<Scalars['Boolean']['input']>;
  uTeacher?: InputMaybe<Scalars['Boolean']['input']>;
  uTelefon?: InputMaybe<Scalars['String']['input']>;
  uTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `User` values. */
export type UsersConnection = {
  __typename?: 'UsersConnection';
  /** A list of edges which contains the `User` and cursor to aid in pagination. */
  edges: Array<UsersEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection. */
export type UsersEdge = {
  __typename?: 'UsersEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
};

/** Methods to use when ordering `User`. */
export type UsersOrderBy =
  | 'AKCE_ITEMS_BY_AI_USER__COUNT_ASC'
  | 'AKCE_ITEMS_BY_AI_USER__COUNT_DESC'
  | 'AKTUALITIES_BY_AT_KDO__COUNT_ASC'
  | 'AKTUALITIES_BY_AT_KDO__COUNT_DESC'
  | 'ATTACHMENTS_BY_UPLOADED_BY__COUNT_ASC'
  | 'ATTACHMENTS_BY_UPLOADED_BY__COUNT_DESC'
  | 'ATTENDEE_EXTERNALS_BY_CONFIRMED_BY__COUNT_ASC'
  | 'ATTENDEE_EXTERNALS_BY_CONFIRMED_BY__COUNT_DESC'
  | 'ATTENDEE_EXTERNALS_BY_MANAGED_BY__COUNT_ASC'
  | 'ATTENDEE_EXTERNALS_BY_MANAGED_BY__COUNT_DESC'
  | 'ATTENDEE_USERS_BY_USER_ID__COUNT_ASC'
  | 'ATTENDEE_USERS_BY_USER_ID__COUNT_DESC'
  | 'DOKUMENTIES_BY_D_KDO__COUNT_ASC'
  | 'DOKUMENTIES_BY_D_KDO__COUNT_DESC'
  | 'GALERIE_FOTOS_BY_GF_KDO__COUNT_ASC'
  | 'GALERIE_FOTOS_BY_GF_KDO__COUNT_DESC'
  | 'NABIDKAS_BY_N_TRENER__COUNT_ASC'
  | 'NABIDKAS_BY_N_TRENER__COUNT_DESC'
  | 'NATURAL'
  | 'PARIES_BY_P_ID_PARTNERKA__COUNT_ASC'
  | 'PARIES_BY_P_ID_PARTNERKA__COUNT_DESC'
  | 'PARIES_BY_P_ID_PARTNER__COUNT_ASC'
  | 'PARIES_BY_P_ID_PARTNER__COUNT_DESC'
  | 'PARY_NAVRHS_BY_PN_NAVRHL__COUNT_ASC'
  | 'PARY_NAVRHS_BY_PN_NAVRHL__COUNT_DESC'
  | 'PARY_NAVRHS_BY_PN_PARTNERKA__COUNT_ASC'
  | 'PARY_NAVRHS_BY_PN_PARTNERKA__COUNT_DESC'
  | 'PARY_NAVRHS_BY_PN_PARTNER__COUNT_ASC'
  | 'PARY_NAVRHS_BY_PN_PARTNER__COUNT_DESC'
  | 'PERMISSION_BY_U_GROUP__PE_ID_ASC'
  | 'PERMISSION_BY_U_GROUP__PE_ID_DESC'
  | 'PLATBY_ITEMS_BY_PI_ID_USER__COUNT_ASC'
  | 'PLATBY_ITEMS_BY_PI_ID_USER__COUNT_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'ROZPIS_BY_R_TRENER__COUNT_ASC'
  | 'ROZPIS_BY_R_TRENER__COUNT_DESC'
  | 'SESSIONS_BY_SS_USER__COUNT_ASC'
  | 'SESSIONS_BY_SS_USER__COUNT_DESC'
  | 'SKUPINY_BY_U_SKUPINA__COHORT_GROUP_ASC'
  | 'SKUPINY_BY_U_SKUPINA__COHORT_GROUP_DESC'
  | 'SKUPINY_BY_U_SKUPINA__ORDERING_ASC'
  | 'SKUPINY_BY_U_SKUPINA__ORDERING_DESC'
  | 'SKUPINY_BY_U_SKUPINA__S_ID_ASC'
  | 'SKUPINY_BY_U_SKUPINA__S_ID_DESC'
  | 'SKUPINY_BY_U_SKUPINA__S_VISIBLE_ASC'
  | 'SKUPINY_BY_U_SKUPINA__S_VISIBLE_DESC'
  | 'UPOZORNENIS_BY_UP_KDO__COUNT_ASC'
  | 'UPOZORNENIS_BY_UP_KDO__COUNT_DESC'
  | 'U_BAN_ASC'
  | 'U_BAN_DESC'
  | 'U_CONFIRMED_ASC'
  | 'U_CONFIRMED_DESC'
  | 'U_GROUP_ASC'
  | 'U_GROUP_DESC'
  | 'U_ID_ASC'
  | 'U_ID_DESC'
  | 'U_JMENO_ASC'
  | 'U_JMENO_DESC'
  | 'U_LOGIN_ASC'
  | 'U_LOGIN_DESC'
  | 'U_NAROZENI_ASC'
  | 'U_NAROZENI_DESC'
  | 'U_PRIJMENI_ASC'
  | 'U_PRIJMENI_DESC'
  | 'U_SKUPINA_ASC'
  | 'U_SKUPINA_DESC'
  | 'U_SYSTEM_ASC'
  | 'U_SYSTEM_DESC';

/** All input for the `verifyFunction` mutation. */
export type VerifyFunctionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  f?: InputMaybe<Scalars['RegProc']['input']>;
  relid?: InputMaybe<Scalars['RegClass']['input']>;
};

/** The output of our `verifyFunction` mutation. */
export type VerifyFunctionPayload = {
  __typename?: 'VerifyFunctionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type Video = {
  __typename?: 'Video';
  vAuthor: Scalars['String']['output'];
  vCreatedAt: Scalars['Datetime']['output'];
  vDescription: Scalars['String']['output'];
  vId: Scalars['BigInt']['output'];
  vPlaylist: Maybe<Scalars['String']['output']>;
  vTitle: Scalars['String']['output'];
  vUpdatedAt: Scalars['Datetime']['output'];
  vUri: Scalars['String']['output'];
};

/** A connection to a list of `Video` values. */
export type VideosConnection = {
  __typename?: 'VideosConnection';
  /** A list of edges which contains the `Video` and cursor to aid in pagination. */
  edges: Array<VideosEdge>;
  /** A list of `Video` objects. */
  nodes: Array<Video>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Video` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Video` edge in the connection. */
export type VideosEdge = {
  __typename?: 'VideosEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Video` at the end of the edge. */
  node: Video;
};

export type WithTypename<T extends { __typename?: any }> = Partial<T> & { __typename: NonNullable<T['__typename']> };

export type GraphCacheKeysConfig = {
  Akce?: (data: WithTypename<Akce>) => null | string,
  AkceItem?: (data: WithTypename<AkceItem>) => null | string,
  AkceItemsConnection?: (data: WithTypename<AkceItemsConnection>) => null | string,
  AkceItemsEdge?: (data: WithTypename<AkceItemsEdge>) => null | string,
  AkcesConnection?: (data: WithTypename<AkcesConnection>) => null | string,
  AkcesEdge?: (data: WithTypename<AkcesEdge>) => null | string,
  AktualitiesConnection?: (data: WithTypename<AktualitiesConnection>) => null | string,
  AktualitiesEdge?: (data: WithTypename<AktualitiesEdge>) => null | string,
  Aktuality?: (data: WithTypename<Aktuality>) => null | string,
  Attachment?: (data: WithTypename<Attachment>) => null | string,
  AttachmentDirectoriesConnection?: (data: WithTypename<AttachmentDirectoriesConnection>) => null | string,
  AttachmentDirectoryEdge?: (data: WithTypename<AttachmentDirectoryEdge>) => null | string,
  AttachmentsConnection?: (data: WithTypename<AttachmentsConnection>) => null | string,
  AttachmentsEdge?: (data: WithTypename<AttachmentsEdge>) => null | string,
  AttendeeCouple?: (data: WithTypename<AttendeeCouple>) => null | string,
  AttendeeCouplesConnection?: (data: WithTypename<AttendeeCouplesConnection>) => null | string,
  AttendeeCouplesEdge?: (data: WithTypename<AttendeeCouplesEdge>) => null | string,
  AttendeeExternal?: (data: WithTypename<AttendeeExternal>) => null | string,
  AttendeeExternalsConnection?: (data: WithTypename<AttendeeExternalsConnection>) => null | string,
  AttendeeExternalsEdge?: (data: WithTypename<AttendeeExternalsEdge>) => null | string,
  AttendeeList?: (data: WithTypename<AttendeeList>) => null | string,
  AttendeeListsConnection?: (data: WithTypename<AttendeeListsConnection>) => null | string,
  AttendeeListsEdge?: (data: WithTypename<AttendeeListsEdge>) => null | string,
  AttendeePeopleConnection?: (data: WithTypename<AttendeePeopleConnection>) => null | string,
  AttendeePeopleEdge?: (data: WithTypename<AttendeePeopleEdge>) => null | string,
  AttendeePerson?: (data: WithTypename<AttendeePerson>) => null | string,
  AttendeeUser?: (data: WithTypename<AttendeeUser>) => null | string,
  AttendeeUsersConnection?: (data: WithTypename<AttendeeUsersConnection>) => null | string,
  AttendeeUsersEdge?: (data: WithTypename<AttendeeUsersEdge>) => null | string,
  BookLessonPayload?: (data: WithTypename<BookLessonPayload>) => null | string,
  CancelLessonPayload?: (data: WithTypename<CancelLessonPayload>) => null | string,
  CancelParticipationPayload?: (data: WithTypename<CancelParticipationPayload>) => null | string,
  ChangePasswordPayload?: (data: WithTypename<ChangePasswordPayload>) => null | string,
  CohortGroup?: (data: WithTypename<CohortGroup>) => null | string,
  CohortGroupsConnection?: (data: WithTypename<CohortGroupsConnection>) => null | string,
  CohortGroupsEdge?: (data: WithTypename<CohortGroupsEdge>) => null | string,
  ConfirmUserPayload?: (data: WithTypename<ConfirmUserPayload>) => null | string,
  Couple?: (data: WithTypename<Couple>) => null | string,
  CouplesConnection?: (data: WithTypename<CouplesConnection>) => null | string,
  CouplesEdge?: (data: WithTypename<CouplesEdge>) => null | string,
  CreateAkceItemPayload?: (data: WithTypename<CreateAkceItemPayload>) => null | string,
  CreateAkcePayload?: (data: WithTypename<CreateAkcePayload>) => null | string,
  CreateAktualityPayload?: (data: WithTypename<CreateAktualityPayload>) => null | string,
  CreateAttachmentPayload?: (data: WithTypename<CreateAttachmentPayload>) => null | string,
  CreateAttendeeExternalPayload?: (data: WithTypename<CreateAttendeeExternalPayload>) => null | string,
  CreateAttendeeUserPayload?: (data: WithTypename<CreateAttendeeUserPayload>) => null | string,
  CreateCohortGroupPayload?: (data: WithTypename<CreateCohortGroupPayload>) => null | string,
  CreateCouplePayload?: (data: WithTypename<CreateCouplePayload>) => null | string,
  CreateDokumentyPayload?: (data: WithTypename<CreateDokumentyPayload>) => null | string,
  CreateEventPayload?: (data: WithTypename<CreateEventPayload>) => null | string,
  CreateFormResponsePayload?: (data: WithTypename<CreateFormResponsePayload>) => null | string,
  CreateGalerieDirPayload?: (data: WithTypename<CreateGalerieDirPayload>) => null | string,
  CreateGalerieFotoPayload?: (data: WithTypename<CreateGalerieFotoPayload>) => null | string,
  CreateLocationAttachmentPayload?: (data: WithTypename<CreateLocationAttachmentPayload>) => null | string,
  CreateLocationPayload?: (data: WithTypename<CreateLocationPayload>) => null | string,
  CreateNabidkaItemPayload?: (data: WithTypename<CreateNabidkaItemPayload>) => null | string,
  CreateNabidkaPayload?: (data: WithTypename<CreateNabidkaPayload>) => null | string,
  CreatePagePayload?: (data: WithTypename<CreatePagePayload>) => null | string,
  CreateParameterPayload?: (data: WithTypename<CreateParameterPayload>) => null | string,
  CreateParticipationExternalPayload?: (data: WithTypename<CreateParticipationExternalPayload>) => null | string,
  CreateParticipationPayload?: (data: WithTypename<CreateParticipationPayload>) => null | string,
  CreateParyNavrhPayload?: (data: WithTypename<CreateParyNavrhPayload>) => null | string,
  CreateParyPayload?: (data: WithTypename<CreateParyPayload>) => null | string,
  CreatePermissionPayload?: (data: WithTypename<CreatePermissionPayload>) => null | string,
  CreatePersonPayload?: (data: WithTypename<CreatePersonPayload>) => null | string,
  CreatePlatbyCategoryGroupPayload?: (data: WithTypename<CreatePlatbyCategoryGroupPayload>) => null | string,
  CreatePlatbyCategoryPayload?: (data: WithTypename<CreatePlatbyCategoryPayload>) => null | string,
  CreatePlatbyGroupPayload?: (data: WithTypename<CreatePlatbyGroupPayload>) => null | string,
  CreatePlatbyGroupSkupinaPayload?: (data: WithTypename<CreatePlatbyGroupSkupinaPayload>) => null | string,
  CreatePlatbyItemPayload?: (data: WithTypename<CreatePlatbyItemPayload>) => null | string,
  CreatePlatbyRawPayload?: (data: WithTypename<CreatePlatbyRawPayload>) => null | string,
  CreateRoomAttachmentPayload?: (data: WithTypename<CreateRoomAttachmentPayload>) => null | string,
  CreateRoomPayload?: (data: WithTypename<CreateRoomPayload>) => null | string,
  CreateRozpiPayload?: (data: WithTypename<CreateRozpiPayload>) => null | string,
  CreateRozpisItemPayload?: (data: WithTypename<CreateRozpisItemPayload>) => null | string,
  CreateSkupinyPayload?: (data: WithTypename<CreateSkupinyPayload>) => null | string,
  CreateTenantAttachmentPayload?: (data: WithTypename<CreateTenantAttachmentPayload>) => null | string,
  CreateTenantLocationPayload?: (data: WithTypename<CreateTenantLocationPayload>) => null | string,
  CreateTenantPayload?: (data: WithTypename<CreateTenantPayload>) => null | string,
  CreateTenantPersonPayload?: (data: WithTypename<CreateTenantPersonPayload>) => null | string,
  CreateUpozorneniPayload?: (data: WithTypename<CreateUpozorneniPayload>) => null | string,
  CreateUpozorneniSkupinyPayload?: (data: WithTypename<CreateUpozorneniSkupinyPayload>) => null | string,
  CreateUserPayload?: (data: WithTypename<CreateUserPayload>) => null | string,
  CurrentCoupleIdEdge?: (data: WithTypename<CurrentCoupleIdEdge>) => null | string,
  CurrentCoupleIdsConnection?: (data: WithTypename<CurrentCoupleIdsConnection>) => null | string,
  DeleteAktualityPayload?: (data: WithTypename<DeleteAktualityPayload>) => null | string,
  DeleteAttachmentPayload?: (data: WithTypename<DeleteAttachmentPayload>) => null | string,
  DeleteAttendeeExternalPayload?: (data: WithTypename<DeleteAttendeeExternalPayload>) => null | string,
  DeleteAttendeeUserPayload?: (data: WithTypename<DeleteAttendeeUserPayload>) => null | string,
  DeleteCohortGroupPayload?: (data: WithTypename<DeleteCohortGroupPayload>) => null | string,
  DeleteDokumentyPayload?: (data: WithTypename<DeleteDokumentyPayload>) => null | string,
  DeleteEventPayload?: (data: WithTypename<DeleteEventPayload>) => null | string,
  DeleteFormResponsePayload?: (data: WithTypename<DeleteFormResponsePayload>) => null | string,
  DeleteGalerieDirPayload?: (data: WithTypename<DeleteGalerieDirPayload>) => null | string,
  DeleteGalerieFotoPayload?: (data: WithTypename<DeleteGalerieFotoPayload>) => null | string,
  DeleteLocationAttachmentPayload?: (data: WithTypename<DeleteLocationAttachmentPayload>) => null | string,
  DeleteLocationPayload?: (data: WithTypename<DeleteLocationPayload>) => null | string,
  DeleteNabidkaItemPayload?: (data: WithTypename<DeleteNabidkaItemPayload>) => null | string,
  DeleteNabidkaPayload?: (data: WithTypename<DeleteNabidkaPayload>) => null | string,
  DeleteParameterPayload?: (data: WithTypename<DeleteParameterPayload>) => null | string,
  DeleteParyNavrhPayload?: (data: WithTypename<DeleteParyNavrhPayload>) => null | string,
  DeleteParyPayload?: (data: WithTypename<DeleteParyPayload>) => null | string,
  DeletePermissionPayload?: (data: WithTypename<DeletePermissionPayload>) => null | string,
  DeletePersonPayload?: (data: WithTypename<DeletePersonPayload>) => null | string,
  DeletePlatbyCategoryGroupPayload?: (data: WithTypename<DeletePlatbyCategoryGroupPayload>) => null | string,
  DeletePlatbyCategoryPayload?: (data: WithTypename<DeletePlatbyCategoryPayload>) => null | string,
  DeletePlatbyGroupPayload?: (data: WithTypename<DeletePlatbyGroupPayload>) => null | string,
  DeletePlatbyGroupSkupinaPayload?: (data: WithTypename<DeletePlatbyGroupSkupinaPayload>) => null | string,
  DeletePlatbyItemPayload?: (data: WithTypename<DeletePlatbyItemPayload>) => null | string,
  DeletePlatbyRawPayload?: (data: WithTypename<DeletePlatbyRawPayload>) => null | string,
  DeleteRoomAttachmentPayload?: (data: WithTypename<DeleteRoomAttachmentPayload>) => null | string,
  DeleteRoomPayload?: (data: WithTypename<DeleteRoomPayload>) => null | string,
  DeleteRozpiPayload?: (data: WithTypename<DeleteRozpiPayload>) => null | string,
  DeleteRozpisItemPayload?: (data: WithTypename<DeleteRozpisItemPayload>) => null | string,
  DeleteSkupinyPayload?: (data: WithTypename<DeleteSkupinyPayload>) => null | string,
  DeleteTenantAttachmentPayload?: (data: WithTypename<DeleteTenantAttachmentPayload>) => null | string,
  DeleteTenantLocationPayload?: (data: WithTypename<DeleteTenantLocationPayload>) => null | string,
  DeleteTenantPayload?: (data: WithTypename<DeleteTenantPayload>) => null | string,
  DeleteTenantPersonPayload?: (data: WithTypename<DeleteTenantPersonPayload>) => null | string,
  DeleteUpozorneniPayload?: (data: WithTypename<DeleteUpozorneniPayload>) => null | string,
  DeleteUpozorneniSkupinyPayload?: (data: WithTypename<DeleteUpozorneniSkupinyPayload>) => null | string,
  DeleteUserPayload?: (data: WithTypename<DeleteUserPayload>) => null | string,
  DokumentiesConnection?: (data: WithTypename<DokumentiesConnection>) => null | string,
  DokumentiesEdge?: (data: WithTypename<DokumentiesEdge>) => null | string,
  Dokumenty?: (data: WithTypename<Dokumenty>) => null | string,
  Event?: (data: WithTypename<Event>) => null | string,
  EventsConnection?: (data: WithTypename<EventsConnection>) => null | string,
  EventsEdge?: (data: WithTypename<EventsEdge>) => null | string,
  FixUnpairedCouplesPayload?: (data: WithTypename<FixUnpairedCouplesPayload>) => null | string,
  FormResponse?: (data: WithTypename<FormResponse>) => null | string,
  FormResponsesConnection?: (data: WithTypename<FormResponsesConnection>) => null | string,
  FormResponsesEdge?: (data: WithTypename<FormResponsesEdge>) => null | string,
  GalerieDir?: (data: WithTypename<GalerieDir>) => null | string,
  GalerieDirsConnection?: (data: WithTypename<GalerieDirsConnection>) => null | string,
  GalerieDirsEdge?: (data: WithTypename<GalerieDirsEdge>) => null | string,
  GalerieFoto?: (data: WithTypename<GalerieFoto>) => null | string,
  GalerieFotosConnection?: (data: WithTypename<GalerieFotosConnection>) => null | string,
  GalerieFotosEdge?: (data: WithTypename<GalerieFotosEdge>) => null | string,
  Location?: (data: WithTypename<Location>) => null | string,
  LocationAttachment?: (data: WithTypename<LocationAttachment>) => null | string,
  LocationAttachmentsConnection?: (data: WithTypename<LocationAttachmentsConnection>) => null | string,
  LocationAttachmentsEdge?: (data: WithTypename<LocationAttachmentsEdge>) => null | string,
  LocationsConnection?: (data: WithTypename<LocationsConnection>) => null | string,
  LocationsEdge?: (data: WithTypename<LocationsEdge>) => null | string,
  LoginPayload?: (data: WithTypename<LoginPayload>) => null | string,
  LoginRecord?: (data: WithTypename<LoginRecord>) => null | string,
  LogoutPayload?: (data: WithTypename<LogoutPayload>) => null | string,
  Nabidka?: (data: WithTypename<Nabidka>) => null | string,
  NabidkaItem?: (data: WithTypename<NabidkaItem>) => null | string,
  NabidkaItemsConnection?: (data: WithTypename<NabidkaItemsConnection>) => null | string,
  NabidkaItemsEdge?: (data: WithTypename<NabidkaItemsEdge>) => null | string,
  NabidkasConnection?: (data: WithTypename<NabidkasConnection>) => null | string,
  NabidkasEdge?: (data: WithTypename<NabidkasEdge>) => null | string,
  Page?: (data: WithTypename<Page>) => null | string,
  PageInfo?: (data: WithTypename<PageInfo>) => null | string,
  PageRevision?: (data: WithTypename<PageRevision>) => null | string,
  PageRevisionsConnection?: (data: WithTypename<PageRevisionsConnection>) => null | string,
  PageRevisionsEdge?: (data: WithTypename<PageRevisionsEdge>) => null | string,
  PagesConnection?: (data: WithTypename<PagesConnection>) => null | string,
  PagesEdge?: (data: WithTypename<PagesEdge>) => null | string,
  Parameter?: (data: WithTypename<Parameter>) => null | string,
  ParametersConnection?: (data: WithTypename<ParametersConnection>) => null | string,
  ParametersEdge?: (data: WithTypename<ParametersEdge>) => null | string,
  PariesConnection?: (data: WithTypename<PariesConnection>) => null | string,
  PariesEdge?: (data: WithTypename<PariesEdge>) => null | string,
  Pary?: (data: WithTypename<Pary>) => null | string,
  ParyNavrh?: (data: WithTypename<ParyNavrh>) => null | string,
  ParyNavrhsConnection?: (data: WithTypename<ParyNavrhsConnection>) => null | string,
  ParyNavrhsEdge?: (data: WithTypename<ParyNavrhsEdge>) => null | string,
  PeopleConnection?: (data: WithTypename<PeopleConnection>) => null | string,
  PeopleEdge?: (data: WithTypename<PeopleEdge>) => null | string,
  Permission?: (data: WithTypename<Permission>) => null | string,
  PermissionsConnection?: (data: WithTypename<PermissionsConnection>) => null | string,
  PermissionsEdge?: (data: WithTypename<PermissionsEdge>) => null | string,
  Person?: (data: WithTypename<Person>) => null | string,
  PlatbyCategoriesConnection?: (data: WithTypename<PlatbyCategoriesConnection>) => null | string,
  PlatbyCategoriesEdge?: (data: WithTypename<PlatbyCategoriesEdge>) => null | string,
  PlatbyCategory?: (data: WithTypename<PlatbyCategory>) => null | string,
  PlatbyCategoryGroup?: (data: WithTypename<PlatbyCategoryGroup>) => null | string,
  PlatbyCategoryGroupsConnection?: (data: WithTypename<PlatbyCategoryGroupsConnection>) => null | string,
  PlatbyCategoryGroupsEdge?: (data: WithTypename<PlatbyCategoryGroupsEdge>) => null | string,
  PlatbyGroup?: (data: WithTypename<PlatbyGroup>) => null | string,
  PlatbyGroupSkupina?: (data: WithTypename<PlatbyGroupSkupina>) => null | string,
  PlatbyGroupSkupinasConnection?: (data: WithTypename<PlatbyGroupSkupinasConnection>) => null | string,
  PlatbyGroupSkupinasEdge?: (data: WithTypename<PlatbyGroupSkupinasEdge>) => null | string,
  PlatbyGroupsConnection?: (data: WithTypename<PlatbyGroupsConnection>) => null | string,
  PlatbyGroupsEdge?: (data: WithTypename<PlatbyGroupsEdge>) => null | string,
  PlatbyItem?: (data: WithTypename<PlatbyItem>) => null | string,
  PlatbyItemsConnection?: (data: WithTypename<PlatbyItemsConnection>) => null | string,
  PlatbyItemsEdge?: (data: WithTypename<PlatbyItemsEdge>) => null | string,
  PlatbyRaw?: (data: WithTypename<PlatbyRaw>) => null | string,
  PlatbyRawsConnection?: (data: WithTypename<PlatbyRawsConnection>) => null | string,
  PlatbyRawsEdge?: (data: WithTypename<PlatbyRawsEdge>) => null | string,
  ProspectFormDancerPayload?: (data: WithTypename<ProspectFormDancerPayload>) => null | string,
  ReservationSetDesiredLessonsPayload?: (data: WithTypename<ReservationSetDesiredLessonsPayload>) => null | string,
  ResetPasswordPayload?: (data: WithTypename<ResetPasswordPayload>) => null | string,
  Room?: (data: WithTypename<Room>) => null | string,
  RoomAttachment?: (data: WithTypename<RoomAttachment>) => null | string,
  RoomAttachmentsConnection?: (data: WithTypename<RoomAttachmentsConnection>) => null | string,
  RoomAttachmentsEdge?: (data: WithTypename<RoomAttachmentsEdge>) => null | string,
  RoomsConnection?: (data: WithTypename<RoomsConnection>) => null | string,
  RoomsEdge?: (data: WithTypename<RoomsEdge>) => null | string,
  Rozpi?: (data: WithTypename<Rozpi>) => null | string,
  RozpisConnection?: (data: WithTypename<RozpisConnection>) => null | string,
  RozpisEdge?: (data: WithTypename<RozpisEdge>) => null | string,
  RozpisItem?: (data: WithTypename<RozpisItem>) => null | string,
  RozpisItemsConnection?: (data: WithTypename<RozpisItemsConnection>) => null | string,
  RozpisItemsEdge?: (data: WithTypename<RozpisItemsEdge>) => null | string,
  Session?: (data: WithTypename<Session>) => null | string,
  SessionsConnection?: (data: WithTypename<SessionsConnection>) => null | string,
  SessionsEdge?: (data: WithTypename<SessionsEdge>) => null | string,
  SkupiniesConnection?: (data: WithTypename<SkupiniesConnection>) => null | string,
  SkupiniesEdge?: (data: WithTypename<SkupiniesEdge>) => null | string,
  Skupiny?: (data: WithTypename<Skupiny>) => null | string,
  SubmitFormPayload?: (data: WithTypename<SubmitFormPayload>) => null | string,
  Tenant?: (data: WithTypename<Tenant>) => null | string,
  TenantAttachment?: (data: WithTypename<TenantAttachment>) => null | string,
  TenantAttachmentsConnection?: (data: WithTypename<TenantAttachmentsConnection>) => null | string,
  TenantAttachmentsEdge?: (data: WithTypename<TenantAttachmentsEdge>) => null | string,
  TenantLocation?: (data: WithTypename<TenantLocation>) => null | string,
  TenantLocationsConnection?: (data: WithTypename<TenantLocationsConnection>) => null | string,
  TenantLocationsEdge?: (data: WithTypename<TenantLocationsEdge>) => null | string,
  TenantPeopleConnection?: (data: WithTypename<TenantPeopleConnection>) => null | string,
  TenantPeopleEdge?: (data: WithTypename<TenantPeopleEdge>) => null | string,
  TenantPerson?: (data: WithTypename<TenantPerson>) => null | string,
  TenantsConnection?: (data: WithTypename<TenantsConnection>) => null | string,
  TenantsEdge?: (data: WithTypename<TenantsEdge>) => null | string,
  UpdateAktualityPayload?: (data: WithTypename<UpdateAktualityPayload>) => null | string,
  UpdateAttachmentPayload?: (data: WithTypename<UpdateAttachmentPayload>) => null | string,
  UpdateAttendeeExternalPayload?: (data: WithTypename<UpdateAttendeeExternalPayload>) => null | string,
  UpdateAttendeeUserPayload?: (data: WithTypename<UpdateAttendeeUserPayload>) => null | string,
  UpdateCohortGroupPayload?: (data: WithTypename<UpdateCohortGroupPayload>) => null | string,
  UpdateDokumentyPayload?: (data: WithTypename<UpdateDokumentyPayload>) => null | string,
  UpdateEventPayload?: (data: WithTypename<UpdateEventPayload>) => null | string,
  UpdateFormResponsePayload?: (data: WithTypename<UpdateFormResponsePayload>) => null | string,
  UpdateGalerieDirPayload?: (data: WithTypename<UpdateGalerieDirPayload>) => null | string,
  UpdateGalerieFotoPayload?: (data: WithTypename<UpdateGalerieFotoPayload>) => null | string,
  UpdateLocationAttachmentPayload?: (data: WithTypename<UpdateLocationAttachmentPayload>) => null | string,
  UpdateLocationPayload?: (data: WithTypename<UpdateLocationPayload>) => null | string,
  UpdateNabidkaItemPayload?: (data: WithTypename<UpdateNabidkaItemPayload>) => null | string,
  UpdateNabidkaPayload?: (data: WithTypename<UpdateNabidkaPayload>) => null | string,
  UpdatePagePayload?: (data: WithTypename<UpdatePagePayload>) => null | string,
  UpdateParameterPayload?: (data: WithTypename<UpdateParameterPayload>) => null | string,
  UpdateParyNavrhPayload?: (data: WithTypename<UpdateParyNavrhPayload>) => null | string,
  UpdateParyPayload?: (data: WithTypename<UpdateParyPayload>) => null | string,
  UpdatePermissionPayload?: (data: WithTypename<UpdatePermissionPayload>) => null | string,
  UpdatePersonPayload?: (data: WithTypename<UpdatePersonPayload>) => null | string,
  UpdatePlatbyCategoryGroupPayload?: (data: WithTypename<UpdatePlatbyCategoryGroupPayload>) => null | string,
  UpdatePlatbyCategoryPayload?: (data: WithTypename<UpdatePlatbyCategoryPayload>) => null | string,
  UpdatePlatbyGroupPayload?: (data: WithTypename<UpdatePlatbyGroupPayload>) => null | string,
  UpdatePlatbyGroupSkupinaPayload?: (data: WithTypename<UpdatePlatbyGroupSkupinaPayload>) => null | string,
  UpdatePlatbyItemPayload?: (data: WithTypename<UpdatePlatbyItemPayload>) => null | string,
  UpdatePlatbyRawPayload?: (data: WithTypename<UpdatePlatbyRawPayload>) => null | string,
  UpdateRoomAttachmentPayload?: (data: WithTypename<UpdateRoomAttachmentPayload>) => null | string,
  UpdateRoomPayload?: (data: WithTypename<UpdateRoomPayload>) => null | string,
  UpdateRozpiPayload?: (data: WithTypename<UpdateRozpiPayload>) => null | string,
  UpdateRozpisItemPayload?: (data: WithTypename<UpdateRozpisItemPayload>) => null | string,
  UpdateSkupinyPayload?: (data: WithTypename<UpdateSkupinyPayload>) => null | string,
  UpdateTenantAttachmentPayload?: (data: WithTypename<UpdateTenantAttachmentPayload>) => null | string,
  UpdateTenantLocationPayload?: (data: WithTypename<UpdateTenantLocationPayload>) => null | string,
  UpdateTenantPayload?: (data: WithTypename<UpdateTenantPayload>) => null | string,
  UpdateTenantPersonPayload?: (data: WithTypename<UpdateTenantPersonPayload>) => null | string,
  UpdateUpozorneniPayload?: (data: WithTypename<UpdateUpozorneniPayload>) => null | string,
  UpdateUpozorneniSkupinyPayload?: (data: WithTypename<UpdateUpozorneniSkupinyPayload>) => null | string,
  UpdateUserPayload?: (data: WithTypename<UpdateUserPayload>) => null | string,
  Upozorneni?: (data: WithTypename<Upozorneni>) => null | string,
  UpozorneniSkupiniesConnection?: (data: WithTypename<UpozorneniSkupiniesConnection>) => null | string,
  UpozorneniSkupiniesEdge?: (data: WithTypename<UpozorneniSkupiniesEdge>) => null | string,
  UpozorneniSkupiny?: (data: WithTypename<UpozorneniSkupiny>) => null | string,
  UpozornenisConnection?: (data: WithTypename<UpozornenisConnection>) => null | string,
  UpozornenisEdge?: (data: WithTypename<UpozornenisEdge>) => null | string,
  User?: (data: WithTypename<User>) => null | string,
  UsersConnection?: (data: WithTypename<UsersConnection>) => null | string,
  UsersEdge?: (data: WithTypename<UsersEdge>) => null | string,
  VerifyFunctionPayload?: (data: WithTypename<VerifyFunctionPayload>) => null | string,
  Video?: (data: WithTypename<Video>) => null | string,
  VideosConnection?: (data: WithTypename<VideosConnection>) => null | string,
  VideosEdge?: (data: WithTypename<VideosEdge>) => null | string
}

export type GraphCacheResolvers = {
  Query?: {
    activeCouples?: GraphCacheResolver<WithTypename<Query>, QueryActiveCouplesArgs, WithTypename<PariesConnection> | string>,
    akceItems?: GraphCacheResolver<WithTypename<Query>, QueryAkceItemsArgs, WithTypename<AkceItemsConnection> | string>,
    akces?: GraphCacheResolver<WithTypename<Query>, QueryAkcesArgs, WithTypename<AkcesConnection> | string>,
    aktualities?: GraphCacheResolver<WithTypename<Query>, QueryAktualitiesArgs, WithTypename<AktualitiesConnection> | string>,
    aktuality?: GraphCacheResolver<WithTypename<Query>, QueryAktualityArgs, WithTypename<Aktuality> | string>,
    archivedAnnouncements?: GraphCacheResolver<WithTypename<Query>, QueryArchivedAnnouncementsArgs, WithTypename<UpozornenisConnection> | string>,
    attachment?: GraphCacheResolver<WithTypename<Query>, QueryAttachmentArgs, WithTypename<Attachment> | string>,
    attachmentDirectories?: GraphCacheResolver<WithTypename<Query>, QueryAttachmentDirectoriesArgs, WithTypename<AttachmentDirectoriesConnection> | string>,
    attachments?: GraphCacheResolver<WithTypename<Query>, QueryAttachmentsArgs, WithTypename<AttachmentsConnection> | string>,
    attendeeCouple?: GraphCacheResolver<WithTypename<Query>, QueryAttendeeCoupleArgs, WithTypename<AttendeeCouple> | string>,
    attendeeCouples?: GraphCacheResolver<WithTypename<Query>, QueryAttendeeCouplesArgs, WithTypename<AttendeeCouplesConnection> | string>,
    attendeeExternal?: GraphCacheResolver<WithTypename<Query>, QueryAttendeeExternalArgs, WithTypename<AttendeeExternal> | string>,
    attendeeExternals?: GraphCacheResolver<WithTypename<Query>, QueryAttendeeExternalsArgs, WithTypename<AttendeeExternalsConnection> | string>,
    attendeeList?: GraphCacheResolver<WithTypename<Query>, QueryAttendeeListArgs, WithTypename<AttendeeList> | string>,
    attendeeLists?: GraphCacheResolver<WithTypename<Query>, QueryAttendeeListsArgs, WithTypename<AttendeeListsConnection> | string>,
    attendeePeople?: GraphCacheResolver<WithTypename<Query>, QueryAttendeePeopleArgs, WithTypename<AttendeePeopleConnection> | string>,
    attendeePerson?: GraphCacheResolver<WithTypename<Query>, QueryAttendeePersonArgs, WithTypename<AttendeePerson> | string>,
    attendeeUser?: GraphCacheResolver<WithTypename<Query>, QueryAttendeeUserArgs, WithTypename<AttendeeUser> | string>,
    attendeeUserByUserIdAndEventId?: GraphCacheResolver<WithTypename<Query>, QueryAttendeeUserByUserIdAndEventIdArgs, WithTypename<AttendeeUser> | string>,
    attendeeUsers?: GraphCacheResolver<WithTypename<Query>, QueryAttendeeUsersArgs, WithTypename<AttendeeUsersConnection> | string>,
    cohortGroup?: GraphCacheResolver<WithTypename<Query>, QueryCohortGroupArgs, WithTypename<CohortGroup> | string>,
    cohortGroups?: GraphCacheResolver<WithTypename<Query>, QueryCohortGroupsArgs, WithTypename<CohortGroupsConnection> | string>,
    couple?: GraphCacheResolver<WithTypename<Query>, QueryCoupleArgs, WithTypename<Couple> | string>,
    couples?: GraphCacheResolver<WithTypename<Query>, QueryCouplesArgs, WithTypename<CouplesConnection> | string>,
    currentCoupleIds?: GraphCacheResolver<WithTypename<Query>, QueryCurrentCoupleIdsArgs, WithTypename<CurrentCoupleIdsConnection> | string>,
    currentPermissions?: GraphCacheResolver<WithTypename<Query>, QueryCurrentPermissionsArgs, WithTypename<PermissionsConnection> | string>,
    currentSessionId?: GraphCacheResolver<WithTypename<Query>, Record<string, never>, Scalars['String'] | string>,
    currentTenantId?: GraphCacheResolver<WithTypename<Query>, Record<string, never>, Scalars['BigInt'] | string>,
    currentUserId?: GraphCacheResolver<WithTypename<Query>, Record<string, never>, Scalars['BigInt'] | string>,
    dokumenties?: GraphCacheResolver<WithTypename<Query>, QueryDokumentiesArgs, WithTypename<DokumentiesConnection> | string>,
    dokumenty?: GraphCacheResolver<WithTypename<Query>, QueryDokumentyArgs, WithTypename<Dokumenty> | string>,
    event?: GraphCacheResolver<WithTypename<Query>, QueryEventArgs, WithTypename<Event> | string>,
    events?: GraphCacheResolver<WithTypename<Query>, QueryEventsArgs, WithTypename<EventsConnection> | string>,
    formResponse?: GraphCacheResolver<WithTypename<Query>, QueryFormResponseArgs, WithTypename<FormResponse> | string>,
    formResponses?: GraphCacheResolver<WithTypename<Query>, QueryFormResponsesArgs, WithTypename<FormResponsesConnection> | string>,
    galerieDir?: GraphCacheResolver<WithTypename<Query>, QueryGalerieDirArgs, WithTypename<GalerieDir> | string>,
    galerieDirs?: GraphCacheResolver<WithTypename<Query>, QueryGalerieDirsArgs, WithTypename<GalerieDirsConnection> | string>,
    galerieFoto?: GraphCacheResolver<WithTypename<Query>, QueryGalerieFotoArgs, WithTypename<GalerieFoto> | string>,
    galerieFotos?: GraphCacheResolver<WithTypename<Query>, QueryGalerieFotosArgs, WithTypename<GalerieFotosConnection> | string>,
    getCurrentCouple?: GraphCacheResolver<WithTypename<Query>, Record<string, never>, WithTypename<Pary> | string>,
    getCurrentTenant?: GraphCacheResolver<WithTypename<Query>, Record<string, never>, WithTypename<Tenant> | string>,
    getCurrentUser?: GraphCacheResolver<WithTypename<Query>, Record<string, never>, WithTypename<User> | string>,
    location?: GraphCacheResolver<WithTypename<Query>, QueryLocationArgs, WithTypename<Location> | string>,
    locationAttachment?: GraphCacheResolver<WithTypename<Query>, QueryLocationAttachmentArgs, WithTypename<LocationAttachment> | string>,
    locationAttachments?: GraphCacheResolver<WithTypename<Query>, QueryLocationAttachmentsArgs, WithTypename<LocationAttachmentsConnection> | string>,
    locations?: GraphCacheResolver<WithTypename<Query>, QueryLocationsArgs, WithTypename<LocationsConnection> | string>,
    myAnnouncements?: GraphCacheResolver<WithTypename<Query>, QueryMyAnnouncementsArgs, WithTypename<UpozornenisConnection> | string>,
    myLessons?: GraphCacheResolver<WithTypename<Query>, QueryMyLessonsArgs, WithTypename<RozpisItemsConnection> | string>,
    nabidka?: GraphCacheResolver<WithTypename<Query>, QueryNabidkaArgs, WithTypename<Nabidka> | string>,
    nabidkaItem?: GraphCacheResolver<WithTypename<Query>, QueryNabidkaItemArgs, WithTypename<NabidkaItem> | string>,
    nabidkaItemByNiPartnerAndNiIdRodic?: GraphCacheResolver<WithTypename<Query>, QueryNabidkaItemByNiPartnerAndNiIdRodicArgs, WithTypename<NabidkaItem> | string>,
    nabidkaItems?: GraphCacheResolver<WithTypename<Query>, QueryNabidkaItemsArgs, WithTypename<NabidkaItemsConnection> | string>,
    nabidkas?: GraphCacheResolver<WithTypename<Query>, QueryNabidkasArgs, WithTypename<NabidkasConnection> | string>,
    page?: GraphCacheResolver<WithTypename<Query>, QueryPageArgs, WithTypename<Page> | string>,
    pageByUrl?: GraphCacheResolver<WithTypename<Query>, QueryPageByUrlArgs, WithTypename<Page> | string>,
    pageRevision?: GraphCacheResolver<WithTypename<Query>, QueryPageRevisionArgs, WithTypename<PageRevision> | string>,
    pageRevisions?: GraphCacheResolver<WithTypename<Query>, QueryPageRevisionsArgs, WithTypename<PageRevisionsConnection> | string>,
    pages?: GraphCacheResolver<WithTypename<Query>, QueryPagesArgs, WithTypename<PagesConnection> | string>,
    parameter?: GraphCacheResolver<WithTypename<Query>, QueryParameterArgs, WithTypename<Parameter> | string>,
    parameters?: GraphCacheResolver<WithTypename<Query>, QueryParametersArgs, WithTypename<ParametersConnection> | string>,
    paries?: GraphCacheResolver<WithTypename<Query>, QueryPariesArgs, WithTypename<PariesConnection> | string>,
    pary?: GraphCacheResolver<WithTypename<Query>, QueryParyArgs, WithTypename<Pary> | string>,
    paryNavrh?: GraphCacheResolver<WithTypename<Query>, QueryParyNavrhArgs, WithTypename<ParyNavrh> | string>,
    paryNavrhs?: GraphCacheResolver<WithTypename<Query>, QueryParyNavrhsArgs, WithTypename<ParyNavrhsConnection> | string>,
    people?: GraphCacheResolver<WithTypename<Query>, QueryPeopleArgs, WithTypename<PeopleConnection> | string>,
    permission?: GraphCacheResolver<WithTypename<Query>, QueryPermissionArgs, WithTypename<Permission> | string>,
    permissions?: GraphCacheResolver<WithTypename<Query>, QueryPermissionsArgs, WithTypename<PermissionsConnection> | string>,
    person?: GraphCacheResolver<WithTypename<Query>, QueryPersonArgs, WithTypename<Person> | string>,
    platbyCategories?: GraphCacheResolver<WithTypename<Query>, QueryPlatbyCategoriesArgs, WithTypename<PlatbyCategoriesConnection> | string>,
    platbyCategory?: GraphCacheResolver<WithTypename<Query>, QueryPlatbyCategoryArgs, WithTypename<PlatbyCategory> | string>,
    platbyCategoryGroup?: GraphCacheResolver<WithTypename<Query>, QueryPlatbyCategoryGroupArgs, WithTypename<PlatbyCategoryGroup> | string>,
    platbyCategoryGroups?: GraphCacheResolver<WithTypename<Query>, QueryPlatbyCategoryGroupsArgs, WithTypename<PlatbyCategoryGroupsConnection> | string>,
    platbyGroup?: GraphCacheResolver<WithTypename<Query>, QueryPlatbyGroupArgs, WithTypename<PlatbyGroup> | string>,
    platbyGroupSkupina?: GraphCacheResolver<WithTypename<Query>, QueryPlatbyGroupSkupinaArgs, WithTypename<PlatbyGroupSkupina> | string>,
    platbyGroupSkupinas?: GraphCacheResolver<WithTypename<Query>, QueryPlatbyGroupSkupinasArgs, WithTypename<PlatbyGroupSkupinasConnection> | string>,
    platbyGroups?: GraphCacheResolver<WithTypename<Query>, QueryPlatbyGroupsArgs, WithTypename<PlatbyGroupsConnection> | string>,
    platbyItem?: GraphCacheResolver<WithTypename<Query>, QueryPlatbyItemArgs, WithTypename<PlatbyItem> | string>,
    platbyItems?: GraphCacheResolver<WithTypename<Query>, QueryPlatbyItemsArgs, WithTypename<PlatbyItemsConnection> | string>,
    platbyRaw?: GraphCacheResolver<WithTypename<Query>, QueryPlatbyRawArgs, WithTypename<PlatbyRaw> | string>,
    platbyRaws?: GraphCacheResolver<WithTypename<Query>, QueryPlatbyRawsArgs, WithTypename<PlatbyRawsConnection> | string>,
    query?: GraphCacheResolver<WithTypename<Query>, Record<string, never>, WithTypename<Query> | string>,
    reservationsForRange?: GraphCacheResolver<WithTypename<Query>, QueryReservationsForRangeArgs, WithTypename<NabidkasConnection> | string>,
    room?: GraphCacheResolver<WithTypename<Query>, QueryRoomArgs, WithTypename<Room> | string>,
    roomAttachment?: GraphCacheResolver<WithTypename<Query>, QueryRoomAttachmentArgs, WithTypename<RoomAttachment> | string>,
    roomAttachments?: GraphCacheResolver<WithTypename<Query>, QueryRoomAttachmentsArgs, WithTypename<RoomAttachmentsConnection> | string>,
    rooms?: GraphCacheResolver<WithTypename<Query>, QueryRoomsArgs, WithTypename<RoomsConnection> | string>,
    rozpi?: GraphCacheResolver<WithTypename<Query>, QueryRozpiArgs, WithTypename<Rozpi> | string>,
    rozpis?: GraphCacheResolver<WithTypename<Query>, QueryRozpisArgs, WithTypename<RozpisConnection> | string>,
    rozpisItem?: GraphCacheResolver<WithTypename<Query>, QueryRozpisItemArgs, WithTypename<RozpisItem> | string>,
    rozpisItems?: GraphCacheResolver<WithTypename<Query>, QueryRozpisItemsArgs, WithTypename<RozpisItemsConnection> | string>,
    schedulesForRange?: GraphCacheResolver<WithTypename<Query>, QuerySchedulesForRangeArgs, WithTypename<RozpisConnection> | string>,
    session?: GraphCacheResolver<WithTypename<Query>, QuerySessionArgs, WithTypename<Session> | string>,
    sessions?: GraphCacheResolver<WithTypename<Query>, QuerySessionsArgs, WithTypename<SessionsConnection> | string>,
    skupinies?: GraphCacheResolver<WithTypename<Query>, QuerySkupiniesArgs, WithTypename<SkupiniesConnection> | string>,
    skupiny?: GraphCacheResolver<WithTypename<Query>, QuerySkupinyArgs, WithTypename<Skupiny> | string>,
    stickyAnnouncements?: GraphCacheResolver<WithTypename<Query>, QueryStickyAnnouncementsArgs, WithTypename<UpozornenisConnection> | string>,
    tenant?: GraphCacheResolver<WithTypename<Query>, QueryTenantArgs, WithTypename<Tenant> | string>,
    tenantAttachment?: GraphCacheResolver<WithTypename<Query>, QueryTenantAttachmentArgs, WithTypename<TenantAttachment> | string>,
    tenantAttachments?: GraphCacheResolver<WithTypename<Query>, QueryTenantAttachmentsArgs, WithTypename<TenantAttachmentsConnection> | string>,
    tenantLocation?: GraphCacheResolver<WithTypename<Query>, QueryTenantLocationArgs, WithTypename<TenantLocation> | string>,
    tenantLocations?: GraphCacheResolver<WithTypename<Query>, QueryTenantLocationsArgs, WithTypename<TenantLocationsConnection> | string>,
    tenantPeople?: GraphCacheResolver<WithTypename<Query>, QueryTenantPeopleArgs, WithTypename<TenantPeopleConnection> | string>,
    tenantPerson?: GraphCacheResolver<WithTypename<Query>, QueryTenantPersonArgs, WithTypename<TenantPerson> | string>,
    tenants?: GraphCacheResolver<WithTypename<Query>, QueryTenantsArgs, WithTypename<TenantsConnection> | string>,
    titleVideos?: GraphCacheResolver<WithTypename<Query>, QueryTitleVideosArgs, WithTypename<VideosConnection> | string>,
    trainers?: GraphCacheResolver<WithTypename<Query>, QueryTrainersArgs, WithTypename<UsersConnection> | string>,
    upozorneni?: GraphCacheResolver<WithTypename<Query>, QueryUpozorneniArgs, WithTypename<Upozorneni> | string>,
    upozorneniSkupinies?: GraphCacheResolver<WithTypename<Query>, QueryUpozorneniSkupiniesArgs, WithTypename<UpozorneniSkupiniesConnection> | string>,
    upozorneniSkupiny?: GraphCacheResolver<WithTypename<Query>, QueryUpozorneniSkupinyArgs, WithTypename<UpozorneniSkupiny> | string>,
    upozornenis?: GraphCacheResolver<WithTypename<Query>, QueryUpozornenisArgs, WithTypename<UpozornenisConnection> | string>,
    user?: GraphCacheResolver<WithTypename<Query>, QueryUserArgs, WithTypename<User> | string>,
    users?: GraphCacheResolver<WithTypename<Query>, QueryUsersArgs, WithTypename<UsersConnection> | string>
  },
  Akce?: {
    aDo?: GraphCacheResolver<WithTypename<Akce>, Record<string, never>, Scalars['Date'] | string>,
    aDokumenty?: GraphCacheResolver<WithTypename<Akce>, Record<string, never>, Scalars['String'] | string>,
    aId?: GraphCacheResolver<WithTypename<Akce>, Record<string, never>, Scalars['BigInt'] | string>,
    aInfo?: GraphCacheResolver<WithTypename<Akce>, Record<string, never>, Scalars['String'] | string>,
    aJmeno?: GraphCacheResolver<WithTypename<Akce>, Record<string, never>, Scalars['String'] | string>,
    aKapacita?: GraphCacheResolver<WithTypename<Akce>, Record<string, never>, Scalars['BigInt'] | string>,
    aKde?: GraphCacheResolver<WithTypename<Akce>, Record<string, never>, Scalars['String'] | string>,
    aLock?: GraphCacheResolver<WithTypename<Akce>, Record<string, never>, Scalars['Boolean'] | string>,
    aOd?: GraphCacheResolver<WithTypename<Akce>, Record<string, never>, Scalars['Date'] | string>,
    aTimestamp?: GraphCacheResolver<WithTypename<Akce>, Record<string, never>, Scalars['Datetime'] | string>,
    aVisible?: GraphCacheResolver<WithTypename<Akce>, Record<string, never>, Scalars['Boolean'] | string>,
    akceItemsByAiIdRodic?: GraphCacheResolver<WithTypename<Akce>, AkceAkceItemsByAiIdRodicArgs, WithTypename<AkceItemsConnection> | string>,
    enableNotes?: GraphCacheResolver<WithTypename<Akce>, Record<string, never>, Scalars['Boolean'] | string>,
    isPublic?: GraphCacheResolver<WithTypename<Akce>, Record<string, never>, Scalars['Boolean'] | string>,
    summary?: GraphCacheResolver<WithTypename<Akce>, Record<string, never>, Scalars['String'] | string>
  },
  AkceItem?: {
    aiId?: GraphCacheResolver<WithTypename<AkceItem>, Record<string, never>, Scalars['BigInt'] | string>,
    aiIdRodic?: GraphCacheResolver<WithTypename<AkceItem>, Record<string, never>, Scalars['BigInt'] | string>,
    aiRokNarozeni?: GraphCacheResolver<WithTypename<AkceItem>, Record<string, never>, Scalars['Int'] | string>,
    aiUser?: GraphCacheResolver<WithTypename<AkceItem>, Record<string, never>, Scalars['BigInt'] | string>,
    akceByAiIdRodic?: GraphCacheResolver<WithTypename<AkceItem>, Record<string, never>, WithTypename<Akce> | string>,
    notes?: GraphCacheResolver<WithTypename<AkceItem>, Record<string, never>, Scalars['String'] | string>,
    userByAiUser?: GraphCacheResolver<WithTypename<AkceItem>, Record<string, never>, WithTypename<User> | string>
  },
  AkceItemsConnection?: {
    edges?: GraphCacheResolver<WithTypename<AkceItemsConnection>, Record<string, never>, Array<WithTypename<AkceItemsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<AkceItemsConnection>, Record<string, never>, Array<WithTypename<AkceItem> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<AkceItemsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<AkceItemsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  AkceItemsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<AkceItemsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<AkceItemsEdge>, Record<string, never>, WithTypename<AkceItem> | string>
  },
  AkcesConnection?: {
    edges?: GraphCacheResolver<WithTypename<AkcesConnection>, Record<string, never>, Array<WithTypename<AkcesEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<AkcesConnection>, Record<string, never>, Array<WithTypename<Akce> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<AkcesConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<AkcesConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  AkcesEdge?: {
    cursor?: GraphCacheResolver<WithTypename<AkcesEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<AkcesEdge>, Record<string, never>, WithTypename<Akce> | string>
  },
  AktualitiesConnection?: {
    edges?: GraphCacheResolver<WithTypename<AktualitiesConnection>, Record<string, never>, Array<WithTypename<AktualitiesEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<AktualitiesConnection>, Record<string, never>, Array<WithTypename<Aktuality> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<AktualitiesConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<AktualitiesConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  AktualitiesEdge?: {
    cursor?: GraphCacheResolver<WithTypename<AktualitiesEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<AktualitiesEdge>, Record<string, never>, WithTypename<Aktuality> | string>
  },
  Aktuality?: {
    atFoto?: GraphCacheResolver<WithTypename<Aktuality>, Record<string, never>, Scalars['BigInt'] | string>,
    atFotoMain?: GraphCacheResolver<WithTypename<Aktuality>, Record<string, never>, Scalars['BigInt'] | string>,
    atId?: GraphCacheResolver<WithTypename<Aktuality>, Record<string, never>, Scalars['BigInt'] | string>,
    atJmeno?: GraphCacheResolver<WithTypename<Aktuality>, Record<string, never>, Scalars['String'] | string>,
    atKat?: GraphCacheResolver<WithTypename<Aktuality>, Record<string, never>, Scalars['String'] | string>,
    atKdo?: GraphCacheResolver<WithTypename<Aktuality>, Record<string, never>, Scalars['BigInt'] | string>,
    atPreview?: GraphCacheResolver<WithTypename<Aktuality>, Record<string, never>, Scalars['String'] | string>,
    atText?: GraphCacheResolver<WithTypename<Aktuality>, Record<string, never>, Scalars['String'] | string>,
    atTimestamp?: GraphCacheResolver<WithTypename<Aktuality>, Record<string, never>, Scalars['Datetime'] | string>,
    atTimestampAdd?: GraphCacheResolver<WithTypename<Aktuality>, Record<string, never>, Scalars['Datetime'] | string>,
    galerieFotoByAtFotoMain?: GraphCacheResolver<WithTypename<Aktuality>, Record<string, never>, WithTypename<GalerieFoto> | string>,
    id?: GraphCacheResolver<WithTypename<Aktuality>, Record<string, never>, Scalars['BigInt'] | string>,
    tenantId?: GraphCacheResolver<WithTypename<Aktuality>, Record<string, never>, Scalars['BigInt'] | string>,
    userByAtKdo?: GraphCacheResolver<WithTypename<Aktuality>, Record<string, never>, WithTypename<User> | string>
  },
  Attachment?: {
    directory?: GraphCacheResolver<WithTypename<Attachment>, Record<string, never>, Scalars['String'] | string>,
    downloadUrl?: GraphCacheResolver<WithTypename<Attachment>, Record<string, never>, Scalars['String'] | string>,
    height?: GraphCacheResolver<WithTypename<Attachment>, Record<string, never>, Scalars['Int'] | string>,
    locationAttachmentsByObjectName?: GraphCacheResolver<WithTypename<Attachment>, AttachmentLocationAttachmentsByObjectNameArgs, WithTypename<LocationAttachmentsConnection> | string>,
    objectName?: GraphCacheResolver<WithTypename<Attachment>, Record<string, never>, Scalars['String'] | string>,
    previewObjectName?: GraphCacheResolver<WithTypename<Attachment>, Record<string, never>, Scalars['String'] | string>,
    publicUrl?: GraphCacheResolver<WithTypename<Attachment>, Record<string, never>, Scalars['String'] | string>,
    roomAttachmentsByObjectName?: GraphCacheResolver<WithTypename<Attachment>, AttachmentRoomAttachmentsByObjectNameArgs, WithTypename<RoomAttachmentsConnection> | string>,
    tenantAttachmentsByObjectName?: GraphCacheResolver<WithTypename<Attachment>, AttachmentTenantAttachmentsByObjectNameArgs, WithTypename<TenantAttachmentsConnection> | string>,
    thumbhash?: GraphCacheResolver<WithTypename<Attachment>, Record<string, never>, Scalars['String'] | string>,
    uploadUrl?: GraphCacheResolver<WithTypename<Attachment>, Record<string, never>, Scalars['String'] | string>,
    uploadedAt?: GraphCacheResolver<WithTypename<Attachment>, Record<string, never>, Scalars['Datetime'] | string>,
    uploadedBy?: GraphCacheResolver<WithTypename<Attachment>, Record<string, never>, Scalars['BigInt'] | string>,
    userByUploadedBy?: GraphCacheResolver<WithTypename<Attachment>, Record<string, never>, WithTypename<User> | string>,
    width?: GraphCacheResolver<WithTypename<Attachment>, Record<string, never>, Scalars['Int'] | string>
  },
  AttachmentDirectoriesConnection?: {
    edges?: GraphCacheResolver<WithTypename<AttachmentDirectoriesConnection>, Record<string, never>, Array<WithTypename<AttachmentDirectoryEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<AttachmentDirectoriesConnection>, Record<string, never>, Array<Scalars['String'] | string>>,
    totalCount?: GraphCacheResolver<WithTypename<AttachmentDirectoriesConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  AttachmentDirectoryEdge?: {
    cursor?: GraphCacheResolver<WithTypename<AttachmentDirectoryEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<AttachmentDirectoryEdge>, Record<string, never>, Scalars['String'] | string>
  },
  AttachmentsConnection?: {
    edges?: GraphCacheResolver<WithTypename<AttachmentsConnection>, Record<string, never>, Array<WithTypename<AttachmentsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<AttachmentsConnection>, Record<string, never>, Array<WithTypename<Attachment> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<AttachmentsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<AttachmentsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  AttachmentsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<AttachmentsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<AttachmentsEdge>, Record<string, never>, WithTypename<Attachment> | string>
  },
  AttendeeCouple?: {
    couple?: GraphCacheResolver<WithTypename<AttendeeCouple>, Record<string, never>, WithTypename<Couple> | string>,
    coupleId?: GraphCacheResolver<WithTypename<AttendeeCouple>, Record<string, never>, Scalars['BigInt'] | string>,
    createdAt?: GraphCacheResolver<WithTypename<AttendeeCouple>, Record<string, never>, Scalars['Datetime'] | string>,
    id?: GraphCacheResolver<WithTypename<AttendeeCouple>, Record<string, never>, Scalars['BigInt'] | string>,
    list?: GraphCacheResolver<WithTypename<AttendeeCouple>, Record<string, never>, WithTypename<AttendeeList> | string>,
    listId?: GraphCacheResolver<WithTypename<AttendeeCouple>, Record<string, never>, Scalars['BigInt'] | string>,
    tenant?: GraphCacheResolver<WithTypename<AttendeeCouple>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantId?: GraphCacheResolver<WithTypename<AttendeeCouple>, Record<string, never>, Scalars['BigInt'] | string>,
    updatedAt?: GraphCacheResolver<WithTypename<AttendeeCouple>, Record<string, never>, Scalars['Datetime'] | string>
  },
  AttendeeCouplesConnection?: {
    edges?: GraphCacheResolver<WithTypename<AttendeeCouplesConnection>, Record<string, never>, Array<WithTypename<AttendeeCouplesEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<AttendeeCouplesConnection>, Record<string, never>, Array<WithTypename<AttendeeCouple> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<AttendeeCouplesConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<AttendeeCouplesConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  AttendeeCouplesEdge?: {
    cursor?: GraphCacheResolver<WithTypename<AttendeeCouplesEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<AttendeeCouplesEdge>, Record<string, never>, WithTypename<AttendeeCouple> | string>
  },
  AttendeeExternal?: {
    birthNumber?: GraphCacheResolver<WithTypename<AttendeeExternal>, Record<string, never>, Scalars['String'] | string>,
    confirmedAt?: GraphCacheResolver<WithTypename<AttendeeExternal>, Record<string, never>, Scalars['Datetime'] | string>,
    confirmedBy?: GraphCacheResolver<WithTypename<AttendeeExternal>, Record<string, never>, Scalars['BigInt'] | string>,
    createdAt?: GraphCacheResolver<WithTypename<AttendeeExternal>, Record<string, never>, Scalars['Datetime'] | string>,
    email?: GraphCacheResolver<WithTypename<AttendeeExternal>, Record<string, never>, Scalars['String'] | string>,
    event?: GraphCacheResolver<WithTypename<AttendeeExternal>, Record<string, never>, WithTypename<Event> | string>,
    eventId?: GraphCacheResolver<WithTypename<AttendeeExternal>, Record<string, never>, Scalars['BigInt'] | string>,
    firstName?: GraphCacheResolver<WithTypename<AttendeeExternal>, Record<string, never>, Scalars['String'] | string>,
    guardianName?: GraphCacheResolver<WithTypename<AttendeeExternal>, Record<string, never>, Scalars['String'] | string>,
    id?: GraphCacheResolver<WithTypename<AttendeeExternal>, Record<string, never>, Scalars['BigInt'] | string>,
    lastName?: GraphCacheResolver<WithTypename<AttendeeExternal>, Record<string, never>, Scalars['String'] | string>,
    managedBy?: GraphCacheResolver<WithTypename<AttendeeExternal>, Record<string, never>, Scalars['BigInt'] | string>,
    notes?: GraphCacheResolver<WithTypename<AttendeeExternal>, Record<string, never>, Scalars['String'] | string>,
    phone?: GraphCacheResolver<WithTypename<AttendeeExternal>, Record<string, never>, Scalars['String'] | string>,
    tenantId?: GraphCacheResolver<WithTypename<AttendeeExternal>, Record<string, never>, Scalars['BigInt'] | string>,
    updatedAt?: GraphCacheResolver<WithTypename<AttendeeExternal>, Record<string, never>, Scalars['Datetime'] | string>,
    userByConfirmedBy?: GraphCacheResolver<WithTypename<AttendeeExternal>, Record<string, never>, WithTypename<User> | string>,
    userByManagedBy?: GraphCacheResolver<WithTypename<AttendeeExternal>, Record<string, never>, WithTypename<User> | string>
  },
  AttendeeExternalsConnection?: {
    edges?: GraphCacheResolver<WithTypename<AttendeeExternalsConnection>, Record<string, never>, Array<WithTypename<AttendeeExternalsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<AttendeeExternalsConnection>, Record<string, never>, Array<WithTypename<AttendeeExternal> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<AttendeeExternalsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<AttendeeExternalsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  AttendeeExternalsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<AttendeeExternalsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<AttendeeExternalsEdge>, Record<string, never>, WithTypename<AttendeeExternal> | string>
  },
  AttendeeList?: {
    attendeeCouplesByListId?: GraphCacheResolver<WithTypename<AttendeeList>, AttendeeListAttendeeCouplesByListIdArgs, WithTypename<AttendeeCouplesConnection> | string>,
    attendeePeopleByListId?: GraphCacheResolver<WithTypename<AttendeeList>, AttendeeListAttendeePeopleByListIdArgs, WithTypename<AttendeePeopleConnection> | string>,
    createdAt?: GraphCacheResolver<WithTypename<AttendeeList>, Record<string, never>, Scalars['Datetime'] | string>,
    id?: GraphCacheResolver<WithTypename<AttendeeList>, Record<string, never>, Scalars['BigInt'] | string>,
    tenant?: GraphCacheResolver<WithTypename<AttendeeList>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantId?: GraphCacheResolver<WithTypename<AttendeeList>, Record<string, never>, Scalars['BigInt'] | string>,
    updatedAt?: GraphCacheResolver<WithTypename<AttendeeList>, Record<string, never>, Scalars['Datetime'] | string>
  },
  AttendeeListsConnection?: {
    edges?: GraphCacheResolver<WithTypename<AttendeeListsConnection>, Record<string, never>, Array<WithTypename<AttendeeListsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<AttendeeListsConnection>, Record<string, never>, Array<WithTypename<AttendeeList> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<AttendeeListsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<AttendeeListsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  AttendeeListsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<AttendeeListsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<AttendeeListsEdge>, Record<string, never>, WithTypename<AttendeeList> | string>
  },
  AttendeePeopleConnection?: {
    edges?: GraphCacheResolver<WithTypename<AttendeePeopleConnection>, Record<string, never>, Array<WithTypename<AttendeePeopleEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<AttendeePeopleConnection>, Record<string, never>, Array<WithTypename<AttendeePerson> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<AttendeePeopleConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<AttendeePeopleConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  AttendeePeopleEdge?: {
    cursor?: GraphCacheResolver<WithTypename<AttendeePeopleEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<AttendeePeopleEdge>, Record<string, never>, WithTypename<AttendeePerson> | string>
  },
  AttendeePerson?: {
    createdAt?: GraphCacheResolver<WithTypename<AttendeePerson>, Record<string, never>, Scalars['Datetime'] | string>,
    id?: GraphCacheResolver<WithTypename<AttendeePerson>, Record<string, never>, Scalars['BigInt'] | string>,
    list?: GraphCacheResolver<WithTypename<AttendeePerson>, Record<string, never>, WithTypename<AttendeeList> | string>,
    listId?: GraphCacheResolver<WithTypename<AttendeePerson>, Record<string, never>, Scalars['BigInt'] | string>,
    person?: GraphCacheResolver<WithTypename<AttendeePerson>, Record<string, never>, WithTypename<Person> | string>,
    personId?: GraphCacheResolver<WithTypename<AttendeePerson>, Record<string, never>, Scalars['BigInt'] | string>,
    tenant?: GraphCacheResolver<WithTypename<AttendeePerson>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantId?: GraphCacheResolver<WithTypename<AttendeePerson>, Record<string, never>, Scalars['BigInt'] | string>,
    updatedAt?: GraphCacheResolver<WithTypename<AttendeePerson>, Record<string, never>, Scalars['Datetime'] | string>
  },
  AttendeeUser?: {
    birthYear?: GraphCacheResolver<WithTypename<AttendeeUser>, Record<string, never>, Scalars['Int'] | string>,
    event?: GraphCacheResolver<WithTypename<AttendeeUser>, Record<string, never>, WithTypename<Event> | string>,
    eventId?: GraphCacheResolver<WithTypename<AttendeeUser>, Record<string, never>, Scalars['BigInt'] | string>,
    id?: GraphCacheResolver<WithTypename<AttendeeUser>, Record<string, never>, Scalars['BigInt'] | string>,
    notes?: GraphCacheResolver<WithTypename<AttendeeUser>, Record<string, never>, Scalars['String'] | string>,
    tenantId?: GraphCacheResolver<WithTypename<AttendeeUser>, Record<string, never>, Scalars['BigInt'] | string>,
    user?: GraphCacheResolver<WithTypename<AttendeeUser>, Record<string, never>, WithTypename<User> | string>,
    userId?: GraphCacheResolver<WithTypename<AttendeeUser>, Record<string, never>, Scalars['BigInt'] | string>
  },
  AttendeeUsersConnection?: {
    edges?: GraphCacheResolver<WithTypename<AttendeeUsersConnection>, Record<string, never>, Array<WithTypename<AttendeeUsersEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<AttendeeUsersConnection>, Record<string, never>, Array<WithTypename<AttendeeUser> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<AttendeeUsersConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<AttendeeUsersConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  AttendeeUsersEdge?: {
    cursor?: GraphCacheResolver<WithTypename<AttendeeUsersEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<AttendeeUsersEdge>, Record<string, never>, WithTypename<AttendeeUser> | string>
  },
  BookLessonPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<BookLessonPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<BookLessonPayload>, Record<string, never>, WithTypename<Query> | string>,
    rozpisItems?: GraphCacheResolver<WithTypename<BookLessonPayload>, Record<string, never>, Array<WithTypename<RozpisItem> | string>>
  },
  CancelLessonPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CancelLessonPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<CancelLessonPayload>, Record<string, never>, WithTypename<Query> | string>,
    rozpisItems?: GraphCacheResolver<WithTypename<CancelLessonPayload>, Record<string, never>, Array<WithTypename<RozpisItem> | string>>
  },
  CancelParticipationPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CancelParticipationPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<CancelParticipationPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  ChangePasswordPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<ChangePasswordPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<ChangePasswordPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  CohortGroup?: {
    description?: GraphCacheResolver<WithTypename<CohortGroup>, Record<string, never>, Scalars['String'] | string>,
    id?: GraphCacheResolver<WithTypename<CohortGroup>, Record<string, never>, Scalars['BigInt'] | string>,
    isPublic?: GraphCacheResolver<WithTypename<CohortGroup>, Record<string, never>, Scalars['Boolean'] | string>,
    name?: GraphCacheResolver<WithTypename<CohortGroup>, Record<string, never>, Scalars['String'] | string>,
    ordering?: GraphCacheResolver<WithTypename<CohortGroup>, Record<string, never>, Scalars['Int'] | string>,
    skupiniesByCohortGroup?: GraphCacheResolver<WithTypename<CohortGroup>, CohortGroupSkupiniesByCohortGroupArgs, WithTypename<SkupiniesConnection> | string>,
    tenant?: GraphCacheResolver<WithTypename<CohortGroup>, Record<string, never>, Scalars['BigInt'] | string>,
    tenantByTenant?: GraphCacheResolver<WithTypename<CohortGroup>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantId?: GraphCacheResolver<WithTypename<CohortGroup>, Record<string, never>, Scalars['BigInt'] | string>
  },
  CohortGroupsConnection?: {
    edges?: GraphCacheResolver<WithTypename<CohortGroupsConnection>, Record<string, never>, Array<WithTypename<CohortGroupsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<CohortGroupsConnection>, Record<string, never>, Array<WithTypename<CohortGroup> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<CohortGroupsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<CohortGroupsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  CohortGroupsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<CohortGroupsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<CohortGroupsEdge>, Record<string, never>, WithTypename<CohortGroup> | string>
  },
  ConfirmUserPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<ConfirmUserPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<ConfirmUserPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  Couple?: {
    attendeeCouples?: GraphCacheResolver<WithTypename<Couple>, CoupleAttendeeCouplesArgs, WithTypename<AttendeeCouplesConnection> | string>,
    createdAt?: GraphCacheResolver<WithTypename<Couple>, Record<string, never>, Scalars['Datetime'] | string>,
    follower?: GraphCacheResolver<WithTypename<Couple>, Record<string, never>, WithTypename<Person> | string>,
    followerId?: GraphCacheResolver<WithTypename<Couple>, Record<string, never>, Scalars['BigInt'] | string>,
    id?: GraphCacheResolver<WithTypename<Couple>, Record<string, never>, Scalars['BigInt'] | string>,
    leader?: GraphCacheResolver<WithTypename<Couple>, Record<string, never>, WithTypename<Person> | string>,
    leaderId?: GraphCacheResolver<WithTypename<Couple>, Record<string, never>, Scalars['BigInt'] | string>,
    since?: GraphCacheResolver<WithTypename<Couple>, Record<string, never>, Scalars['Datetime'] | string>,
    tenant?: GraphCacheResolver<WithTypename<Couple>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantId?: GraphCacheResolver<WithTypename<Couple>, Record<string, never>, Scalars['BigInt'] | string>,
    until?: GraphCacheResolver<WithTypename<Couple>, Record<string, never>, Scalars['Datetime'] | string>,
    updatedAt?: GraphCacheResolver<WithTypename<Couple>, Record<string, never>, Scalars['Datetime'] | string>
  },
  CouplesConnection?: {
    edges?: GraphCacheResolver<WithTypename<CouplesConnection>, Record<string, never>, Array<WithTypename<CouplesEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<CouplesConnection>, Record<string, never>, Array<WithTypename<Couple> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<CouplesConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<CouplesConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  CouplesEdge?: {
    cursor?: GraphCacheResolver<WithTypename<CouplesEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<CouplesEdge>, Record<string, never>, WithTypename<Couple> | string>
  },
  CreateAkceItemPayload?: {
    akceByAiIdRodic?: GraphCacheResolver<WithTypename<CreateAkceItemPayload>, Record<string, never>, WithTypename<Akce> | string>,
    akceItem?: GraphCacheResolver<WithTypename<CreateAkceItemPayload>, Record<string, never>, WithTypename<AkceItem> | string>,
    akceItemEdge?: GraphCacheResolver<WithTypename<CreateAkceItemPayload>, CreateAkceItemPayloadAkceItemEdgeArgs, WithTypename<AkceItemsEdge> | string>,
    clientMutationId?: GraphCacheResolver<WithTypename<CreateAkceItemPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<CreateAkceItemPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByAiUser?: GraphCacheResolver<WithTypename<CreateAkceItemPayload>, Record<string, never>, WithTypename<User> | string>
  },
  CreateAkcePayload?: {
    akce?: GraphCacheResolver<WithTypename<CreateAkcePayload>, Record<string, never>, WithTypename<Akce> | string>,
    akceEdge?: GraphCacheResolver<WithTypename<CreateAkcePayload>, CreateAkcePayloadAkceEdgeArgs, WithTypename<AkcesEdge> | string>,
    clientMutationId?: GraphCacheResolver<WithTypename<CreateAkcePayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<CreateAkcePayload>, Record<string, never>, WithTypename<Query> | string>
  },
  CreateAktualityPayload?: {
    aktuality?: GraphCacheResolver<WithTypename<CreateAktualityPayload>, Record<string, never>, WithTypename<Aktuality> | string>,
    aktualityEdge?: GraphCacheResolver<WithTypename<CreateAktualityPayload>, CreateAktualityPayloadAktualityEdgeArgs, WithTypename<AktualitiesEdge> | string>,
    clientMutationId?: GraphCacheResolver<WithTypename<CreateAktualityPayload>, Record<string, never>, Scalars['String'] | string>,
    galerieFotoByAtFotoMain?: GraphCacheResolver<WithTypename<CreateAktualityPayload>, Record<string, never>, WithTypename<GalerieFoto> | string>,
    query?: GraphCacheResolver<WithTypename<CreateAktualityPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByAtKdo?: GraphCacheResolver<WithTypename<CreateAktualityPayload>, Record<string, never>, WithTypename<User> | string>
  },
  CreateAttachmentPayload?: {
    attachment?: GraphCacheResolver<WithTypename<CreateAttachmentPayload>, Record<string, never>, WithTypename<Attachment> | string>,
    attachmentEdge?: GraphCacheResolver<WithTypename<CreateAttachmentPayload>, CreateAttachmentPayloadAttachmentEdgeArgs, WithTypename<AttachmentsEdge> | string>,
    clientMutationId?: GraphCacheResolver<WithTypename<CreateAttachmentPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<CreateAttachmentPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByUploadedBy?: GraphCacheResolver<WithTypename<CreateAttachmentPayload>, Record<string, never>, WithTypename<User> | string>
  },
  CreateAttendeeExternalPayload?: {
    attendeeExternal?: GraphCacheResolver<WithTypename<CreateAttendeeExternalPayload>, Record<string, never>, WithTypename<AttendeeExternal> | string>,
    attendeeExternalEdge?: GraphCacheResolver<WithTypename<CreateAttendeeExternalPayload>, CreateAttendeeExternalPayloadAttendeeExternalEdgeArgs, WithTypename<AttendeeExternalsEdge> | string>,
    clientMutationId?: GraphCacheResolver<WithTypename<CreateAttendeeExternalPayload>, Record<string, never>, Scalars['String'] | string>,
    event?: GraphCacheResolver<WithTypename<CreateAttendeeExternalPayload>, Record<string, never>, WithTypename<Event> | string>,
    query?: GraphCacheResolver<WithTypename<CreateAttendeeExternalPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByConfirmedBy?: GraphCacheResolver<WithTypename<CreateAttendeeExternalPayload>, Record<string, never>, WithTypename<User> | string>,
    userByManagedBy?: GraphCacheResolver<WithTypename<CreateAttendeeExternalPayload>, Record<string, never>, WithTypename<User> | string>
  },
  CreateAttendeeUserPayload?: {
    attendeeUser?: GraphCacheResolver<WithTypename<CreateAttendeeUserPayload>, Record<string, never>, WithTypename<AttendeeUser> | string>,
    attendeeUserEdge?: GraphCacheResolver<WithTypename<CreateAttendeeUserPayload>, CreateAttendeeUserPayloadAttendeeUserEdgeArgs, WithTypename<AttendeeUsersEdge> | string>,
    clientMutationId?: GraphCacheResolver<WithTypename<CreateAttendeeUserPayload>, Record<string, never>, Scalars['String'] | string>,
    event?: GraphCacheResolver<WithTypename<CreateAttendeeUserPayload>, Record<string, never>, WithTypename<Event> | string>,
    query?: GraphCacheResolver<WithTypename<CreateAttendeeUserPayload>, Record<string, never>, WithTypename<Query> | string>,
    user?: GraphCacheResolver<WithTypename<CreateAttendeeUserPayload>, Record<string, never>, WithTypename<User> | string>
  },
  CreateCohortGroupPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateCohortGroupPayload>, Record<string, never>, Scalars['String'] | string>,
    cohortGroup?: GraphCacheResolver<WithTypename<CreateCohortGroupPayload>, Record<string, never>, WithTypename<CohortGroup> | string>,
    cohortGroupEdge?: GraphCacheResolver<WithTypename<CreateCohortGroupPayload>, CreateCohortGroupPayloadCohortGroupEdgeArgs, WithTypename<CohortGroupsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<CreateCohortGroupPayload>, Record<string, never>, WithTypename<Query> | string>,
    tenantByTenant?: GraphCacheResolver<WithTypename<CreateCohortGroupPayload>, Record<string, never>, WithTypename<Tenant> | string>
  },
  CreateCouplePayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateCouplePayload>, Record<string, never>, Scalars['String'] | string>,
    paries?: GraphCacheResolver<WithTypename<CreateCouplePayload>, Record<string, never>, Array<WithTypename<Pary> | string>>,
    query?: GraphCacheResolver<WithTypename<CreateCouplePayload>, Record<string, never>, WithTypename<Query> | string>
  },
  CreateDokumentyPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateDokumentyPayload>, Record<string, never>, Scalars['String'] | string>,
    dokumenty?: GraphCacheResolver<WithTypename<CreateDokumentyPayload>, Record<string, never>, WithTypename<Dokumenty> | string>,
    dokumentyEdge?: GraphCacheResolver<WithTypename<CreateDokumentyPayload>, CreateDokumentyPayloadDokumentyEdgeArgs, WithTypename<DokumentiesEdge> | string>,
    query?: GraphCacheResolver<WithTypename<CreateDokumentyPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByDKdo?: GraphCacheResolver<WithTypename<CreateDokumentyPayload>, Record<string, never>, WithTypename<User> | string>
  },
  CreateEventPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateEventPayload>, Record<string, never>, Scalars['String'] | string>,
    event?: GraphCacheResolver<WithTypename<CreateEventPayload>, Record<string, never>, WithTypename<Event> | string>,
    eventEdge?: GraphCacheResolver<WithTypename<CreateEventPayload>, CreateEventPayloadEventEdgeArgs, WithTypename<EventsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<CreateEventPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  CreateFormResponsePayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateFormResponsePayload>, Record<string, never>, Scalars['String'] | string>,
    formResponse?: GraphCacheResolver<WithTypename<CreateFormResponsePayload>, Record<string, never>, WithTypename<FormResponse> | string>,
    formResponseEdge?: GraphCacheResolver<WithTypename<CreateFormResponsePayload>, CreateFormResponsePayloadFormResponseEdgeArgs, WithTypename<FormResponsesEdge> | string>,
    query?: GraphCacheResolver<WithTypename<CreateFormResponsePayload>, Record<string, never>, WithTypename<Query> | string>
  },
  CreateGalerieDirPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateGalerieDirPayload>, Record<string, never>, Scalars['String'] | string>,
    galerieDir?: GraphCacheResolver<WithTypename<CreateGalerieDirPayload>, Record<string, never>, WithTypename<GalerieDir> | string>,
    galerieDirEdge?: GraphCacheResolver<WithTypename<CreateGalerieDirPayload>, CreateGalerieDirPayloadGalerieDirEdgeArgs, WithTypename<GalerieDirsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<CreateGalerieDirPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  CreateGalerieFotoPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateGalerieFotoPayload>, Record<string, never>, Scalars['String'] | string>,
    galerieDirByGfIdRodic?: GraphCacheResolver<WithTypename<CreateGalerieFotoPayload>, Record<string, never>, WithTypename<GalerieDir> | string>,
    galerieFoto?: GraphCacheResolver<WithTypename<CreateGalerieFotoPayload>, Record<string, never>, WithTypename<GalerieFoto> | string>,
    galerieFotoEdge?: GraphCacheResolver<WithTypename<CreateGalerieFotoPayload>, CreateGalerieFotoPayloadGalerieFotoEdgeArgs, WithTypename<GalerieFotosEdge> | string>,
    query?: GraphCacheResolver<WithTypename<CreateGalerieFotoPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByGfKdo?: GraphCacheResolver<WithTypename<CreateGalerieFotoPayload>, Record<string, never>, WithTypename<User> | string>
  },
  CreateLocationAttachmentPayload?: {
    attachmentByObjectName?: GraphCacheResolver<WithTypename<CreateLocationAttachmentPayload>, Record<string, never>, WithTypename<Attachment> | string>,
    clientMutationId?: GraphCacheResolver<WithTypename<CreateLocationAttachmentPayload>, Record<string, never>, Scalars['String'] | string>,
    location?: GraphCacheResolver<WithTypename<CreateLocationAttachmentPayload>, Record<string, never>, WithTypename<Location> | string>,
    locationAttachment?: GraphCacheResolver<WithTypename<CreateLocationAttachmentPayload>, Record<string, never>, WithTypename<LocationAttachment> | string>,
    locationAttachmentEdge?: GraphCacheResolver<WithTypename<CreateLocationAttachmentPayload>, CreateLocationAttachmentPayloadLocationAttachmentEdgeArgs, WithTypename<LocationAttachmentsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<CreateLocationAttachmentPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  CreateLocationPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateLocationPayload>, Record<string, never>, Scalars['String'] | string>,
    location?: GraphCacheResolver<WithTypename<CreateLocationPayload>, Record<string, never>, WithTypename<Location> | string>,
    locationEdge?: GraphCacheResolver<WithTypename<CreateLocationPayload>, CreateLocationPayloadLocationEdgeArgs, WithTypename<LocationsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<CreateLocationPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  CreateNabidkaItemPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateNabidkaItemPayload>, Record<string, never>, Scalars['String'] | string>,
    nabidkaByNiIdRodic?: GraphCacheResolver<WithTypename<CreateNabidkaItemPayload>, Record<string, never>, WithTypename<Nabidka> | string>,
    nabidkaItem?: GraphCacheResolver<WithTypename<CreateNabidkaItemPayload>, Record<string, never>, WithTypename<NabidkaItem> | string>,
    nabidkaItemEdge?: GraphCacheResolver<WithTypename<CreateNabidkaItemPayload>, CreateNabidkaItemPayloadNabidkaItemEdgeArgs, WithTypename<NabidkaItemsEdge> | string>,
    paryByNiPartner?: GraphCacheResolver<WithTypename<CreateNabidkaItemPayload>, Record<string, never>, WithTypename<Pary> | string>,
    query?: GraphCacheResolver<WithTypename<CreateNabidkaItemPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  CreateNabidkaPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateNabidkaPayload>, Record<string, never>, Scalars['String'] | string>,
    nabidka?: GraphCacheResolver<WithTypename<CreateNabidkaPayload>, Record<string, never>, WithTypename<Nabidka> | string>,
    nabidkaEdge?: GraphCacheResolver<WithTypename<CreateNabidkaPayload>, CreateNabidkaPayloadNabidkaEdgeArgs, WithTypename<NabidkasEdge> | string>,
    query?: GraphCacheResolver<WithTypename<CreateNabidkaPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByNTrener?: GraphCacheResolver<WithTypename<CreateNabidkaPayload>, Record<string, never>, WithTypename<User> | string>
  },
  CreatePagePayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreatePagePayload>, Record<string, never>, Scalars['String'] | string>,
    page?: GraphCacheResolver<WithTypename<CreatePagePayload>, Record<string, never>, WithTypename<Page> | string>,
    pageEdge?: GraphCacheResolver<WithTypename<CreatePagePayload>, CreatePagePayloadPageEdgeArgs, WithTypename<PagesEdge> | string>,
    query?: GraphCacheResolver<WithTypename<CreatePagePayload>, Record<string, never>, WithTypename<Query> | string>
  },
  CreateParameterPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateParameterPayload>, Record<string, never>, Scalars['String'] | string>,
    parameter?: GraphCacheResolver<WithTypename<CreateParameterPayload>, Record<string, never>, WithTypename<Parameter> | string>,
    parameterEdge?: GraphCacheResolver<WithTypename<CreateParameterPayload>, CreateParameterPayloadParameterEdgeArgs, WithTypename<ParametersEdge> | string>,
    query?: GraphCacheResolver<WithTypename<CreateParameterPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  CreateParticipationExternalPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateParticipationExternalPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<CreateParticipationExternalPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  CreateParticipationPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateParticipationPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<CreateParticipationPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  CreateParyNavrhPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateParyNavrhPayload>, Record<string, never>, Scalars['String'] | string>,
    paryNavrh?: GraphCacheResolver<WithTypename<CreateParyNavrhPayload>, Record<string, never>, WithTypename<ParyNavrh> | string>,
    paryNavrhEdge?: GraphCacheResolver<WithTypename<CreateParyNavrhPayload>, CreateParyNavrhPayloadParyNavrhEdgeArgs, WithTypename<ParyNavrhsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<CreateParyNavrhPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByPnNavrhl?: GraphCacheResolver<WithTypename<CreateParyNavrhPayload>, Record<string, never>, WithTypename<User> | string>,
    userByPnPartner?: GraphCacheResolver<WithTypename<CreateParyNavrhPayload>, Record<string, never>, WithTypename<User> | string>,
    userByPnPartnerka?: GraphCacheResolver<WithTypename<CreateParyNavrhPayload>, Record<string, never>, WithTypename<User> | string>
  },
  CreateParyPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateParyPayload>, Record<string, never>, Scalars['String'] | string>,
    pary?: GraphCacheResolver<WithTypename<CreateParyPayload>, Record<string, never>, WithTypename<Pary> | string>,
    paryEdge?: GraphCacheResolver<WithTypename<CreateParyPayload>, CreateParyPayloadParyEdgeArgs, WithTypename<PariesEdge> | string>,
    query?: GraphCacheResolver<WithTypename<CreateParyPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByPIdPartner?: GraphCacheResolver<WithTypename<CreateParyPayload>, Record<string, never>, WithTypename<User> | string>,
    userByPIdPartnerka?: GraphCacheResolver<WithTypename<CreateParyPayload>, Record<string, never>, WithTypename<User> | string>
  },
  CreatePermissionPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreatePermissionPayload>, Record<string, never>, Scalars['String'] | string>,
    permission?: GraphCacheResolver<WithTypename<CreatePermissionPayload>, Record<string, never>, WithTypename<Permission> | string>,
    permissionEdge?: GraphCacheResolver<WithTypename<CreatePermissionPayload>, CreatePermissionPayloadPermissionEdgeArgs, WithTypename<PermissionsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<CreatePermissionPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  CreatePersonPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreatePersonPayload>, Record<string, never>, Scalars['String'] | string>,
    person?: GraphCacheResolver<WithTypename<CreatePersonPayload>, Record<string, never>, WithTypename<Person> | string>,
    personEdge?: GraphCacheResolver<WithTypename<CreatePersonPayload>, CreatePersonPayloadPersonEdgeArgs, WithTypename<PeopleEdge> | string>,
    query?: GraphCacheResolver<WithTypename<CreatePersonPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  CreatePlatbyCategoryGroupPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreatePlatbyCategoryGroupPayload>, Record<string, never>, Scalars['String'] | string>,
    platbyCategoryByPcgIdCategory?: GraphCacheResolver<WithTypename<CreatePlatbyCategoryGroupPayload>, Record<string, never>, WithTypename<PlatbyCategory> | string>,
    platbyCategoryGroup?: GraphCacheResolver<WithTypename<CreatePlatbyCategoryGroupPayload>, Record<string, never>, WithTypename<PlatbyCategoryGroup> | string>,
    platbyCategoryGroupEdge?: GraphCacheResolver<WithTypename<CreatePlatbyCategoryGroupPayload>, CreatePlatbyCategoryGroupPayloadPlatbyCategoryGroupEdgeArgs, WithTypename<PlatbyCategoryGroupsEdge> | string>,
    platbyGroupByPcgIdGroup?: GraphCacheResolver<WithTypename<CreatePlatbyCategoryGroupPayload>, Record<string, never>, WithTypename<PlatbyGroup> | string>,
    query?: GraphCacheResolver<WithTypename<CreatePlatbyCategoryGroupPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  CreatePlatbyCategoryPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreatePlatbyCategoryPayload>, Record<string, never>, Scalars['String'] | string>,
    platbyCategory?: GraphCacheResolver<WithTypename<CreatePlatbyCategoryPayload>, Record<string, never>, WithTypename<PlatbyCategory> | string>,
    platbyCategoryEdge?: GraphCacheResolver<WithTypename<CreatePlatbyCategoryPayload>, CreatePlatbyCategoryPayloadPlatbyCategoryEdgeArgs, WithTypename<PlatbyCategoriesEdge> | string>,
    query?: GraphCacheResolver<WithTypename<CreatePlatbyCategoryPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  CreatePlatbyGroupPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreatePlatbyGroupPayload>, Record<string, never>, Scalars['String'] | string>,
    platbyGroup?: GraphCacheResolver<WithTypename<CreatePlatbyGroupPayload>, Record<string, never>, WithTypename<PlatbyGroup> | string>,
    platbyGroupEdge?: GraphCacheResolver<WithTypename<CreatePlatbyGroupPayload>, CreatePlatbyGroupPayloadPlatbyGroupEdgeArgs, WithTypename<PlatbyGroupsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<CreatePlatbyGroupPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  CreatePlatbyGroupSkupinaPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreatePlatbyGroupSkupinaPayload>, Record<string, never>, Scalars['String'] | string>,
    platbyGroupByPgsIdGroup?: GraphCacheResolver<WithTypename<CreatePlatbyGroupSkupinaPayload>, Record<string, never>, WithTypename<PlatbyGroup> | string>,
    platbyGroupSkupina?: GraphCacheResolver<WithTypename<CreatePlatbyGroupSkupinaPayload>, Record<string, never>, WithTypename<PlatbyGroupSkupina> | string>,
    platbyGroupSkupinaEdge?: GraphCacheResolver<WithTypename<CreatePlatbyGroupSkupinaPayload>, CreatePlatbyGroupSkupinaPayloadPlatbyGroupSkupinaEdgeArgs, WithTypename<PlatbyGroupSkupinasEdge> | string>,
    query?: GraphCacheResolver<WithTypename<CreatePlatbyGroupSkupinaPayload>, Record<string, never>, WithTypename<Query> | string>,
    skupinyByPgsIdSkupina?: GraphCacheResolver<WithTypename<CreatePlatbyGroupSkupinaPayload>, Record<string, never>, WithTypename<Skupiny> | string>
  },
  CreatePlatbyItemPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreatePlatbyItemPayload>, Record<string, never>, Scalars['String'] | string>,
    platbyCategoryByPiIdCategory?: GraphCacheResolver<WithTypename<CreatePlatbyItemPayload>, Record<string, never>, WithTypename<PlatbyCategory> | string>,
    platbyItem?: GraphCacheResolver<WithTypename<CreatePlatbyItemPayload>, Record<string, never>, WithTypename<PlatbyItem> | string>,
    platbyItemEdge?: GraphCacheResolver<WithTypename<CreatePlatbyItemPayload>, CreatePlatbyItemPayloadPlatbyItemEdgeArgs, WithTypename<PlatbyItemsEdge> | string>,
    platbyRawByPiIdRaw?: GraphCacheResolver<WithTypename<CreatePlatbyItemPayload>, Record<string, never>, WithTypename<PlatbyRaw> | string>,
    query?: GraphCacheResolver<WithTypename<CreatePlatbyItemPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByPiIdUser?: GraphCacheResolver<WithTypename<CreatePlatbyItemPayload>, Record<string, never>, WithTypename<User> | string>
  },
  CreatePlatbyRawPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreatePlatbyRawPayload>, Record<string, never>, Scalars['String'] | string>,
    platbyRaw?: GraphCacheResolver<WithTypename<CreatePlatbyRawPayload>, Record<string, never>, WithTypename<PlatbyRaw> | string>,
    platbyRawEdge?: GraphCacheResolver<WithTypename<CreatePlatbyRawPayload>, CreatePlatbyRawPayloadPlatbyRawEdgeArgs, WithTypename<PlatbyRawsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<CreatePlatbyRawPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  CreateRoomAttachmentPayload?: {
    attachmentByObjectName?: GraphCacheResolver<WithTypename<CreateRoomAttachmentPayload>, Record<string, never>, WithTypename<Attachment> | string>,
    clientMutationId?: GraphCacheResolver<WithTypename<CreateRoomAttachmentPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<CreateRoomAttachmentPayload>, Record<string, never>, WithTypename<Query> | string>,
    room?: GraphCacheResolver<WithTypename<CreateRoomAttachmentPayload>, Record<string, never>, WithTypename<Room> | string>,
    roomAttachment?: GraphCacheResolver<WithTypename<CreateRoomAttachmentPayload>, Record<string, never>, WithTypename<RoomAttachment> | string>,
    roomAttachmentEdge?: GraphCacheResolver<WithTypename<CreateRoomAttachmentPayload>, CreateRoomAttachmentPayloadRoomAttachmentEdgeArgs, WithTypename<RoomAttachmentsEdge> | string>
  },
  CreateRoomPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateRoomPayload>, Record<string, never>, Scalars['String'] | string>,
    locationByLocation?: GraphCacheResolver<WithTypename<CreateRoomPayload>, Record<string, never>, WithTypename<Location> | string>,
    query?: GraphCacheResolver<WithTypename<CreateRoomPayload>, Record<string, never>, WithTypename<Query> | string>,
    room?: GraphCacheResolver<WithTypename<CreateRoomPayload>, Record<string, never>, WithTypename<Room> | string>,
    roomEdge?: GraphCacheResolver<WithTypename<CreateRoomPayload>, CreateRoomPayloadRoomEdgeArgs, WithTypename<RoomsEdge> | string>
  },
  CreateRozpiPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateRozpiPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<CreateRozpiPayload>, Record<string, never>, WithTypename<Query> | string>,
    rozpi?: GraphCacheResolver<WithTypename<CreateRozpiPayload>, Record<string, never>, WithTypename<Rozpi> | string>,
    rozpiEdge?: GraphCacheResolver<WithTypename<CreateRozpiPayload>, CreateRozpiPayloadRozpiEdgeArgs, WithTypename<RozpisEdge> | string>,
    userByRTrener?: GraphCacheResolver<WithTypename<CreateRozpiPayload>, Record<string, never>, WithTypename<User> | string>
  },
  CreateRozpisItemPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateRozpisItemPayload>, Record<string, never>, Scalars['String'] | string>,
    paryByRiPartner?: GraphCacheResolver<WithTypename<CreateRozpisItemPayload>, Record<string, never>, WithTypename<Pary> | string>,
    query?: GraphCacheResolver<WithTypename<CreateRozpisItemPayload>, Record<string, never>, WithTypename<Query> | string>,
    rozpiByRiIdRodic?: GraphCacheResolver<WithTypename<CreateRozpisItemPayload>, Record<string, never>, WithTypename<Rozpi> | string>,
    rozpisItem?: GraphCacheResolver<WithTypename<CreateRozpisItemPayload>, Record<string, never>, WithTypename<RozpisItem> | string>,
    rozpisItemEdge?: GraphCacheResolver<WithTypename<CreateRozpisItemPayload>, CreateRozpisItemPayloadRozpisItemEdgeArgs, WithTypename<RozpisItemsEdge> | string>
  },
  CreateSkupinyPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateSkupinyPayload>, Record<string, never>, Scalars['String'] | string>,
    cohortGroupByCohortGroup?: GraphCacheResolver<WithTypename<CreateSkupinyPayload>, Record<string, never>, WithTypename<CohortGroup> | string>,
    query?: GraphCacheResolver<WithTypename<CreateSkupinyPayload>, Record<string, never>, WithTypename<Query> | string>,
    skupiny?: GraphCacheResolver<WithTypename<CreateSkupinyPayload>, Record<string, never>, WithTypename<Skupiny> | string>,
    skupinyEdge?: GraphCacheResolver<WithTypename<CreateSkupinyPayload>, CreateSkupinyPayloadSkupinyEdgeArgs, WithTypename<SkupiniesEdge> | string>
  },
  CreateTenantAttachmentPayload?: {
    attachmentByObjectName?: GraphCacheResolver<WithTypename<CreateTenantAttachmentPayload>, Record<string, never>, WithTypename<Attachment> | string>,
    clientMutationId?: GraphCacheResolver<WithTypename<CreateTenantAttachmentPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<CreateTenantAttachmentPayload>, Record<string, never>, WithTypename<Query> | string>,
    tenant?: GraphCacheResolver<WithTypename<CreateTenantAttachmentPayload>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantAttachment?: GraphCacheResolver<WithTypename<CreateTenantAttachmentPayload>, Record<string, never>, WithTypename<TenantAttachment> | string>,
    tenantAttachmentEdge?: GraphCacheResolver<WithTypename<CreateTenantAttachmentPayload>, CreateTenantAttachmentPayloadTenantAttachmentEdgeArgs, WithTypename<TenantAttachmentsEdge> | string>
  },
  CreateTenantLocationPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateTenantLocationPayload>, Record<string, never>, Scalars['String'] | string>,
    location?: GraphCacheResolver<WithTypename<CreateTenantLocationPayload>, Record<string, never>, WithTypename<Location> | string>,
    query?: GraphCacheResolver<WithTypename<CreateTenantLocationPayload>, Record<string, never>, WithTypename<Query> | string>,
    tenant?: GraphCacheResolver<WithTypename<CreateTenantLocationPayload>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantLocation?: GraphCacheResolver<WithTypename<CreateTenantLocationPayload>, Record<string, never>, WithTypename<TenantLocation> | string>,
    tenantLocationEdge?: GraphCacheResolver<WithTypename<CreateTenantLocationPayload>, CreateTenantLocationPayloadTenantLocationEdgeArgs, WithTypename<TenantLocationsEdge> | string>
  },
  CreateTenantPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateTenantPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<CreateTenantPayload>, Record<string, never>, WithTypename<Query> | string>,
    tenant?: GraphCacheResolver<WithTypename<CreateTenantPayload>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantEdge?: GraphCacheResolver<WithTypename<CreateTenantPayload>, CreateTenantPayloadTenantEdgeArgs, WithTypename<TenantsEdge> | string>
  },
  CreateTenantPersonPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateTenantPersonPayload>, Record<string, never>, Scalars['String'] | string>,
    person?: GraphCacheResolver<WithTypename<CreateTenantPersonPayload>, Record<string, never>, WithTypename<Person> | string>,
    query?: GraphCacheResolver<WithTypename<CreateTenantPersonPayload>, Record<string, never>, WithTypename<Query> | string>,
    tenant?: GraphCacheResolver<WithTypename<CreateTenantPersonPayload>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantPerson?: GraphCacheResolver<WithTypename<CreateTenantPersonPayload>, Record<string, never>, WithTypename<TenantPerson> | string>,
    tenantPersonEdge?: GraphCacheResolver<WithTypename<CreateTenantPersonPayload>, CreateTenantPersonPayloadTenantPersonEdgeArgs, WithTypename<TenantPeopleEdge> | string>
  },
  CreateUpozorneniPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateUpozorneniPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<CreateUpozorneniPayload>, Record<string, never>, WithTypename<Query> | string>,
    upozorneni?: GraphCacheResolver<WithTypename<CreateUpozorneniPayload>, Record<string, never>, WithTypename<Upozorneni> | string>,
    upozorneniEdge?: GraphCacheResolver<WithTypename<CreateUpozorneniPayload>, CreateUpozorneniPayloadUpozorneniEdgeArgs, WithTypename<UpozornenisEdge> | string>,
    userByUpKdo?: GraphCacheResolver<WithTypename<CreateUpozorneniPayload>, Record<string, never>, WithTypename<User> | string>
  },
  CreateUpozorneniSkupinyPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateUpozorneniSkupinyPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<CreateUpozorneniSkupinyPayload>, Record<string, never>, WithTypename<Query> | string>,
    skupinyByUpsIdSkupina?: GraphCacheResolver<WithTypename<CreateUpozorneniSkupinyPayload>, Record<string, never>, WithTypename<Skupiny> | string>,
    upozorneniByUpsIdRodic?: GraphCacheResolver<WithTypename<CreateUpozorneniSkupinyPayload>, Record<string, never>, WithTypename<Upozorneni> | string>,
    upozorneniSkupiny?: GraphCacheResolver<WithTypename<CreateUpozorneniSkupinyPayload>, Record<string, never>, WithTypename<UpozorneniSkupiny> | string>,
    upozorneniSkupinyEdge?: GraphCacheResolver<WithTypename<CreateUpozorneniSkupinyPayload>, CreateUpozorneniSkupinyPayloadUpozorneniSkupinyEdgeArgs, WithTypename<UpozorneniSkupiniesEdge> | string>
  },
  CreateUserPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateUserPayload>, Record<string, never>, Scalars['String'] | string>,
    permissionByUGroup?: GraphCacheResolver<WithTypename<CreateUserPayload>, Record<string, never>, WithTypename<Permission> | string>,
    query?: GraphCacheResolver<WithTypename<CreateUserPayload>, Record<string, never>, WithTypename<Query> | string>,
    skupinyByUSkupina?: GraphCacheResolver<WithTypename<CreateUserPayload>, Record<string, never>, WithTypename<Skupiny> | string>,
    user?: GraphCacheResolver<WithTypename<CreateUserPayload>, Record<string, never>, WithTypename<User> | string>,
    userEdge?: GraphCacheResolver<WithTypename<CreateUserPayload>, CreateUserPayloadUserEdgeArgs, WithTypename<UsersEdge> | string>
  },
  CurrentCoupleIdEdge?: {
    cursor?: GraphCacheResolver<WithTypename<CurrentCoupleIdEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<CurrentCoupleIdEdge>, Record<string, never>, Scalars['BigInt'] | string>
  },
  CurrentCoupleIdsConnection?: {
    edges?: GraphCacheResolver<WithTypename<CurrentCoupleIdsConnection>, Record<string, never>, Array<WithTypename<CurrentCoupleIdEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<CurrentCoupleIdsConnection>, Record<string, never>, Array<Scalars['BigInt'] | string>>,
    totalCount?: GraphCacheResolver<WithTypename<CurrentCoupleIdsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  DeleteAktualityPayload?: {
    aktuality?: GraphCacheResolver<WithTypename<DeleteAktualityPayload>, Record<string, never>, WithTypename<Aktuality> | string>,
    aktualityEdge?: GraphCacheResolver<WithTypename<DeleteAktualityPayload>, DeleteAktualityPayloadAktualityEdgeArgs, WithTypename<AktualitiesEdge> | string>,
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteAktualityPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedAktualityNodeId?: GraphCacheResolver<WithTypename<DeleteAktualityPayload>, Record<string, never>, Scalars['ID'] | string>,
    galerieFotoByAtFotoMain?: GraphCacheResolver<WithTypename<DeleteAktualityPayload>, Record<string, never>, WithTypename<GalerieFoto> | string>,
    query?: GraphCacheResolver<WithTypename<DeleteAktualityPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByAtKdo?: GraphCacheResolver<WithTypename<DeleteAktualityPayload>, Record<string, never>, WithTypename<User> | string>
  },
  DeleteAttachmentPayload?: {
    attachment?: GraphCacheResolver<WithTypename<DeleteAttachmentPayload>, Record<string, never>, WithTypename<Attachment> | string>,
    attachmentEdge?: GraphCacheResolver<WithTypename<DeleteAttachmentPayload>, DeleteAttachmentPayloadAttachmentEdgeArgs, WithTypename<AttachmentsEdge> | string>,
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteAttachmentPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedAttachmentNodeId?: GraphCacheResolver<WithTypename<DeleteAttachmentPayload>, Record<string, never>, Scalars['ID'] | string>,
    query?: GraphCacheResolver<WithTypename<DeleteAttachmentPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByUploadedBy?: GraphCacheResolver<WithTypename<DeleteAttachmentPayload>, Record<string, never>, WithTypename<User> | string>
  },
  DeleteAttendeeExternalPayload?: {
    attendeeExternal?: GraphCacheResolver<WithTypename<DeleteAttendeeExternalPayload>, Record<string, never>, WithTypename<AttendeeExternal> | string>,
    attendeeExternalEdge?: GraphCacheResolver<WithTypename<DeleteAttendeeExternalPayload>, DeleteAttendeeExternalPayloadAttendeeExternalEdgeArgs, WithTypename<AttendeeExternalsEdge> | string>,
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteAttendeeExternalPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedAttendeeExternalNodeId?: GraphCacheResolver<WithTypename<DeleteAttendeeExternalPayload>, Record<string, never>, Scalars['ID'] | string>,
    event?: GraphCacheResolver<WithTypename<DeleteAttendeeExternalPayload>, Record<string, never>, WithTypename<Event> | string>,
    query?: GraphCacheResolver<WithTypename<DeleteAttendeeExternalPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByConfirmedBy?: GraphCacheResolver<WithTypename<DeleteAttendeeExternalPayload>, Record<string, never>, WithTypename<User> | string>,
    userByManagedBy?: GraphCacheResolver<WithTypename<DeleteAttendeeExternalPayload>, Record<string, never>, WithTypename<User> | string>
  },
  DeleteAttendeeUserPayload?: {
    attendeeUser?: GraphCacheResolver<WithTypename<DeleteAttendeeUserPayload>, Record<string, never>, WithTypename<AttendeeUser> | string>,
    attendeeUserEdge?: GraphCacheResolver<WithTypename<DeleteAttendeeUserPayload>, DeleteAttendeeUserPayloadAttendeeUserEdgeArgs, WithTypename<AttendeeUsersEdge> | string>,
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteAttendeeUserPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedAttendeeUserNodeId?: GraphCacheResolver<WithTypename<DeleteAttendeeUserPayload>, Record<string, never>, Scalars['ID'] | string>,
    event?: GraphCacheResolver<WithTypename<DeleteAttendeeUserPayload>, Record<string, never>, WithTypename<Event> | string>,
    query?: GraphCacheResolver<WithTypename<DeleteAttendeeUserPayload>, Record<string, never>, WithTypename<Query> | string>,
    user?: GraphCacheResolver<WithTypename<DeleteAttendeeUserPayload>, Record<string, never>, WithTypename<User> | string>
  },
  DeleteCohortGroupPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteCohortGroupPayload>, Record<string, never>, Scalars['String'] | string>,
    cohortGroup?: GraphCacheResolver<WithTypename<DeleteCohortGroupPayload>, Record<string, never>, WithTypename<CohortGroup> | string>,
    cohortGroupEdge?: GraphCacheResolver<WithTypename<DeleteCohortGroupPayload>, DeleteCohortGroupPayloadCohortGroupEdgeArgs, WithTypename<CohortGroupsEdge> | string>,
    deletedCohortGroupNodeId?: GraphCacheResolver<WithTypename<DeleteCohortGroupPayload>, Record<string, never>, Scalars['ID'] | string>,
    query?: GraphCacheResolver<WithTypename<DeleteCohortGroupPayload>, Record<string, never>, WithTypename<Query> | string>,
    tenantByTenant?: GraphCacheResolver<WithTypename<DeleteCohortGroupPayload>, Record<string, never>, WithTypename<Tenant> | string>
  },
  DeleteDokumentyPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteDokumentyPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedDokumentyNodeId?: GraphCacheResolver<WithTypename<DeleteDokumentyPayload>, Record<string, never>, Scalars['ID'] | string>,
    dokumenty?: GraphCacheResolver<WithTypename<DeleteDokumentyPayload>, Record<string, never>, WithTypename<Dokumenty> | string>,
    dokumentyEdge?: GraphCacheResolver<WithTypename<DeleteDokumentyPayload>, DeleteDokumentyPayloadDokumentyEdgeArgs, WithTypename<DokumentiesEdge> | string>,
    query?: GraphCacheResolver<WithTypename<DeleteDokumentyPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByDKdo?: GraphCacheResolver<WithTypename<DeleteDokumentyPayload>, Record<string, never>, WithTypename<User> | string>
  },
  DeleteEventPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteEventPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedEventNodeId?: GraphCacheResolver<WithTypename<DeleteEventPayload>, Record<string, never>, Scalars['ID'] | string>,
    event?: GraphCacheResolver<WithTypename<DeleteEventPayload>, Record<string, never>, WithTypename<Event> | string>,
    eventEdge?: GraphCacheResolver<WithTypename<DeleteEventPayload>, DeleteEventPayloadEventEdgeArgs, WithTypename<EventsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<DeleteEventPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  DeleteFormResponsePayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteFormResponsePayload>, Record<string, never>, Scalars['String'] | string>,
    deletedFormResponseNodeId?: GraphCacheResolver<WithTypename<DeleteFormResponsePayload>, Record<string, never>, Scalars['ID'] | string>,
    formResponse?: GraphCacheResolver<WithTypename<DeleteFormResponsePayload>, Record<string, never>, WithTypename<FormResponse> | string>,
    formResponseEdge?: GraphCacheResolver<WithTypename<DeleteFormResponsePayload>, DeleteFormResponsePayloadFormResponseEdgeArgs, WithTypename<FormResponsesEdge> | string>,
    query?: GraphCacheResolver<WithTypename<DeleteFormResponsePayload>, Record<string, never>, WithTypename<Query> | string>
  },
  DeleteGalerieDirPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteGalerieDirPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedGalerieDirNodeId?: GraphCacheResolver<WithTypename<DeleteGalerieDirPayload>, Record<string, never>, Scalars['ID'] | string>,
    galerieDir?: GraphCacheResolver<WithTypename<DeleteGalerieDirPayload>, Record<string, never>, WithTypename<GalerieDir> | string>,
    galerieDirEdge?: GraphCacheResolver<WithTypename<DeleteGalerieDirPayload>, DeleteGalerieDirPayloadGalerieDirEdgeArgs, WithTypename<GalerieDirsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<DeleteGalerieDirPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  DeleteGalerieFotoPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteGalerieFotoPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedGalerieFotoNodeId?: GraphCacheResolver<WithTypename<DeleteGalerieFotoPayload>, Record<string, never>, Scalars['ID'] | string>,
    galerieDirByGfIdRodic?: GraphCacheResolver<WithTypename<DeleteGalerieFotoPayload>, Record<string, never>, WithTypename<GalerieDir> | string>,
    galerieFoto?: GraphCacheResolver<WithTypename<DeleteGalerieFotoPayload>, Record<string, never>, WithTypename<GalerieFoto> | string>,
    galerieFotoEdge?: GraphCacheResolver<WithTypename<DeleteGalerieFotoPayload>, DeleteGalerieFotoPayloadGalerieFotoEdgeArgs, WithTypename<GalerieFotosEdge> | string>,
    query?: GraphCacheResolver<WithTypename<DeleteGalerieFotoPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByGfKdo?: GraphCacheResolver<WithTypename<DeleteGalerieFotoPayload>, Record<string, never>, WithTypename<User> | string>
  },
  DeleteLocationAttachmentPayload?: {
    attachmentByObjectName?: GraphCacheResolver<WithTypename<DeleteLocationAttachmentPayload>, Record<string, never>, WithTypename<Attachment> | string>,
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteLocationAttachmentPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedLocationAttachmentNodeId?: GraphCacheResolver<WithTypename<DeleteLocationAttachmentPayload>, Record<string, never>, Scalars['ID'] | string>,
    location?: GraphCacheResolver<WithTypename<DeleteLocationAttachmentPayload>, Record<string, never>, WithTypename<Location> | string>,
    locationAttachment?: GraphCacheResolver<WithTypename<DeleteLocationAttachmentPayload>, Record<string, never>, WithTypename<LocationAttachment> | string>,
    locationAttachmentEdge?: GraphCacheResolver<WithTypename<DeleteLocationAttachmentPayload>, DeleteLocationAttachmentPayloadLocationAttachmentEdgeArgs, WithTypename<LocationAttachmentsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<DeleteLocationAttachmentPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  DeleteLocationPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteLocationPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedLocationNodeId?: GraphCacheResolver<WithTypename<DeleteLocationPayload>, Record<string, never>, Scalars['ID'] | string>,
    location?: GraphCacheResolver<WithTypename<DeleteLocationPayload>, Record<string, never>, WithTypename<Location> | string>,
    locationEdge?: GraphCacheResolver<WithTypename<DeleteLocationPayload>, DeleteLocationPayloadLocationEdgeArgs, WithTypename<LocationsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<DeleteLocationPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  DeleteNabidkaItemPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteNabidkaItemPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedNabidkaItemNodeId?: GraphCacheResolver<WithTypename<DeleteNabidkaItemPayload>, Record<string, never>, Scalars['ID'] | string>,
    nabidkaByNiIdRodic?: GraphCacheResolver<WithTypename<DeleteNabidkaItemPayload>, Record<string, never>, WithTypename<Nabidka> | string>,
    nabidkaItem?: GraphCacheResolver<WithTypename<DeleteNabidkaItemPayload>, Record<string, never>, WithTypename<NabidkaItem> | string>,
    nabidkaItemEdge?: GraphCacheResolver<WithTypename<DeleteNabidkaItemPayload>, DeleteNabidkaItemPayloadNabidkaItemEdgeArgs, WithTypename<NabidkaItemsEdge> | string>,
    paryByNiPartner?: GraphCacheResolver<WithTypename<DeleteNabidkaItemPayload>, Record<string, never>, WithTypename<Pary> | string>,
    query?: GraphCacheResolver<WithTypename<DeleteNabidkaItemPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  DeleteNabidkaPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteNabidkaPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedNabidkaNodeId?: GraphCacheResolver<WithTypename<DeleteNabidkaPayload>, Record<string, never>, Scalars['ID'] | string>,
    nabidka?: GraphCacheResolver<WithTypename<DeleteNabidkaPayload>, Record<string, never>, WithTypename<Nabidka> | string>,
    nabidkaEdge?: GraphCacheResolver<WithTypename<DeleteNabidkaPayload>, DeleteNabidkaPayloadNabidkaEdgeArgs, WithTypename<NabidkasEdge> | string>,
    query?: GraphCacheResolver<WithTypename<DeleteNabidkaPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByNTrener?: GraphCacheResolver<WithTypename<DeleteNabidkaPayload>, Record<string, never>, WithTypename<User> | string>
  },
  DeleteParameterPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteParameterPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedParameterNodeId?: GraphCacheResolver<WithTypename<DeleteParameterPayload>, Record<string, never>, Scalars['ID'] | string>,
    parameter?: GraphCacheResolver<WithTypename<DeleteParameterPayload>, Record<string, never>, WithTypename<Parameter> | string>,
    parameterEdge?: GraphCacheResolver<WithTypename<DeleteParameterPayload>, DeleteParameterPayloadParameterEdgeArgs, WithTypename<ParametersEdge> | string>,
    query?: GraphCacheResolver<WithTypename<DeleteParameterPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  DeleteParyNavrhPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteParyNavrhPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedParyNavrhNodeId?: GraphCacheResolver<WithTypename<DeleteParyNavrhPayload>, Record<string, never>, Scalars['ID'] | string>,
    paryNavrh?: GraphCacheResolver<WithTypename<DeleteParyNavrhPayload>, Record<string, never>, WithTypename<ParyNavrh> | string>,
    paryNavrhEdge?: GraphCacheResolver<WithTypename<DeleteParyNavrhPayload>, DeleteParyNavrhPayloadParyNavrhEdgeArgs, WithTypename<ParyNavrhsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<DeleteParyNavrhPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByPnNavrhl?: GraphCacheResolver<WithTypename<DeleteParyNavrhPayload>, Record<string, never>, WithTypename<User> | string>,
    userByPnPartner?: GraphCacheResolver<WithTypename<DeleteParyNavrhPayload>, Record<string, never>, WithTypename<User> | string>,
    userByPnPartnerka?: GraphCacheResolver<WithTypename<DeleteParyNavrhPayload>, Record<string, never>, WithTypename<User> | string>
  },
  DeleteParyPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteParyPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedParyNodeId?: GraphCacheResolver<WithTypename<DeleteParyPayload>, Record<string, never>, Scalars['ID'] | string>,
    pary?: GraphCacheResolver<WithTypename<DeleteParyPayload>, Record<string, never>, WithTypename<Pary> | string>,
    paryEdge?: GraphCacheResolver<WithTypename<DeleteParyPayload>, DeleteParyPayloadParyEdgeArgs, WithTypename<PariesEdge> | string>,
    query?: GraphCacheResolver<WithTypename<DeleteParyPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByPIdPartner?: GraphCacheResolver<WithTypename<DeleteParyPayload>, Record<string, never>, WithTypename<User> | string>,
    userByPIdPartnerka?: GraphCacheResolver<WithTypename<DeleteParyPayload>, Record<string, never>, WithTypename<User> | string>
  },
  DeletePermissionPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeletePermissionPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedPermissionNodeId?: GraphCacheResolver<WithTypename<DeletePermissionPayload>, Record<string, never>, Scalars['ID'] | string>,
    permission?: GraphCacheResolver<WithTypename<DeletePermissionPayload>, Record<string, never>, WithTypename<Permission> | string>,
    permissionEdge?: GraphCacheResolver<WithTypename<DeletePermissionPayload>, DeletePermissionPayloadPermissionEdgeArgs, WithTypename<PermissionsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<DeletePermissionPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  DeletePersonPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeletePersonPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedPersonNodeId?: GraphCacheResolver<WithTypename<DeletePersonPayload>, Record<string, never>, Scalars['ID'] | string>,
    person?: GraphCacheResolver<WithTypename<DeletePersonPayload>, Record<string, never>, WithTypename<Person> | string>,
    personEdge?: GraphCacheResolver<WithTypename<DeletePersonPayload>, DeletePersonPayloadPersonEdgeArgs, WithTypename<PeopleEdge> | string>,
    query?: GraphCacheResolver<WithTypename<DeletePersonPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  DeletePlatbyCategoryGroupPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeletePlatbyCategoryGroupPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedPlatbyCategoryGroupNodeId?: GraphCacheResolver<WithTypename<DeletePlatbyCategoryGroupPayload>, Record<string, never>, Scalars['ID'] | string>,
    platbyCategoryByPcgIdCategory?: GraphCacheResolver<WithTypename<DeletePlatbyCategoryGroupPayload>, Record<string, never>, WithTypename<PlatbyCategory> | string>,
    platbyCategoryGroup?: GraphCacheResolver<WithTypename<DeletePlatbyCategoryGroupPayload>, Record<string, never>, WithTypename<PlatbyCategoryGroup> | string>,
    platbyCategoryGroupEdge?: GraphCacheResolver<WithTypename<DeletePlatbyCategoryGroupPayload>, DeletePlatbyCategoryGroupPayloadPlatbyCategoryGroupEdgeArgs, WithTypename<PlatbyCategoryGroupsEdge> | string>,
    platbyGroupByPcgIdGroup?: GraphCacheResolver<WithTypename<DeletePlatbyCategoryGroupPayload>, Record<string, never>, WithTypename<PlatbyGroup> | string>,
    query?: GraphCacheResolver<WithTypename<DeletePlatbyCategoryGroupPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  DeletePlatbyCategoryPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeletePlatbyCategoryPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedPlatbyCategoryNodeId?: GraphCacheResolver<WithTypename<DeletePlatbyCategoryPayload>, Record<string, never>, Scalars['ID'] | string>,
    platbyCategory?: GraphCacheResolver<WithTypename<DeletePlatbyCategoryPayload>, Record<string, never>, WithTypename<PlatbyCategory> | string>,
    platbyCategoryEdge?: GraphCacheResolver<WithTypename<DeletePlatbyCategoryPayload>, DeletePlatbyCategoryPayloadPlatbyCategoryEdgeArgs, WithTypename<PlatbyCategoriesEdge> | string>,
    query?: GraphCacheResolver<WithTypename<DeletePlatbyCategoryPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  DeletePlatbyGroupPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeletePlatbyGroupPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedPlatbyGroupNodeId?: GraphCacheResolver<WithTypename<DeletePlatbyGroupPayload>, Record<string, never>, Scalars['ID'] | string>,
    platbyGroup?: GraphCacheResolver<WithTypename<DeletePlatbyGroupPayload>, Record<string, never>, WithTypename<PlatbyGroup> | string>,
    platbyGroupEdge?: GraphCacheResolver<WithTypename<DeletePlatbyGroupPayload>, DeletePlatbyGroupPayloadPlatbyGroupEdgeArgs, WithTypename<PlatbyGroupsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<DeletePlatbyGroupPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  DeletePlatbyGroupSkupinaPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeletePlatbyGroupSkupinaPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedPlatbyGroupSkupinaNodeId?: GraphCacheResolver<WithTypename<DeletePlatbyGroupSkupinaPayload>, Record<string, never>, Scalars['ID'] | string>,
    platbyGroupByPgsIdGroup?: GraphCacheResolver<WithTypename<DeletePlatbyGroupSkupinaPayload>, Record<string, never>, WithTypename<PlatbyGroup> | string>,
    platbyGroupSkupina?: GraphCacheResolver<WithTypename<DeletePlatbyGroupSkupinaPayload>, Record<string, never>, WithTypename<PlatbyGroupSkupina> | string>,
    platbyGroupSkupinaEdge?: GraphCacheResolver<WithTypename<DeletePlatbyGroupSkupinaPayload>, DeletePlatbyGroupSkupinaPayloadPlatbyGroupSkupinaEdgeArgs, WithTypename<PlatbyGroupSkupinasEdge> | string>,
    query?: GraphCacheResolver<WithTypename<DeletePlatbyGroupSkupinaPayload>, Record<string, never>, WithTypename<Query> | string>,
    skupinyByPgsIdSkupina?: GraphCacheResolver<WithTypename<DeletePlatbyGroupSkupinaPayload>, Record<string, never>, WithTypename<Skupiny> | string>
  },
  DeletePlatbyItemPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeletePlatbyItemPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedPlatbyItemNodeId?: GraphCacheResolver<WithTypename<DeletePlatbyItemPayload>, Record<string, never>, Scalars['ID'] | string>,
    platbyCategoryByPiIdCategory?: GraphCacheResolver<WithTypename<DeletePlatbyItemPayload>, Record<string, never>, WithTypename<PlatbyCategory> | string>,
    platbyItem?: GraphCacheResolver<WithTypename<DeletePlatbyItemPayload>, Record<string, never>, WithTypename<PlatbyItem> | string>,
    platbyItemEdge?: GraphCacheResolver<WithTypename<DeletePlatbyItemPayload>, DeletePlatbyItemPayloadPlatbyItemEdgeArgs, WithTypename<PlatbyItemsEdge> | string>,
    platbyRawByPiIdRaw?: GraphCacheResolver<WithTypename<DeletePlatbyItemPayload>, Record<string, never>, WithTypename<PlatbyRaw> | string>,
    query?: GraphCacheResolver<WithTypename<DeletePlatbyItemPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByPiIdUser?: GraphCacheResolver<WithTypename<DeletePlatbyItemPayload>, Record<string, never>, WithTypename<User> | string>
  },
  DeletePlatbyRawPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeletePlatbyRawPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedPlatbyRawNodeId?: GraphCacheResolver<WithTypename<DeletePlatbyRawPayload>, Record<string, never>, Scalars['ID'] | string>,
    platbyRaw?: GraphCacheResolver<WithTypename<DeletePlatbyRawPayload>, Record<string, never>, WithTypename<PlatbyRaw> | string>,
    platbyRawEdge?: GraphCacheResolver<WithTypename<DeletePlatbyRawPayload>, DeletePlatbyRawPayloadPlatbyRawEdgeArgs, WithTypename<PlatbyRawsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<DeletePlatbyRawPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  DeleteRoomAttachmentPayload?: {
    attachmentByObjectName?: GraphCacheResolver<WithTypename<DeleteRoomAttachmentPayload>, Record<string, never>, WithTypename<Attachment> | string>,
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteRoomAttachmentPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedRoomAttachmentNodeId?: GraphCacheResolver<WithTypename<DeleteRoomAttachmentPayload>, Record<string, never>, Scalars['ID'] | string>,
    query?: GraphCacheResolver<WithTypename<DeleteRoomAttachmentPayload>, Record<string, never>, WithTypename<Query> | string>,
    room?: GraphCacheResolver<WithTypename<DeleteRoomAttachmentPayload>, Record<string, never>, WithTypename<Room> | string>,
    roomAttachment?: GraphCacheResolver<WithTypename<DeleteRoomAttachmentPayload>, Record<string, never>, WithTypename<RoomAttachment> | string>,
    roomAttachmentEdge?: GraphCacheResolver<WithTypename<DeleteRoomAttachmentPayload>, DeleteRoomAttachmentPayloadRoomAttachmentEdgeArgs, WithTypename<RoomAttachmentsEdge> | string>
  },
  DeleteRoomPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteRoomPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedRoomNodeId?: GraphCacheResolver<WithTypename<DeleteRoomPayload>, Record<string, never>, Scalars['ID'] | string>,
    locationByLocation?: GraphCacheResolver<WithTypename<DeleteRoomPayload>, Record<string, never>, WithTypename<Location> | string>,
    query?: GraphCacheResolver<WithTypename<DeleteRoomPayload>, Record<string, never>, WithTypename<Query> | string>,
    room?: GraphCacheResolver<WithTypename<DeleteRoomPayload>, Record<string, never>, WithTypename<Room> | string>,
    roomEdge?: GraphCacheResolver<WithTypename<DeleteRoomPayload>, DeleteRoomPayloadRoomEdgeArgs, WithTypename<RoomsEdge> | string>
  },
  DeleteRozpiPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteRozpiPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedRozpiNodeId?: GraphCacheResolver<WithTypename<DeleteRozpiPayload>, Record<string, never>, Scalars['ID'] | string>,
    query?: GraphCacheResolver<WithTypename<DeleteRozpiPayload>, Record<string, never>, WithTypename<Query> | string>,
    rozpi?: GraphCacheResolver<WithTypename<DeleteRozpiPayload>, Record<string, never>, WithTypename<Rozpi> | string>,
    rozpiEdge?: GraphCacheResolver<WithTypename<DeleteRozpiPayload>, DeleteRozpiPayloadRozpiEdgeArgs, WithTypename<RozpisEdge> | string>,
    userByRTrener?: GraphCacheResolver<WithTypename<DeleteRozpiPayload>, Record<string, never>, WithTypename<User> | string>
  },
  DeleteRozpisItemPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteRozpisItemPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedRozpisItemNodeId?: GraphCacheResolver<WithTypename<DeleteRozpisItemPayload>, Record<string, never>, Scalars['ID'] | string>,
    paryByRiPartner?: GraphCacheResolver<WithTypename<DeleteRozpisItemPayload>, Record<string, never>, WithTypename<Pary> | string>,
    query?: GraphCacheResolver<WithTypename<DeleteRozpisItemPayload>, Record<string, never>, WithTypename<Query> | string>,
    rozpiByRiIdRodic?: GraphCacheResolver<WithTypename<DeleteRozpisItemPayload>, Record<string, never>, WithTypename<Rozpi> | string>,
    rozpisItem?: GraphCacheResolver<WithTypename<DeleteRozpisItemPayload>, Record<string, never>, WithTypename<RozpisItem> | string>,
    rozpisItemEdge?: GraphCacheResolver<WithTypename<DeleteRozpisItemPayload>, DeleteRozpisItemPayloadRozpisItemEdgeArgs, WithTypename<RozpisItemsEdge> | string>
  },
  DeleteSkupinyPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteSkupinyPayload>, Record<string, never>, Scalars['String'] | string>,
    cohortGroupByCohortGroup?: GraphCacheResolver<WithTypename<DeleteSkupinyPayload>, Record<string, never>, WithTypename<CohortGroup> | string>,
    deletedSkupinyNodeId?: GraphCacheResolver<WithTypename<DeleteSkupinyPayload>, Record<string, never>, Scalars['ID'] | string>,
    query?: GraphCacheResolver<WithTypename<DeleteSkupinyPayload>, Record<string, never>, WithTypename<Query> | string>,
    skupiny?: GraphCacheResolver<WithTypename<DeleteSkupinyPayload>, Record<string, never>, WithTypename<Skupiny> | string>,
    skupinyEdge?: GraphCacheResolver<WithTypename<DeleteSkupinyPayload>, DeleteSkupinyPayloadSkupinyEdgeArgs, WithTypename<SkupiniesEdge> | string>
  },
  DeleteTenantAttachmentPayload?: {
    attachmentByObjectName?: GraphCacheResolver<WithTypename<DeleteTenantAttachmentPayload>, Record<string, never>, WithTypename<Attachment> | string>,
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteTenantAttachmentPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedTenantAttachmentNodeId?: GraphCacheResolver<WithTypename<DeleteTenantAttachmentPayload>, Record<string, never>, Scalars['ID'] | string>,
    query?: GraphCacheResolver<WithTypename<DeleteTenantAttachmentPayload>, Record<string, never>, WithTypename<Query> | string>,
    tenant?: GraphCacheResolver<WithTypename<DeleteTenantAttachmentPayload>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantAttachment?: GraphCacheResolver<WithTypename<DeleteTenantAttachmentPayload>, Record<string, never>, WithTypename<TenantAttachment> | string>,
    tenantAttachmentEdge?: GraphCacheResolver<WithTypename<DeleteTenantAttachmentPayload>, DeleteTenantAttachmentPayloadTenantAttachmentEdgeArgs, WithTypename<TenantAttachmentsEdge> | string>
  },
  DeleteTenantLocationPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteTenantLocationPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedTenantLocationNodeId?: GraphCacheResolver<WithTypename<DeleteTenantLocationPayload>, Record<string, never>, Scalars['ID'] | string>,
    location?: GraphCacheResolver<WithTypename<DeleteTenantLocationPayload>, Record<string, never>, WithTypename<Location> | string>,
    query?: GraphCacheResolver<WithTypename<DeleteTenantLocationPayload>, Record<string, never>, WithTypename<Query> | string>,
    tenant?: GraphCacheResolver<WithTypename<DeleteTenantLocationPayload>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantLocation?: GraphCacheResolver<WithTypename<DeleteTenantLocationPayload>, Record<string, never>, WithTypename<TenantLocation> | string>,
    tenantLocationEdge?: GraphCacheResolver<WithTypename<DeleteTenantLocationPayload>, DeleteTenantLocationPayloadTenantLocationEdgeArgs, WithTypename<TenantLocationsEdge> | string>
  },
  DeleteTenantPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteTenantPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedTenantNodeId?: GraphCacheResolver<WithTypename<DeleteTenantPayload>, Record<string, never>, Scalars['ID'] | string>,
    query?: GraphCacheResolver<WithTypename<DeleteTenantPayload>, Record<string, never>, WithTypename<Query> | string>,
    tenant?: GraphCacheResolver<WithTypename<DeleteTenantPayload>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantEdge?: GraphCacheResolver<WithTypename<DeleteTenantPayload>, DeleteTenantPayloadTenantEdgeArgs, WithTypename<TenantsEdge> | string>
  },
  DeleteTenantPersonPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteTenantPersonPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedTenantPersonNodeId?: GraphCacheResolver<WithTypename<DeleteTenantPersonPayload>, Record<string, never>, Scalars['ID'] | string>,
    person?: GraphCacheResolver<WithTypename<DeleteTenantPersonPayload>, Record<string, never>, WithTypename<Person> | string>,
    query?: GraphCacheResolver<WithTypename<DeleteTenantPersonPayload>, Record<string, never>, WithTypename<Query> | string>,
    tenant?: GraphCacheResolver<WithTypename<DeleteTenantPersonPayload>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantPerson?: GraphCacheResolver<WithTypename<DeleteTenantPersonPayload>, Record<string, never>, WithTypename<TenantPerson> | string>,
    tenantPersonEdge?: GraphCacheResolver<WithTypename<DeleteTenantPersonPayload>, DeleteTenantPersonPayloadTenantPersonEdgeArgs, WithTypename<TenantPeopleEdge> | string>
  },
  DeleteUpozorneniPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteUpozorneniPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedUpozorneniNodeId?: GraphCacheResolver<WithTypename<DeleteUpozorneniPayload>, Record<string, never>, Scalars['ID'] | string>,
    query?: GraphCacheResolver<WithTypename<DeleteUpozorneniPayload>, Record<string, never>, WithTypename<Query> | string>,
    upozorneni?: GraphCacheResolver<WithTypename<DeleteUpozorneniPayload>, Record<string, never>, WithTypename<Upozorneni> | string>,
    upozorneniEdge?: GraphCacheResolver<WithTypename<DeleteUpozorneniPayload>, DeleteUpozorneniPayloadUpozorneniEdgeArgs, WithTypename<UpozornenisEdge> | string>,
    userByUpKdo?: GraphCacheResolver<WithTypename<DeleteUpozorneniPayload>, Record<string, never>, WithTypename<User> | string>
  },
  DeleteUpozorneniSkupinyPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteUpozorneniSkupinyPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedUpozorneniSkupinyNodeId?: GraphCacheResolver<WithTypename<DeleteUpozorneniSkupinyPayload>, Record<string, never>, Scalars['ID'] | string>,
    query?: GraphCacheResolver<WithTypename<DeleteUpozorneniSkupinyPayload>, Record<string, never>, WithTypename<Query> | string>,
    skupinyByUpsIdSkupina?: GraphCacheResolver<WithTypename<DeleteUpozorneniSkupinyPayload>, Record<string, never>, WithTypename<Skupiny> | string>,
    upozorneniByUpsIdRodic?: GraphCacheResolver<WithTypename<DeleteUpozorneniSkupinyPayload>, Record<string, never>, WithTypename<Upozorneni> | string>,
    upozorneniSkupiny?: GraphCacheResolver<WithTypename<DeleteUpozorneniSkupinyPayload>, Record<string, never>, WithTypename<UpozorneniSkupiny> | string>,
    upozorneniSkupinyEdge?: GraphCacheResolver<WithTypename<DeleteUpozorneniSkupinyPayload>, DeleteUpozorneniSkupinyPayloadUpozorneniSkupinyEdgeArgs, WithTypename<UpozorneniSkupiniesEdge> | string>
  },
  DeleteUserPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteUserPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedUserNodeId?: GraphCacheResolver<WithTypename<DeleteUserPayload>, Record<string, never>, Scalars['ID'] | string>,
    permissionByUGroup?: GraphCacheResolver<WithTypename<DeleteUserPayload>, Record<string, never>, WithTypename<Permission> | string>,
    query?: GraphCacheResolver<WithTypename<DeleteUserPayload>, Record<string, never>, WithTypename<Query> | string>,
    skupinyByUSkupina?: GraphCacheResolver<WithTypename<DeleteUserPayload>, Record<string, never>, WithTypename<Skupiny> | string>,
    user?: GraphCacheResolver<WithTypename<DeleteUserPayload>, Record<string, never>, WithTypename<User> | string>,
    userEdge?: GraphCacheResolver<WithTypename<DeleteUserPayload>, DeleteUserPayloadUserEdgeArgs, WithTypename<UsersEdge> | string>
  },
  DokumentiesConnection?: {
    edges?: GraphCacheResolver<WithTypename<DokumentiesConnection>, Record<string, never>, Array<WithTypename<DokumentiesEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<DokumentiesConnection>, Record<string, never>, Array<WithTypename<Dokumenty> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<DokumentiesConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<DokumentiesConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  DokumentiesEdge?: {
    cursor?: GraphCacheResolver<WithTypename<DokumentiesEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<DokumentiesEdge>, Record<string, never>, WithTypename<Dokumenty> | string>
  },
  Dokumenty?: {
    dFilename?: GraphCacheResolver<WithTypename<Dokumenty>, Record<string, never>, Scalars['String'] | string>,
    dId?: GraphCacheResolver<WithTypename<Dokumenty>, Record<string, never>, Scalars['BigInt'] | string>,
    dKategorie?: GraphCacheResolver<WithTypename<Dokumenty>, Record<string, never>, Scalars['Int'] | string>,
    dKdo?: GraphCacheResolver<WithTypename<Dokumenty>, Record<string, never>, Scalars['BigInt'] | string>,
    dName?: GraphCacheResolver<WithTypename<Dokumenty>, Record<string, never>, Scalars['String'] | string>,
    dPath?: GraphCacheResolver<WithTypename<Dokumenty>, Record<string, never>, Scalars['String'] | string>,
    dTimestamp?: GraphCacheResolver<WithTypename<Dokumenty>, Record<string, never>, Scalars['Datetime'] | string>,
    id?: GraphCacheResolver<WithTypename<Dokumenty>, Record<string, never>, Scalars['BigInt'] | string>,
    tenantId?: GraphCacheResolver<WithTypename<Dokumenty>, Record<string, never>, Scalars['BigInt'] | string>,
    userByDKdo?: GraphCacheResolver<WithTypename<Dokumenty>, Record<string, never>, WithTypename<User> | string>
  },
  Event?: {
    attendeeExternals?: GraphCacheResolver<WithTypename<Event>, EventAttendeeExternalsArgs, WithTypename<AttendeeExternalsConnection> | string>,
    attendeeUsers?: GraphCacheResolver<WithTypename<Event>, EventAttendeeUsersArgs, WithTypename<AttendeeUsersConnection> | string>,
    capacity?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['BigInt'] | string>,
    description?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['String'] | string>,
    descriptionMember?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['String'] | string>,
    enableNotes?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['Boolean'] | string>,
    filesLegacy?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['String'] | string>,
    id?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['BigInt'] | string>,
    isFuture?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['Boolean'] | string>,
    isLocked?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['Boolean'] | string>,
    isPublic?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['Boolean'] | string>,
    isVisible?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['Boolean'] | string>,
    locationText?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['String'] | string>,
    name?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['String'] | string>,
    remainingSpots?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['Int'] | string>,
    since?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['Date'] | string>,
    summary?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['String'] | string>,
    tenantId?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['BigInt'] | string>,
    titleImageLegacy?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['String'] | string>,
    type?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, EventType | string>,
    until?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['Date'] | string>,
    updatedAt?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['Datetime'] | string>
  },
  EventsConnection?: {
    edges?: GraphCacheResolver<WithTypename<EventsConnection>, Record<string, never>, Array<WithTypename<EventsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<EventsConnection>, Record<string, never>, Array<WithTypename<Event> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<EventsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<EventsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  EventsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<EventsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<EventsEdge>, Record<string, never>, WithTypename<Event> | string>
  },
  FixUnpairedCouplesPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<FixUnpairedCouplesPayload>, Record<string, never>, Scalars['String'] | string>,
    paries?: GraphCacheResolver<WithTypename<FixUnpairedCouplesPayload>, Record<string, never>, Array<WithTypename<Pary> | string>>,
    query?: GraphCacheResolver<WithTypename<FixUnpairedCouplesPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  FormResponse?: {
    createdAt?: GraphCacheResolver<WithTypename<FormResponse>, Record<string, never>, Scalars['Datetime'] | string>,
    data?: GraphCacheResolver<WithTypename<FormResponse>, Record<string, never>, Scalars['JSON'] | string>,
    id?: GraphCacheResolver<WithTypename<FormResponse>, Record<string, never>, Scalars['BigInt'] | string>,
    tenantId?: GraphCacheResolver<WithTypename<FormResponse>, Record<string, never>, Scalars['BigInt'] | string>,
    type?: GraphCacheResolver<WithTypename<FormResponse>, Record<string, never>, Scalars['String'] | string>,
    updatedAt?: GraphCacheResolver<WithTypename<FormResponse>, Record<string, never>, Scalars['Datetime'] | string>,
    url?: GraphCacheResolver<WithTypename<FormResponse>, Record<string, never>, Scalars['String'] | string>
  },
  FormResponsesConnection?: {
    edges?: GraphCacheResolver<WithTypename<FormResponsesConnection>, Record<string, never>, Array<WithTypename<FormResponsesEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<FormResponsesConnection>, Record<string, never>, Array<WithTypename<FormResponse> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<FormResponsesConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<FormResponsesConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  FormResponsesEdge?: {
    cursor?: GraphCacheResolver<WithTypename<FormResponsesEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<FormResponsesEdge>, Record<string, never>, WithTypename<FormResponse> | string>
  },
  GalerieDir?: {
    galerieFotosByGfIdRodic?: GraphCacheResolver<WithTypename<GalerieDir>, GalerieDirGalerieFotosByGfIdRodicArgs, WithTypename<GalerieFotosConnection> | string>,
    gdHidden?: GraphCacheResolver<WithTypename<GalerieDir>, Record<string, never>, Scalars['Boolean'] | string>,
    gdId?: GraphCacheResolver<WithTypename<GalerieDir>, Record<string, never>, Scalars['BigInt'] | string>,
    gdIdRodic?: GraphCacheResolver<WithTypename<GalerieDir>, Record<string, never>, Scalars['BigInt'] | string>,
    gdLevel?: GraphCacheResolver<WithTypename<GalerieDir>, Record<string, never>, Scalars['Int'] | string>,
    gdName?: GraphCacheResolver<WithTypename<GalerieDir>, Record<string, never>, Scalars['String'] | string>,
    gdPath?: GraphCacheResolver<WithTypename<GalerieDir>, Record<string, never>, Scalars['String'] | string>,
    id?: GraphCacheResolver<WithTypename<GalerieDir>, Record<string, never>, Scalars['BigInt'] | string>,
    tenantId?: GraphCacheResolver<WithTypename<GalerieDir>, Record<string, never>, Scalars['BigInt'] | string>
  },
  GalerieDirsConnection?: {
    edges?: GraphCacheResolver<WithTypename<GalerieDirsConnection>, Record<string, never>, Array<WithTypename<GalerieDirsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<GalerieDirsConnection>, Record<string, never>, Array<WithTypename<GalerieDir> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<GalerieDirsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<GalerieDirsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  GalerieDirsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<GalerieDirsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<GalerieDirsEdge>, Record<string, never>, WithTypename<GalerieDir> | string>
  },
  GalerieFoto?: {
    aktualitiesByAtFotoMain?: GraphCacheResolver<WithTypename<GalerieFoto>, GalerieFotoAktualitiesByAtFotoMainArgs, WithTypename<AktualitiesConnection> | string>,
    galerieDirByGfIdRodic?: GraphCacheResolver<WithTypename<GalerieFoto>, Record<string, never>, WithTypename<GalerieDir> | string>,
    gfId?: GraphCacheResolver<WithTypename<GalerieFoto>, Record<string, never>, Scalars['BigInt'] | string>,
    gfIdRodic?: GraphCacheResolver<WithTypename<GalerieFoto>, Record<string, never>, Scalars['BigInt'] | string>,
    gfKdo?: GraphCacheResolver<WithTypename<GalerieFoto>, Record<string, never>, Scalars['BigInt'] | string>,
    gfName?: GraphCacheResolver<WithTypename<GalerieFoto>, Record<string, never>, Scalars['String'] | string>,
    gfPath?: GraphCacheResolver<WithTypename<GalerieFoto>, Record<string, never>, Scalars['String'] | string>,
    gfTimestamp?: GraphCacheResolver<WithTypename<GalerieFoto>, Record<string, never>, Scalars['Datetime'] | string>,
    id?: GraphCacheResolver<WithTypename<GalerieFoto>, Record<string, never>, Scalars['BigInt'] | string>,
    tenantId?: GraphCacheResolver<WithTypename<GalerieFoto>, Record<string, never>, Scalars['BigInt'] | string>,
    userByGfKdo?: GraphCacheResolver<WithTypename<GalerieFoto>, Record<string, never>, WithTypename<User> | string>
  },
  GalerieFotosConnection?: {
    edges?: GraphCacheResolver<WithTypename<GalerieFotosConnection>, Record<string, never>, Array<WithTypename<GalerieFotosEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<GalerieFotosConnection>, Record<string, never>, Array<WithTypename<GalerieFoto> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<GalerieFotosConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<GalerieFotosConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  GalerieFotosEdge?: {
    cursor?: GraphCacheResolver<WithTypename<GalerieFotosEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<GalerieFotosEdge>, Record<string, never>, WithTypename<GalerieFoto> | string>
  },
  Location?: {
    description?: GraphCacheResolver<WithTypename<Location>, Record<string, never>, Scalars['JSON'] | string>,
    id?: GraphCacheResolver<WithTypename<Location>, Record<string, never>, Scalars['BigInt'] | string>,
    locationAttachments?: GraphCacheResolver<WithTypename<Location>, LocationLocationAttachmentsArgs, WithTypename<LocationAttachmentsConnection> | string>,
    name?: GraphCacheResolver<WithTypename<Location>, Record<string, never>, Scalars['String'] | string>,
    roomsByLocation?: GraphCacheResolver<WithTypename<Location>, LocationRoomsByLocationArgs, WithTypename<RoomsConnection> | string>,
    tenantLocations?: GraphCacheResolver<WithTypename<Location>, LocationTenantLocationsArgs, WithTypename<TenantLocationsConnection> | string>
  },
  LocationAttachment?: {
    attachmentByObjectName?: GraphCacheResolver<WithTypename<LocationAttachment>, Record<string, never>, WithTypename<Attachment> | string>,
    location?: GraphCacheResolver<WithTypename<LocationAttachment>, Record<string, never>, WithTypename<Location> | string>,
    locationId?: GraphCacheResolver<WithTypename<LocationAttachment>, Record<string, never>, Scalars['BigInt'] | string>,
    objectName?: GraphCacheResolver<WithTypename<LocationAttachment>, Record<string, never>, Scalars['String'] | string>
  },
  LocationAttachmentsConnection?: {
    edges?: GraphCacheResolver<WithTypename<LocationAttachmentsConnection>, Record<string, never>, Array<WithTypename<LocationAttachmentsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<LocationAttachmentsConnection>, Record<string, never>, Array<WithTypename<LocationAttachment> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<LocationAttachmentsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<LocationAttachmentsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  LocationAttachmentsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<LocationAttachmentsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<LocationAttachmentsEdge>, Record<string, never>, WithTypename<LocationAttachment> | string>
  },
  LocationsConnection?: {
    edges?: GraphCacheResolver<WithTypename<LocationsConnection>, Record<string, never>, Array<WithTypename<LocationsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<LocationsConnection>, Record<string, never>, Array<WithTypename<Location> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<LocationsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<LocationsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  LocationsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<LocationsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<LocationsEdge>, Record<string, never>, WithTypename<Location> | string>
  },
  LoginPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<LoginPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<LoginPayload>, Record<string, never>, WithTypename<Query> | string>,
    result?: GraphCacheResolver<WithTypename<LoginPayload>, Record<string, never>, WithTypename<LoginRecord> | string>
  },
  LoginRecord?: {
    couple?: GraphCacheResolver<WithTypename<LoginRecord>, Record<string, never>, WithTypename<Pary> | string>,
    sess?: GraphCacheResolver<WithTypename<LoginRecord>, Record<string, never>, WithTypename<Session> | string>,
    usr?: GraphCacheResolver<WithTypename<LoginRecord>, Record<string, never>, WithTypename<User> | string>
  },
  LogoutPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<LogoutPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<LogoutPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  Nabidka?: {
    freeLessons?: GraphCacheResolver<WithTypename<Nabidka>, Record<string, never>, Scalars['Int'] | string>,
    id?: GraphCacheResolver<WithTypename<Nabidka>, Record<string, never>, Scalars['BigInt'] | string>,
    myLessons?: GraphCacheResolver<WithTypename<Nabidka>, Record<string, never>, Scalars['Int'] | string>,
    nDo?: GraphCacheResolver<WithTypename<Nabidka>, Record<string, never>, Scalars['Date'] | string>,
    nId?: GraphCacheResolver<WithTypename<Nabidka>, Record<string, never>, Scalars['BigInt'] | string>,
    nLock?: GraphCacheResolver<WithTypename<Nabidka>, Record<string, never>, Scalars['Boolean'] | string>,
    nMaxPocetHod?: GraphCacheResolver<WithTypename<Nabidka>, Record<string, never>, Scalars['Int'] | string>,
    nOd?: GraphCacheResolver<WithTypename<Nabidka>, Record<string, never>, Scalars['Date'] | string>,
    nPocetHod?: GraphCacheResolver<WithTypename<Nabidka>, Record<string, never>, Scalars['Int'] | string>,
    nTimestamp?: GraphCacheResolver<WithTypename<Nabidka>, Record<string, never>, Scalars['Datetime'] | string>,
    nTrener?: GraphCacheResolver<WithTypename<Nabidka>, Record<string, never>, Scalars['BigInt'] | string>,
    nVisible?: GraphCacheResolver<WithTypename<Nabidka>, Record<string, never>, Scalars['Boolean'] | string>,
    nabidkaItemsByNiIdRodic?: GraphCacheResolver<WithTypename<Nabidka>, NabidkaNabidkaItemsByNiIdRodicArgs, WithTypename<NabidkaItemsConnection> | string>,
    tenantId?: GraphCacheResolver<WithTypename<Nabidka>, Record<string, never>, Scalars['BigInt'] | string>,
    userByNTrener?: GraphCacheResolver<WithTypename<Nabidka>, Record<string, never>, WithTypename<User> | string>
  },
  NabidkaItem?: {
    id?: GraphCacheResolver<WithTypename<NabidkaItem>, Record<string, never>, Scalars['BigInt'] | string>,
    nabidkaByNiIdRodic?: GraphCacheResolver<WithTypename<NabidkaItem>, Record<string, never>, WithTypename<Nabidka> | string>,
    niId?: GraphCacheResolver<WithTypename<NabidkaItem>, Record<string, never>, Scalars['BigInt'] | string>,
    niIdRodic?: GraphCacheResolver<WithTypename<NabidkaItem>, Record<string, never>, Scalars['BigInt'] | string>,
    niLock?: GraphCacheResolver<WithTypename<NabidkaItem>, Record<string, never>, Scalars['Boolean'] | string>,
    niPartner?: GraphCacheResolver<WithTypename<NabidkaItem>, Record<string, never>, Scalars['BigInt'] | string>,
    niPocetHod?: GraphCacheResolver<WithTypename<NabidkaItem>, Record<string, never>, Scalars['Int'] | string>,
    paryByNiPartner?: GraphCacheResolver<WithTypename<NabidkaItem>, Record<string, never>, WithTypename<Pary> | string>,
    tenantId?: GraphCacheResolver<WithTypename<NabidkaItem>, Record<string, never>, Scalars['BigInt'] | string>
  },
  NabidkaItemsConnection?: {
    edges?: GraphCacheResolver<WithTypename<NabidkaItemsConnection>, Record<string, never>, Array<WithTypename<NabidkaItemsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<NabidkaItemsConnection>, Record<string, never>, Array<WithTypename<NabidkaItem> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<NabidkaItemsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<NabidkaItemsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  NabidkaItemsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<NabidkaItemsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<NabidkaItemsEdge>, Record<string, never>, WithTypename<NabidkaItem> | string>
  },
  NabidkasConnection?: {
    edges?: GraphCacheResolver<WithTypename<NabidkasConnection>, Record<string, never>, Array<WithTypename<NabidkasEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<NabidkasConnection>, Record<string, never>, Array<WithTypename<Nabidka> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<NabidkasConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<NabidkasConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  NabidkasEdge?: {
    cursor?: GraphCacheResolver<WithTypename<NabidkasEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<NabidkasEdge>, Record<string, never>, WithTypename<Nabidka> | string>
  },
  Page?: {
    content?: GraphCacheResolver<WithTypename<Page>, Record<string, never>, Scalars['JSON'] | string>,
    createdAt?: GraphCacheResolver<WithTypename<Page>, Record<string, never>, Scalars['Datetime'] | string>,
    id?: GraphCacheResolver<WithTypename<Page>, Record<string, never>, Scalars['Int'] | string>,
    title?: GraphCacheResolver<WithTypename<Page>, Record<string, never>, Scalars['String'] | string>,
    updatedAt?: GraphCacheResolver<WithTypename<Page>, Record<string, never>, Scalars['Datetime'] | string>,
    url?: GraphCacheResolver<WithTypename<Page>, Record<string, never>, Scalars['String'] | string>
  },
  PageInfo?: {
    endCursor?: GraphCacheResolver<WithTypename<PageInfo>, Record<string, never>, Scalars['Cursor'] | string>,
    hasNextPage?: GraphCacheResolver<WithTypename<PageInfo>, Record<string, never>, Scalars['Boolean'] | string>,
    hasPreviousPage?: GraphCacheResolver<WithTypename<PageInfo>, Record<string, never>, Scalars['Boolean'] | string>,
    startCursor?: GraphCacheResolver<WithTypename<PageInfo>, Record<string, never>, Scalars['Cursor'] | string>
  },
  PageRevision?: {
    content?: GraphCacheResolver<WithTypename<PageRevision>, Record<string, never>, Scalars['JSON'] | string>,
    createdAt?: GraphCacheResolver<WithTypename<PageRevision>, Record<string, never>, Scalars['Datetime'] | string>,
    id?: GraphCacheResolver<WithTypename<PageRevision>, Record<string, never>, Scalars['Int'] | string>,
    revNumber?: GraphCacheResolver<WithTypename<PageRevision>, Record<string, never>, Scalars['Int'] | string>,
    revOperation?: GraphCacheResolver<WithTypename<PageRevision>, Record<string, never>, Scalars['String'] | string>,
    revTimestamp?: GraphCacheResolver<WithTypename<PageRevision>, Record<string, never>, Scalars['Datetime'] | string>,
    title?: GraphCacheResolver<WithTypename<PageRevision>, Record<string, never>, Scalars['String'] | string>,
    updatedAt?: GraphCacheResolver<WithTypename<PageRevision>, Record<string, never>, Scalars['Datetime'] | string>,
    url?: GraphCacheResolver<WithTypename<PageRevision>, Record<string, never>, Scalars['String'] | string>
  },
  PageRevisionsConnection?: {
    edges?: GraphCacheResolver<WithTypename<PageRevisionsConnection>, Record<string, never>, Array<WithTypename<PageRevisionsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<PageRevisionsConnection>, Record<string, never>, Array<WithTypename<PageRevision> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<PageRevisionsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<PageRevisionsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  PageRevisionsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<PageRevisionsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<PageRevisionsEdge>, Record<string, never>, WithTypename<PageRevision> | string>
  },
  PagesConnection?: {
    edges?: GraphCacheResolver<WithTypename<PagesConnection>, Record<string, never>, Array<WithTypename<PagesEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<PagesConnection>, Record<string, never>, Array<WithTypename<Page> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<PagesConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<PagesConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  PagesEdge?: {
    cursor?: GraphCacheResolver<WithTypename<PagesEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<PagesEdge>, Record<string, never>, WithTypename<Page> | string>
  },
  Parameter?: {
    paName?: GraphCacheResolver<WithTypename<Parameter>, Record<string, never>, Scalars['String'] | string>,
    paValue?: GraphCacheResolver<WithTypename<Parameter>, Record<string, never>, Scalars['String'] | string>
  },
  ParametersConnection?: {
    edges?: GraphCacheResolver<WithTypename<ParametersConnection>, Record<string, never>, Array<WithTypename<ParametersEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<ParametersConnection>, Record<string, never>, Array<WithTypename<Parameter> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<ParametersConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<ParametersConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  ParametersEdge?: {
    cursor?: GraphCacheResolver<WithTypename<ParametersEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<ParametersEdge>, Record<string, never>, WithTypename<Parameter> | string>
  },
  PariesConnection?: {
    edges?: GraphCacheResolver<WithTypename<PariesConnection>, Record<string, never>, Array<WithTypename<PariesEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<PariesConnection>, Record<string, never>, Array<WithTypename<Pary> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<PariesConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<PariesConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  PariesEdge?: {
    cursor?: GraphCacheResolver<WithTypename<PariesEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<PariesEdge>, Record<string, never>, WithTypename<Pary> | string>
  },
  Pary?: {
    id?: GraphCacheResolver<WithTypename<Pary>, Record<string, never>, Scalars['BigInt'] | string>,
    nabidkaItemsByNiPartner?: GraphCacheResolver<WithTypename<Pary>, ParyNabidkaItemsByNiPartnerArgs, WithTypename<NabidkaItemsConnection> | string>,
    pArchiv?: GraphCacheResolver<WithTypename<Pary>, Record<string, never>, Scalars['Boolean'] | string>,
    pHodnoceni?: GraphCacheResolver<WithTypename<Pary>, Record<string, never>, Scalars['Int'] | string>,
    pId?: GraphCacheResolver<WithTypename<Pary>, Record<string, never>, Scalars['BigInt'] | string>,
    pIdPartner?: GraphCacheResolver<WithTypename<Pary>, Record<string, never>, Scalars['BigInt'] | string>,
    pIdPartnerka?: GraphCacheResolver<WithTypename<Pary>, Record<string, never>, Scalars['BigInt'] | string>,
    pLatBody?: GraphCacheResolver<WithTypename<Pary>, Record<string, never>, Scalars['Int'] | string>,
    pLatFinale?: GraphCacheResolver<WithTypename<Pary>, Record<string, never>, Scalars['Boolean'] | string>,
    pLatTrida?: GraphCacheResolver<WithTypename<Pary>, Record<string, never>, ParyPLatTrida | string>,
    pSttBody?: GraphCacheResolver<WithTypename<Pary>, Record<string, never>, Scalars['Int'] | string>,
    pSttFinale?: GraphCacheResolver<WithTypename<Pary>, Record<string, never>, Scalars['Boolean'] | string>,
    pSttTrida?: GraphCacheResolver<WithTypename<Pary>, Record<string, never>, ParyPSttTrida | string>,
    pTimestampAdd?: GraphCacheResolver<WithTypename<Pary>, Record<string, never>, Scalars['Datetime'] | string>,
    pTimestampArchive?: GraphCacheResolver<WithTypename<Pary>, Record<string, never>, Scalars['Datetime'] | string>,
    rozpisItemsByRiPartner?: GraphCacheResolver<WithTypename<Pary>, ParyRozpisItemsByRiPartnerArgs, WithTypename<RozpisItemsConnection> | string>,
    userByPIdPartner?: GraphCacheResolver<WithTypename<Pary>, Record<string, never>, WithTypename<User> | string>,
    userByPIdPartnerka?: GraphCacheResolver<WithTypename<Pary>, Record<string, never>, WithTypename<User> | string>
  },
  ParyNavrh?: {
    id?: GraphCacheResolver<WithTypename<ParyNavrh>, Record<string, never>, Scalars['BigInt'] | string>,
    pnId?: GraphCacheResolver<WithTypename<ParyNavrh>, Record<string, never>, Scalars['BigInt'] | string>,
    pnNavrhl?: GraphCacheResolver<WithTypename<ParyNavrh>, Record<string, never>, Scalars['BigInt'] | string>,
    pnPartner?: GraphCacheResolver<WithTypename<ParyNavrh>, Record<string, never>, Scalars['BigInt'] | string>,
    pnPartnerka?: GraphCacheResolver<WithTypename<ParyNavrh>, Record<string, never>, Scalars['BigInt'] | string>,
    userByPnNavrhl?: GraphCacheResolver<WithTypename<ParyNavrh>, Record<string, never>, WithTypename<User> | string>,
    userByPnPartner?: GraphCacheResolver<WithTypename<ParyNavrh>, Record<string, never>, WithTypename<User> | string>,
    userByPnPartnerka?: GraphCacheResolver<WithTypename<ParyNavrh>, Record<string, never>, WithTypename<User> | string>
  },
  ParyNavrhsConnection?: {
    edges?: GraphCacheResolver<WithTypename<ParyNavrhsConnection>, Record<string, never>, Array<WithTypename<ParyNavrhsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<ParyNavrhsConnection>, Record<string, never>, Array<WithTypename<ParyNavrh> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<ParyNavrhsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<ParyNavrhsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  ParyNavrhsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<ParyNavrhsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<ParyNavrhsEdge>, Record<string, never>, WithTypename<ParyNavrh> | string>
  },
  PeopleConnection?: {
    edges?: GraphCacheResolver<WithTypename<PeopleConnection>, Record<string, never>, Array<WithTypename<PeopleEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<PeopleConnection>, Record<string, never>, Array<WithTypename<Person> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<PeopleConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<PeopleConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  PeopleEdge?: {
    cursor?: GraphCacheResolver<WithTypename<PeopleEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<PeopleEdge>, Record<string, never>, WithTypename<Person> | string>
  },
  Permission?: {
    id?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['BigInt'] | string>,
    peAkce?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    peAktuality?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    peAnkety?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    peDescription?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['String'] | string>,
    peDokumenty?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    peGalerie?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    peId?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['BigInt'] | string>,
    peInzerce?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    peKonzole?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    peMain?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    peNabidka?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    peName?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['String'] | string>,
    peNastenka?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    peNovinky?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    pePary?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    pePermissions?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    pePlatby?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    peRozpis?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    peSkupiny?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    peUsers?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    usersByUGroup?: GraphCacheResolver<WithTypename<Permission>, PermissionUsersByUGroupArgs, WithTypename<UsersConnection> | string>
  },
  PermissionsConnection?: {
    edges?: GraphCacheResolver<WithTypename<PermissionsConnection>, Record<string, never>, Array<WithTypename<PermissionsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<PermissionsConnection>, Record<string, never>, Array<WithTypename<Permission> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<PermissionsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<PermissionsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  PermissionsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<PermissionsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<PermissionsEdge>, Record<string, never>, WithTypename<Permission> | string>
  },
  Person?: {
    attendeePeople?: GraphCacheResolver<WithTypename<Person>, PersonAttendeePeopleArgs, WithTypename<AttendeePeopleConnection> | string>,
    couplesByFollowerId?: GraphCacheResolver<WithTypename<Person>, PersonCouplesByFollowerIdArgs, WithTypename<CouplesConnection> | string>,
    couplesByLeaderId?: GraphCacheResolver<WithTypename<Person>, PersonCouplesByLeaderIdArgs, WithTypename<CouplesConnection> | string>,
    firstName?: GraphCacheResolver<WithTypename<Person>, Record<string, never>, Scalars['String'] | string>,
    gender?: GraphCacheResolver<WithTypename<Person>, Record<string, never>, GenderType | string>,
    id?: GraphCacheResolver<WithTypename<Person>, Record<string, never>, Scalars['BigInt'] | string>,
    lastName?: GraphCacheResolver<WithTypename<Person>, Record<string, never>, Scalars['String'] | string>,
    tenantPeople?: GraphCacheResolver<WithTypename<Person>, PersonTenantPeopleArgs, WithTypename<TenantPeopleConnection> | string>,
    userId?: GraphCacheResolver<WithTypename<Person>, Record<string, never>, Scalars['BigInt'] | string>
  },
  PlatbyCategoriesConnection?: {
    edges?: GraphCacheResolver<WithTypename<PlatbyCategoriesConnection>, Record<string, never>, Array<WithTypename<PlatbyCategoriesEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<PlatbyCategoriesConnection>, Record<string, never>, Array<WithTypename<PlatbyCategory> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<PlatbyCategoriesConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<PlatbyCategoriesConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  PlatbyCategoriesEdge?: {
    cursor?: GraphCacheResolver<WithTypename<PlatbyCategoriesEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<PlatbyCategoriesEdge>, Record<string, never>, WithTypename<PlatbyCategory> | string>
  },
  PlatbyCategory?: {
    id?: GraphCacheResolver<WithTypename<PlatbyCategory>, Record<string, never>, Scalars['BigInt'] | string>,
    pcAmount?: GraphCacheResolver<WithTypename<PlatbyCategory>, Record<string, never>, Scalars['BigFloat'] | string>,
    pcArchive?: GraphCacheResolver<WithTypename<PlatbyCategory>, Record<string, never>, Scalars['Boolean'] | string>,
    pcDateDue?: GraphCacheResolver<WithTypename<PlatbyCategory>, Record<string, never>, Scalars['Date'] | string>,
    pcId?: GraphCacheResolver<WithTypename<PlatbyCategory>, Record<string, never>, Scalars['BigInt'] | string>,
    pcName?: GraphCacheResolver<WithTypename<PlatbyCategory>, Record<string, never>, Scalars['String'] | string>,
    pcSymbol?: GraphCacheResolver<WithTypename<PlatbyCategory>, Record<string, never>, Scalars['BigInt'] | string>,
    pcUseBase?: GraphCacheResolver<WithTypename<PlatbyCategory>, Record<string, never>, Scalars['Boolean'] | string>,
    pcUsePrefix?: GraphCacheResolver<WithTypename<PlatbyCategory>, Record<string, never>, Scalars['Boolean'] | string>,
    pcValidFrom?: GraphCacheResolver<WithTypename<PlatbyCategory>, Record<string, never>, Scalars['Date'] | string>,
    pcValidTo?: GraphCacheResolver<WithTypename<PlatbyCategory>, Record<string, never>, Scalars['Date'] | string>,
    pcVisible?: GraphCacheResolver<WithTypename<PlatbyCategory>, Record<string, never>, Scalars['Boolean'] | string>,
    platbyCategoryGroupsByPcgIdCategory?: GraphCacheResolver<WithTypename<PlatbyCategory>, PlatbyCategoryPlatbyCategoryGroupsByPcgIdCategoryArgs, WithTypename<PlatbyCategoryGroupsConnection> | string>,
    platbyItemsByPiIdCategory?: GraphCacheResolver<WithTypename<PlatbyCategory>, PlatbyCategoryPlatbyItemsByPiIdCategoryArgs, WithTypename<PlatbyItemsConnection> | string>,
    tenantId?: GraphCacheResolver<WithTypename<PlatbyCategory>, Record<string, never>, Scalars['BigInt'] | string>
  },
  PlatbyCategoryGroup?: {
    id?: GraphCacheResolver<WithTypename<PlatbyCategoryGroup>, Record<string, never>, Scalars['BigInt'] | string>,
    pcgId?: GraphCacheResolver<WithTypename<PlatbyCategoryGroup>, Record<string, never>, Scalars['BigInt'] | string>,
    pcgIdCategory?: GraphCacheResolver<WithTypename<PlatbyCategoryGroup>, Record<string, never>, Scalars['BigInt'] | string>,
    pcgIdGroup?: GraphCacheResolver<WithTypename<PlatbyCategoryGroup>, Record<string, never>, Scalars['BigInt'] | string>,
    platbyCategoryByPcgIdCategory?: GraphCacheResolver<WithTypename<PlatbyCategoryGroup>, Record<string, never>, WithTypename<PlatbyCategory> | string>,
    platbyGroupByPcgIdGroup?: GraphCacheResolver<WithTypename<PlatbyCategoryGroup>, Record<string, never>, WithTypename<PlatbyGroup> | string>,
    tenantId?: GraphCacheResolver<WithTypename<PlatbyCategoryGroup>, Record<string, never>, Scalars['BigInt'] | string>
  },
  PlatbyCategoryGroupsConnection?: {
    edges?: GraphCacheResolver<WithTypename<PlatbyCategoryGroupsConnection>, Record<string, never>, Array<WithTypename<PlatbyCategoryGroupsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<PlatbyCategoryGroupsConnection>, Record<string, never>, Array<WithTypename<PlatbyCategoryGroup> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<PlatbyCategoryGroupsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<PlatbyCategoryGroupsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  PlatbyCategoryGroupsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<PlatbyCategoryGroupsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<PlatbyCategoryGroupsEdge>, Record<string, never>, WithTypename<PlatbyCategoryGroup> | string>
  },
  PlatbyGroup?: {
    id?: GraphCacheResolver<WithTypename<PlatbyGroup>, Record<string, never>, Scalars['BigInt'] | string>,
    pgBase?: GraphCacheResolver<WithTypename<PlatbyGroup>, Record<string, never>, Scalars['BigInt'] | string>,
    pgDescription?: GraphCacheResolver<WithTypename<PlatbyGroup>, Record<string, never>, Scalars['String'] | string>,
    pgId?: GraphCacheResolver<WithTypename<PlatbyGroup>, Record<string, never>, Scalars['BigInt'] | string>,
    pgName?: GraphCacheResolver<WithTypename<PlatbyGroup>, Record<string, never>, Scalars['String'] | string>,
    pgType?: GraphCacheResolver<WithTypename<PlatbyGroup>, Record<string, never>, Scalars['BigFloat'] | string>,
    platbyCategoryGroupsByPcgIdGroup?: GraphCacheResolver<WithTypename<PlatbyGroup>, PlatbyGroupPlatbyCategoryGroupsByPcgIdGroupArgs, WithTypename<PlatbyCategoryGroupsConnection> | string>,
    platbyGroupSkupinasByPgsIdGroup?: GraphCacheResolver<WithTypename<PlatbyGroup>, PlatbyGroupPlatbyGroupSkupinasByPgsIdGroupArgs, WithTypename<PlatbyGroupSkupinasConnection> | string>,
    tenantId?: GraphCacheResolver<WithTypename<PlatbyGroup>, Record<string, never>, Scalars['BigInt'] | string>
  },
  PlatbyGroupSkupina?: {
    id?: GraphCacheResolver<WithTypename<PlatbyGroupSkupina>, Record<string, never>, Scalars['BigInt'] | string>,
    pgsId?: GraphCacheResolver<WithTypename<PlatbyGroupSkupina>, Record<string, never>, Scalars['BigInt'] | string>,
    pgsIdGroup?: GraphCacheResolver<WithTypename<PlatbyGroupSkupina>, Record<string, never>, Scalars['BigInt'] | string>,
    pgsIdSkupina?: GraphCacheResolver<WithTypename<PlatbyGroupSkupina>, Record<string, never>, Scalars['BigInt'] | string>,
    platbyGroupByPgsIdGroup?: GraphCacheResolver<WithTypename<PlatbyGroupSkupina>, Record<string, never>, WithTypename<PlatbyGroup> | string>,
    skupinyByPgsIdSkupina?: GraphCacheResolver<WithTypename<PlatbyGroupSkupina>, Record<string, never>, WithTypename<Skupiny> | string>,
    tenantId?: GraphCacheResolver<WithTypename<PlatbyGroupSkupina>, Record<string, never>, Scalars['BigInt'] | string>
  },
  PlatbyGroupSkupinasConnection?: {
    edges?: GraphCacheResolver<WithTypename<PlatbyGroupSkupinasConnection>, Record<string, never>, Array<WithTypename<PlatbyGroupSkupinasEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<PlatbyGroupSkupinasConnection>, Record<string, never>, Array<WithTypename<PlatbyGroupSkupina> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<PlatbyGroupSkupinasConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<PlatbyGroupSkupinasConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  PlatbyGroupSkupinasEdge?: {
    cursor?: GraphCacheResolver<WithTypename<PlatbyGroupSkupinasEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<PlatbyGroupSkupinasEdge>, Record<string, never>, WithTypename<PlatbyGroupSkupina> | string>
  },
  PlatbyGroupsConnection?: {
    edges?: GraphCacheResolver<WithTypename<PlatbyGroupsConnection>, Record<string, never>, Array<WithTypename<PlatbyGroupsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<PlatbyGroupsConnection>, Record<string, never>, Array<WithTypename<PlatbyGroup> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<PlatbyGroupsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<PlatbyGroupsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  PlatbyGroupsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<PlatbyGroupsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<PlatbyGroupsEdge>, Record<string, never>, WithTypename<PlatbyGroup> | string>
  },
  PlatbyItem?: {
    id?: GraphCacheResolver<WithTypename<PlatbyItem>, Record<string, never>, Scalars['BigInt'] | string>,
    piAmount?: GraphCacheResolver<WithTypename<PlatbyItem>, Record<string, never>, Scalars['BigFloat'] | string>,
    piDate?: GraphCacheResolver<WithTypename<PlatbyItem>, Record<string, never>, Scalars['Date'] | string>,
    piId?: GraphCacheResolver<WithTypename<PlatbyItem>, Record<string, never>, Scalars['BigInt'] | string>,
    piIdCategory?: GraphCacheResolver<WithTypename<PlatbyItem>, Record<string, never>, Scalars['BigInt'] | string>,
    piIdRaw?: GraphCacheResolver<WithTypename<PlatbyItem>, Record<string, never>, Scalars['BigInt'] | string>,
    piIdUser?: GraphCacheResolver<WithTypename<PlatbyItem>, Record<string, never>, Scalars['BigInt'] | string>,
    piPrefix?: GraphCacheResolver<WithTypename<PlatbyItem>, Record<string, never>, Scalars['Int'] | string>,
    platbyCategoryByPiIdCategory?: GraphCacheResolver<WithTypename<PlatbyItem>, Record<string, never>, WithTypename<PlatbyCategory> | string>,
    platbyRawByPiIdRaw?: GraphCacheResolver<WithTypename<PlatbyItem>, Record<string, never>, WithTypename<PlatbyRaw> | string>,
    tenantId?: GraphCacheResolver<WithTypename<PlatbyItem>, Record<string, never>, Scalars['BigInt'] | string>,
    userByPiIdUser?: GraphCacheResolver<WithTypename<PlatbyItem>, Record<string, never>, WithTypename<User> | string>
  },
  PlatbyItemsConnection?: {
    edges?: GraphCacheResolver<WithTypename<PlatbyItemsConnection>, Record<string, never>, Array<WithTypename<PlatbyItemsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<PlatbyItemsConnection>, Record<string, never>, Array<WithTypename<PlatbyItem> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<PlatbyItemsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<PlatbyItemsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  PlatbyItemsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<PlatbyItemsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<PlatbyItemsEdge>, Record<string, never>, WithTypename<PlatbyItem> | string>
  },
  PlatbyRaw?: {
    id?: GraphCacheResolver<WithTypename<PlatbyRaw>, Record<string, never>, Scalars['BigInt'] | string>,
    platbyItemsByPiIdRaw?: GraphCacheResolver<WithTypename<PlatbyRaw>, PlatbyRawPlatbyItemsByPiIdRawArgs, WithTypename<PlatbyItemsConnection> | string>,
    prDiscarded?: GraphCacheResolver<WithTypename<PlatbyRaw>, Record<string, never>, Scalars['Boolean'] | string>,
    prHash?: GraphCacheResolver<WithTypename<PlatbyRaw>, Record<string, never>, Scalars['String'] | string>,
    prId?: GraphCacheResolver<WithTypename<PlatbyRaw>, Record<string, never>, Scalars['BigInt'] | string>,
    prRaw?: GraphCacheResolver<WithTypename<PlatbyRaw>, Record<string, never>, Scalars['String'] | string>,
    prSorted?: GraphCacheResolver<WithTypename<PlatbyRaw>, Record<string, never>, Scalars['Boolean'] | string>,
    tenantId?: GraphCacheResolver<WithTypename<PlatbyRaw>, Record<string, never>, Scalars['BigInt'] | string>
  },
  PlatbyRawsConnection?: {
    edges?: GraphCacheResolver<WithTypename<PlatbyRawsConnection>, Record<string, never>, Array<WithTypename<PlatbyRawsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<PlatbyRawsConnection>, Record<string, never>, Array<WithTypename<PlatbyRaw> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<PlatbyRawsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<PlatbyRawsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  PlatbyRawsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<PlatbyRawsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<PlatbyRawsEdge>, Record<string, never>, WithTypename<PlatbyRaw> | string>
  },
  ProspectFormDancerPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<ProspectFormDancerPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<ProspectFormDancerPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  ReservationSetDesiredLessonsPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<ReservationSetDesiredLessonsPayload>, Record<string, never>, Scalars['String'] | string>,
    nabidkaEdge?: GraphCacheResolver<WithTypename<ReservationSetDesiredLessonsPayload>, ReservationSetDesiredLessonsPayloadNabidkaEdgeArgs, WithTypename<NabidkasEdge> | string>,
    query?: GraphCacheResolver<WithTypename<ReservationSetDesiredLessonsPayload>, Record<string, never>, WithTypename<Query> | string>,
    reservation?: GraphCacheResolver<WithTypename<ReservationSetDesiredLessonsPayload>, Record<string, never>, WithTypename<Nabidka> | string>,
    userByNTrener?: GraphCacheResolver<WithTypename<ReservationSetDesiredLessonsPayload>, Record<string, never>, WithTypename<User> | string>
  },
  ResetPasswordPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<ResetPasswordPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<ResetPasswordPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  Room?: {
    description?: GraphCacheResolver<WithTypename<Room>, Record<string, never>, Scalars['JSON'] | string>,
    id?: GraphCacheResolver<WithTypename<Room>, Record<string, never>, Scalars['BigInt'] | string>,
    location?: GraphCacheResolver<WithTypename<Room>, Record<string, never>, Scalars['BigInt'] | string>,
    locationByLocation?: GraphCacheResolver<WithTypename<Room>, Record<string, never>, WithTypename<Location> | string>,
    name?: GraphCacheResolver<WithTypename<Room>, Record<string, never>, Scalars['String'] | string>,
    roomAttachments?: GraphCacheResolver<WithTypename<Room>, RoomRoomAttachmentsArgs, WithTypename<RoomAttachmentsConnection> | string>
  },
  RoomAttachment?: {
    attachmentByObjectName?: GraphCacheResolver<WithTypename<RoomAttachment>, Record<string, never>, WithTypename<Attachment> | string>,
    objectName?: GraphCacheResolver<WithTypename<RoomAttachment>, Record<string, never>, Scalars['String'] | string>,
    room?: GraphCacheResolver<WithTypename<RoomAttachment>, Record<string, never>, WithTypename<Room> | string>,
    roomId?: GraphCacheResolver<WithTypename<RoomAttachment>, Record<string, never>, Scalars['BigInt'] | string>
  },
  RoomAttachmentsConnection?: {
    edges?: GraphCacheResolver<WithTypename<RoomAttachmentsConnection>, Record<string, never>, Array<WithTypename<RoomAttachmentsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<RoomAttachmentsConnection>, Record<string, never>, Array<WithTypename<RoomAttachment> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<RoomAttachmentsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<RoomAttachmentsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  RoomAttachmentsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<RoomAttachmentsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<RoomAttachmentsEdge>, Record<string, never>, WithTypename<RoomAttachment> | string>
  },
  RoomsConnection?: {
    edges?: GraphCacheResolver<WithTypename<RoomsConnection>, Record<string, never>, Array<WithTypename<RoomsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<RoomsConnection>, Record<string, never>, Array<WithTypename<Room> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<RoomsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<RoomsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  RoomsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<RoomsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<RoomsEdge>, Record<string, never>, WithTypename<Room> | string>
  },
  Rozpi?: {
    id?: GraphCacheResolver<WithTypename<Rozpi>, Record<string, never>, Scalars['BigInt'] | string>,
    rDatum?: GraphCacheResolver<WithTypename<Rozpi>, Record<string, never>, Scalars['Date'] | string>,
    rId?: GraphCacheResolver<WithTypename<Rozpi>, Record<string, never>, Scalars['BigInt'] | string>,
    rKde?: GraphCacheResolver<WithTypename<Rozpi>, Record<string, never>, Scalars['String'] | string>,
    rLock?: GraphCacheResolver<WithTypename<Rozpi>, Record<string, never>, Scalars['Boolean'] | string>,
    rTimestamp?: GraphCacheResolver<WithTypename<Rozpi>, Record<string, never>, Scalars['Datetime'] | string>,
    rTrener?: GraphCacheResolver<WithTypename<Rozpi>, Record<string, never>, Scalars['BigInt'] | string>,
    rVisible?: GraphCacheResolver<WithTypename<Rozpi>, Record<string, never>, Scalars['Boolean'] | string>,
    rozpisItemsByRiIdRodic?: GraphCacheResolver<WithTypename<Rozpi>, RozpiRozpisItemsByRiIdRodicArgs, WithTypename<RozpisItemsConnection> | string>,
    tenantId?: GraphCacheResolver<WithTypename<Rozpi>, Record<string, never>, Scalars['BigInt'] | string>,
    userByRTrener?: GraphCacheResolver<WithTypename<Rozpi>, Record<string, never>, WithTypename<User> | string>
  },
  RozpisConnection?: {
    edges?: GraphCacheResolver<WithTypename<RozpisConnection>, Record<string, never>, Array<WithTypename<RozpisEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<RozpisConnection>, Record<string, never>, Array<WithTypename<Rozpi> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<RozpisConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<RozpisConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  RozpisEdge?: {
    cursor?: GraphCacheResolver<WithTypename<RozpisEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<RozpisEdge>, Record<string, never>, WithTypename<Rozpi> | string>
  },
  RozpisItem?: {
    id?: GraphCacheResolver<WithTypename<RozpisItem>, Record<string, never>, Scalars['BigInt'] | string>,
    paryByRiPartner?: GraphCacheResolver<WithTypename<RozpisItem>, Record<string, never>, WithTypename<Pary> | string>,
    riDo?: GraphCacheResolver<WithTypename<RozpisItem>, Record<string, never>, Scalars['Time'] | string>,
    riId?: GraphCacheResolver<WithTypename<RozpisItem>, Record<string, never>, Scalars['BigInt'] | string>,
    riIdRodic?: GraphCacheResolver<WithTypename<RozpisItem>, Record<string, never>, Scalars['BigInt'] | string>,
    riLock?: GraphCacheResolver<WithTypename<RozpisItem>, Record<string, never>, Scalars['Boolean'] | string>,
    riOd?: GraphCacheResolver<WithTypename<RozpisItem>, Record<string, never>, Scalars['Time'] | string>,
    riPartner?: GraphCacheResolver<WithTypename<RozpisItem>, Record<string, never>, Scalars['BigInt'] | string>,
    rozpiByRiIdRodic?: GraphCacheResolver<WithTypename<RozpisItem>, Record<string, never>, WithTypename<Rozpi> | string>,
    tenantId?: GraphCacheResolver<WithTypename<RozpisItem>, Record<string, never>, Scalars['BigInt'] | string>
  },
  RozpisItemsConnection?: {
    edges?: GraphCacheResolver<WithTypename<RozpisItemsConnection>, Record<string, never>, Array<WithTypename<RozpisItemsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<RozpisItemsConnection>, Record<string, never>, Array<WithTypename<RozpisItem> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<RozpisItemsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<RozpisItemsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  RozpisItemsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<RozpisItemsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<RozpisItemsEdge>, Record<string, never>, WithTypename<RozpisItem> | string>
  },
  Session?: {
    ssId?: GraphCacheResolver<WithTypename<Session>, Record<string, never>, Scalars['String'] | string>,
    ssLifetime?: GraphCacheResolver<WithTypename<Session>, Record<string, never>, Scalars['BigInt'] | string>,
    ssUpdatedAt?: GraphCacheResolver<WithTypename<Session>, Record<string, never>, Scalars['Datetime'] | string>,
    ssUser?: GraphCacheResolver<WithTypename<Session>, Record<string, never>, Scalars['BigInt'] | string>,
    userBySsUser?: GraphCacheResolver<WithTypename<Session>, Record<string, never>, WithTypename<User> | string>
  },
  SessionsConnection?: {
    edges?: GraphCacheResolver<WithTypename<SessionsConnection>, Record<string, never>, Array<WithTypename<SessionsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<SessionsConnection>, Record<string, never>, Array<WithTypename<Session> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<SessionsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<SessionsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  SessionsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<SessionsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<SessionsEdge>, Record<string, never>, WithTypename<Session> | string>
  },
  SkupiniesConnection?: {
    edges?: GraphCacheResolver<WithTypename<SkupiniesConnection>, Record<string, never>, Array<WithTypename<SkupiniesEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<SkupiniesConnection>, Record<string, never>, Array<WithTypename<Skupiny> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<SkupiniesConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<SkupiniesConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  SkupiniesEdge?: {
    cursor?: GraphCacheResolver<WithTypename<SkupiniesEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<SkupiniesEdge>, Record<string, never>, WithTypename<Skupiny> | string>
  },
  Skupiny?: {
    cohortGroup?: GraphCacheResolver<WithTypename<Skupiny>, Record<string, never>, Scalars['BigInt'] | string>,
    cohortGroupByCohortGroup?: GraphCacheResolver<WithTypename<Skupiny>, Record<string, never>, WithTypename<CohortGroup> | string>,
    id?: GraphCacheResolver<WithTypename<Skupiny>, Record<string, never>, Scalars['BigInt'] | string>,
    internalInfo?: GraphCacheResolver<WithTypename<Skupiny>, Record<string, never>, Scalars['String'] | string>,
    ordering?: GraphCacheResolver<WithTypename<Skupiny>, Record<string, never>, Scalars['Int'] | string>,
    platbyGroupSkupinasByPgsIdSkupina?: GraphCacheResolver<WithTypename<Skupiny>, SkupinyPlatbyGroupSkupinasByPgsIdSkupinaArgs, WithTypename<PlatbyGroupSkupinasConnection> | string>,
    sColorRgb?: GraphCacheResolver<WithTypename<Skupiny>, Record<string, never>, Scalars['String'] | string>,
    sColorText?: GraphCacheResolver<WithTypename<Skupiny>, Record<string, never>, Scalars['String'] | string>,
    sDescription?: GraphCacheResolver<WithTypename<Skupiny>, Record<string, never>, Scalars['String'] | string>,
    sId?: GraphCacheResolver<WithTypename<Skupiny>, Record<string, never>, Scalars['BigInt'] | string>,
    sLocation?: GraphCacheResolver<WithTypename<Skupiny>, Record<string, never>, Scalars['String'] | string>,
    sName?: GraphCacheResolver<WithTypename<Skupiny>, Record<string, never>, Scalars['String'] | string>,
    sVisible?: GraphCacheResolver<WithTypename<Skupiny>, Record<string, never>, Scalars['Boolean'] | string>,
    tenantId?: GraphCacheResolver<WithTypename<Skupiny>, Record<string, never>, Scalars['BigInt'] | string>,
    upozorneniSkupiniesByUpsIdSkupina?: GraphCacheResolver<WithTypename<Skupiny>, SkupinyUpozorneniSkupiniesByUpsIdSkupinaArgs, WithTypename<UpozorneniSkupiniesConnection> | string>,
    usersByUSkupina?: GraphCacheResolver<WithTypename<Skupiny>, SkupinyUsersByUSkupinaArgs, WithTypename<UsersConnection> | string>
  },
  SubmitFormPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<SubmitFormPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<SubmitFormPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  Tenant?: {
    attendeeCouples?: GraphCacheResolver<WithTypename<Tenant>, TenantAttendeeCouplesArgs, WithTypename<AttendeeCouplesConnection> | string>,
    attendeeLists?: GraphCacheResolver<WithTypename<Tenant>, TenantAttendeeListsArgs, WithTypename<AttendeeListsConnection> | string>,
    attendeePeople?: GraphCacheResolver<WithTypename<Tenant>, TenantAttendeePeopleArgs, WithTypename<AttendeePeopleConnection> | string>,
    cohortGroupsByTenant?: GraphCacheResolver<WithTypename<Tenant>, TenantCohortGroupsByTenantArgs, WithTypename<CohortGroupsConnection> | string>,
    couples?: GraphCacheResolver<WithTypename<Tenant>, TenantCouplesArgs, WithTypename<CouplesConnection> | string>,
    id?: GraphCacheResolver<WithTypename<Tenant>, Record<string, never>, Scalars['BigInt'] | string>,
    memberInfo?: GraphCacheResolver<WithTypename<Tenant>, Record<string, never>, Scalars['String'] | string>,
    name?: GraphCacheResolver<WithTypename<Tenant>, Record<string, never>, Scalars['String'] | string>,
    origins?: GraphCacheResolver<WithTypename<Tenant>, Record<string, never>, Array<Scalars['String'] | string>>,
    tenantAttachments?: GraphCacheResolver<WithTypename<Tenant>, TenantTenantAttachmentsArgs, WithTypename<TenantAttachmentsConnection> | string>,
    tenantLocations?: GraphCacheResolver<WithTypename<Tenant>, TenantTenantLocationsArgs, WithTypename<TenantLocationsConnection> | string>,
    tenantPeople?: GraphCacheResolver<WithTypename<Tenant>, TenantTenantPeopleArgs, WithTypename<TenantPeopleConnection> | string>
  },
  TenantAttachment?: {
    attachmentByObjectName?: GraphCacheResolver<WithTypename<TenantAttachment>, Record<string, never>, WithTypename<Attachment> | string>,
    objectName?: GraphCacheResolver<WithTypename<TenantAttachment>, Record<string, never>, Scalars['String'] | string>,
    tenant?: GraphCacheResolver<WithTypename<TenantAttachment>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantId?: GraphCacheResolver<WithTypename<TenantAttachment>, Record<string, never>, Scalars['BigInt'] | string>,
    type?: GraphCacheResolver<WithTypename<TenantAttachment>, Record<string, never>, TenantAttachmentType | string>
  },
  TenantAttachmentsConnection?: {
    edges?: GraphCacheResolver<WithTypename<TenantAttachmentsConnection>, Record<string, never>, Array<WithTypename<TenantAttachmentsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<TenantAttachmentsConnection>, Record<string, never>, Array<WithTypename<TenantAttachment> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<TenantAttachmentsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<TenantAttachmentsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  TenantAttachmentsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<TenantAttachmentsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<TenantAttachmentsEdge>, Record<string, never>, WithTypename<TenantAttachment> | string>
  },
  TenantLocation?: {
    location?: GraphCacheResolver<WithTypename<TenantLocation>, Record<string, never>, WithTypename<Location> | string>,
    locationId?: GraphCacheResolver<WithTypename<TenantLocation>, Record<string, never>, Scalars['BigInt'] | string>,
    tenant?: GraphCacheResolver<WithTypename<TenantLocation>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantId?: GraphCacheResolver<WithTypename<TenantLocation>, Record<string, never>, Scalars['BigInt'] | string>
  },
  TenantLocationsConnection?: {
    edges?: GraphCacheResolver<WithTypename<TenantLocationsConnection>, Record<string, never>, Array<WithTypename<TenantLocationsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<TenantLocationsConnection>, Record<string, never>, Array<WithTypename<TenantLocation> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<TenantLocationsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<TenantLocationsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  TenantLocationsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<TenantLocationsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<TenantLocationsEdge>, Record<string, never>, WithTypename<TenantLocation> | string>
  },
  TenantPeopleConnection?: {
    edges?: GraphCacheResolver<WithTypename<TenantPeopleConnection>, Record<string, never>, Array<WithTypename<TenantPeopleEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<TenantPeopleConnection>, Record<string, never>, Array<WithTypename<TenantPerson> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<TenantPeopleConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<TenantPeopleConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  TenantPeopleEdge?: {
    cursor?: GraphCacheResolver<WithTypename<TenantPeopleEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<TenantPeopleEdge>, Record<string, never>, WithTypename<TenantPerson> | string>
  },
  TenantPerson?: {
    person?: GraphCacheResolver<WithTypename<TenantPerson>, Record<string, never>, WithTypename<Person> | string>,
    personId?: GraphCacheResolver<WithTypename<TenantPerson>, Record<string, never>, Scalars['BigInt'] | string>,
    tenant?: GraphCacheResolver<WithTypename<TenantPerson>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantId?: GraphCacheResolver<WithTypename<TenantPerson>, Record<string, never>, Scalars['BigInt'] | string>
  },
  TenantsConnection?: {
    edges?: GraphCacheResolver<WithTypename<TenantsConnection>, Record<string, never>, Array<WithTypename<TenantsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<TenantsConnection>, Record<string, never>, Array<WithTypename<Tenant> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<TenantsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<TenantsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  TenantsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<TenantsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<TenantsEdge>, Record<string, never>, WithTypename<Tenant> | string>
  },
  UpdateAktualityPayload?: {
    aktuality?: GraphCacheResolver<WithTypename<UpdateAktualityPayload>, Record<string, never>, WithTypename<Aktuality> | string>,
    aktualityEdge?: GraphCacheResolver<WithTypename<UpdateAktualityPayload>, UpdateAktualityPayloadAktualityEdgeArgs, WithTypename<AktualitiesEdge> | string>,
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateAktualityPayload>, Record<string, never>, Scalars['String'] | string>,
    galerieFotoByAtFotoMain?: GraphCacheResolver<WithTypename<UpdateAktualityPayload>, Record<string, never>, WithTypename<GalerieFoto> | string>,
    query?: GraphCacheResolver<WithTypename<UpdateAktualityPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByAtKdo?: GraphCacheResolver<WithTypename<UpdateAktualityPayload>, Record<string, never>, WithTypename<User> | string>
  },
  UpdateAttachmentPayload?: {
    attachment?: GraphCacheResolver<WithTypename<UpdateAttachmentPayload>, Record<string, never>, WithTypename<Attachment> | string>,
    attachmentEdge?: GraphCacheResolver<WithTypename<UpdateAttachmentPayload>, UpdateAttachmentPayloadAttachmentEdgeArgs, WithTypename<AttachmentsEdge> | string>,
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateAttachmentPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<UpdateAttachmentPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByUploadedBy?: GraphCacheResolver<WithTypename<UpdateAttachmentPayload>, Record<string, never>, WithTypename<User> | string>
  },
  UpdateAttendeeExternalPayload?: {
    attendeeExternal?: GraphCacheResolver<WithTypename<UpdateAttendeeExternalPayload>, Record<string, never>, WithTypename<AttendeeExternal> | string>,
    attendeeExternalEdge?: GraphCacheResolver<WithTypename<UpdateAttendeeExternalPayload>, UpdateAttendeeExternalPayloadAttendeeExternalEdgeArgs, WithTypename<AttendeeExternalsEdge> | string>,
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateAttendeeExternalPayload>, Record<string, never>, Scalars['String'] | string>,
    event?: GraphCacheResolver<WithTypename<UpdateAttendeeExternalPayload>, Record<string, never>, WithTypename<Event> | string>,
    query?: GraphCacheResolver<WithTypename<UpdateAttendeeExternalPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByConfirmedBy?: GraphCacheResolver<WithTypename<UpdateAttendeeExternalPayload>, Record<string, never>, WithTypename<User> | string>,
    userByManagedBy?: GraphCacheResolver<WithTypename<UpdateAttendeeExternalPayload>, Record<string, never>, WithTypename<User> | string>
  },
  UpdateAttendeeUserPayload?: {
    attendeeUser?: GraphCacheResolver<WithTypename<UpdateAttendeeUserPayload>, Record<string, never>, WithTypename<AttendeeUser> | string>,
    attendeeUserEdge?: GraphCacheResolver<WithTypename<UpdateAttendeeUserPayload>, UpdateAttendeeUserPayloadAttendeeUserEdgeArgs, WithTypename<AttendeeUsersEdge> | string>,
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateAttendeeUserPayload>, Record<string, never>, Scalars['String'] | string>,
    event?: GraphCacheResolver<WithTypename<UpdateAttendeeUserPayload>, Record<string, never>, WithTypename<Event> | string>,
    query?: GraphCacheResolver<WithTypename<UpdateAttendeeUserPayload>, Record<string, never>, WithTypename<Query> | string>,
    user?: GraphCacheResolver<WithTypename<UpdateAttendeeUserPayload>, Record<string, never>, WithTypename<User> | string>
  },
  UpdateCohortGroupPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateCohortGroupPayload>, Record<string, never>, Scalars['String'] | string>,
    cohortGroup?: GraphCacheResolver<WithTypename<UpdateCohortGroupPayload>, Record<string, never>, WithTypename<CohortGroup> | string>,
    cohortGroupEdge?: GraphCacheResolver<WithTypename<UpdateCohortGroupPayload>, UpdateCohortGroupPayloadCohortGroupEdgeArgs, WithTypename<CohortGroupsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<UpdateCohortGroupPayload>, Record<string, never>, WithTypename<Query> | string>,
    tenantByTenant?: GraphCacheResolver<WithTypename<UpdateCohortGroupPayload>, Record<string, never>, WithTypename<Tenant> | string>
  },
  UpdateDokumentyPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateDokumentyPayload>, Record<string, never>, Scalars['String'] | string>,
    dokumenty?: GraphCacheResolver<WithTypename<UpdateDokumentyPayload>, Record<string, never>, WithTypename<Dokumenty> | string>,
    dokumentyEdge?: GraphCacheResolver<WithTypename<UpdateDokumentyPayload>, UpdateDokumentyPayloadDokumentyEdgeArgs, WithTypename<DokumentiesEdge> | string>,
    query?: GraphCacheResolver<WithTypename<UpdateDokumentyPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByDKdo?: GraphCacheResolver<WithTypename<UpdateDokumentyPayload>, Record<string, never>, WithTypename<User> | string>
  },
  UpdateEventPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateEventPayload>, Record<string, never>, Scalars['String'] | string>,
    event?: GraphCacheResolver<WithTypename<UpdateEventPayload>, Record<string, never>, WithTypename<Event> | string>,
    eventEdge?: GraphCacheResolver<WithTypename<UpdateEventPayload>, UpdateEventPayloadEventEdgeArgs, WithTypename<EventsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<UpdateEventPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  UpdateFormResponsePayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateFormResponsePayload>, Record<string, never>, Scalars['String'] | string>,
    formResponse?: GraphCacheResolver<WithTypename<UpdateFormResponsePayload>, Record<string, never>, WithTypename<FormResponse> | string>,
    formResponseEdge?: GraphCacheResolver<WithTypename<UpdateFormResponsePayload>, UpdateFormResponsePayloadFormResponseEdgeArgs, WithTypename<FormResponsesEdge> | string>,
    query?: GraphCacheResolver<WithTypename<UpdateFormResponsePayload>, Record<string, never>, WithTypename<Query> | string>
  },
  UpdateGalerieDirPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateGalerieDirPayload>, Record<string, never>, Scalars['String'] | string>,
    galerieDir?: GraphCacheResolver<WithTypename<UpdateGalerieDirPayload>, Record<string, never>, WithTypename<GalerieDir> | string>,
    galerieDirEdge?: GraphCacheResolver<WithTypename<UpdateGalerieDirPayload>, UpdateGalerieDirPayloadGalerieDirEdgeArgs, WithTypename<GalerieDirsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<UpdateGalerieDirPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  UpdateGalerieFotoPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateGalerieFotoPayload>, Record<string, never>, Scalars['String'] | string>,
    galerieDirByGfIdRodic?: GraphCacheResolver<WithTypename<UpdateGalerieFotoPayload>, Record<string, never>, WithTypename<GalerieDir> | string>,
    galerieFoto?: GraphCacheResolver<WithTypename<UpdateGalerieFotoPayload>, Record<string, never>, WithTypename<GalerieFoto> | string>,
    galerieFotoEdge?: GraphCacheResolver<WithTypename<UpdateGalerieFotoPayload>, UpdateGalerieFotoPayloadGalerieFotoEdgeArgs, WithTypename<GalerieFotosEdge> | string>,
    query?: GraphCacheResolver<WithTypename<UpdateGalerieFotoPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByGfKdo?: GraphCacheResolver<WithTypename<UpdateGalerieFotoPayload>, Record<string, never>, WithTypename<User> | string>
  },
  UpdateLocationAttachmentPayload?: {
    attachmentByObjectName?: GraphCacheResolver<WithTypename<UpdateLocationAttachmentPayload>, Record<string, never>, WithTypename<Attachment> | string>,
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateLocationAttachmentPayload>, Record<string, never>, Scalars['String'] | string>,
    location?: GraphCacheResolver<WithTypename<UpdateLocationAttachmentPayload>, Record<string, never>, WithTypename<Location> | string>,
    locationAttachment?: GraphCacheResolver<WithTypename<UpdateLocationAttachmentPayload>, Record<string, never>, WithTypename<LocationAttachment> | string>,
    locationAttachmentEdge?: GraphCacheResolver<WithTypename<UpdateLocationAttachmentPayload>, UpdateLocationAttachmentPayloadLocationAttachmentEdgeArgs, WithTypename<LocationAttachmentsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<UpdateLocationAttachmentPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  UpdateLocationPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateLocationPayload>, Record<string, never>, Scalars['String'] | string>,
    location?: GraphCacheResolver<WithTypename<UpdateLocationPayload>, Record<string, never>, WithTypename<Location> | string>,
    locationEdge?: GraphCacheResolver<WithTypename<UpdateLocationPayload>, UpdateLocationPayloadLocationEdgeArgs, WithTypename<LocationsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<UpdateLocationPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  UpdateNabidkaItemPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateNabidkaItemPayload>, Record<string, never>, Scalars['String'] | string>,
    nabidkaByNiIdRodic?: GraphCacheResolver<WithTypename<UpdateNabidkaItemPayload>, Record<string, never>, WithTypename<Nabidka> | string>,
    nabidkaItem?: GraphCacheResolver<WithTypename<UpdateNabidkaItemPayload>, Record<string, never>, WithTypename<NabidkaItem> | string>,
    nabidkaItemEdge?: GraphCacheResolver<WithTypename<UpdateNabidkaItemPayload>, UpdateNabidkaItemPayloadNabidkaItemEdgeArgs, WithTypename<NabidkaItemsEdge> | string>,
    paryByNiPartner?: GraphCacheResolver<WithTypename<UpdateNabidkaItemPayload>, Record<string, never>, WithTypename<Pary> | string>,
    query?: GraphCacheResolver<WithTypename<UpdateNabidkaItemPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  UpdateNabidkaPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateNabidkaPayload>, Record<string, never>, Scalars['String'] | string>,
    nabidka?: GraphCacheResolver<WithTypename<UpdateNabidkaPayload>, Record<string, never>, WithTypename<Nabidka> | string>,
    nabidkaEdge?: GraphCacheResolver<WithTypename<UpdateNabidkaPayload>, UpdateNabidkaPayloadNabidkaEdgeArgs, WithTypename<NabidkasEdge> | string>,
    query?: GraphCacheResolver<WithTypename<UpdateNabidkaPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByNTrener?: GraphCacheResolver<WithTypename<UpdateNabidkaPayload>, Record<string, never>, WithTypename<User> | string>
  },
  UpdatePagePayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdatePagePayload>, Record<string, never>, Scalars['String'] | string>,
    page?: GraphCacheResolver<WithTypename<UpdatePagePayload>, Record<string, never>, WithTypename<Page> | string>,
    pageEdge?: GraphCacheResolver<WithTypename<UpdatePagePayload>, UpdatePagePayloadPageEdgeArgs, WithTypename<PagesEdge> | string>,
    query?: GraphCacheResolver<WithTypename<UpdatePagePayload>, Record<string, never>, WithTypename<Query> | string>
  },
  UpdateParameterPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateParameterPayload>, Record<string, never>, Scalars['String'] | string>,
    parameter?: GraphCacheResolver<WithTypename<UpdateParameterPayload>, Record<string, never>, WithTypename<Parameter> | string>,
    parameterEdge?: GraphCacheResolver<WithTypename<UpdateParameterPayload>, UpdateParameterPayloadParameterEdgeArgs, WithTypename<ParametersEdge> | string>,
    query?: GraphCacheResolver<WithTypename<UpdateParameterPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  UpdateParyNavrhPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateParyNavrhPayload>, Record<string, never>, Scalars['String'] | string>,
    paryNavrh?: GraphCacheResolver<WithTypename<UpdateParyNavrhPayload>, Record<string, never>, WithTypename<ParyNavrh> | string>,
    paryNavrhEdge?: GraphCacheResolver<WithTypename<UpdateParyNavrhPayload>, UpdateParyNavrhPayloadParyNavrhEdgeArgs, WithTypename<ParyNavrhsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<UpdateParyNavrhPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByPnNavrhl?: GraphCacheResolver<WithTypename<UpdateParyNavrhPayload>, Record<string, never>, WithTypename<User> | string>,
    userByPnPartner?: GraphCacheResolver<WithTypename<UpdateParyNavrhPayload>, Record<string, never>, WithTypename<User> | string>,
    userByPnPartnerka?: GraphCacheResolver<WithTypename<UpdateParyNavrhPayload>, Record<string, never>, WithTypename<User> | string>
  },
  UpdateParyPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateParyPayload>, Record<string, never>, Scalars['String'] | string>,
    pary?: GraphCacheResolver<WithTypename<UpdateParyPayload>, Record<string, never>, WithTypename<Pary> | string>,
    paryEdge?: GraphCacheResolver<WithTypename<UpdateParyPayload>, UpdateParyPayloadParyEdgeArgs, WithTypename<PariesEdge> | string>,
    query?: GraphCacheResolver<WithTypename<UpdateParyPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByPIdPartner?: GraphCacheResolver<WithTypename<UpdateParyPayload>, Record<string, never>, WithTypename<User> | string>,
    userByPIdPartnerka?: GraphCacheResolver<WithTypename<UpdateParyPayload>, Record<string, never>, WithTypename<User> | string>
  },
  UpdatePermissionPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdatePermissionPayload>, Record<string, never>, Scalars['String'] | string>,
    permission?: GraphCacheResolver<WithTypename<UpdatePermissionPayload>, Record<string, never>, WithTypename<Permission> | string>,
    permissionEdge?: GraphCacheResolver<WithTypename<UpdatePermissionPayload>, UpdatePermissionPayloadPermissionEdgeArgs, WithTypename<PermissionsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<UpdatePermissionPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  UpdatePersonPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdatePersonPayload>, Record<string, never>, Scalars['String'] | string>,
    person?: GraphCacheResolver<WithTypename<UpdatePersonPayload>, Record<string, never>, WithTypename<Person> | string>,
    personEdge?: GraphCacheResolver<WithTypename<UpdatePersonPayload>, UpdatePersonPayloadPersonEdgeArgs, WithTypename<PeopleEdge> | string>,
    query?: GraphCacheResolver<WithTypename<UpdatePersonPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  UpdatePlatbyCategoryGroupPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdatePlatbyCategoryGroupPayload>, Record<string, never>, Scalars['String'] | string>,
    platbyCategoryByPcgIdCategory?: GraphCacheResolver<WithTypename<UpdatePlatbyCategoryGroupPayload>, Record<string, never>, WithTypename<PlatbyCategory> | string>,
    platbyCategoryGroup?: GraphCacheResolver<WithTypename<UpdatePlatbyCategoryGroupPayload>, Record<string, never>, WithTypename<PlatbyCategoryGroup> | string>,
    platbyCategoryGroupEdge?: GraphCacheResolver<WithTypename<UpdatePlatbyCategoryGroupPayload>, UpdatePlatbyCategoryGroupPayloadPlatbyCategoryGroupEdgeArgs, WithTypename<PlatbyCategoryGroupsEdge> | string>,
    platbyGroupByPcgIdGroup?: GraphCacheResolver<WithTypename<UpdatePlatbyCategoryGroupPayload>, Record<string, never>, WithTypename<PlatbyGroup> | string>,
    query?: GraphCacheResolver<WithTypename<UpdatePlatbyCategoryGroupPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  UpdatePlatbyCategoryPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdatePlatbyCategoryPayload>, Record<string, never>, Scalars['String'] | string>,
    platbyCategory?: GraphCacheResolver<WithTypename<UpdatePlatbyCategoryPayload>, Record<string, never>, WithTypename<PlatbyCategory> | string>,
    platbyCategoryEdge?: GraphCacheResolver<WithTypename<UpdatePlatbyCategoryPayload>, UpdatePlatbyCategoryPayloadPlatbyCategoryEdgeArgs, WithTypename<PlatbyCategoriesEdge> | string>,
    query?: GraphCacheResolver<WithTypename<UpdatePlatbyCategoryPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  UpdatePlatbyGroupPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdatePlatbyGroupPayload>, Record<string, never>, Scalars['String'] | string>,
    platbyGroup?: GraphCacheResolver<WithTypename<UpdatePlatbyGroupPayload>, Record<string, never>, WithTypename<PlatbyGroup> | string>,
    platbyGroupEdge?: GraphCacheResolver<WithTypename<UpdatePlatbyGroupPayload>, UpdatePlatbyGroupPayloadPlatbyGroupEdgeArgs, WithTypename<PlatbyGroupsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<UpdatePlatbyGroupPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  UpdatePlatbyGroupSkupinaPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdatePlatbyGroupSkupinaPayload>, Record<string, never>, Scalars['String'] | string>,
    platbyGroupByPgsIdGroup?: GraphCacheResolver<WithTypename<UpdatePlatbyGroupSkupinaPayload>, Record<string, never>, WithTypename<PlatbyGroup> | string>,
    platbyGroupSkupina?: GraphCacheResolver<WithTypename<UpdatePlatbyGroupSkupinaPayload>, Record<string, never>, WithTypename<PlatbyGroupSkupina> | string>,
    platbyGroupSkupinaEdge?: GraphCacheResolver<WithTypename<UpdatePlatbyGroupSkupinaPayload>, UpdatePlatbyGroupSkupinaPayloadPlatbyGroupSkupinaEdgeArgs, WithTypename<PlatbyGroupSkupinasEdge> | string>,
    query?: GraphCacheResolver<WithTypename<UpdatePlatbyGroupSkupinaPayload>, Record<string, never>, WithTypename<Query> | string>,
    skupinyByPgsIdSkupina?: GraphCacheResolver<WithTypename<UpdatePlatbyGroupSkupinaPayload>, Record<string, never>, WithTypename<Skupiny> | string>
  },
  UpdatePlatbyItemPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdatePlatbyItemPayload>, Record<string, never>, Scalars['String'] | string>,
    platbyCategoryByPiIdCategory?: GraphCacheResolver<WithTypename<UpdatePlatbyItemPayload>, Record<string, never>, WithTypename<PlatbyCategory> | string>,
    platbyItem?: GraphCacheResolver<WithTypename<UpdatePlatbyItemPayload>, Record<string, never>, WithTypename<PlatbyItem> | string>,
    platbyItemEdge?: GraphCacheResolver<WithTypename<UpdatePlatbyItemPayload>, UpdatePlatbyItemPayloadPlatbyItemEdgeArgs, WithTypename<PlatbyItemsEdge> | string>,
    platbyRawByPiIdRaw?: GraphCacheResolver<WithTypename<UpdatePlatbyItemPayload>, Record<string, never>, WithTypename<PlatbyRaw> | string>,
    query?: GraphCacheResolver<WithTypename<UpdatePlatbyItemPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByPiIdUser?: GraphCacheResolver<WithTypename<UpdatePlatbyItemPayload>, Record<string, never>, WithTypename<User> | string>
  },
  UpdatePlatbyRawPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdatePlatbyRawPayload>, Record<string, never>, Scalars['String'] | string>,
    platbyRaw?: GraphCacheResolver<WithTypename<UpdatePlatbyRawPayload>, Record<string, never>, WithTypename<PlatbyRaw> | string>,
    platbyRawEdge?: GraphCacheResolver<WithTypename<UpdatePlatbyRawPayload>, UpdatePlatbyRawPayloadPlatbyRawEdgeArgs, WithTypename<PlatbyRawsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<UpdatePlatbyRawPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  UpdateRoomAttachmentPayload?: {
    attachmentByObjectName?: GraphCacheResolver<WithTypename<UpdateRoomAttachmentPayload>, Record<string, never>, WithTypename<Attachment> | string>,
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateRoomAttachmentPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<UpdateRoomAttachmentPayload>, Record<string, never>, WithTypename<Query> | string>,
    room?: GraphCacheResolver<WithTypename<UpdateRoomAttachmentPayload>, Record<string, never>, WithTypename<Room> | string>,
    roomAttachment?: GraphCacheResolver<WithTypename<UpdateRoomAttachmentPayload>, Record<string, never>, WithTypename<RoomAttachment> | string>,
    roomAttachmentEdge?: GraphCacheResolver<WithTypename<UpdateRoomAttachmentPayload>, UpdateRoomAttachmentPayloadRoomAttachmentEdgeArgs, WithTypename<RoomAttachmentsEdge> | string>
  },
  UpdateRoomPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateRoomPayload>, Record<string, never>, Scalars['String'] | string>,
    locationByLocation?: GraphCacheResolver<WithTypename<UpdateRoomPayload>, Record<string, never>, WithTypename<Location> | string>,
    query?: GraphCacheResolver<WithTypename<UpdateRoomPayload>, Record<string, never>, WithTypename<Query> | string>,
    room?: GraphCacheResolver<WithTypename<UpdateRoomPayload>, Record<string, never>, WithTypename<Room> | string>,
    roomEdge?: GraphCacheResolver<WithTypename<UpdateRoomPayload>, UpdateRoomPayloadRoomEdgeArgs, WithTypename<RoomsEdge> | string>
  },
  UpdateRozpiPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateRozpiPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<UpdateRozpiPayload>, Record<string, never>, WithTypename<Query> | string>,
    rozpi?: GraphCacheResolver<WithTypename<UpdateRozpiPayload>, Record<string, never>, WithTypename<Rozpi> | string>,
    rozpiEdge?: GraphCacheResolver<WithTypename<UpdateRozpiPayload>, UpdateRozpiPayloadRozpiEdgeArgs, WithTypename<RozpisEdge> | string>,
    userByRTrener?: GraphCacheResolver<WithTypename<UpdateRozpiPayload>, Record<string, never>, WithTypename<User> | string>
  },
  UpdateRozpisItemPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateRozpisItemPayload>, Record<string, never>, Scalars['String'] | string>,
    paryByRiPartner?: GraphCacheResolver<WithTypename<UpdateRozpisItemPayload>, Record<string, never>, WithTypename<Pary> | string>,
    query?: GraphCacheResolver<WithTypename<UpdateRozpisItemPayload>, Record<string, never>, WithTypename<Query> | string>,
    rozpiByRiIdRodic?: GraphCacheResolver<WithTypename<UpdateRozpisItemPayload>, Record<string, never>, WithTypename<Rozpi> | string>,
    rozpisItem?: GraphCacheResolver<WithTypename<UpdateRozpisItemPayload>, Record<string, never>, WithTypename<RozpisItem> | string>,
    rozpisItemEdge?: GraphCacheResolver<WithTypename<UpdateRozpisItemPayload>, UpdateRozpisItemPayloadRozpisItemEdgeArgs, WithTypename<RozpisItemsEdge> | string>
  },
  UpdateSkupinyPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateSkupinyPayload>, Record<string, never>, Scalars['String'] | string>,
    cohortGroupByCohortGroup?: GraphCacheResolver<WithTypename<UpdateSkupinyPayload>, Record<string, never>, WithTypename<CohortGroup> | string>,
    query?: GraphCacheResolver<WithTypename<UpdateSkupinyPayload>, Record<string, never>, WithTypename<Query> | string>,
    skupiny?: GraphCacheResolver<WithTypename<UpdateSkupinyPayload>, Record<string, never>, WithTypename<Skupiny> | string>,
    skupinyEdge?: GraphCacheResolver<WithTypename<UpdateSkupinyPayload>, UpdateSkupinyPayloadSkupinyEdgeArgs, WithTypename<SkupiniesEdge> | string>
  },
  UpdateTenantAttachmentPayload?: {
    attachmentByObjectName?: GraphCacheResolver<WithTypename<UpdateTenantAttachmentPayload>, Record<string, never>, WithTypename<Attachment> | string>,
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateTenantAttachmentPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<UpdateTenantAttachmentPayload>, Record<string, never>, WithTypename<Query> | string>,
    tenant?: GraphCacheResolver<WithTypename<UpdateTenantAttachmentPayload>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantAttachment?: GraphCacheResolver<WithTypename<UpdateTenantAttachmentPayload>, Record<string, never>, WithTypename<TenantAttachment> | string>,
    tenantAttachmentEdge?: GraphCacheResolver<WithTypename<UpdateTenantAttachmentPayload>, UpdateTenantAttachmentPayloadTenantAttachmentEdgeArgs, WithTypename<TenantAttachmentsEdge> | string>
  },
  UpdateTenantLocationPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateTenantLocationPayload>, Record<string, never>, Scalars['String'] | string>,
    location?: GraphCacheResolver<WithTypename<UpdateTenantLocationPayload>, Record<string, never>, WithTypename<Location> | string>,
    query?: GraphCacheResolver<WithTypename<UpdateTenantLocationPayload>, Record<string, never>, WithTypename<Query> | string>,
    tenant?: GraphCacheResolver<WithTypename<UpdateTenantLocationPayload>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantLocation?: GraphCacheResolver<WithTypename<UpdateTenantLocationPayload>, Record<string, never>, WithTypename<TenantLocation> | string>,
    tenantLocationEdge?: GraphCacheResolver<WithTypename<UpdateTenantLocationPayload>, UpdateTenantLocationPayloadTenantLocationEdgeArgs, WithTypename<TenantLocationsEdge> | string>
  },
  UpdateTenantPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateTenantPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<UpdateTenantPayload>, Record<string, never>, WithTypename<Query> | string>,
    tenant?: GraphCacheResolver<WithTypename<UpdateTenantPayload>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantEdge?: GraphCacheResolver<WithTypename<UpdateTenantPayload>, UpdateTenantPayloadTenantEdgeArgs, WithTypename<TenantsEdge> | string>
  },
  UpdateTenantPersonPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateTenantPersonPayload>, Record<string, never>, Scalars['String'] | string>,
    person?: GraphCacheResolver<WithTypename<UpdateTenantPersonPayload>, Record<string, never>, WithTypename<Person> | string>,
    query?: GraphCacheResolver<WithTypename<UpdateTenantPersonPayload>, Record<string, never>, WithTypename<Query> | string>,
    tenant?: GraphCacheResolver<WithTypename<UpdateTenantPersonPayload>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantPerson?: GraphCacheResolver<WithTypename<UpdateTenantPersonPayload>, Record<string, never>, WithTypename<TenantPerson> | string>,
    tenantPersonEdge?: GraphCacheResolver<WithTypename<UpdateTenantPersonPayload>, UpdateTenantPersonPayloadTenantPersonEdgeArgs, WithTypename<TenantPeopleEdge> | string>
  },
  UpdateUpozorneniPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateUpozorneniPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<UpdateUpozorneniPayload>, Record<string, never>, WithTypename<Query> | string>,
    upozorneni?: GraphCacheResolver<WithTypename<UpdateUpozorneniPayload>, Record<string, never>, WithTypename<Upozorneni> | string>,
    upozorneniEdge?: GraphCacheResolver<WithTypename<UpdateUpozorneniPayload>, UpdateUpozorneniPayloadUpozorneniEdgeArgs, WithTypename<UpozornenisEdge> | string>,
    userByUpKdo?: GraphCacheResolver<WithTypename<UpdateUpozorneniPayload>, Record<string, never>, WithTypename<User> | string>
  },
  UpdateUpozorneniSkupinyPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateUpozorneniSkupinyPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<UpdateUpozorneniSkupinyPayload>, Record<string, never>, WithTypename<Query> | string>,
    skupinyByUpsIdSkupina?: GraphCacheResolver<WithTypename<UpdateUpozorneniSkupinyPayload>, Record<string, never>, WithTypename<Skupiny> | string>,
    upozorneniByUpsIdRodic?: GraphCacheResolver<WithTypename<UpdateUpozorneniSkupinyPayload>, Record<string, never>, WithTypename<Upozorneni> | string>,
    upozorneniSkupiny?: GraphCacheResolver<WithTypename<UpdateUpozorneniSkupinyPayload>, Record<string, never>, WithTypename<UpozorneniSkupiny> | string>,
    upozorneniSkupinyEdge?: GraphCacheResolver<WithTypename<UpdateUpozorneniSkupinyPayload>, UpdateUpozorneniSkupinyPayloadUpozorneniSkupinyEdgeArgs, WithTypename<UpozorneniSkupiniesEdge> | string>
  },
  UpdateUserPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateUserPayload>, Record<string, never>, Scalars['String'] | string>,
    permissionByUGroup?: GraphCacheResolver<WithTypename<UpdateUserPayload>, Record<string, never>, WithTypename<Permission> | string>,
    query?: GraphCacheResolver<WithTypename<UpdateUserPayload>, Record<string, never>, WithTypename<Query> | string>,
    skupinyByUSkupina?: GraphCacheResolver<WithTypename<UpdateUserPayload>, Record<string, never>, WithTypename<Skupiny> | string>,
    user?: GraphCacheResolver<WithTypename<UpdateUserPayload>, Record<string, never>, WithTypename<User> | string>,
    userEdge?: GraphCacheResolver<WithTypename<UpdateUserPayload>, UpdateUserPayloadUserEdgeArgs, WithTypename<UsersEdge> | string>
  },
  Upozorneni?: {
    id?: GraphCacheResolver<WithTypename<Upozorneni>, Record<string, never>, Scalars['BigInt'] | string>,
    isVisible?: GraphCacheResolver<WithTypename<Upozorneni>, Record<string, never>, Scalars['Boolean'] | string>,
    scheduledSince?: GraphCacheResolver<WithTypename<Upozorneni>, Record<string, never>, Scalars['Datetime'] | string>,
    scheduledUntil?: GraphCacheResolver<WithTypename<Upozorneni>, Record<string, never>, Scalars['Datetime'] | string>,
    sticky?: GraphCacheResolver<WithTypename<Upozorneni>, Record<string, never>, Scalars['Boolean'] | string>,
    tenantId?: GraphCacheResolver<WithTypename<Upozorneni>, Record<string, never>, Scalars['BigInt'] | string>,
    upBarvy?: GraphCacheResolver<WithTypename<Upozorneni>, Record<string, never>, Scalars['BigInt'] | string>,
    upId?: GraphCacheResolver<WithTypename<Upozorneni>, Record<string, never>, Scalars['BigInt'] | string>,
    upKdo?: GraphCacheResolver<WithTypename<Upozorneni>, Record<string, never>, Scalars['BigInt'] | string>,
    upLock?: GraphCacheResolver<WithTypename<Upozorneni>, Record<string, never>, Scalars['Boolean'] | string>,
    upNadpis?: GraphCacheResolver<WithTypename<Upozorneni>, Record<string, never>, Scalars['String'] | string>,
    upText?: GraphCacheResolver<WithTypename<Upozorneni>, Record<string, never>, Scalars['String'] | string>,
    upTimestamp?: GraphCacheResolver<WithTypename<Upozorneni>, Record<string, never>, Scalars['Datetime'] | string>,
    upTimestampAdd?: GraphCacheResolver<WithTypename<Upozorneni>, Record<string, never>, Scalars['Datetime'] | string>,
    upozorneniSkupiniesByUpsIdRodic?: GraphCacheResolver<WithTypename<Upozorneni>, UpozorneniUpozorneniSkupiniesByUpsIdRodicArgs, WithTypename<UpozorneniSkupiniesConnection> | string>,
    userByUpKdo?: GraphCacheResolver<WithTypename<Upozorneni>, Record<string, never>, WithTypename<User> | string>
  },
  UpozorneniSkupiniesConnection?: {
    edges?: GraphCacheResolver<WithTypename<UpozorneniSkupiniesConnection>, Record<string, never>, Array<WithTypename<UpozorneniSkupiniesEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<UpozorneniSkupiniesConnection>, Record<string, never>, Array<WithTypename<UpozorneniSkupiny> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<UpozorneniSkupiniesConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<UpozorneniSkupiniesConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  UpozorneniSkupiniesEdge?: {
    cursor?: GraphCacheResolver<WithTypename<UpozorneniSkupiniesEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<UpozorneniSkupiniesEdge>, Record<string, never>, WithTypename<UpozorneniSkupiny> | string>
  },
  UpozorneniSkupiny?: {
    id?: GraphCacheResolver<WithTypename<UpozorneniSkupiny>, Record<string, never>, Scalars['BigInt'] | string>,
    skupinyByUpsIdSkupina?: GraphCacheResolver<WithTypename<UpozorneniSkupiny>, Record<string, never>, WithTypename<Skupiny> | string>,
    tenantId?: GraphCacheResolver<WithTypename<UpozorneniSkupiny>, Record<string, never>, Scalars['BigInt'] | string>,
    upozorneniByUpsIdRodic?: GraphCacheResolver<WithTypename<UpozorneniSkupiny>, Record<string, never>, WithTypename<Upozorneni> | string>,
    upsColor?: GraphCacheResolver<WithTypename<UpozorneniSkupiny>, Record<string, never>, Scalars['String'] | string>,
    upsId?: GraphCacheResolver<WithTypename<UpozorneniSkupiny>, Record<string, never>, Scalars['BigInt'] | string>,
    upsIdRodic?: GraphCacheResolver<WithTypename<UpozorneniSkupiny>, Record<string, never>, Scalars['BigInt'] | string>,
    upsIdSkupina?: GraphCacheResolver<WithTypename<UpozorneniSkupiny>, Record<string, never>, Scalars['BigInt'] | string>
  },
  UpozornenisConnection?: {
    edges?: GraphCacheResolver<WithTypename<UpozornenisConnection>, Record<string, never>, Array<WithTypename<UpozornenisEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<UpozornenisConnection>, Record<string, never>, Array<WithTypename<Upozorneni> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<UpozornenisConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<UpozornenisConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  UpozornenisEdge?: {
    cursor?: GraphCacheResolver<WithTypename<UpozornenisEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<UpozornenisEdge>, Record<string, never>, WithTypename<Upozorneni> | string>
  },
  User?: {
    akceItemsByAiUser?: GraphCacheResolver<WithTypename<User>, UserAkceItemsByAiUserArgs, WithTypename<AkceItemsConnection> | string>,
    aktualitiesByAtKdo?: GraphCacheResolver<WithTypename<User>, UserAktualitiesByAtKdoArgs, WithTypename<AktualitiesConnection> | string>,
    attachmentsByUploadedBy?: GraphCacheResolver<WithTypename<User>, UserAttachmentsByUploadedByArgs, WithTypename<AttachmentsConnection> | string>,
    attendeeExternalsByConfirmedBy?: GraphCacheResolver<WithTypename<User>, UserAttendeeExternalsByConfirmedByArgs, WithTypename<AttendeeExternalsConnection> | string>,
    attendeeExternalsByManagedBy?: GraphCacheResolver<WithTypename<User>, UserAttendeeExternalsByManagedByArgs, WithTypename<AttendeeExternalsConnection> | string>,
    attendeeUsers?: GraphCacheResolver<WithTypename<User>, UserAttendeeUsersArgs, WithTypename<AttendeeUsersConnection> | string>,
    dateOfNewestPayment?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['Date'] | string>,
    dateOfOldestPayment?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['Date'] | string>,
    dokumentiesByDKdo?: GraphCacheResolver<WithTypename<User>, UserDokumentiesByDKdoArgs, WithTypename<DokumentiesConnection> | string>,
    fullName?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['String'] | string>,
    galerieFotosByGfKdo?: GraphCacheResolver<WithTypename<User>, UserGalerieFotosByGfKdoArgs, WithTypename<GalerieFotosConnection> | string>,
    hasValidPayment?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['Boolean'] | string>,
    id?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['BigInt'] | string>,
    inPublicCohort?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['Boolean'] | string>,
    nabidkasByNTrener?: GraphCacheResolver<WithTypename<User>, UserNabidkasByNTrenerArgs, WithTypename<NabidkasConnection> | string>,
    pariesByPIdPartner?: GraphCacheResolver<WithTypename<User>, UserPariesByPIdPartnerArgs, WithTypename<PariesConnection> | string>,
    pariesByPIdPartnerka?: GraphCacheResolver<WithTypename<User>, UserPariesByPIdPartnerkaArgs, WithTypename<PariesConnection> | string>,
    paryNavrhsByPnNavrhl?: GraphCacheResolver<WithTypename<User>, UserParyNavrhsByPnNavrhlArgs, WithTypename<ParyNavrhsConnection> | string>,
    paryNavrhsByPnPartner?: GraphCacheResolver<WithTypename<User>, UserParyNavrhsByPnPartnerArgs, WithTypename<ParyNavrhsConnection> | string>,
    paryNavrhsByPnPartnerka?: GraphCacheResolver<WithTypename<User>, UserParyNavrhsByPnPartnerkaArgs, WithTypename<ParyNavrhsConnection> | string>,
    permissionByUGroup?: GraphCacheResolver<WithTypename<User>, Record<string, never>, WithTypename<Permission> | string>,
    platbyItemsByPiIdUser?: GraphCacheResolver<WithTypename<User>, UserPlatbyItemsByPiIdUserArgs, WithTypename<PlatbyItemsConnection> | string>,
    rozpisByRTrener?: GraphCacheResolver<WithTypename<User>, UserRozpisByRTrenerArgs, WithTypename<RozpisConnection> | string>,
    sessionsBySsUser?: GraphCacheResolver<WithTypename<User>, UserSessionsBySsUserArgs, WithTypename<SessionsConnection> | string>,
    skupinyByUSkupina?: GraphCacheResolver<WithTypename<User>, Record<string, never>, WithTypename<Skupiny> | string>,
    tenantId?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['BigInt'] | string>,
    uBan?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['Boolean'] | string>,
    uCity?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['String'] | string>,
    uConfirmed?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['Boolean'] | string>,
    uConscriptionNumber?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['String'] | string>,
    uCreatedAt?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['Datetime'] | string>,
    uDancer?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['Boolean'] | string>,
    uDistrict?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['String'] | string>,
    uEmail?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['String'] | string>,
    uGdprSignedAt?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['Datetime'] | string>,
    uGroup?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['BigInt'] | string>,
    uId?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['BigInt'] | string>,
    uJmeno?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['String'] | string>,
    uLevel?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['Int'] | string>,
    uLock?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['Boolean'] | string>,
    uLogin?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['String'] | string>,
    uMemberSince?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['Datetime'] | string>,
    uMemberUntil?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['Datetime'] | string>,
    uNarozeni?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['Date'] | string>,
    uNationality?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['String'] | string>,
    uOrientationNumber?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['String'] | string>,
    uPass?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['String'] | string>,
    uPohlavi?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['String'] | string>,
    uPostalCode?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['String'] | string>,
    uPoznamky?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['String'] | string>,
    uPrijmeni?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['String'] | string>,
    uRodneCislo?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['String'] | string>,
    uSkupina?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['BigInt'] | string>,
    uStreet?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['String'] | string>,
    uSystem?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['Boolean'] | string>,
    uTeacher?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['Boolean'] | string>,
    uTelefon?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['String'] | string>,
    uTimestamp?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['Datetime'] | string>,
    upozornenisByUpKdo?: GraphCacheResolver<WithTypename<User>, UserUpozornenisByUpKdoArgs, WithTypename<UpozornenisConnection> | string>
  },
  UsersConnection?: {
    edges?: GraphCacheResolver<WithTypename<UsersConnection>, Record<string, never>, Array<WithTypename<UsersEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<UsersConnection>, Record<string, never>, Array<WithTypename<User> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<UsersConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<UsersConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  UsersEdge?: {
    cursor?: GraphCacheResolver<WithTypename<UsersEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<UsersEdge>, Record<string, never>, WithTypename<User> | string>
  },
  VerifyFunctionPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<VerifyFunctionPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<VerifyFunctionPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  Video?: {
    vAuthor?: GraphCacheResolver<WithTypename<Video>, Record<string, never>, Scalars['String'] | string>,
    vCreatedAt?: GraphCacheResolver<WithTypename<Video>, Record<string, never>, Scalars['Datetime'] | string>,
    vDescription?: GraphCacheResolver<WithTypename<Video>, Record<string, never>, Scalars['String'] | string>,
    vId?: GraphCacheResolver<WithTypename<Video>, Record<string, never>, Scalars['BigInt'] | string>,
    vPlaylist?: GraphCacheResolver<WithTypename<Video>, Record<string, never>, Scalars['String'] | string>,
    vTitle?: GraphCacheResolver<WithTypename<Video>, Record<string, never>, Scalars['String'] | string>,
    vUpdatedAt?: GraphCacheResolver<WithTypename<Video>, Record<string, never>, Scalars['Datetime'] | string>,
    vUri?: GraphCacheResolver<WithTypename<Video>, Record<string, never>, Scalars['String'] | string>
  },
  VideosConnection?: {
    edges?: GraphCacheResolver<WithTypename<VideosConnection>, Record<string, never>, Array<WithTypename<VideosEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<VideosConnection>, Record<string, never>, Array<WithTypename<Video> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<VideosConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<VideosConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  VideosEdge?: {
    cursor?: GraphCacheResolver<WithTypename<VideosEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<VideosEdge>, Record<string, never>, WithTypename<Video> | string>
  }
};

export type GraphCacheOptimisticUpdaters = {
  bookLesson?: GraphCacheOptimisticMutationResolver<MutationBookLessonArgs, Maybe<WithTypename<BookLessonPayload>>>,
  cancelLesson?: GraphCacheOptimisticMutationResolver<MutationCancelLessonArgs, Maybe<WithTypename<CancelLessonPayload>>>,
  cancelParticipation?: GraphCacheOptimisticMutationResolver<MutationCancelParticipationArgs, Maybe<WithTypename<CancelParticipationPayload>>>,
  changePassword?: GraphCacheOptimisticMutationResolver<MutationChangePasswordArgs, Maybe<WithTypename<ChangePasswordPayload>>>,
  confirmUser?: GraphCacheOptimisticMutationResolver<MutationConfirmUserArgs, Maybe<WithTypename<ConfirmUserPayload>>>,
  createAkce?: GraphCacheOptimisticMutationResolver<MutationCreateAkceArgs, Maybe<WithTypename<CreateAkcePayload>>>,
  createAkceItem?: GraphCacheOptimisticMutationResolver<MutationCreateAkceItemArgs, Maybe<WithTypename<CreateAkceItemPayload>>>,
  createAktuality?: GraphCacheOptimisticMutationResolver<MutationCreateAktualityArgs, Maybe<WithTypename<CreateAktualityPayload>>>,
  createAttachment?: GraphCacheOptimisticMutationResolver<MutationCreateAttachmentArgs, Maybe<WithTypename<CreateAttachmentPayload>>>,
  createAttendeeExternal?: GraphCacheOptimisticMutationResolver<MutationCreateAttendeeExternalArgs, Maybe<WithTypename<CreateAttendeeExternalPayload>>>,
  createAttendeeUser?: GraphCacheOptimisticMutationResolver<MutationCreateAttendeeUserArgs, Maybe<WithTypename<CreateAttendeeUserPayload>>>,
  createCohortGroup?: GraphCacheOptimisticMutationResolver<MutationCreateCohortGroupArgs, Maybe<WithTypename<CreateCohortGroupPayload>>>,
  createCouple?: GraphCacheOptimisticMutationResolver<MutationCreateCoupleArgs, Maybe<WithTypename<CreateCouplePayload>>>,
  createDokumenty?: GraphCacheOptimisticMutationResolver<MutationCreateDokumentyArgs, Maybe<WithTypename<CreateDokumentyPayload>>>,
  createEvent?: GraphCacheOptimisticMutationResolver<MutationCreateEventArgs, Maybe<WithTypename<CreateEventPayload>>>,
  createFormResponse?: GraphCacheOptimisticMutationResolver<MutationCreateFormResponseArgs, Maybe<WithTypename<CreateFormResponsePayload>>>,
  createGalerieDir?: GraphCacheOptimisticMutationResolver<MutationCreateGalerieDirArgs, Maybe<WithTypename<CreateGalerieDirPayload>>>,
  createGalerieFoto?: GraphCacheOptimisticMutationResolver<MutationCreateGalerieFotoArgs, Maybe<WithTypename<CreateGalerieFotoPayload>>>,
  createLocation?: GraphCacheOptimisticMutationResolver<MutationCreateLocationArgs, Maybe<WithTypename<CreateLocationPayload>>>,
  createLocationAttachment?: GraphCacheOptimisticMutationResolver<MutationCreateLocationAttachmentArgs, Maybe<WithTypename<CreateLocationAttachmentPayload>>>,
  createNabidka?: GraphCacheOptimisticMutationResolver<MutationCreateNabidkaArgs, Maybe<WithTypename<CreateNabidkaPayload>>>,
  createNabidkaItem?: GraphCacheOptimisticMutationResolver<MutationCreateNabidkaItemArgs, Maybe<WithTypename<CreateNabidkaItemPayload>>>,
  createPage?: GraphCacheOptimisticMutationResolver<MutationCreatePageArgs, Maybe<WithTypename<CreatePagePayload>>>,
  createParameter?: GraphCacheOptimisticMutationResolver<MutationCreateParameterArgs, Maybe<WithTypename<CreateParameterPayload>>>,
  createParticipation?: GraphCacheOptimisticMutationResolver<MutationCreateParticipationArgs, Maybe<WithTypename<CreateParticipationPayload>>>,
  createParticipationExternal?: GraphCacheOptimisticMutationResolver<MutationCreateParticipationExternalArgs, Maybe<WithTypename<CreateParticipationExternalPayload>>>,
  createPary?: GraphCacheOptimisticMutationResolver<MutationCreateParyArgs, Maybe<WithTypename<CreateParyPayload>>>,
  createParyNavrh?: GraphCacheOptimisticMutationResolver<MutationCreateParyNavrhArgs, Maybe<WithTypename<CreateParyNavrhPayload>>>,
  createPermission?: GraphCacheOptimisticMutationResolver<MutationCreatePermissionArgs, Maybe<WithTypename<CreatePermissionPayload>>>,
  createPerson?: GraphCacheOptimisticMutationResolver<MutationCreatePersonArgs, Maybe<WithTypename<CreatePersonPayload>>>,
  createPlatbyCategory?: GraphCacheOptimisticMutationResolver<MutationCreatePlatbyCategoryArgs, Maybe<WithTypename<CreatePlatbyCategoryPayload>>>,
  createPlatbyCategoryGroup?: GraphCacheOptimisticMutationResolver<MutationCreatePlatbyCategoryGroupArgs, Maybe<WithTypename<CreatePlatbyCategoryGroupPayload>>>,
  createPlatbyGroup?: GraphCacheOptimisticMutationResolver<MutationCreatePlatbyGroupArgs, Maybe<WithTypename<CreatePlatbyGroupPayload>>>,
  createPlatbyGroupSkupina?: GraphCacheOptimisticMutationResolver<MutationCreatePlatbyGroupSkupinaArgs, Maybe<WithTypename<CreatePlatbyGroupSkupinaPayload>>>,
  createPlatbyItem?: GraphCacheOptimisticMutationResolver<MutationCreatePlatbyItemArgs, Maybe<WithTypename<CreatePlatbyItemPayload>>>,
  createPlatbyRaw?: GraphCacheOptimisticMutationResolver<MutationCreatePlatbyRawArgs, Maybe<WithTypename<CreatePlatbyRawPayload>>>,
  createRoom?: GraphCacheOptimisticMutationResolver<MutationCreateRoomArgs, Maybe<WithTypename<CreateRoomPayload>>>,
  createRoomAttachment?: GraphCacheOptimisticMutationResolver<MutationCreateRoomAttachmentArgs, Maybe<WithTypename<CreateRoomAttachmentPayload>>>,
  createRozpi?: GraphCacheOptimisticMutationResolver<MutationCreateRozpiArgs, Maybe<WithTypename<CreateRozpiPayload>>>,
  createRozpisItem?: GraphCacheOptimisticMutationResolver<MutationCreateRozpisItemArgs, Maybe<WithTypename<CreateRozpisItemPayload>>>,
  createSkupiny?: GraphCacheOptimisticMutationResolver<MutationCreateSkupinyArgs, Maybe<WithTypename<CreateSkupinyPayload>>>,
  createTenant?: GraphCacheOptimisticMutationResolver<MutationCreateTenantArgs, Maybe<WithTypename<CreateTenantPayload>>>,
  createTenantAttachment?: GraphCacheOptimisticMutationResolver<MutationCreateTenantAttachmentArgs, Maybe<WithTypename<CreateTenantAttachmentPayload>>>,
  createTenantLocation?: GraphCacheOptimisticMutationResolver<MutationCreateTenantLocationArgs, Maybe<WithTypename<CreateTenantLocationPayload>>>,
  createTenantPerson?: GraphCacheOptimisticMutationResolver<MutationCreateTenantPersonArgs, Maybe<WithTypename<CreateTenantPersonPayload>>>,
  createUpozorneni?: GraphCacheOptimisticMutationResolver<MutationCreateUpozorneniArgs, Maybe<WithTypename<CreateUpozorneniPayload>>>,
  createUpozorneniSkupiny?: GraphCacheOptimisticMutationResolver<MutationCreateUpozorneniSkupinyArgs, Maybe<WithTypename<CreateUpozorneniSkupinyPayload>>>,
  createUser?: GraphCacheOptimisticMutationResolver<MutationCreateUserArgs, Maybe<WithTypename<CreateUserPayload>>>,
  deleteAktuality?: GraphCacheOptimisticMutationResolver<MutationDeleteAktualityArgs, Maybe<WithTypename<DeleteAktualityPayload>>>,
  deleteAttachment?: GraphCacheOptimisticMutationResolver<MutationDeleteAttachmentArgs, Maybe<WithTypename<DeleteAttachmentPayload>>>,
  deleteAttendeeExternal?: GraphCacheOptimisticMutationResolver<MutationDeleteAttendeeExternalArgs, Maybe<WithTypename<DeleteAttendeeExternalPayload>>>,
  deleteAttendeeUser?: GraphCacheOptimisticMutationResolver<MutationDeleteAttendeeUserArgs, Maybe<WithTypename<DeleteAttendeeUserPayload>>>,
  deleteAttendeeUserByUserIdAndEventId?: GraphCacheOptimisticMutationResolver<MutationDeleteAttendeeUserByUserIdAndEventIdArgs, Maybe<WithTypename<DeleteAttendeeUserPayload>>>,
  deleteCohortGroup?: GraphCacheOptimisticMutationResolver<MutationDeleteCohortGroupArgs, Maybe<WithTypename<DeleteCohortGroupPayload>>>,
  deleteDokumenty?: GraphCacheOptimisticMutationResolver<MutationDeleteDokumentyArgs, Maybe<WithTypename<DeleteDokumentyPayload>>>,
  deleteEvent?: GraphCacheOptimisticMutationResolver<MutationDeleteEventArgs, Maybe<WithTypename<DeleteEventPayload>>>,
  deleteFormResponse?: GraphCacheOptimisticMutationResolver<MutationDeleteFormResponseArgs, Maybe<WithTypename<DeleteFormResponsePayload>>>,
  deleteGalerieDir?: GraphCacheOptimisticMutationResolver<MutationDeleteGalerieDirArgs, Maybe<WithTypename<DeleteGalerieDirPayload>>>,
  deleteGalerieFoto?: GraphCacheOptimisticMutationResolver<MutationDeleteGalerieFotoArgs, Maybe<WithTypename<DeleteGalerieFotoPayload>>>,
  deleteLocation?: GraphCacheOptimisticMutationResolver<MutationDeleteLocationArgs, Maybe<WithTypename<DeleteLocationPayload>>>,
  deleteLocationAttachment?: GraphCacheOptimisticMutationResolver<MutationDeleteLocationAttachmentArgs, Maybe<WithTypename<DeleteLocationAttachmentPayload>>>,
  deleteNabidka?: GraphCacheOptimisticMutationResolver<MutationDeleteNabidkaArgs, Maybe<WithTypename<DeleteNabidkaPayload>>>,
  deleteNabidkaItem?: GraphCacheOptimisticMutationResolver<MutationDeleteNabidkaItemArgs, Maybe<WithTypename<DeleteNabidkaItemPayload>>>,
  deleteNabidkaItemByNiPartnerAndNiIdRodic?: GraphCacheOptimisticMutationResolver<MutationDeleteNabidkaItemByNiPartnerAndNiIdRodicArgs, Maybe<WithTypename<DeleteNabidkaItemPayload>>>,
  deleteParameter?: GraphCacheOptimisticMutationResolver<MutationDeleteParameterArgs, Maybe<WithTypename<DeleteParameterPayload>>>,
  deletePary?: GraphCacheOptimisticMutationResolver<MutationDeleteParyArgs, Maybe<WithTypename<DeleteParyPayload>>>,
  deleteParyNavrh?: GraphCacheOptimisticMutationResolver<MutationDeleteParyNavrhArgs, Maybe<WithTypename<DeleteParyNavrhPayload>>>,
  deletePermission?: GraphCacheOptimisticMutationResolver<MutationDeletePermissionArgs, Maybe<WithTypename<DeletePermissionPayload>>>,
  deletePerson?: GraphCacheOptimisticMutationResolver<MutationDeletePersonArgs, Maybe<WithTypename<DeletePersonPayload>>>,
  deletePlatbyCategory?: GraphCacheOptimisticMutationResolver<MutationDeletePlatbyCategoryArgs, Maybe<WithTypename<DeletePlatbyCategoryPayload>>>,
  deletePlatbyCategoryGroup?: GraphCacheOptimisticMutationResolver<MutationDeletePlatbyCategoryGroupArgs, Maybe<WithTypename<DeletePlatbyCategoryGroupPayload>>>,
  deletePlatbyGroup?: GraphCacheOptimisticMutationResolver<MutationDeletePlatbyGroupArgs, Maybe<WithTypename<DeletePlatbyGroupPayload>>>,
  deletePlatbyGroupSkupina?: GraphCacheOptimisticMutationResolver<MutationDeletePlatbyGroupSkupinaArgs, Maybe<WithTypename<DeletePlatbyGroupSkupinaPayload>>>,
  deletePlatbyItem?: GraphCacheOptimisticMutationResolver<MutationDeletePlatbyItemArgs, Maybe<WithTypename<DeletePlatbyItemPayload>>>,
  deletePlatbyRaw?: GraphCacheOptimisticMutationResolver<MutationDeletePlatbyRawArgs, Maybe<WithTypename<DeletePlatbyRawPayload>>>,
  deleteRoom?: GraphCacheOptimisticMutationResolver<MutationDeleteRoomArgs, Maybe<WithTypename<DeleteRoomPayload>>>,
  deleteRoomAttachment?: GraphCacheOptimisticMutationResolver<MutationDeleteRoomAttachmentArgs, Maybe<WithTypename<DeleteRoomAttachmentPayload>>>,
  deleteRozpi?: GraphCacheOptimisticMutationResolver<MutationDeleteRozpiArgs, Maybe<WithTypename<DeleteRozpiPayload>>>,
  deleteRozpisItem?: GraphCacheOptimisticMutationResolver<MutationDeleteRozpisItemArgs, Maybe<WithTypename<DeleteRozpisItemPayload>>>,
  deleteSkupiny?: GraphCacheOptimisticMutationResolver<MutationDeleteSkupinyArgs, Maybe<WithTypename<DeleteSkupinyPayload>>>,
  deleteTenant?: GraphCacheOptimisticMutationResolver<MutationDeleteTenantArgs, Maybe<WithTypename<DeleteTenantPayload>>>,
  deleteTenantAttachment?: GraphCacheOptimisticMutationResolver<MutationDeleteTenantAttachmentArgs, Maybe<WithTypename<DeleteTenantAttachmentPayload>>>,
  deleteTenantLocation?: GraphCacheOptimisticMutationResolver<MutationDeleteTenantLocationArgs, Maybe<WithTypename<DeleteTenantLocationPayload>>>,
  deleteTenantPerson?: GraphCacheOptimisticMutationResolver<MutationDeleteTenantPersonArgs, Maybe<WithTypename<DeleteTenantPersonPayload>>>,
  deleteUpozorneni?: GraphCacheOptimisticMutationResolver<MutationDeleteUpozorneniArgs, Maybe<WithTypename<DeleteUpozorneniPayload>>>,
  deleteUpozorneniSkupiny?: GraphCacheOptimisticMutationResolver<MutationDeleteUpozorneniSkupinyArgs, Maybe<WithTypename<DeleteUpozorneniSkupinyPayload>>>,
  deleteUser?: GraphCacheOptimisticMutationResolver<MutationDeleteUserArgs, Maybe<WithTypename<DeleteUserPayload>>>,
  fixUnpairedCouples?: GraphCacheOptimisticMutationResolver<MutationFixUnpairedCouplesArgs, Maybe<WithTypename<FixUnpairedCouplesPayload>>>,
  login?: GraphCacheOptimisticMutationResolver<MutationLoginArgs, Maybe<WithTypename<LoginPayload>>>,
  logout?: GraphCacheOptimisticMutationResolver<MutationLogoutArgs, Maybe<WithTypename<LogoutPayload>>>,
  prospectFormDancer?: GraphCacheOptimisticMutationResolver<MutationProspectFormDancerArgs, Maybe<WithTypename<ProspectFormDancerPayload>>>,
  reservationSetDesiredLessons?: GraphCacheOptimisticMutationResolver<MutationReservationSetDesiredLessonsArgs, Maybe<WithTypename<ReservationSetDesiredLessonsPayload>>>,
  resetPassword?: GraphCacheOptimisticMutationResolver<MutationResetPasswordArgs, Maybe<WithTypename<ResetPasswordPayload>>>,
  submitForm?: GraphCacheOptimisticMutationResolver<MutationSubmitFormArgs, Maybe<WithTypename<SubmitFormPayload>>>,
  updateAktuality?: GraphCacheOptimisticMutationResolver<MutationUpdateAktualityArgs, Maybe<WithTypename<UpdateAktualityPayload>>>,
  updateAttachment?: GraphCacheOptimisticMutationResolver<MutationUpdateAttachmentArgs, Maybe<WithTypename<UpdateAttachmentPayload>>>,
  updateAttendeeExternal?: GraphCacheOptimisticMutationResolver<MutationUpdateAttendeeExternalArgs, Maybe<WithTypename<UpdateAttendeeExternalPayload>>>,
  updateAttendeeUser?: GraphCacheOptimisticMutationResolver<MutationUpdateAttendeeUserArgs, Maybe<WithTypename<UpdateAttendeeUserPayload>>>,
  updateAttendeeUserByUserIdAndEventId?: GraphCacheOptimisticMutationResolver<MutationUpdateAttendeeUserByUserIdAndEventIdArgs, Maybe<WithTypename<UpdateAttendeeUserPayload>>>,
  updateCohortGroup?: GraphCacheOptimisticMutationResolver<MutationUpdateCohortGroupArgs, Maybe<WithTypename<UpdateCohortGroupPayload>>>,
  updateDokumenty?: GraphCacheOptimisticMutationResolver<MutationUpdateDokumentyArgs, Maybe<WithTypename<UpdateDokumentyPayload>>>,
  updateEvent?: GraphCacheOptimisticMutationResolver<MutationUpdateEventArgs, Maybe<WithTypename<UpdateEventPayload>>>,
  updateFormResponse?: GraphCacheOptimisticMutationResolver<MutationUpdateFormResponseArgs, Maybe<WithTypename<UpdateFormResponsePayload>>>,
  updateGalerieDir?: GraphCacheOptimisticMutationResolver<MutationUpdateGalerieDirArgs, Maybe<WithTypename<UpdateGalerieDirPayload>>>,
  updateGalerieFoto?: GraphCacheOptimisticMutationResolver<MutationUpdateGalerieFotoArgs, Maybe<WithTypename<UpdateGalerieFotoPayload>>>,
  updateLocation?: GraphCacheOptimisticMutationResolver<MutationUpdateLocationArgs, Maybe<WithTypename<UpdateLocationPayload>>>,
  updateLocationAttachment?: GraphCacheOptimisticMutationResolver<MutationUpdateLocationAttachmentArgs, Maybe<WithTypename<UpdateLocationAttachmentPayload>>>,
  updateNabidka?: GraphCacheOptimisticMutationResolver<MutationUpdateNabidkaArgs, Maybe<WithTypename<UpdateNabidkaPayload>>>,
  updateNabidkaItem?: GraphCacheOptimisticMutationResolver<MutationUpdateNabidkaItemArgs, Maybe<WithTypename<UpdateNabidkaItemPayload>>>,
  updateNabidkaItemByNiPartnerAndNiIdRodic?: GraphCacheOptimisticMutationResolver<MutationUpdateNabidkaItemByNiPartnerAndNiIdRodicArgs, Maybe<WithTypename<UpdateNabidkaItemPayload>>>,
  updatePage?: GraphCacheOptimisticMutationResolver<MutationUpdatePageArgs, Maybe<WithTypename<UpdatePagePayload>>>,
  updatePageByUrl?: GraphCacheOptimisticMutationResolver<MutationUpdatePageByUrlArgs, Maybe<WithTypename<UpdatePagePayload>>>,
  updateParameter?: GraphCacheOptimisticMutationResolver<MutationUpdateParameterArgs, Maybe<WithTypename<UpdateParameterPayload>>>,
  updatePary?: GraphCacheOptimisticMutationResolver<MutationUpdateParyArgs, Maybe<WithTypename<UpdateParyPayload>>>,
  updateParyNavrh?: GraphCacheOptimisticMutationResolver<MutationUpdateParyNavrhArgs, Maybe<WithTypename<UpdateParyNavrhPayload>>>,
  updatePermission?: GraphCacheOptimisticMutationResolver<MutationUpdatePermissionArgs, Maybe<WithTypename<UpdatePermissionPayload>>>,
  updatePerson?: GraphCacheOptimisticMutationResolver<MutationUpdatePersonArgs, Maybe<WithTypename<UpdatePersonPayload>>>,
  updatePlatbyCategory?: GraphCacheOptimisticMutationResolver<MutationUpdatePlatbyCategoryArgs, Maybe<WithTypename<UpdatePlatbyCategoryPayload>>>,
  updatePlatbyCategoryGroup?: GraphCacheOptimisticMutationResolver<MutationUpdatePlatbyCategoryGroupArgs, Maybe<WithTypename<UpdatePlatbyCategoryGroupPayload>>>,
  updatePlatbyGroup?: GraphCacheOptimisticMutationResolver<MutationUpdatePlatbyGroupArgs, Maybe<WithTypename<UpdatePlatbyGroupPayload>>>,
  updatePlatbyGroupSkupina?: GraphCacheOptimisticMutationResolver<MutationUpdatePlatbyGroupSkupinaArgs, Maybe<WithTypename<UpdatePlatbyGroupSkupinaPayload>>>,
  updatePlatbyItem?: GraphCacheOptimisticMutationResolver<MutationUpdatePlatbyItemArgs, Maybe<WithTypename<UpdatePlatbyItemPayload>>>,
  updatePlatbyRaw?: GraphCacheOptimisticMutationResolver<MutationUpdatePlatbyRawArgs, Maybe<WithTypename<UpdatePlatbyRawPayload>>>,
  updateRoom?: GraphCacheOptimisticMutationResolver<MutationUpdateRoomArgs, Maybe<WithTypename<UpdateRoomPayload>>>,
  updateRoomAttachment?: GraphCacheOptimisticMutationResolver<MutationUpdateRoomAttachmentArgs, Maybe<WithTypename<UpdateRoomAttachmentPayload>>>,
  updateRozpi?: GraphCacheOptimisticMutationResolver<MutationUpdateRozpiArgs, Maybe<WithTypename<UpdateRozpiPayload>>>,
  updateRozpisItem?: GraphCacheOptimisticMutationResolver<MutationUpdateRozpisItemArgs, Maybe<WithTypename<UpdateRozpisItemPayload>>>,
  updateSkupiny?: GraphCacheOptimisticMutationResolver<MutationUpdateSkupinyArgs, Maybe<WithTypename<UpdateSkupinyPayload>>>,
  updateTenant?: GraphCacheOptimisticMutationResolver<MutationUpdateTenantArgs, Maybe<WithTypename<UpdateTenantPayload>>>,
  updateTenantAttachment?: GraphCacheOptimisticMutationResolver<MutationUpdateTenantAttachmentArgs, Maybe<WithTypename<UpdateTenantAttachmentPayload>>>,
  updateTenantLocation?: GraphCacheOptimisticMutationResolver<MutationUpdateTenantLocationArgs, Maybe<WithTypename<UpdateTenantLocationPayload>>>,
  updateTenantPerson?: GraphCacheOptimisticMutationResolver<MutationUpdateTenantPersonArgs, Maybe<WithTypename<UpdateTenantPersonPayload>>>,
  updateUpozorneni?: GraphCacheOptimisticMutationResolver<MutationUpdateUpozorneniArgs, Maybe<WithTypename<UpdateUpozorneniPayload>>>,
  updateUpozorneniSkupiny?: GraphCacheOptimisticMutationResolver<MutationUpdateUpozorneniSkupinyArgs, Maybe<WithTypename<UpdateUpozorneniSkupinyPayload>>>,
  updateUser?: GraphCacheOptimisticMutationResolver<MutationUpdateUserArgs, Maybe<WithTypename<UpdateUserPayload>>>,
  verifyFunction?: GraphCacheOptimisticMutationResolver<MutationVerifyFunctionArgs, Maybe<WithTypename<VerifyFunctionPayload>>>
};

export type GraphCacheUpdaters = {
  Mutation?: {
    bookLesson?: GraphCacheUpdateResolver<{ bookLesson: Maybe<WithTypename<BookLessonPayload>> }, MutationBookLessonArgs>,
    cancelLesson?: GraphCacheUpdateResolver<{ cancelLesson: Maybe<WithTypename<CancelLessonPayload>> }, MutationCancelLessonArgs>,
    cancelParticipation?: GraphCacheUpdateResolver<{ cancelParticipation: Maybe<WithTypename<CancelParticipationPayload>> }, MutationCancelParticipationArgs>,
    changePassword?: GraphCacheUpdateResolver<{ changePassword: Maybe<WithTypename<ChangePasswordPayload>> }, MutationChangePasswordArgs>,
    confirmUser?: GraphCacheUpdateResolver<{ confirmUser: Maybe<WithTypename<ConfirmUserPayload>> }, MutationConfirmUserArgs>,
    createAkce?: GraphCacheUpdateResolver<{ createAkce: Maybe<WithTypename<CreateAkcePayload>> }, MutationCreateAkceArgs>,
    createAkceItem?: GraphCacheUpdateResolver<{ createAkceItem: Maybe<WithTypename<CreateAkceItemPayload>> }, MutationCreateAkceItemArgs>,
    createAktuality?: GraphCacheUpdateResolver<{ createAktuality: Maybe<WithTypename<CreateAktualityPayload>> }, MutationCreateAktualityArgs>,
    createAttachment?: GraphCacheUpdateResolver<{ createAttachment: Maybe<WithTypename<CreateAttachmentPayload>> }, MutationCreateAttachmentArgs>,
    createAttendeeExternal?: GraphCacheUpdateResolver<{ createAttendeeExternal: Maybe<WithTypename<CreateAttendeeExternalPayload>> }, MutationCreateAttendeeExternalArgs>,
    createAttendeeUser?: GraphCacheUpdateResolver<{ createAttendeeUser: Maybe<WithTypename<CreateAttendeeUserPayload>> }, MutationCreateAttendeeUserArgs>,
    createCohortGroup?: GraphCacheUpdateResolver<{ createCohortGroup: Maybe<WithTypename<CreateCohortGroupPayload>> }, MutationCreateCohortGroupArgs>,
    createCouple?: GraphCacheUpdateResolver<{ createCouple: Maybe<WithTypename<CreateCouplePayload>> }, MutationCreateCoupleArgs>,
    createDokumenty?: GraphCacheUpdateResolver<{ createDokumenty: Maybe<WithTypename<CreateDokumentyPayload>> }, MutationCreateDokumentyArgs>,
    createEvent?: GraphCacheUpdateResolver<{ createEvent: Maybe<WithTypename<CreateEventPayload>> }, MutationCreateEventArgs>,
    createFormResponse?: GraphCacheUpdateResolver<{ createFormResponse: Maybe<WithTypename<CreateFormResponsePayload>> }, MutationCreateFormResponseArgs>,
    createGalerieDir?: GraphCacheUpdateResolver<{ createGalerieDir: Maybe<WithTypename<CreateGalerieDirPayload>> }, MutationCreateGalerieDirArgs>,
    createGalerieFoto?: GraphCacheUpdateResolver<{ createGalerieFoto: Maybe<WithTypename<CreateGalerieFotoPayload>> }, MutationCreateGalerieFotoArgs>,
    createLocation?: GraphCacheUpdateResolver<{ createLocation: Maybe<WithTypename<CreateLocationPayload>> }, MutationCreateLocationArgs>,
    createLocationAttachment?: GraphCacheUpdateResolver<{ createLocationAttachment: Maybe<WithTypename<CreateLocationAttachmentPayload>> }, MutationCreateLocationAttachmentArgs>,
    createNabidka?: GraphCacheUpdateResolver<{ createNabidka: Maybe<WithTypename<CreateNabidkaPayload>> }, MutationCreateNabidkaArgs>,
    createNabidkaItem?: GraphCacheUpdateResolver<{ createNabidkaItem: Maybe<WithTypename<CreateNabidkaItemPayload>> }, MutationCreateNabidkaItemArgs>,
    createPage?: GraphCacheUpdateResolver<{ createPage: Maybe<WithTypename<CreatePagePayload>> }, MutationCreatePageArgs>,
    createParameter?: GraphCacheUpdateResolver<{ createParameter: Maybe<WithTypename<CreateParameterPayload>> }, MutationCreateParameterArgs>,
    createParticipation?: GraphCacheUpdateResolver<{ createParticipation: Maybe<WithTypename<CreateParticipationPayload>> }, MutationCreateParticipationArgs>,
    createParticipationExternal?: GraphCacheUpdateResolver<{ createParticipationExternal: Maybe<WithTypename<CreateParticipationExternalPayload>> }, MutationCreateParticipationExternalArgs>,
    createPary?: GraphCacheUpdateResolver<{ createPary: Maybe<WithTypename<CreateParyPayload>> }, MutationCreateParyArgs>,
    createParyNavrh?: GraphCacheUpdateResolver<{ createParyNavrh: Maybe<WithTypename<CreateParyNavrhPayload>> }, MutationCreateParyNavrhArgs>,
    createPermission?: GraphCacheUpdateResolver<{ createPermission: Maybe<WithTypename<CreatePermissionPayload>> }, MutationCreatePermissionArgs>,
    createPerson?: GraphCacheUpdateResolver<{ createPerson: Maybe<WithTypename<CreatePersonPayload>> }, MutationCreatePersonArgs>,
    createPlatbyCategory?: GraphCacheUpdateResolver<{ createPlatbyCategory: Maybe<WithTypename<CreatePlatbyCategoryPayload>> }, MutationCreatePlatbyCategoryArgs>,
    createPlatbyCategoryGroup?: GraphCacheUpdateResolver<{ createPlatbyCategoryGroup: Maybe<WithTypename<CreatePlatbyCategoryGroupPayload>> }, MutationCreatePlatbyCategoryGroupArgs>,
    createPlatbyGroup?: GraphCacheUpdateResolver<{ createPlatbyGroup: Maybe<WithTypename<CreatePlatbyGroupPayload>> }, MutationCreatePlatbyGroupArgs>,
    createPlatbyGroupSkupina?: GraphCacheUpdateResolver<{ createPlatbyGroupSkupina: Maybe<WithTypename<CreatePlatbyGroupSkupinaPayload>> }, MutationCreatePlatbyGroupSkupinaArgs>,
    createPlatbyItem?: GraphCacheUpdateResolver<{ createPlatbyItem: Maybe<WithTypename<CreatePlatbyItemPayload>> }, MutationCreatePlatbyItemArgs>,
    createPlatbyRaw?: GraphCacheUpdateResolver<{ createPlatbyRaw: Maybe<WithTypename<CreatePlatbyRawPayload>> }, MutationCreatePlatbyRawArgs>,
    createRoom?: GraphCacheUpdateResolver<{ createRoom: Maybe<WithTypename<CreateRoomPayload>> }, MutationCreateRoomArgs>,
    createRoomAttachment?: GraphCacheUpdateResolver<{ createRoomAttachment: Maybe<WithTypename<CreateRoomAttachmentPayload>> }, MutationCreateRoomAttachmentArgs>,
    createRozpi?: GraphCacheUpdateResolver<{ createRozpi: Maybe<WithTypename<CreateRozpiPayload>> }, MutationCreateRozpiArgs>,
    createRozpisItem?: GraphCacheUpdateResolver<{ createRozpisItem: Maybe<WithTypename<CreateRozpisItemPayload>> }, MutationCreateRozpisItemArgs>,
    createSkupiny?: GraphCacheUpdateResolver<{ createSkupiny: Maybe<WithTypename<CreateSkupinyPayload>> }, MutationCreateSkupinyArgs>,
    createTenant?: GraphCacheUpdateResolver<{ createTenant: Maybe<WithTypename<CreateTenantPayload>> }, MutationCreateTenantArgs>,
    createTenantAttachment?: GraphCacheUpdateResolver<{ createTenantAttachment: Maybe<WithTypename<CreateTenantAttachmentPayload>> }, MutationCreateTenantAttachmentArgs>,
    createTenantLocation?: GraphCacheUpdateResolver<{ createTenantLocation: Maybe<WithTypename<CreateTenantLocationPayload>> }, MutationCreateTenantLocationArgs>,
    createTenantPerson?: GraphCacheUpdateResolver<{ createTenantPerson: Maybe<WithTypename<CreateTenantPersonPayload>> }, MutationCreateTenantPersonArgs>,
    createUpozorneni?: GraphCacheUpdateResolver<{ createUpozorneni: Maybe<WithTypename<CreateUpozorneniPayload>> }, MutationCreateUpozorneniArgs>,
    createUpozorneniSkupiny?: GraphCacheUpdateResolver<{ createUpozorneniSkupiny: Maybe<WithTypename<CreateUpozorneniSkupinyPayload>> }, MutationCreateUpozorneniSkupinyArgs>,
    createUser?: GraphCacheUpdateResolver<{ createUser: Maybe<WithTypename<CreateUserPayload>> }, MutationCreateUserArgs>,
    deleteAktuality?: GraphCacheUpdateResolver<{ deleteAktuality: Maybe<WithTypename<DeleteAktualityPayload>> }, MutationDeleteAktualityArgs>,
    deleteAttachment?: GraphCacheUpdateResolver<{ deleteAttachment: Maybe<WithTypename<DeleteAttachmentPayload>> }, MutationDeleteAttachmentArgs>,
    deleteAttendeeExternal?: GraphCacheUpdateResolver<{ deleteAttendeeExternal: Maybe<WithTypename<DeleteAttendeeExternalPayload>> }, MutationDeleteAttendeeExternalArgs>,
    deleteAttendeeUser?: GraphCacheUpdateResolver<{ deleteAttendeeUser: Maybe<WithTypename<DeleteAttendeeUserPayload>> }, MutationDeleteAttendeeUserArgs>,
    deleteAttendeeUserByUserIdAndEventId?: GraphCacheUpdateResolver<{ deleteAttendeeUserByUserIdAndEventId: Maybe<WithTypename<DeleteAttendeeUserPayload>> }, MutationDeleteAttendeeUserByUserIdAndEventIdArgs>,
    deleteCohortGroup?: GraphCacheUpdateResolver<{ deleteCohortGroup: Maybe<WithTypename<DeleteCohortGroupPayload>> }, MutationDeleteCohortGroupArgs>,
    deleteDokumenty?: GraphCacheUpdateResolver<{ deleteDokumenty: Maybe<WithTypename<DeleteDokumentyPayload>> }, MutationDeleteDokumentyArgs>,
    deleteEvent?: GraphCacheUpdateResolver<{ deleteEvent: Maybe<WithTypename<DeleteEventPayload>> }, MutationDeleteEventArgs>,
    deleteFormResponse?: GraphCacheUpdateResolver<{ deleteFormResponse: Maybe<WithTypename<DeleteFormResponsePayload>> }, MutationDeleteFormResponseArgs>,
    deleteGalerieDir?: GraphCacheUpdateResolver<{ deleteGalerieDir: Maybe<WithTypename<DeleteGalerieDirPayload>> }, MutationDeleteGalerieDirArgs>,
    deleteGalerieFoto?: GraphCacheUpdateResolver<{ deleteGalerieFoto: Maybe<WithTypename<DeleteGalerieFotoPayload>> }, MutationDeleteGalerieFotoArgs>,
    deleteLocation?: GraphCacheUpdateResolver<{ deleteLocation: Maybe<WithTypename<DeleteLocationPayload>> }, MutationDeleteLocationArgs>,
    deleteLocationAttachment?: GraphCacheUpdateResolver<{ deleteLocationAttachment: Maybe<WithTypename<DeleteLocationAttachmentPayload>> }, MutationDeleteLocationAttachmentArgs>,
    deleteNabidka?: GraphCacheUpdateResolver<{ deleteNabidka: Maybe<WithTypename<DeleteNabidkaPayload>> }, MutationDeleteNabidkaArgs>,
    deleteNabidkaItem?: GraphCacheUpdateResolver<{ deleteNabidkaItem: Maybe<WithTypename<DeleteNabidkaItemPayload>> }, MutationDeleteNabidkaItemArgs>,
    deleteNabidkaItemByNiPartnerAndNiIdRodic?: GraphCacheUpdateResolver<{ deleteNabidkaItemByNiPartnerAndNiIdRodic: Maybe<WithTypename<DeleteNabidkaItemPayload>> }, MutationDeleteNabidkaItemByNiPartnerAndNiIdRodicArgs>,
    deleteParameter?: GraphCacheUpdateResolver<{ deleteParameter: Maybe<WithTypename<DeleteParameterPayload>> }, MutationDeleteParameterArgs>,
    deletePary?: GraphCacheUpdateResolver<{ deletePary: Maybe<WithTypename<DeleteParyPayload>> }, MutationDeleteParyArgs>,
    deleteParyNavrh?: GraphCacheUpdateResolver<{ deleteParyNavrh: Maybe<WithTypename<DeleteParyNavrhPayload>> }, MutationDeleteParyNavrhArgs>,
    deletePermission?: GraphCacheUpdateResolver<{ deletePermission: Maybe<WithTypename<DeletePermissionPayload>> }, MutationDeletePermissionArgs>,
    deletePerson?: GraphCacheUpdateResolver<{ deletePerson: Maybe<WithTypename<DeletePersonPayload>> }, MutationDeletePersonArgs>,
    deletePlatbyCategory?: GraphCacheUpdateResolver<{ deletePlatbyCategory: Maybe<WithTypename<DeletePlatbyCategoryPayload>> }, MutationDeletePlatbyCategoryArgs>,
    deletePlatbyCategoryGroup?: GraphCacheUpdateResolver<{ deletePlatbyCategoryGroup: Maybe<WithTypename<DeletePlatbyCategoryGroupPayload>> }, MutationDeletePlatbyCategoryGroupArgs>,
    deletePlatbyGroup?: GraphCacheUpdateResolver<{ deletePlatbyGroup: Maybe<WithTypename<DeletePlatbyGroupPayload>> }, MutationDeletePlatbyGroupArgs>,
    deletePlatbyGroupSkupina?: GraphCacheUpdateResolver<{ deletePlatbyGroupSkupina: Maybe<WithTypename<DeletePlatbyGroupSkupinaPayload>> }, MutationDeletePlatbyGroupSkupinaArgs>,
    deletePlatbyItem?: GraphCacheUpdateResolver<{ deletePlatbyItem: Maybe<WithTypename<DeletePlatbyItemPayload>> }, MutationDeletePlatbyItemArgs>,
    deletePlatbyRaw?: GraphCacheUpdateResolver<{ deletePlatbyRaw: Maybe<WithTypename<DeletePlatbyRawPayload>> }, MutationDeletePlatbyRawArgs>,
    deleteRoom?: GraphCacheUpdateResolver<{ deleteRoom: Maybe<WithTypename<DeleteRoomPayload>> }, MutationDeleteRoomArgs>,
    deleteRoomAttachment?: GraphCacheUpdateResolver<{ deleteRoomAttachment: Maybe<WithTypename<DeleteRoomAttachmentPayload>> }, MutationDeleteRoomAttachmentArgs>,
    deleteRozpi?: GraphCacheUpdateResolver<{ deleteRozpi: Maybe<WithTypename<DeleteRozpiPayload>> }, MutationDeleteRozpiArgs>,
    deleteRozpisItem?: GraphCacheUpdateResolver<{ deleteRozpisItem: Maybe<WithTypename<DeleteRozpisItemPayload>> }, MutationDeleteRozpisItemArgs>,
    deleteSkupiny?: GraphCacheUpdateResolver<{ deleteSkupiny: Maybe<WithTypename<DeleteSkupinyPayload>> }, MutationDeleteSkupinyArgs>,
    deleteTenant?: GraphCacheUpdateResolver<{ deleteTenant: Maybe<WithTypename<DeleteTenantPayload>> }, MutationDeleteTenantArgs>,
    deleteTenantAttachment?: GraphCacheUpdateResolver<{ deleteTenantAttachment: Maybe<WithTypename<DeleteTenantAttachmentPayload>> }, MutationDeleteTenantAttachmentArgs>,
    deleteTenantLocation?: GraphCacheUpdateResolver<{ deleteTenantLocation: Maybe<WithTypename<DeleteTenantLocationPayload>> }, MutationDeleteTenantLocationArgs>,
    deleteTenantPerson?: GraphCacheUpdateResolver<{ deleteTenantPerson: Maybe<WithTypename<DeleteTenantPersonPayload>> }, MutationDeleteTenantPersonArgs>,
    deleteUpozorneni?: GraphCacheUpdateResolver<{ deleteUpozorneni: Maybe<WithTypename<DeleteUpozorneniPayload>> }, MutationDeleteUpozorneniArgs>,
    deleteUpozorneniSkupiny?: GraphCacheUpdateResolver<{ deleteUpozorneniSkupiny: Maybe<WithTypename<DeleteUpozorneniSkupinyPayload>> }, MutationDeleteUpozorneniSkupinyArgs>,
    deleteUser?: GraphCacheUpdateResolver<{ deleteUser: Maybe<WithTypename<DeleteUserPayload>> }, MutationDeleteUserArgs>,
    fixUnpairedCouples?: GraphCacheUpdateResolver<{ fixUnpairedCouples: Maybe<WithTypename<FixUnpairedCouplesPayload>> }, MutationFixUnpairedCouplesArgs>,
    login?: GraphCacheUpdateResolver<{ login: Maybe<WithTypename<LoginPayload>> }, MutationLoginArgs>,
    logout?: GraphCacheUpdateResolver<{ logout: Maybe<WithTypename<LogoutPayload>> }, MutationLogoutArgs>,
    prospectFormDancer?: GraphCacheUpdateResolver<{ prospectFormDancer: Maybe<WithTypename<ProspectFormDancerPayload>> }, MutationProspectFormDancerArgs>,
    reservationSetDesiredLessons?: GraphCacheUpdateResolver<{ reservationSetDesiredLessons: Maybe<WithTypename<ReservationSetDesiredLessonsPayload>> }, MutationReservationSetDesiredLessonsArgs>,
    resetPassword?: GraphCacheUpdateResolver<{ resetPassword: Maybe<WithTypename<ResetPasswordPayload>> }, MutationResetPasswordArgs>,
    submitForm?: GraphCacheUpdateResolver<{ submitForm: Maybe<WithTypename<SubmitFormPayload>> }, MutationSubmitFormArgs>,
    updateAktuality?: GraphCacheUpdateResolver<{ updateAktuality: Maybe<WithTypename<UpdateAktualityPayload>> }, MutationUpdateAktualityArgs>,
    updateAttachment?: GraphCacheUpdateResolver<{ updateAttachment: Maybe<WithTypename<UpdateAttachmentPayload>> }, MutationUpdateAttachmentArgs>,
    updateAttendeeExternal?: GraphCacheUpdateResolver<{ updateAttendeeExternal: Maybe<WithTypename<UpdateAttendeeExternalPayload>> }, MutationUpdateAttendeeExternalArgs>,
    updateAttendeeUser?: GraphCacheUpdateResolver<{ updateAttendeeUser: Maybe<WithTypename<UpdateAttendeeUserPayload>> }, MutationUpdateAttendeeUserArgs>,
    updateAttendeeUserByUserIdAndEventId?: GraphCacheUpdateResolver<{ updateAttendeeUserByUserIdAndEventId: Maybe<WithTypename<UpdateAttendeeUserPayload>> }, MutationUpdateAttendeeUserByUserIdAndEventIdArgs>,
    updateCohortGroup?: GraphCacheUpdateResolver<{ updateCohortGroup: Maybe<WithTypename<UpdateCohortGroupPayload>> }, MutationUpdateCohortGroupArgs>,
    updateDokumenty?: GraphCacheUpdateResolver<{ updateDokumenty: Maybe<WithTypename<UpdateDokumentyPayload>> }, MutationUpdateDokumentyArgs>,
    updateEvent?: GraphCacheUpdateResolver<{ updateEvent: Maybe<WithTypename<UpdateEventPayload>> }, MutationUpdateEventArgs>,
    updateFormResponse?: GraphCacheUpdateResolver<{ updateFormResponse: Maybe<WithTypename<UpdateFormResponsePayload>> }, MutationUpdateFormResponseArgs>,
    updateGalerieDir?: GraphCacheUpdateResolver<{ updateGalerieDir: Maybe<WithTypename<UpdateGalerieDirPayload>> }, MutationUpdateGalerieDirArgs>,
    updateGalerieFoto?: GraphCacheUpdateResolver<{ updateGalerieFoto: Maybe<WithTypename<UpdateGalerieFotoPayload>> }, MutationUpdateGalerieFotoArgs>,
    updateLocation?: GraphCacheUpdateResolver<{ updateLocation: Maybe<WithTypename<UpdateLocationPayload>> }, MutationUpdateLocationArgs>,
    updateLocationAttachment?: GraphCacheUpdateResolver<{ updateLocationAttachment: Maybe<WithTypename<UpdateLocationAttachmentPayload>> }, MutationUpdateLocationAttachmentArgs>,
    updateNabidka?: GraphCacheUpdateResolver<{ updateNabidka: Maybe<WithTypename<UpdateNabidkaPayload>> }, MutationUpdateNabidkaArgs>,
    updateNabidkaItem?: GraphCacheUpdateResolver<{ updateNabidkaItem: Maybe<WithTypename<UpdateNabidkaItemPayload>> }, MutationUpdateNabidkaItemArgs>,
    updateNabidkaItemByNiPartnerAndNiIdRodic?: GraphCacheUpdateResolver<{ updateNabidkaItemByNiPartnerAndNiIdRodic: Maybe<WithTypename<UpdateNabidkaItemPayload>> }, MutationUpdateNabidkaItemByNiPartnerAndNiIdRodicArgs>,
    updatePage?: GraphCacheUpdateResolver<{ updatePage: Maybe<WithTypename<UpdatePagePayload>> }, MutationUpdatePageArgs>,
    updatePageByUrl?: GraphCacheUpdateResolver<{ updatePageByUrl: Maybe<WithTypename<UpdatePagePayload>> }, MutationUpdatePageByUrlArgs>,
    updateParameter?: GraphCacheUpdateResolver<{ updateParameter: Maybe<WithTypename<UpdateParameterPayload>> }, MutationUpdateParameterArgs>,
    updatePary?: GraphCacheUpdateResolver<{ updatePary: Maybe<WithTypename<UpdateParyPayload>> }, MutationUpdateParyArgs>,
    updateParyNavrh?: GraphCacheUpdateResolver<{ updateParyNavrh: Maybe<WithTypename<UpdateParyNavrhPayload>> }, MutationUpdateParyNavrhArgs>,
    updatePermission?: GraphCacheUpdateResolver<{ updatePermission: Maybe<WithTypename<UpdatePermissionPayload>> }, MutationUpdatePermissionArgs>,
    updatePerson?: GraphCacheUpdateResolver<{ updatePerson: Maybe<WithTypename<UpdatePersonPayload>> }, MutationUpdatePersonArgs>,
    updatePlatbyCategory?: GraphCacheUpdateResolver<{ updatePlatbyCategory: Maybe<WithTypename<UpdatePlatbyCategoryPayload>> }, MutationUpdatePlatbyCategoryArgs>,
    updatePlatbyCategoryGroup?: GraphCacheUpdateResolver<{ updatePlatbyCategoryGroup: Maybe<WithTypename<UpdatePlatbyCategoryGroupPayload>> }, MutationUpdatePlatbyCategoryGroupArgs>,
    updatePlatbyGroup?: GraphCacheUpdateResolver<{ updatePlatbyGroup: Maybe<WithTypename<UpdatePlatbyGroupPayload>> }, MutationUpdatePlatbyGroupArgs>,
    updatePlatbyGroupSkupina?: GraphCacheUpdateResolver<{ updatePlatbyGroupSkupina: Maybe<WithTypename<UpdatePlatbyGroupSkupinaPayload>> }, MutationUpdatePlatbyGroupSkupinaArgs>,
    updatePlatbyItem?: GraphCacheUpdateResolver<{ updatePlatbyItem: Maybe<WithTypename<UpdatePlatbyItemPayload>> }, MutationUpdatePlatbyItemArgs>,
    updatePlatbyRaw?: GraphCacheUpdateResolver<{ updatePlatbyRaw: Maybe<WithTypename<UpdatePlatbyRawPayload>> }, MutationUpdatePlatbyRawArgs>,
    updateRoom?: GraphCacheUpdateResolver<{ updateRoom: Maybe<WithTypename<UpdateRoomPayload>> }, MutationUpdateRoomArgs>,
    updateRoomAttachment?: GraphCacheUpdateResolver<{ updateRoomAttachment: Maybe<WithTypename<UpdateRoomAttachmentPayload>> }, MutationUpdateRoomAttachmentArgs>,
    updateRozpi?: GraphCacheUpdateResolver<{ updateRozpi: Maybe<WithTypename<UpdateRozpiPayload>> }, MutationUpdateRozpiArgs>,
    updateRozpisItem?: GraphCacheUpdateResolver<{ updateRozpisItem: Maybe<WithTypename<UpdateRozpisItemPayload>> }, MutationUpdateRozpisItemArgs>,
    updateSkupiny?: GraphCacheUpdateResolver<{ updateSkupiny: Maybe<WithTypename<UpdateSkupinyPayload>> }, MutationUpdateSkupinyArgs>,
    updateTenant?: GraphCacheUpdateResolver<{ updateTenant: Maybe<WithTypename<UpdateTenantPayload>> }, MutationUpdateTenantArgs>,
    updateTenantAttachment?: GraphCacheUpdateResolver<{ updateTenantAttachment: Maybe<WithTypename<UpdateTenantAttachmentPayload>> }, MutationUpdateTenantAttachmentArgs>,
    updateTenantLocation?: GraphCacheUpdateResolver<{ updateTenantLocation: Maybe<WithTypename<UpdateTenantLocationPayload>> }, MutationUpdateTenantLocationArgs>,
    updateTenantPerson?: GraphCacheUpdateResolver<{ updateTenantPerson: Maybe<WithTypename<UpdateTenantPersonPayload>> }, MutationUpdateTenantPersonArgs>,
    updateUpozorneni?: GraphCacheUpdateResolver<{ updateUpozorneni: Maybe<WithTypename<UpdateUpozorneniPayload>> }, MutationUpdateUpozorneniArgs>,
    updateUpozorneniSkupiny?: GraphCacheUpdateResolver<{ updateUpozorneniSkupiny: Maybe<WithTypename<UpdateUpozorneniSkupinyPayload>> }, MutationUpdateUpozorneniSkupinyArgs>,
    updateUser?: GraphCacheUpdateResolver<{ updateUser: Maybe<WithTypename<UpdateUserPayload>> }, MutationUpdateUserArgs>,
    verifyFunction?: GraphCacheUpdateResolver<{ verifyFunction: Maybe<WithTypename<VerifyFunctionPayload>> }, MutationVerifyFunctionArgs>
  },
  Subscription?: {},
};

export type GraphCacheConfig = Parameters<typeof offlineExchange>[0] & {
  updates?: GraphCacheUpdaters,
  keys?: GraphCacheKeysConfig,
  optimistic?: GraphCacheOptimisticUpdaters,
  resolvers?: GraphCacheResolvers,
};