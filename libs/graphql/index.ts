/* DO NOT EDIT! This file is auto-generated by graphql-code-generator - see `codegen.yml` */
/* eslint-disable */
import { offlineExchange } from '@urql/exchange-graphcache';
import type { Resolver as GraphCacheResolver, UpdateResolver as GraphCacheUpdateResolver, OptimisticMutationResolver as GraphCacheOptimisticMutationResolver } from '@urql/exchange-graphcache';

export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /** A floating point number that requires more precision than IEEE 754 binary 64 */
  BigFloat: { input: any; output: any; }
  /**
   * A signed eight-byte integer. The upper big integer values are greater than the
   * max value for a JavaScript number. Therefore all big integers will be output as
   * strings and not numbers.
   */
  BigInt: { input: string; output: string; }
  /** A location in a connection that can be used for resuming pagination. */
  Cursor: { input: any; output: any; }
  /** The day, does not include a time. */
  Date: { input: string; output: string; }
  /**
   * A point in time as described by the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
   */
  Datetime: { input: string; output: string; }
  /** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
  JSON: { input: { [key: string]: any }; output: { [key: string]: any }; }
};

export type Address = {
  __typename?: 'Address';
  city: Scalars['String']['output'];
  conscriptionNumber: Scalars['String']['output'];
  createdAt: Scalars['Datetime']['output'];
  district: Scalars['String']['output'];
  id: Scalars['BigInt']['output'];
  orientationNumber: Scalars['String']['output'];
  postalCode: Scalars['String']['output'];
  street: Scalars['String']['output'];
  updatedAt: Scalars['Datetime']['output'];
};

export type AddressDomain = {
  __typename?: 'AddressDomain';
  city: Maybe<Scalars['String']['output']>;
  conscriptionNumber: Maybe<Scalars['String']['output']>;
  district: Maybe<Scalars['String']['output']>;
  orientationNumber: Maybe<Scalars['String']['output']>;
  postalCode: Maybe<Scalars['String']['output']>;
  region: Maybe<Scalars['String']['output']>;
  street: Maybe<Scalars['String']['output']>;
};

export type AddressDomainInput = {
  city?: InputMaybe<Scalars['String']['input']>;
  conscriptionNumber?: InputMaybe<Scalars['String']['input']>;
  district?: InputMaybe<Scalars['String']['input']>;
  orientationNumber?: InputMaybe<Scalars['String']['input']>;
  postalCode?: InputMaybe<Scalars['String']['input']>;
  region?: InputMaybe<Scalars['String']['input']>;
  street?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `Aktuality` values. */
export type AktualitiesConnection = {
  __typename?: 'AktualitiesConnection';
  /** A list of edges which contains the `Aktuality` and cursor to aid in pagination. */
  edges: Array<AktualitiesEdge>;
  /** A list of `Aktuality` objects. */
  nodes: Array<Aktuality>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Aktuality` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Aktuality` edge in the connection. */
export type AktualitiesEdge = {
  __typename?: 'AktualitiesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Aktuality` at the end of the edge. */
  node: Aktuality;
};

/** Methods to use when ordering `Aktuality`. */
export type AktualitiesOrderBy =
  | 'AT_FOTO_MAIN_ASC'
  | 'AT_FOTO_MAIN_DESC'
  | 'AT_ID_ASC'
  | 'AT_ID_DESC'
  | 'AT_KDO_ASC'
  | 'AT_KDO_DESC'
  | 'AT_TIMESTAMP_ADD_ASC'
  | 'AT_TIMESTAMP_ADD_DESC'
  | 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_ID_ASC'
  | 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_ID_DESC'
  | 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_ID_RODIC_ASC'
  | 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_ID_RODIC_DESC'
  | 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_KDO_ASC'
  | 'GALERIE_FOTO_BY_AT_FOTO_MAIN__GF_KDO_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TENANT_ID_ASC'
  | 'TENANT_ID_DESC'
  | 'USER_BY_AT_KDO__U_ID_ASC'
  | 'USER_BY_AT_KDO__U_ID_DESC'
  | 'USER_BY_AT_KDO__U_JMENO_ASC'
  | 'USER_BY_AT_KDO__U_JMENO_DESC'
  | 'USER_BY_AT_KDO__U_LOGIN_ASC'
  | 'USER_BY_AT_KDO__U_LOGIN_DESC'
  | 'USER_BY_AT_KDO__U_PRIJMENI_ASC'
  | 'USER_BY_AT_KDO__U_PRIJMENI_DESC';

export type Aktuality = {
  __typename?: 'Aktuality';
  atFoto: Maybe<Scalars['BigInt']['output']>;
  atFotoMain: Maybe<Scalars['BigInt']['output']>;
  atId: Scalars['BigInt']['output'];
  atJmeno: Scalars['String']['output'];
  atKat: Scalars['String']['output'];
  atKdo: Maybe<Scalars['BigInt']['output']>;
  atPreview: Scalars['String']['output'];
  atText: Scalars['String']['output'];
  atTimestamp: Maybe<Scalars['Datetime']['output']>;
  atTimestampAdd: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
  galerieFotoByAtFotoMain: Maybe<GalerieFoto>;
  id: Maybe<Scalars['BigInt']['output']>;
  tenantId: Scalars['BigInt']['output'];
  /** Reads a single `User` that is related to this `Aktuality`. */
  userByAtKdo: Maybe<User>;
};

/**
 * A condition to be used against `Aktuality` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type AktualityCondition = {
  /** Checks for equality with the object’s `atFotoMain` field. */
  atFotoMain?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `atId` field. */
  atId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `atKdo` field. */
  atKdo?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `atTimestampAdd` field. */
  atTimestampAdd?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `tenantId` field. */
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `Aktuality` */
export type AktualityInput = {
  atFoto?: InputMaybe<Scalars['BigInt']['input']>;
  atFotoMain?: InputMaybe<Scalars['BigInt']['input']>;
  atId?: InputMaybe<Scalars['BigInt']['input']>;
  atJmeno: Scalars['String']['input'];
  atKat?: InputMaybe<Scalars['String']['input']>;
  atKdo?: InputMaybe<Scalars['BigInt']['input']>;
  atPreview: Scalars['String']['input'];
  atText: Scalars['String']['input'];
  atTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
  atTimestampAdd?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Represents an update to a `Aktuality`. Fields that are set will be updated. */
export type AktualityPatch = {
  atFoto?: InputMaybe<Scalars['BigInt']['input']>;
  atFotoMain?: InputMaybe<Scalars['BigInt']['input']>;
  atId?: InputMaybe<Scalars['BigInt']['input']>;
  atJmeno?: InputMaybe<Scalars['String']['input']>;
  atKat?: InputMaybe<Scalars['String']['input']>;
  atKdo?: InputMaybe<Scalars['BigInt']['input']>;
  atPreview?: InputMaybe<Scalars['String']['input']>;
  atText?: InputMaybe<Scalars['String']['input']>;
  atTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
  atTimestampAdd?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

export type Attachment = {
  __typename?: 'Attachment';
  directory: Maybe<Scalars['String']['output']>;
  downloadUrl: Scalars['String']['output'];
  height: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `LocationAttachment`. */
  locationAttachmentsByObjectName: LocationAttachmentsConnection;
  objectName: Scalars['String']['output'];
  previewObjectName: Maybe<Scalars['String']['output']>;
  publicUrl: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `RoomAttachment`. */
  roomAttachmentsByObjectName: RoomAttachmentsConnection;
  /** Reads and enables pagination through a set of `TenantAttachment`. */
  tenantAttachmentsByObjectName: TenantAttachmentsConnection;
  thumbhash: Maybe<Scalars['String']['output']>;
  uploadUrl: Scalars['String']['output'];
  uploadedAt: Scalars['Datetime']['output'];
  uploadedBy: Maybe<Scalars['BigInt']['output']>;
  /** Reads a single `User` that is related to this `Attachment`. */
  userByUploadedBy: Maybe<User>;
  width: Maybe<Scalars['Int']['output']>;
};


export type AttachmentLocationAttachmentsByObjectNameArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LocationAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LocationAttachmentsOrderBy>>;
};


export type AttachmentRoomAttachmentsByObjectNameArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomAttachmentsOrderBy>>;
};


export type AttachmentTenantAttachmentsByObjectNameArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TenantAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TenantAttachmentsOrderBy>>;
};

/**
 * A condition to be used against `Attachment` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type AttachmentCondition = {
  /** Checks for equality with the object’s `directory` field. */
  directory?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `objectName` field. */
  objectName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `uploadedBy` field. */
  uploadedBy?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `String` values. */
export type AttachmentDirectoriesConnection = {
  __typename?: 'AttachmentDirectoriesConnection';
  /** A list of edges which contains the `String` and cursor to aid in pagination. */
  edges: Array<AttachmentDirectoryEdge>;
  /** A list of `String` objects. */
  nodes: Array<Maybe<Scalars['String']['output']>>;
  /** The count of *all* `String` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `String` edge in the connection. */
export type AttachmentDirectoryEdge = {
  __typename?: 'AttachmentDirectoryEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `String` at the end of the edge. */
  node: Maybe<Scalars['String']['output']>;
};

/** An input for mutations affecting `Attachment` */
export type AttachmentInput = {
  height?: InputMaybe<Scalars['Int']['input']>;
  objectName: Scalars['String']['input'];
  previewObjectName?: InputMaybe<Scalars['String']['input']>;
  thumbhash?: InputMaybe<Scalars['String']['input']>;
  uploadedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uploadedBy?: InputMaybe<Scalars['BigInt']['input']>;
  width?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `Attachment` values. */
export type AttachmentsConnection = {
  __typename?: 'AttachmentsConnection';
  /** A list of edges which contains the `Attachment` and cursor to aid in pagination. */
  edges: Array<AttachmentsEdge>;
  /** A list of `Attachment` objects. */
  nodes: Array<Attachment>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Attachment` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Attachment` edge in the connection. */
export type AttachmentsEdge = {
  __typename?: 'AttachmentsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Attachment` at the end of the edge. */
  node: Attachment;
};

/** Methods to use when ordering `Attachment`. */
export type AttachmentsOrderBy =
  | 'LOCATION_ATTACHMENTS_BY_OBJECT_NAME__COUNT_ASC'
  | 'LOCATION_ATTACHMENTS_BY_OBJECT_NAME__COUNT_DESC'
  | 'NATURAL'
  | 'OBJECT_NAME_ASC'
  | 'OBJECT_NAME_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'ROOM_ATTACHMENTS_BY_OBJECT_NAME__COUNT_ASC'
  | 'ROOM_ATTACHMENTS_BY_OBJECT_NAME__COUNT_DESC'
  | 'TENANT_ATTACHMENTS_BY_OBJECT_NAME__COUNT_ASC'
  | 'TENANT_ATTACHMENTS_BY_OBJECT_NAME__COUNT_DESC'
  | 'UPLOADED_BY_ASC'
  | 'UPLOADED_BY_DESC'
  | 'USER_BY_UPLOADED_BY__U_ID_ASC'
  | 'USER_BY_UPLOADED_BY__U_ID_DESC'
  | 'USER_BY_UPLOADED_BY__U_JMENO_ASC'
  | 'USER_BY_UPLOADED_BY__U_JMENO_DESC'
  | 'USER_BY_UPLOADED_BY__U_LOGIN_ASC'
  | 'USER_BY_UPLOADED_BY__U_LOGIN_DESC'
  | 'USER_BY_UPLOADED_BY__U_PRIJMENI_ASC'
  | 'USER_BY_UPLOADED_BY__U_PRIJMENI_DESC';

export type AttendanceType =
  | 'ATTENDED'
  | 'EXCUSED'
  | 'NOT_EXCUSED'
  | 'UNKNOWN';

/** All input for the `cancelRegistration` mutation. */
export type CancelRegistrationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  registrationId: Scalars['BigInt']['input'];
};

/** The output of our `cancelRegistration` mutation. */
export type CancelRegistrationPayload = {
  __typename?: 'CancelRegistrationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `changePassword` mutation. */
export type ChangePasswordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  newPass: Scalars['String']['input'];
  oldPass: Scalars['String']['input'];
};

/** The output of our `changePassword` mutation. */
export type ChangePasswordPayload = {
  __typename?: 'ChangePasswordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type CohortGroup = {
  __typename?: 'CohortGroup';
  description: Scalars['String']['output'];
  id: Scalars['BigInt']['output'];
  isPublic: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  ordering: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `Skupiny`. */
  skupiniesByCohortGroup: SkupiniesConnection;
  tenant: Maybe<Scalars['BigInt']['output']>;
  /** Reads a single `Tenant` that is related to this `CohortGroup`. */
  tenantByTenant: Maybe<Tenant>;
  tenantId: Scalars['BigInt']['output'];
};


export type CohortGroupSkupiniesByCohortGroupArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SkupinyCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SkupiniesOrderBy>>;
};

/**
 * A condition to be used against `CohortGroup` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type CohortGroupCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `isPublic` field. */
  isPublic?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `ordering` field. */
  ordering?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `tenant` field. */
  tenant?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `CohortGroup` */
export type CohortGroupInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  isPublic?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  ordering?: InputMaybe<Scalars['Int']['input']>;
  tenant?: InputMaybe<Scalars['BigInt']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Represents an update to a `CohortGroup`. Fields that are set will be updated. */
export type CohortGroupPatch = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  isPublic?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ordering?: InputMaybe<Scalars['Int']['input']>;
  tenant?: InputMaybe<Scalars['BigInt']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `CohortGroup` values. */
export type CohortGroupsConnection = {
  __typename?: 'CohortGroupsConnection';
  /** A list of edges which contains the `CohortGroup` and cursor to aid in pagination. */
  edges: Array<CohortGroupsEdge>;
  /** A list of `CohortGroup` objects. */
  nodes: Array<CohortGroup>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CohortGroup` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `CohortGroup` edge in the connection. */
export type CohortGroupsEdge = {
  __typename?: 'CohortGroupsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `CohortGroup` at the end of the edge. */
  node: CohortGroup;
};

/** Methods to use when ordering `CohortGroup`. */
export type CohortGroupsOrderBy =
  | 'ID_ASC'
  | 'ID_DESC'
  | 'IS_PUBLIC_ASC'
  | 'IS_PUBLIC_DESC'
  | 'NATURAL'
  | 'ORDERING_ASC'
  | 'ORDERING_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SKUPINIES_BY_COHORT_GROUP__COUNT_ASC'
  | 'SKUPINIES_BY_COHORT_GROUP__COUNT_DESC'
  | 'TENANT_ASC'
  | 'TENANT_BY_TENANT__ID_ASC'
  | 'TENANT_BY_TENANT__ID_DESC'
  | 'TENANT_DESC';

export type CohortMembership = {
  __typename?: 'CohortMembership';
  active: Scalars['Boolean']['output'];
  /** Reads a single `Skupiny` that is related to this `CohortMembership`. */
  cohort: Maybe<Skupiny>;
  cohortId: Scalars['BigInt']['output'];
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['BigInt']['output'];
  /** Reads a single `Person` that is related to this `CohortMembership`. */
  person: Maybe<Person>;
  personId: Scalars['BigInt']['output'];
  since: Scalars['Datetime']['output'];
  tenantId: Scalars['BigInt']['output'];
  until: Maybe<Scalars['Datetime']['output']>;
  updatedAt: Scalars['Datetime']['output'];
};

/**
 * A condition to be used against `CohortMembership` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CohortMembershipCondition = {
  /** Checks for equality with the object’s `active` field. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `cohortId` field. */
  cohortId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `personId` field. */
  personId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Methods to use when ordering `CohortMembership`. */
export type CohortMembershipsOrderBy =
  | 'ACTIVE_ASC'
  | 'ACTIVE_DESC'
  | 'COHORT_ID_ASC'
  | 'COHORT_ID_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PERSON_BY_PERSON_ID__ID_ASC'
  | 'PERSON_BY_PERSON_ID__ID_DESC'
  | 'PERSON_ID_ASC'
  | 'PERSON_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SKUPINY_BY_COHORT_ID__COHORT_GROUP_ASC'
  | 'SKUPINY_BY_COHORT_ID__COHORT_GROUP_DESC'
  | 'SKUPINY_BY_COHORT_ID__ORDERING_ASC'
  | 'SKUPINY_BY_COHORT_ID__ORDERING_DESC'
  | 'SKUPINY_BY_COHORT_ID__S_ID_ASC'
  | 'SKUPINY_BY_COHORT_ID__S_ID_DESC'
  | 'SKUPINY_BY_COHORT_ID__S_VISIBLE_ASC'
  | 'SKUPINY_BY_COHORT_ID__S_VISIBLE_DESC';

/** All input for the `confirmUser` mutation. */
export type ConfirmUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  cohort: Scalars['BigInt']['input'];
  grp: Scalars['BigInt']['input'];
  id: Scalars['BigInt']['input'];
};

/** The output of our `confirmUser` mutation. */
export type ConfirmUserPayload = {
  __typename?: 'ConfirmUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type Couple = {
  __typename?: 'Couple';
  active: Scalars['Boolean']['output'];
  createdAt: Scalars['Datetime']['output'];
  /** Reads and enables pagination through a set of `EventRegistration`. */
  eventRegistrationsList: Array<EventRegistration>;
  id: Scalars['BigInt']['output'];
  legacyParyId: Maybe<Scalars['BigInt']['output']>;
  /** Reads a single `Person` that is related to this `Couple`. */
  man: Maybe<Person>;
  manId: Scalars['BigInt']['output'];
  since: Scalars['Datetime']['output'];
  until: Maybe<Scalars['Datetime']['output']>;
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Person` that is related to this `Couple`. */
  woman: Maybe<Person>;
  womanId: Scalars['BigInt']['output'];
};


export type CoupleEventRegistrationsListArgs = {
  condition?: InputMaybe<EventRegistrationCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventRegistrationsOrderBy>>;
};

/** A condition to be used against `Couple` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CoupleCondition = {
  /** Checks for equality with the object’s `active` field. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `manId` field. */
  manId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `womanId` field. */
  womanId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `Couple` */
export type CoupleInput = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  legacyParyId?: InputMaybe<Scalars['BigInt']['input']>;
  manId: Scalars['BigInt']['input'];
  since?: InputMaybe<Scalars['Datetime']['input']>;
  until?: InputMaybe<Scalars['Datetime']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  womanId: Scalars['BigInt']['input'];
};

/** A connection to a list of `Couple` values. */
export type CouplesConnection = {
  __typename?: 'CouplesConnection';
  /** A list of edges which contains the `Couple` and cursor to aid in pagination. */
  edges: Array<CouplesEdge>;
  /** A list of `Couple` objects. */
  nodes: Array<Couple>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Couple` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Couple` edge in the connection. */
export type CouplesEdge = {
  __typename?: 'CouplesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Couple` at the end of the edge. */
  node: Couple;
};

/** Methods to use when ordering `Couple`. */
export type CouplesOrderBy =
  | 'ACTIVE_ASC'
  | 'ACTIVE_DESC'
  | 'EVENT_REGISTRATIONS_BY_COUPLE_ID__COUNT_ASC'
  | 'EVENT_REGISTRATIONS_BY_COUPLE_ID__COUNT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'MAN_ID_ASC'
  | 'MAN_ID_DESC'
  | 'NATURAL'
  | 'PERSON_BY_MAN_ID__ID_ASC'
  | 'PERSON_BY_MAN_ID__ID_DESC'
  | 'PERSON_BY_WOMAN_ID__ID_ASC'
  | 'PERSON_BY_WOMAN_ID__ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'WOMAN_ID_ASC'
  | 'WOMAN_ID_DESC';

/** All input for the create `Aktuality` mutation. */
export type CreateAktualityInput = {
  /** The `Aktuality` to be created by this mutation. */
  aktuality: AktualityInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `Aktuality` mutation. */
export type CreateAktualityPayload = {
  __typename?: 'CreateAktualityPayload';
  /** The `Aktuality` that was created by this mutation. */
  aktuality: Maybe<Aktuality>;
  /** An edge for our `Aktuality`. May be used by Relay 1. */
  aktualityEdge: Maybe<AktualitiesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
  galerieFotoByAtFotoMain: Maybe<GalerieFoto>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Aktuality`. */
  userByAtKdo: Maybe<User>;
};


/** The output of our create `Aktuality` mutation. */
export type CreateAktualityPayloadAktualityEdgeArgs = {
  orderBy?: InputMaybe<Array<AktualitiesOrderBy>>;
};

/** All input for the create `Attachment` mutation. */
export type CreateAttachmentInput = {
  /** The `Attachment` to be created by this mutation. */
  attachment: AttachmentInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `Attachment` mutation. */
export type CreateAttachmentPayload = {
  __typename?: 'CreateAttachmentPayload';
  /** The `Attachment` that was created by this mutation. */
  attachment: Maybe<Attachment>;
  /** An edge for our `Attachment`. May be used by Relay 1. */
  attachmentEdge: Maybe<AttachmentsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Attachment`. */
  userByUploadedBy: Maybe<User>;
};


/** The output of our create `Attachment` mutation. */
export type CreateAttachmentPayloadAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<AttachmentsOrderBy>>;
};

/** All input for the create `CohortGroup` mutation. */
export type CreateCohortGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `CohortGroup` to be created by this mutation. */
  cohortGroup: CohortGroupInput;
};

/** The output of our create `CohortGroup` mutation. */
export type CreateCohortGroupPayload = {
  __typename?: 'CreateCohortGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `CohortGroup` that was created by this mutation. */
  cohortGroup: Maybe<CohortGroup>;
  /** An edge for our `CohortGroup`. May be used by Relay 1. */
  cohortGroupEdge: Maybe<CohortGroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `CohortGroup`. */
  tenantByTenant: Maybe<Tenant>;
};


/** The output of our create `CohortGroup` mutation. */
export type CreateCohortGroupPayloadCohortGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<CohortGroupsOrderBy>>;
};

/** All input for the create `Couple` mutation. */
export type CreateCoupleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Couple` to be created by this mutation. */
  couple: CoupleInput;
};

/** The output of our create `Couple` mutation. */
export type CreateCouplePayload = {
  __typename?: 'CreateCouplePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Couple` that was created by this mutation. */
  couple: Maybe<Couple>;
  /** An edge for our `Couple`. May be used by Relay 1. */
  coupleEdge: Maybe<CouplesEdge>;
  /** Reads a single `Person` that is related to this `Couple`. */
  man: Maybe<Person>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Person` that is related to this `Couple`. */
  woman: Maybe<Person>;
};


/** The output of our create `Couple` mutation. */
export type CreateCouplePayloadCoupleEdgeArgs = {
  orderBy?: InputMaybe<Array<CouplesOrderBy>>;
};

/** All input for the create `Dokumenty` mutation. */
export type CreateDokumentyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Dokumenty` to be created by this mutation. */
  dokumenty: DokumentyInput;
};

/** The output of our create `Dokumenty` mutation. */
export type CreateDokumentyPayload = {
  __typename?: 'CreateDokumentyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Dokumenty` that was created by this mutation. */
  dokumenty: Maybe<Dokumenty>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Dokumenty`. */
  userByDKdo: Maybe<User>;
};

/** All input for the create `Event` mutation. */
export type CreateEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Event` to be created by this mutation. */
  event: EventInput;
};

/** The output of our create `Event` mutation. */
export type CreateEventPayload = {
  __typename?: 'CreateEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Event` that was created by this mutation. */
  event: Maybe<Event>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge: Maybe<EventsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Event` mutation. */
export type CreateEventPayloadEventEdgeArgs = {
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};

/** All input for the create `FormResponse` mutation. */
export type CreateFormResponseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `FormResponse` to be created by this mutation. */
  formResponse: FormResponseInput;
};

/** The output of our create `FormResponse` mutation. */
export type CreateFormResponsePayload = {
  __typename?: 'CreateFormResponsePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `FormResponse` that was created by this mutation. */
  formResponse: Maybe<FormResponse>;
  /** An edge for our `FormResponse`. May be used by Relay 1. */
  formResponseEdge: Maybe<FormResponsesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `FormResponse` mutation. */
export type CreateFormResponsePayloadFormResponseEdgeArgs = {
  orderBy?: InputMaybe<Array<FormResponsesOrderBy>>;
};

/** All input for the create `Location` mutation. */
export type CreateLocationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Location` to be created by this mutation. */
  location: LocationInput;
};

/** The output of our create `Location` mutation. */
export type CreateLocationPayload = {
  __typename?: 'CreateLocationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Location` that was created by this mutation. */
  location: Maybe<Location>;
  /** An edge for our `Location`. May be used by Relay 1. */
  locationEdge: Maybe<LocationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Location` mutation. */
export type CreateLocationPayloadLocationEdgeArgs = {
  orderBy?: InputMaybe<Array<LocationsOrderBy>>;
};

/** All input for the create `Permission` mutation. */
export type CreatePermissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Permission` to be created by this mutation. */
  permission: PermissionInput;
};

/** The output of our create `Permission` mutation. */
export type CreatePermissionPayload = {
  __typename?: 'CreatePermissionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Permission` that was created by this mutation. */
  permission: Maybe<Permission>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `Room` mutation. */
export type CreateRoomInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Room` to be created by this mutation. */
  room: RoomInput;
};

/** The output of our create `Room` mutation. */
export type CreateRoomPayload = {
  __typename?: 'CreateRoomPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Location` that is related to this `Room`. */
  locationByLocation: Maybe<Location>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Room` that was created by this mutation. */
  room: Maybe<Room>;
  /** An edge for our `Room`. May be used by Relay 1. */
  roomEdge: Maybe<RoomsEdge>;
};


/** The output of our create `Room` mutation. */
export type CreateRoomPayloadRoomEdgeArgs = {
  orderBy?: InputMaybe<Array<RoomsOrderBy>>;
};

/** All input for the create `Skupiny` mutation. */
export type CreateSkupinyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Skupiny` to be created by this mutation. */
  skupiny: SkupinyInput;
};

/** The output of our create `Skupiny` mutation. */
export type CreateSkupinyPayload = {
  __typename?: 'CreateSkupinyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `CohortGroup` that is related to this `Skupiny`. */
  cohortGroupByCohortGroup: Maybe<CohortGroup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Skupiny` that was created by this mutation. */
  skupiny: Maybe<Skupiny>;
  /** An edge for our `Skupiny`. May be used by Relay 1. */
  skupinyEdge: Maybe<SkupiniesEdge>;
};


/** The output of our create `Skupiny` mutation. */
export type CreateSkupinyPayloadSkupinyEdgeArgs = {
  orderBy?: InputMaybe<Array<SkupiniesOrderBy>>;
};

/** All input for the create `Upozorneni` mutation. */
export type CreateUpozorneniInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Upozorneni` to be created by this mutation. */
  upozorneni: UpozorneniInput;
};

/** The output of our create `Upozorneni` mutation. */
export type CreateUpozorneniPayload = {
  __typename?: 'CreateUpozorneniPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Upozorneni` that was created by this mutation. */
  upozorneni: Maybe<Upozorneni>;
  /** An edge for our `Upozorneni`. May be used by Relay 1. */
  upozorneniEdge: Maybe<UpozornenisEdge>;
  /** Reads a single `User` that is related to this `Upozorneni`. */
  userByUpKdo: Maybe<User>;
};


/** The output of our create `Upozorneni` mutation. */
export type CreateUpozorneniPayloadUpozorneniEdgeArgs = {
  orderBy?: InputMaybe<Array<UpozornenisOrderBy>>;
};

/** A `BigInt` edge in the connection. */
export type CurrentCoupleIdEdge = {
  __typename?: 'CurrentCoupleIdEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `BigInt` at the end of the edge. */
  node: Maybe<Scalars['BigInt']['output']>;
};

/** A connection to a list of `BigInt` values. */
export type CurrentCoupleIdsConnection = {
  __typename?: 'CurrentCoupleIdsConnection';
  /** A list of edges which contains the `BigInt` and cursor to aid in pagination. */
  edges: Array<CurrentCoupleIdEdge>;
  /** A list of `BigInt` objects. */
  nodes: Array<Maybe<Scalars['BigInt']['output']>>;
  /** The count of *all* `BigInt` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** All input for the `currentPersonIds` mutation. */
export type CurrentPersonIdsInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our `currentPersonIds` mutation. */
export type CurrentPersonIdsPayload = {
  __typename?: 'CurrentPersonIdsPayload';
  bigInts: Maybe<Array<Maybe<Scalars['BigInt']['output']>>>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** A range of `Datetime`. */
export type DatetimeRange = {
  __typename?: 'DatetimeRange';
  /** The ending bound of our range. */
  end: Maybe<DatetimeRangeBound>;
  /** The starting bound of our range. */
  start: Maybe<DatetimeRangeBound>;
};

/** The value at one end of a range. A range can either include this value, or not. */
export type DatetimeRangeBound = {
  __typename?: 'DatetimeRangeBound';
  /** Whether or not the value of this bound is included in the range. */
  inclusive: Scalars['Boolean']['output'];
  /** The value at one end of our range. */
  value: Scalars['Datetime']['output'];
};

/** The value at one end of a range. A range can either include this value, or not. */
export type DatetimeRangeBoundInput = {
  /** Whether or not the value of this bound is included in the range. */
  inclusive: Scalars['Boolean']['input'];
  /** The value at one end of our range. */
  value: Scalars['Datetime']['input'];
};

/** A range of `Datetime`. */
export type DatetimeRangeInput = {
  /** The ending bound of our range. */
  end?: InputMaybe<DatetimeRangeBoundInput>;
  /** The starting bound of our range. */
  start?: InputMaybe<DatetimeRangeBoundInput>;
};

/** All input for the `deleteAktuality` mutation. */
export type DeleteAktualityInput = {
  atId: Scalars['BigInt']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our delete `Aktuality` mutation. */
export type DeleteAktualityPayload = {
  __typename?: 'DeleteAktualityPayload';
  /** The `Aktuality` that was deleted by this mutation. */
  aktuality: Maybe<Aktuality>;
  /** An edge for our `Aktuality`. May be used by Relay 1. */
  aktualityEdge: Maybe<AktualitiesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedAktualityNodeId: Maybe<Scalars['ID']['output']>;
  /** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
  galerieFotoByAtFotoMain: Maybe<GalerieFoto>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Aktuality`. */
  userByAtKdo: Maybe<User>;
};


/** The output of our delete `Aktuality` mutation. */
export type DeleteAktualityPayloadAktualityEdgeArgs = {
  orderBy?: InputMaybe<Array<AktualitiesOrderBy>>;
};

/** All input for the `deleteAttachment` mutation. */
export type DeleteAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  objectName: Scalars['String']['input'];
};

/** The output of our delete `Attachment` mutation. */
export type DeleteAttachmentPayload = {
  __typename?: 'DeleteAttachmentPayload';
  /** The `Attachment` that was deleted by this mutation. */
  attachment: Maybe<Attachment>;
  /** An edge for our `Attachment`. May be used by Relay 1. */
  attachmentEdge: Maybe<AttachmentsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedAttachmentNodeId: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Attachment`. */
  userByUploadedBy: Maybe<User>;
};


/** The output of our delete `Attachment` mutation. */
export type DeleteAttachmentPayloadAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<AttachmentsOrderBy>>;
};

/** All input for the `deleteCohortGroup` mutation. */
export type DeleteCohortGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `CohortGroup` mutation. */
export type DeleteCohortGroupPayload = {
  __typename?: 'DeleteCohortGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `CohortGroup` that was deleted by this mutation. */
  cohortGroup: Maybe<CohortGroup>;
  /** An edge for our `CohortGroup`. May be used by Relay 1. */
  cohortGroupEdge: Maybe<CohortGroupsEdge>;
  deletedCohortGroupNodeId: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `CohortGroup`. */
  tenantByTenant: Maybe<Tenant>;
};


/** The output of our delete `CohortGroup` mutation. */
export type DeleteCohortGroupPayloadCohortGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<CohortGroupsOrderBy>>;
};

/** All input for the `deleteCouple` mutation. */
export type DeleteCoupleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  coupleId: Scalars['BigInt']['input'];
};

/** The output of our `deleteCouple` mutation. */
export type DeleteCouplePayload = {
  __typename?: 'DeleteCouplePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  paries: Maybe<Array<Pary>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `deleteDokumenty` mutation. */
export type DeleteDokumentyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  dId: Scalars['BigInt']['input'];
};

/** The output of our delete `Dokumenty` mutation. */
export type DeleteDokumentyPayload = {
  __typename?: 'DeleteDokumentyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedDokumentyNodeId: Maybe<Scalars['ID']['output']>;
  /** The `Dokumenty` that was deleted by this mutation. */
  dokumenty: Maybe<Dokumenty>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Dokumenty`. */
  userByDKdo: Maybe<User>;
};

/** All input for the `deleteEvent` mutation. */
export type DeleteEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Event` mutation. */
export type DeleteEventPayload = {
  __typename?: 'DeleteEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedEventNodeId: Maybe<Scalars['ID']['output']>;
  /** The `Event` that was deleted by this mutation. */
  event: Maybe<Event>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge: Maybe<EventsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Event` mutation. */
export type DeleteEventPayloadEventEdgeArgs = {
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};

/** All input for the `deleteLocation` mutation. */
export type DeleteLocationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Location` mutation. */
export type DeleteLocationPayload = {
  __typename?: 'DeleteLocationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedLocationNodeId: Maybe<Scalars['ID']['output']>;
  /** The `Location` that was deleted by this mutation. */
  location: Maybe<Location>;
  /** An edge for our `Location`. May be used by Relay 1. */
  locationEdge: Maybe<LocationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Location` mutation. */
export type DeleteLocationPayloadLocationEdgeArgs = {
  orderBy?: InputMaybe<Array<LocationsOrderBy>>;
};

/** All input for the `deleteRoom` mutation. */
export type DeleteRoomInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Room` mutation. */
export type DeleteRoomPayload = {
  __typename?: 'DeleteRoomPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedRoomNodeId: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Location` that is related to this `Room`. */
  locationByLocation: Maybe<Location>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Room` that was deleted by this mutation. */
  room: Maybe<Room>;
  /** An edge for our `Room`. May be used by Relay 1. */
  roomEdge: Maybe<RoomsEdge>;
};


/** The output of our delete `Room` mutation. */
export type DeleteRoomPayloadRoomEdgeArgs = {
  orderBy?: InputMaybe<Array<RoomsOrderBy>>;
};

/** All input for the `deleteSkupiny` mutation. */
export type DeleteSkupinyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  sId: Scalars['BigInt']['input'];
};

/** The output of our delete `Skupiny` mutation. */
export type DeleteSkupinyPayload = {
  __typename?: 'DeleteSkupinyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `CohortGroup` that is related to this `Skupiny`. */
  cohortGroupByCohortGroup: Maybe<CohortGroup>;
  deletedSkupinyNodeId: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Skupiny` that was deleted by this mutation. */
  skupiny: Maybe<Skupiny>;
  /** An edge for our `Skupiny`. May be used by Relay 1. */
  skupinyEdge: Maybe<SkupiniesEdge>;
};


/** The output of our delete `Skupiny` mutation. */
export type DeleteSkupinyPayloadSkupinyEdgeArgs = {
  orderBy?: InputMaybe<Array<SkupiniesOrderBy>>;
};

/** All input for the `deleteUpozorneni` mutation. */
export type DeleteUpozorneniInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  upId: Scalars['BigInt']['input'];
};

/** The output of our delete `Upozorneni` mutation. */
export type DeleteUpozorneniPayload = {
  __typename?: 'DeleteUpozorneniPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedUpozorneniNodeId: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Upozorneni` that was deleted by this mutation. */
  upozorneni: Maybe<Upozorneni>;
  /** An edge for our `Upozorneni`. May be used by Relay 1. */
  upozorneniEdge: Maybe<UpozornenisEdge>;
  /** Reads a single `User` that is related to this `Upozorneni`. */
  userByUpKdo: Maybe<User>;
};


/** The output of our delete `Upozorneni` mutation. */
export type DeleteUpozorneniPayloadUpozorneniEdgeArgs = {
  orderBy?: InputMaybe<Array<UpozornenisOrderBy>>;
};

/** Methods to use when ordering `Dokumenty`. */
export type DokumentiesOrderBy =
  | 'D_ID_ASC'
  | 'D_ID_DESC'
  | 'D_KATEGORIE_ASC'
  | 'D_KATEGORIE_DESC'
  | 'D_KDO_ASC'
  | 'D_KDO_DESC'
  | 'D_PATH_ASC'
  | 'D_PATH_DESC'
  | 'D_TIMESTAMP_ASC'
  | 'D_TIMESTAMP_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'USER_BY_D_KDO__U_ID_ASC'
  | 'USER_BY_D_KDO__U_ID_DESC'
  | 'USER_BY_D_KDO__U_JMENO_ASC'
  | 'USER_BY_D_KDO__U_JMENO_DESC'
  | 'USER_BY_D_KDO__U_LOGIN_ASC'
  | 'USER_BY_D_KDO__U_LOGIN_DESC'
  | 'USER_BY_D_KDO__U_PRIJMENI_ASC'
  | 'USER_BY_D_KDO__U_PRIJMENI_DESC';

export type Dokumenty = {
  __typename?: 'Dokumenty';
  dFilename: Scalars['String']['output'];
  dId: Scalars['BigInt']['output'];
  dKategorie: Scalars['Int']['output'];
  dKdo: Scalars['BigInt']['output'];
  dName: Scalars['String']['output'];
  dPath: Scalars['String']['output'];
  dTimestamp: Maybe<Scalars['Datetime']['output']>;
  id: Maybe<Scalars['BigInt']['output']>;
  tenantId: Scalars['BigInt']['output'];
  /** Reads a single `User` that is related to this `Dokumenty`. */
  userByDKdo: Maybe<User>;
};

/**
 * A condition to be used against `Dokumenty` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type DokumentyCondition = {
  /** Checks for equality with the object’s `dId` field. */
  dId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `dKategorie` field. */
  dKategorie?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `dKdo` field. */
  dKdo?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `dPath` field. */
  dPath?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `dTimestamp` field. */
  dTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An input for mutations affecting `Dokumenty` */
export type DokumentyInput = {
  dFilename: Scalars['String']['input'];
  dId?: InputMaybe<Scalars['BigInt']['input']>;
  dKategorie: Scalars['Int']['input'];
  dKdo: Scalars['BigInt']['input'];
  dName: Scalars['String']['input'];
  dPath: Scalars['String']['input'];
  dTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Represents an update to a `Dokumenty`. Fields that are set will be updated. */
export type DokumentyPatch = {
  dFilename?: InputMaybe<Scalars['String']['input']>;
  dId?: InputMaybe<Scalars['BigInt']['input']>;
  dKategorie?: InputMaybe<Scalars['Int']['input']>;
  dKdo?: InputMaybe<Scalars['BigInt']['input']>;
  dName?: InputMaybe<Scalars['String']['input']>;
  dPath?: InputMaybe<Scalars['String']['input']>;
  dTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** All input for the `editRegistration` mutation. */
export type EditRegistrationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  note: Scalars['String']['input'];
  registrationId: Scalars['BigInt']['input'];
};

/** The output of our `editRegistration` mutation. */
export type EditRegistrationPayload = {
  __typename?: 'EditRegistrationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Couple` that is related to this `EventRegistration`. */
  couple: Maybe<Couple>;
  /** Reads a single `Event` that is related to this `EventRegistration`. */
  event: Maybe<Event>;
  eventRegistration: Maybe<EventRegistration>;
  /** Reads a single `PlatbyItem` that is related to this `EventRegistration`. */
  payment: Maybe<PlatbyItem>;
  /** Reads a single `Person` that is related to this `EventRegistration`. */
  person: Maybe<Person>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `EventTargetCohort` that is related to this `EventRegistration`. */
  targetCohort: Maybe<EventTargetCohort>;
  /** Reads a single `Tenant` that is related to this `EventRegistration`. */
  tenant: Maybe<Tenant>;
};

export type Event = {
  __typename?: 'Event';
  capacity: Scalars['BigInt']['output'];
  description: Scalars['String']['output'];
  descriptionMember: Scalars['String']['output'];
  enableNotes: Scalars['Boolean']['output'];
  /** Reads and enables pagination through a set of `EventInstance`. */
  eventInstances: EventInstancesConnection;
  /** Reads and enables pagination through a set of `EventInstance`. */
  eventInstancesList: Array<EventInstance>;
  /** Reads and enables pagination through a set of `EventRegistration`. */
  eventRegistrationsList: Array<EventRegistration>;
  /** Reads and enables pagination through a set of `EventTargetCohort`. */
  eventTargetCohortsList: Array<EventTargetCohort>;
  /** Reads and enables pagination through a set of `EventTrainer`. */
  eventTrainersList: Array<EventTrainer>;
  filesLegacy: Scalars['String']['output'];
  id: Scalars['BigInt']['output'];
  isLocked: Scalars['Boolean']['output'];
  isPublic: Scalars['Boolean']['output'];
  isVisible: Scalars['Boolean']['output'];
  locationText: Scalars['String']['output'];
  name: Scalars['String']['output'];
  registrationPrice: Maybe<Price>;
  remainingLessons: Maybe<Scalars['Int']['output']>;
  remainingPersonSpots: Maybe<Scalars['Int']['output']>;
  since: Maybe<Scalars['Date']['output']>;
  summary: Scalars['String']['output'];
  tenantId: Scalars['BigInt']['output'];
  titleImageLegacy: Maybe<Scalars['String']['output']>;
  type: EventType;
  until: Maybe<Scalars['Date']['output']>;
  updatedAt: Maybe<Scalars['Datetime']['output']>;
};


export type EventEventInstancesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventInstanceCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventInstancesOrderBy>>;
};


export type EventEventInstancesListArgs = {
  condition?: InputMaybe<EventInstanceCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventInstancesOrderBy>>;
};


export type EventEventRegistrationsListArgs = {
  condition?: InputMaybe<EventRegistrationCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventRegistrationsOrderBy>>;
};


export type EventEventTargetCohortsListArgs = {
  condition?: InputMaybe<EventTargetCohortCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventTargetCohortsOrderBy>>;
};


export type EventEventTrainersListArgs = {
  condition?: InputMaybe<EventTrainerCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventTrainersOrderBy>>;
};

export type EventAttendance = {
  __typename?: 'EventAttendance';
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['BigInt']['output'];
  /** Reads a single `EventInstance` that is related to this `EventAttendance`. */
  instance: Maybe<EventInstance>;
  instanceId: Scalars['BigInt']['output'];
  note: Maybe<Scalars['String']['output']>;
  /** Reads a single `Person` that is related to this `EventAttendance`. */
  person: Maybe<Person>;
  personId: Scalars['BigInt']['output'];
  status: AttendanceType;
  /** Reads a single `Tenant` that is related to this `EventAttendance`. */
  tenant: Maybe<Tenant>;
  tenantId: Scalars['BigInt']['output'];
  updatedAt: Scalars['Datetime']['output'];
};

/**
 * A condition to be used against `EventAttendance` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type EventAttendanceCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `instanceId` field. */
  instanceId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `personId` field. */
  personId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `tenantId` field. */
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Methods to use when ordering `EventAttendance`. */
export type EventAttendancesOrderBy =
  | 'EVENT_INSTANCE_BY_INSTANCE_ID__EVENT_ID_ASC'
  | 'EVENT_INSTANCE_BY_INSTANCE_ID__EVENT_ID_DESC'
  | 'EVENT_INSTANCE_BY_INSTANCE_ID__ID_ASC'
  | 'EVENT_INSTANCE_BY_INSTANCE_ID__ID_DESC'
  | 'EVENT_INSTANCE_BY_INSTANCE_ID__LOCATION_ID_ASC'
  | 'EVENT_INSTANCE_BY_INSTANCE_ID__LOCATION_ID_DESC'
  | 'EVENT_INSTANCE_BY_INSTANCE_ID__RANGE_ASC'
  | 'EVENT_INSTANCE_BY_INSTANCE_ID__RANGE_DESC'
  | 'EVENT_INSTANCE_BY_INSTANCE_ID__SINCE_ASC'
  | 'EVENT_INSTANCE_BY_INSTANCE_ID__SINCE_DESC'
  | 'EVENT_INSTANCE_BY_INSTANCE_ID__TENANT_ID_ASC'
  | 'EVENT_INSTANCE_BY_INSTANCE_ID__TENANT_ID_DESC'
  | 'EVENT_INSTANCE_BY_INSTANCE_ID__UNTIL_ASC'
  | 'EVENT_INSTANCE_BY_INSTANCE_ID__UNTIL_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'INSTANCE_ID_ASC'
  | 'INSTANCE_ID_DESC'
  | 'NATURAL'
  | 'PERSON_BY_PERSON_ID__ID_ASC'
  | 'PERSON_BY_PERSON_ID__ID_DESC'
  | 'PERSON_ID_ASC'
  | 'PERSON_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TENANT_BY_TENANT_ID__ID_ASC'
  | 'TENANT_BY_TENANT_ID__ID_DESC'
  | 'TENANT_ID_ASC'
  | 'TENANT_ID_DESC';

/** A condition to be used against `Event` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type EventCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `isVisible` field. */
  isVisible?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `since` field. */
  since?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<EventType>;
};

/** An input for mutations affecting `Event` */
export type EventInput = {
  capacity?: InputMaybe<Scalars['BigInt']['input']>;
  description: Scalars['String']['input'];
  descriptionMember?: InputMaybe<Scalars['String']['input']>;
  enableNotes?: InputMaybe<Scalars['Boolean']['input']>;
  filesLegacy?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  isLocked?: InputMaybe<Scalars['Boolean']['input']>;
  isPublic?: InputMaybe<Scalars['Boolean']['input']>;
  isVisible?: InputMaybe<Scalars['Boolean']['input']>;
  locationText: Scalars['String']['input'];
  name: Scalars['String']['input'];
  registrationPrice?: InputMaybe<PriceInput>;
  since?: InputMaybe<Scalars['Date']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
  titleImageLegacy?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<EventType>;
  until?: InputMaybe<Scalars['Date']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

export type EventInstance = {
  __typename?: 'EventInstance';
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Event` that is related to this `EventInstance`. */
  event: Maybe<Event>;
  /** Reads and enables pagination through a set of `EventAttendance`. */
  eventAttendancesByInstanceIdList: Array<EventAttendance>;
  eventId: Scalars['BigInt']['output'];
  /** Reads and enables pagination through a set of `EventInstanceTrainer`. */
  eventInstanceTrainersByInstanceIdList: Array<EventInstanceTrainer>;
  id: Scalars['BigInt']['output'];
  /** Reads a single `Location` that is related to this `EventInstance`. */
  location: Maybe<Location>;
  locationId: Maybe<Scalars['BigInt']['output']>;
  range: DatetimeRange;
  since: Scalars['Datetime']['output'];
  /** Reads a single `Tenant` that is related to this `EventInstance`. */
  tenant: Maybe<Tenant>;
  tenantId: Scalars['BigInt']['output'];
  until: Scalars['Datetime']['output'];
  updatedAt: Scalars['Datetime']['output'];
};


export type EventInstanceEventAttendancesByInstanceIdListArgs = {
  condition?: InputMaybe<EventAttendanceCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventAttendancesOrderBy>>;
};


export type EventInstanceEventInstanceTrainersByInstanceIdListArgs = {
  condition?: InputMaybe<EventInstanceTrainerCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventInstanceTrainersOrderBy>>;
};

/**
 * A condition to be used against `EventInstance` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type EventInstanceCondition = {
  /** Checks for equality with the object’s `eventId` field. */
  eventId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `locationId` field. */
  locationId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `range` field. */
  range?: InputMaybe<DatetimeRangeInput>;
  /** Checks for equality with the object’s `since` field. */
  since?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `tenantId` field. */
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `until` field. */
  until?: InputMaybe<Scalars['Datetime']['input']>;
};

export type EventInstanceTrainer = {
  __typename?: 'EventInstanceTrainer';
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['BigInt']['output'];
  /** Reads a single `EventInstance` that is related to this `EventInstanceTrainer`. */
  instance: Maybe<EventInstance>;
  instanceId: Scalars['BigInt']['output'];
  /** Reads a single `Person` that is related to this `EventInstanceTrainer`. */
  person: Maybe<Person>;
  personId: Scalars['BigInt']['output'];
  /** Reads a single `Tenant` that is related to this `EventInstanceTrainer`. */
  tenant: Maybe<Tenant>;
  tenantId: Scalars['BigInt']['output'];
  updatedAt: Scalars['Datetime']['output'];
};

/**
 * A condition to be used against `EventInstanceTrainer` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type EventInstanceTrainerCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `instanceId` field. */
  instanceId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `personId` field. */
  personId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `tenantId` field. */
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Methods to use when ordering `EventInstanceTrainer`. */
export type EventInstanceTrainersOrderBy =
  | 'EVENT_INSTANCE_BY_INSTANCE_ID__EVENT_ID_ASC'
  | 'EVENT_INSTANCE_BY_INSTANCE_ID__EVENT_ID_DESC'
  | 'EVENT_INSTANCE_BY_INSTANCE_ID__ID_ASC'
  | 'EVENT_INSTANCE_BY_INSTANCE_ID__ID_DESC'
  | 'EVENT_INSTANCE_BY_INSTANCE_ID__LOCATION_ID_ASC'
  | 'EVENT_INSTANCE_BY_INSTANCE_ID__LOCATION_ID_DESC'
  | 'EVENT_INSTANCE_BY_INSTANCE_ID__RANGE_ASC'
  | 'EVENT_INSTANCE_BY_INSTANCE_ID__RANGE_DESC'
  | 'EVENT_INSTANCE_BY_INSTANCE_ID__SINCE_ASC'
  | 'EVENT_INSTANCE_BY_INSTANCE_ID__SINCE_DESC'
  | 'EVENT_INSTANCE_BY_INSTANCE_ID__TENANT_ID_ASC'
  | 'EVENT_INSTANCE_BY_INSTANCE_ID__TENANT_ID_DESC'
  | 'EVENT_INSTANCE_BY_INSTANCE_ID__UNTIL_ASC'
  | 'EVENT_INSTANCE_BY_INSTANCE_ID__UNTIL_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'INSTANCE_ID_ASC'
  | 'INSTANCE_ID_DESC'
  | 'NATURAL'
  | 'PERSON_BY_PERSON_ID__ID_ASC'
  | 'PERSON_BY_PERSON_ID__ID_DESC'
  | 'PERSON_ID_ASC'
  | 'PERSON_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TENANT_BY_TENANT_ID__ID_ASC'
  | 'TENANT_BY_TENANT_ID__ID_DESC'
  | 'TENANT_ID_ASC'
  | 'TENANT_ID_DESC';

/** A connection to a list of `EventInstance` values. */
export type EventInstancesConnection = {
  __typename?: 'EventInstancesConnection';
  /** A list of edges which contains the `EventInstance` and cursor to aid in pagination. */
  edges: Array<EventInstancesEdge>;
  /** A list of `EventInstance` objects. */
  nodes: Array<EventInstance>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EventInstance` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `EventInstance` edge in the connection. */
export type EventInstancesEdge = {
  __typename?: 'EventInstancesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `EventInstance` at the end of the edge. */
  node: EventInstance;
};

/** Methods to use when ordering `EventInstance`. */
export type EventInstancesOrderBy =
  | 'EVENT_ATTENDANCES_BY_INSTANCE_ID__COUNT_ASC'
  | 'EVENT_ATTENDANCES_BY_INSTANCE_ID__COUNT_DESC'
  | 'EVENT_BY_EVENT_ID__ID_ASC'
  | 'EVENT_BY_EVENT_ID__ID_DESC'
  | 'EVENT_BY_EVENT_ID__IS_VISIBLE_ASC'
  | 'EVENT_BY_EVENT_ID__IS_VISIBLE_DESC'
  | 'EVENT_BY_EVENT_ID__SINCE_ASC'
  | 'EVENT_BY_EVENT_ID__SINCE_DESC'
  | 'EVENT_BY_EVENT_ID__TYPE_ASC'
  | 'EVENT_BY_EVENT_ID__TYPE_DESC'
  | 'EVENT_ID_ASC'
  | 'EVENT_ID_DESC'
  | 'EVENT_INSTANCE_TRAINERS_BY_INSTANCE_ID__COUNT_ASC'
  | 'EVENT_INSTANCE_TRAINERS_BY_INSTANCE_ID__COUNT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'LOCATION_BY_LOCATION_ID__ID_ASC'
  | 'LOCATION_BY_LOCATION_ID__ID_DESC'
  | 'LOCATION_ID_ASC'
  | 'LOCATION_ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'RANGE_ASC'
  | 'RANGE_DESC'
  | 'SINCE_ASC'
  | 'SINCE_DESC'
  | 'TENANT_BY_TENANT_ID__ID_ASC'
  | 'TENANT_BY_TENANT_ID__ID_DESC'
  | 'TENANT_ID_ASC'
  | 'TENANT_ID_DESC'
  | 'UNTIL_ASC'
  | 'UNTIL_DESC';

export type EventLessonDemand = {
  __typename?: 'EventLessonDemand';
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['BigInt']['output'];
  lessonCount: Scalars['Int']['output'];
  /** Reads a single `EventRegistration` that is related to this `EventLessonDemand`. */
  registration: Maybe<EventRegistration>;
  registrationId: Scalars['BigInt']['output'];
  /** Reads a single `Tenant` that is related to this `EventLessonDemand`. */
  tenant: Maybe<Tenant>;
  tenantId: Scalars['BigInt']['output'];
  /** Reads a single `EventTrainer` that is related to this `EventLessonDemand`. */
  trainer: Maybe<EventTrainer>;
  trainerId: Scalars['BigInt']['output'];
  updatedAt: Scalars['Datetime']['output'];
};

/**
 * A condition to be used against `EventLessonDemand` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type EventLessonDemandCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `registrationId` field. */
  registrationId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `tenantId` field. */
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `trainerId` field. */
  trainerId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Represents an update to a `EventLessonDemand`. Fields that are set will be updated. */
export type EventLessonDemandPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  lessonCount?: InputMaybe<Scalars['Int']['input']>;
  registrationId?: InputMaybe<Scalars['BigInt']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
  trainerId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Methods to use when ordering `EventLessonDemand`. */
export type EventLessonDemandsOrderBy =
  | 'EVENT_REGISTRATION_BY_REGISTRATION_ID__COUPLE_ID_ASC'
  | 'EVENT_REGISTRATION_BY_REGISTRATION_ID__COUPLE_ID_DESC'
  | 'EVENT_REGISTRATION_BY_REGISTRATION_ID__EVENT_ID_ASC'
  | 'EVENT_REGISTRATION_BY_REGISTRATION_ID__EVENT_ID_DESC'
  | 'EVENT_REGISTRATION_BY_REGISTRATION_ID__ID_ASC'
  | 'EVENT_REGISTRATION_BY_REGISTRATION_ID__ID_DESC'
  | 'EVENT_REGISTRATION_BY_REGISTRATION_ID__PAYMENT_ID_ASC'
  | 'EVENT_REGISTRATION_BY_REGISTRATION_ID__PAYMENT_ID_DESC'
  | 'EVENT_REGISTRATION_BY_REGISTRATION_ID__PERSON_ID_ASC'
  | 'EVENT_REGISTRATION_BY_REGISTRATION_ID__PERSON_ID_DESC'
  | 'EVENT_REGISTRATION_BY_REGISTRATION_ID__TARGET_COHORT_ID_ASC'
  | 'EVENT_REGISTRATION_BY_REGISTRATION_ID__TARGET_COHORT_ID_DESC'
  | 'EVENT_REGISTRATION_BY_REGISTRATION_ID__TENANT_ID_ASC'
  | 'EVENT_REGISTRATION_BY_REGISTRATION_ID__TENANT_ID_DESC'
  | 'EVENT_TRAINER_BY_TRAINER_ID__EVENT_ID_ASC'
  | 'EVENT_TRAINER_BY_TRAINER_ID__EVENT_ID_DESC'
  | 'EVENT_TRAINER_BY_TRAINER_ID__ID_ASC'
  | 'EVENT_TRAINER_BY_TRAINER_ID__ID_DESC'
  | 'EVENT_TRAINER_BY_TRAINER_ID__PERSON_ID_ASC'
  | 'EVENT_TRAINER_BY_TRAINER_ID__PERSON_ID_DESC'
  | 'EVENT_TRAINER_BY_TRAINER_ID__TENANT_ID_ASC'
  | 'EVENT_TRAINER_BY_TRAINER_ID__TENANT_ID_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'REGISTRATION_ID_ASC'
  | 'REGISTRATION_ID_DESC'
  | 'TENANT_BY_TENANT_ID__ID_ASC'
  | 'TENANT_BY_TENANT_ID__ID_DESC'
  | 'TENANT_ID_ASC'
  | 'TENANT_ID_DESC'
  | 'TRAINER_ID_ASC'
  | 'TRAINER_ID_DESC';

/** Represents an update to a `Event`. Fields that are set will be updated. */
export type EventPatch = {
  capacity?: InputMaybe<Scalars['BigInt']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  descriptionMember?: InputMaybe<Scalars['String']['input']>;
  enableNotes?: InputMaybe<Scalars['Boolean']['input']>;
  filesLegacy?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  isLocked?: InputMaybe<Scalars['Boolean']['input']>;
  isPublic?: InputMaybe<Scalars['Boolean']['input']>;
  isVisible?: InputMaybe<Scalars['Boolean']['input']>;
  locationText?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  registrationPrice?: InputMaybe<PriceInput>;
  since?: InputMaybe<Scalars['Date']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
  titleImageLegacy?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<EventType>;
  until?: InputMaybe<Scalars['Date']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

export type EventRegistration = {
  __typename?: 'EventRegistration';
  confirmedAt: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `Couple` that is related to this `EventRegistration`. */
  couple: Maybe<Couple>;
  coupleId: Maybe<Scalars['BigInt']['output']>;
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Event` that is related to this `EventRegistration`. */
  event: Maybe<Event>;
  eventId: Scalars['BigInt']['output'];
  /** Reads and enables pagination through a set of `EventLessonDemand`. */
  eventLessonDemandsByRegistrationIdList: Array<EventLessonDemand>;
  id: Scalars['BigInt']['output'];
  isConfirmed: Maybe<Scalars['Boolean']['output']>;
  note: Maybe<Scalars['String']['output']>;
  /** Reads a single `PlatbyItem` that is related to this `EventRegistration`. */
  payment: Maybe<PlatbyItem>;
  paymentId: Maybe<Scalars['BigInt']['output']>;
  /** Reads a single `Person` that is related to this `EventRegistration`. */
  person: Maybe<Person>;
  personId: Maybe<Scalars['BigInt']['output']>;
  statusTime: RegistrationTime;
  /** Reads a single `EventTargetCohort` that is related to this `EventRegistration`. */
  targetCohort: Maybe<EventTargetCohort>;
  targetCohortId: Maybe<Scalars['BigInt']['output']>;
  /** Reads a single `Tenant` that is related to this `EventRegistration`. */
  tenant: Maybe<Tenant>;
  tenantId: Scalars['BigInt']['output'];
  updatedAt: Scalars['Datetime']['output'];
};


export type EventRegistrationEventLessonDemandsByRegistrationIdListArgs = {
  condition?: InputMaybe<EventLessonDemandCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventLessonDemandsOrderBy>>;
};

/**
 * A condition to be used against `EventRegistration` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type EventRegistrationCondition = {
  /** Checks for equality with the object’s `coupleId` field. */
  coupleId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `eventId` field. */
  eventId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `paymentId` field. */
  paymentId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `personId` field. */
  personId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `targetCohortId` field. */
  targetCohortId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `tenantId` field. */
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `EventRegistration` */
export type EventRegistrationInput = {
  confirmedAt?: InputMaybe<Scalars['Datetime']['input']>;
  coupleId?: InputMaybe<Scalars['BigInt']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  eventId: Scalars['BigInt']['input'];
  isConfirmed?: InputMaybe<Scalars['Boolean']['input']>;
  note?: InputMaybe<Scalars['String']['input']>;
  paymentId?: InputMaybe<Scalars['BigInt']['input']>;
  personId?: InputMaybe<Scalars['BigInt']['input']>;
  statusTime?: InputMaybe<RegistrationTime>;
  targetCohortId?: InputMaybe<Scalars['BigInt']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Methods to use when ordering `EventRegistration`. */
export type EventRegistrationsOrderBy =
  | 'COUPLE_BY_COUPLE_ID__ACTIVE_ASC'
  | 'COUPLE_BY_COUPLE_ID__ACTIVE_DESC'
  | 'COUPLE_BY_COUPLE_ID__ID_ASC'
  | 'COUPLE_BY_COUPLE_ID__ID_DESC'
  | 'COUPLE_BY_COUPLE_ID__MAN_ID_ASC'
  | 'COUPLE_BY_COUPLE_ID__MAN_ID_DESC'
  | 'COUPLE_BY_COUPLE_ID__WOMAN_ID_ASC'
  | 'COUPLE_BY_COUPLE_ID__WOMAN_ID_DESC'
  | 'COUPLE_ID_ASC'
  | 'COUPLE_ID_DESC'
  | 'EVENT_BY_EVENT_ID__ID_ASC'
  | 'EVENT_BY_EVENT_ID__ID_DESC'
  | 'EVENT_BY_EVENT_ID__IS_VISIBLE_ASC'
  | 'EVENT_BY_EVENT_ID__IS_VISIBLE_DESC'
  | 'EVENT_BY_EVENT_ID__SINCE_ASC'
  | 'EVENT_BY_EVENT_ID__SINCE_DESC'
  | 'EVENT_BY_EVENT_ID__TYPE_ASC'
  | 'EVENT_BY_EVENT_ID__TYPE_DESC'
  | 'EVENT_ID_ASC'
  | 'EVENT_ID_DESC'
  | 'EVENT_LESSON_DEMANDS_BY_REGISTRATION_ID__COUNT_ASC'
  | 'EVENT_LESSON_DEMANDS_BY_REGISTRATION_ID__COUNT_DESC'
  | 'EVENT_TARGET_COHORT_BY_TARGET_COHORT_ID__COHORT_ID_ASC'
  | 'EVENT_TARGET_COHORT_BY_TARGET_COHORT_ID__COHORT_ID_DESC'
  | 'EVENT_TARGET_COHORT_BY_TARGET_COHORT_ID__EVENT_ID_ASC'
  | 'EVENT_TARGET_COHORT_BY_TARGET_COHORT_ID__EVENT_ID_DESC'
  | 'EVENT_TARGET_COHORT_BY_TARGET_COHORT_ID__ID_ASC'
  | 'EVENT_TARGET_COHORT_BY_TARGET_COHORT_ID__ID_DESC'
  | 'EVENT_TARGET_COHORT_BY_TARGET_COHORT_ID__TENANT_ID_ASC'
  | 'EVENT_TARGET_COHORT_BY_TARGET_COHORT_ID__TENANT_ID_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PAYMENT_ID_ASC'
  | 'PAYMENT_ID_DESC'
  | 'PERSON_BY_PERSON_ID__ID_ASC'
  | 'PERSON_BY_PERSON_ID__ID_DESC'
  | 'PERSON_ID_ASC'
  | 'PERSON_ID_DESC'
  | 'PLATBY_ITEM_BY_PAYMENT_ID__PI_ID_ASC'
  | 'PLATBY_ITEM_BY_PAYMENT_ID__PI_ID_CATEGORY_ASC'
  | 'PLATBY_ITEM_BY_PAYMENT_ID__PI_ID_CATEGORY_DESC'
  | 'PLATBY_ITEM_BY_PAYMENT_ID__PI_ID_DESC'
  | 'PLATBY_ITEM_BY_PAYMENT_ID__PI_ID_RAW_ASC'
  | 'PLATBY_ITEM_BY_PAYMENT_ID__PI_ID_RAW_DESC'
  | 'PLATBY_ITEM_BY_PAYMENT_ID__PI_ID_USER_ASC'
  | 'PLATBY_ITEM_BY_PAYMENT_ID__PI_ID_USER_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TARGET_COHORT_ID_ASC'
  | 'TARGET_COHORT_ID_DESC'
  | 'TENANT_BY_TENANT_ID__ID_ASC'
  | 'TENANT_BY_TENANT_ID__ID_DESC'
  | 'TENANT_ID_ASC'
  | 'TENANT_ID_DESC';

export type EventTargetCohort = {
  __typename?: 'EventTargetCohort';
  /** Reads a single `Skupiny` that is related to this `EventTargetCohort`. */
  cohort: Maybe<Skupiny>;
  cohortId: Scalars['BigInt']['output'];
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Event` that is related to this `EventTargetCohort`. */
  event: Maybe<Event>;
  eventId: Scalars['BigInt']['output'];
  /** Reads and enables pagination through a set of `EventRegistration`. */
  eventRegistrationsByTargetCohortIdList: Array<EventRegistration>;
  id: Scalars['BigInt']['output'];
  /** Reads a single `Tenant` that is related to this `EventTargetCohort`. */
  tenant: Maybe<Tenant>;
  tenantId: Scalars['BigInt']['output'];
  updatedAt: Scalars['Datetime']['output'];
};


export type EventTargetCohortEventRegistrationsByTargetCohortIdListArgs = {
  condition?: InputMaybe<EventRegistrationCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventRegistrationsOrderBy>>;
};

/**
 * A condition to be used against `EventTargetCohort` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type EventTargetCohortCondition = {
  /** Checks for equality with the object’s `cohortId` field. */
  cohortId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `eventId` field. */
  eventId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `tenantId` field. */
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Methods to use when ordering `EventTargetCohort`. */
export type EventTargetCohortsOrderBy =
  | 'COHORT_ID_ASC'
  | 'COHORT_ID_DESC'
  | 'EVENT_BY_EVENT_ID__ID_ASC'
  | 'EVENT_BY_EVENT_ID__ID_DESC'
  | 'EVENT_BY_EVENT_ID__IS_VISIBLE_ASC'
  | 'EVENT_BY_EVENT_ID__IS_VISIBLE_DESC'
  | 'EVENT_BY_EVENT_ID__SINCE_ASC'
  | 'EVENT_BY_EVENT_ID__SINCE_DESC'
  | 'EVENT_BY_EVENT_ID__TYPE_ASC'
  | 'EVENT_BY_EVENT_ID__TYPE_DESC'
  | 'EVENT_ID_ASC'
  | 'EVENT_ID_DESC'
  | 'EVENT_REGISTRATIONS_BY_TARGET_COHORT_ID__COUNT_ASC'
  | 'EVENT_REGISTRATIONS_BY_TARGET_COHORT_ID__COUNT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SKUPINY_BY_COHORT_ID__COHORT_GROUP_ASC'
  | 'SKUPINY_BY_COHORT_ID__COHORT_GROUP_DESC'
  | 'SKUPINY_BY_COHORT_ID__ORDERING_ASC'
  | 'SKUPINY_BY_COHORT_ID__ORDERING_DESC'
  | 'SKUPINY_BY_COHORT_ID__S_ID_ASC'
  | 'SKUPINY_BY_COHORT_ID__S_ID_DESC'
  | 'SKUPINY_BY_COHORT_ID__S_VISIBLE_ASC'
  | 'SKUPINY_BY_COHORT_ID__S_VISIBLE_DESC'
  | 'TENANT_BY_TENANT_ID__ID_ASC'
  | 'TENANT_BY_TENANT_ID__ID_DESC'
  | 'TENANT_ID_ASC'
  | 'TENANT_ID_DESC';

export type EventTrainer = {
  __typename?: 'EventTrainer';
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Event` that is related to this `EventTrainer`. */
  event: Maybe<Event>;
  eventId: Scalars['BigInt']['output'];
  /** Reads and enables pagination through a set of `EventLessonDemand`. */
  eventLessonDemandsByTrainerIdList: Array<EventLessonDemand>;
  id: Scalars['BigInt']['output'];
  lessonPrice: Maybe<Price>;
  lessonsOffered: Scalars['Int']['output'];
  lessonsRemaining: Maybe<Scalars['Int']['output']>;
  /** Reads a single `Person` that is related to this `EventTrainer`. */
  person: Maybe<Person>;
  personId: Scalars['BigInt']['output'];
  /** Reads a single `Tenant` that is related to this `EventTrainer`. */
  tenant: Maybe<Tenant>;
  tenantId: Scalars['BigInt']['output'];
  updatedAt: Scalars['Datetime']['output'];
};


export type EventTrainerEventLessonDemandsByTrainerIdListArgs = {
  condition?: InputMaybe<EventLessonDemandCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventLessonDemandsOrderBy>>;
};

/**
 * A condition to be used against `EventTrainer` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type EventTrainerCondition = {
  /** Checks for equality with the object’s `eventId` field. */
  eventId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `personId` field. */
  personId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `tenantId` field. */
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Methods to use when ordering `EventTrainer`. */
export type EventTrainersOrderBy =
  | 'EVENT_BY_EVENT_ID__ID_ASC'
  | 'EVENT_BY_EVENT_ID__ID_DESC'
  | 'EVENT_BY_EVENT_ID__IS_VISIBLE_ASC'
  | 'EVENT_BY_EVENT_ID__IS_VISIBLE_DESC'
  | 'EVENT_BY_EVENT_ID__SINCE_ASC'
  | 'EVENT_BY_EVENT_ID__SINCE_DESC'
  | 'EVENT_BY_EVENT_ID__TYPE_ASC'
  | 'EVENT_BY_EVENT_ID__TYPE_DESC'
  | 'EVENT_ID_ASC'
  | 'EVENT_ID_DESC'
  | 'EVENT_LESSON_DEMANDS_BY_TRAINER_ID__COUNT_ASC'
  | 'EVENT_LESSON_DEMANDS_BY_TRAINER_ID__COUNT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PERSON_BY_PERSON_ID__ID_ASC'
  | 'PERSON_BY_PERSON_ID__ID_DESC'
  | 'PERSON_ID_ASC'
  | 'PERSON_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TENANT_BY_TENANT_ID__ID_ASC'
  | 'TENANT_BY_TENANT_ID__ID_DESC'
  | 'TENANT_ID_ASC'
  | 'TENANT_ID_DESC';

export type EventType =
  | 'CAMP'
  | 'HOLIDAY'
  | 'LESSON'
  | 'RESERVATION';

/** A connection to a list of `Event` values. */
export type EventsConnection = {
  __typename?: 'EventsConnection';
  /** A list of edges which contains the `Event` and cursor to aid in pagination. */
  edges: Array<EventsEdge>;
  /** A list of `Event` objects. */
  nodes: Array<Event>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Event` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Event` edge in the connection. */
export type EventsEdge = {
  __typename?: 'EventsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Event` at the end of the edge. */
  node: Event;
};

/** Methods to use when ordering `Event`. */
export type EventsOrderBy =
  | 'EVENT_INSTANCES_BY_EVENT_ID__COUNT_ASC'
  | 'EVENT_INSTANCES_BY_EVENT_ID__COUNT_DESC'
  | 'EVENT_REGISTRATIONS_BY_EVENT_ID__COUNT_ASC'
  | 'EVENT_REGISTRATIONS_BY_EVENT_ID__COUNT_DESC'
  | 'EVENT_TARGET_COHORTS_BY_EVENT_ID__COUNT_ASC'
  | 'EVENT_TARGET_COHORTS_BY_EVENT_ID__COUNT_DESC'
  | 'EVENT_TRAINERS_BY_EVENT_ID__COUNT_ASC'
  | 'EVENT_TRAINERS_BY_EVENT_ID__COUNT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'IS_VISIBLE_ASC'
  | 'IS_VISIBLE_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SINCE_ASC'
  | 'SINCE_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC';

export type FormResponse = {
  __typename?: 'FormResponse';
  createdAt: Scalars['Datetime']['output'];
  data: Scalars['JSON']['output'];
  id: Scalars['BigInt']['output'];
  tenantId: Scalars['BigInt']['output'];
  type: Scalars['String']['output'];
  updatedAt: Scalars['Datetime']['output'];
  url: Scalars['String']['output'];
};

/**
 * A condition to be used against `FormResponse` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type FormResponseCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An input for mutations affecting `FormResponse` */
export type FormResponseInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  data: Scalars['JSON']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
  type: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  url: Scalars['String']['input'];
};

/** A connection to a list of `FormResponse` values. */
export type FormResponsesConnection = {
  __typename?: 'FormResponsesConnection';
  /** A list of edges which contains the `FormResponse` and cursor to aid in pagination. */
  edges: Array<FormResponsesEdge>;
  /** A list of `FormResponse` objects. */
  nodes: Array<FormResponse>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FormResponse` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FormResponse` edge in the connection. */
export type FormResponsesEdge = {
  __typename?: 'FormResponsesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `FormResponse` at the end of the edge. */
  node: FormResponse;
};

/** Methods to use when ordering `FormResponse`. */
export type FormResponsesOrderBy =
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC';

export type GalerieDir = {
  __typename?: 'GalerieDir';
  /** Reads and enables pagination through a set of `GalerieFoto`. */
  galerieFotosByGfIdRodic: GalerieFotosConnection;
  gdHidden: Scalars['Boolean']['output'];
  gdId: Scalars['BigInt']['output'];
  gdIdRodic: Scalars['BigInt']['output'];
  gdLevel: Scalars['Int']['output'];
  gdName: Scalars['String']['output'];
  gdPath: Scalars['String']['output'];
  id: Maybe<Scalars['BigInt']['output']>;
  tenantId: Scalars['BigInt']['output'];
};


export type GalerieDirGalerieFotosByGfIdRodicArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GalerieFotoCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GalerieFotosOrderBy>>;
};

/**
 * A condition to be used against `GalerieDir` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type GalerieDirCondition = {
  /** Checks for equality with the object’s `gdId` field. */
  gdId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `gdIdRodic` field. */
  gdIdRodic?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `GalerieDir` values. */
export type GalerieDirsConnection = {
  __typename?: 'GalerieDirsConnection';
  /** A list of edges which contains the `GalerieDir` and cursor to aid in pagination. */
  edges: Array<GalerieDirsEdge>;
  /** A list of `GalerieDir` objects. */
  nodes: Array<GalerieDir>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `GalerieDir` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `GalerieDir` edge in the connection. */
export type GalerieDirsEdge = {
  __typename?: 'GalerieDirsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `GalerieDir` at the end of the edge. */
  node: GalerieDir;
};

/** Methods to use when ordering `GalerieDir`. */
export type GalerieDirsOrderBy =
  | 'GALERIE_FOTOS_BY_GF_ID_RODIC__COUNT_ASC'
  | 'GALERIE_FOTOS_BY_GF_ID_RODIC__COUNT_DESC'
  | 'GD_ID_ASC'
  | 'GD_ID_DESC'
  | 'GD_ID_RODIC_ASC'
  | 'GD_ID_RODIC_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

export type GalerieFoto = {
  __typename?: 'GalerieFoto';
  /** Reads and enables pagination through a set of `Aktuality`. */
  aktualitiesByAtFotoMain: AktualitiesConnection;
  /** Reads a single `GalerieDir` that is related to this `GalerieFoto`. */
  galerieDirByGfIdRodic: Maybe<GalerieDir>;
  gfId: Scalars['BigInt']['output'];
  gfIdRodic: Scalars['BigInt']['output'];
  gfKdo: Scalars['BigInt']['output'];
  gfName: Scalars['String']['output'];
  gfPath: Scalars['String']['output'];
  gfTimestamp: Maybe<Scalars['Datetime']['output']>;
  id: Maybe<Scalars['BigInt']['output']>;
  tenantId: Scalars['BigInt']['output'];
  /** Reads a single `User` that is related to this `GalerieFoto`. */
  userByGfKdo: Maybe<User>;
};


export type GalerieFotoAktualitiesByAtFotoMainArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AktualityCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AktualitiesOrderBy>>;
};

/**
 * A condition to be used against `GalerieFoto` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type GalerieFotoCondition = {
  /** Checks for equality with the object’s `gfId` field. */
  gfId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `gfIdRodic` field. */
  gfIdRodic?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `gfKdo` field. */
  gfKdo?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `GalerieFoto` values. */
export type GalerieFotosConnection = {
  __typename?: 'GalerieFotosConnection';
  /** A list of edges which contains the `GalerieFoto` and cursor to aid in pagination. */
  edges: Array<GalerieFotosEdge>;
  /** A list of `GalerieFoto` objects. */
  nodes: Array<GalerieFoto>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `GalerieFoto` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `GalerieFoto` edge in the connection. */
export type GalerieFotosEdge = {
  __typename?: 'GalerieFotosEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `GalerieFoto` at the end of the edge. */
  node: GalerieFoto;
};

/** Methods to use when ordering `GalerieFoto`. */
export type GalerieFotosOrderBy =
  | 'AKTUALITIES_BY_AT_FOTO_MAIN__COUNT_ASC'
  | 'AKTUALITIES_BY_AT_FOTO_MAIN__COUNT_DESC'
  | 'GALERIE_DIR_BY_GF_ID_RODIC__GD_ID_ASC'
  | 'GALERIE_DIR_BY_GF_ID_RODIC__GD_ID_DESC'
  | 'GALERIE_DIR_BY_GF_ID_RODIC__GD_ID_RODIC_ASC'
  | 'GALERIE_DIR_BY_GF_ID_RODIC__GD_ID_RODIC_DESC'
  | 'GF_ID_ASC'
  | 'GF_ID_DESC'
  | 'GF_ID_RODIC_ASC'
  | 'GF_ID_RODIC_DESC'
  | 'GF_KDO_ASC'
  | 'GF_KDO_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'USER_BY_GF_KDO__U_ID_ASC'
  | 'USER_BY_GF_KDO__U_ID_DESC'
  | 'USER_BY_GF_KDO__U_JMENO_ASC'
  | 'USER_BY_GF_KDO__U_JMENO_DESC'
  | 'USER_BY_GF_KDO__U_LOGIN_ASC'
  | 'USER_BY_GF_KDO__U_LOGIN_DESC'
  | 'USER_BY_GF_KDO__U_PRIJMENI_ASC'
  | 'USER_BY_GF_KDO__U_PRIJMENI_DESC';

export type GenderType =
  | 'MAN'
  | 'UNSPECIFIED'
  | 'WOMAN';

/** All input for the `isCurrentTenantMember` mutation. */
export type IsCurrentTenantMemberInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our `isCurrentTenantMember` mutation. */
export type IsCurrentTenantMemberPayload = {
  __typename?: 'IsCurrentTenantMemberPayload';
  boolean: Maybe<Scalars['Boolean']['output']>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type Location = {
  __typename?: 'Location';
  address: Maybe<AddressDomain>;
  description: Scalars['JSON']['output'];
  /** Reads and enables pagination through a set of `EventInstance`. */
  eventInstances: EventInstancesConnection;
  /** Reads and enables pagination through a set of `EventInstance`. */
  eventInstancesList: Array<EventInstance>;
  id: Scalars['BigInt']['output'];
  /** Reads and enables pagination through a set of `LocationAttachment`. */
  locationAttachments: LocationAttachmentsConnection;
  name: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Room`. */
  roomsByLocation: RoomsConnection;
  /** Reads and enables pagination through a set of `TenantLocation`. */
  tenantLocationsList: Array<TenantLocation>;
};


export type LocationEventInstancesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventInstanceCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventInstancesOrderBy>>;
};


export type LocationEventInstancesListArgs = {
  condition?: InputMaybe<EventInstanceCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventInstancesOrderBy>>;
};


export type LocationLocationAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LocationAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LocationAttachmentsOrderBy>>;
};


export type LocationRoomsByLocationArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomsOrderBy>>;
};


export type LocationTenantLocationsListArgs = {
  condition?: InputMaybe<TenantLocationCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TenantLocationsOrderBy>>;
};

export type LocationAttachment = {
  __typename?: 'LocationAttachment';
  /** Reads a single `Attachment` that is related to this `LocationAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  /** Reads a single `Location` that is related to this `LocationAttachment`. */
  location: Maybe<Location>;
  locationId: Scalars['BigInt']['output'];
  objectName: Scalars['String']['output'];
};

/**
 * A condition to be used against `LocationAttachment` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type LocationAttachmentCondition = {
  /** Checks for equality with the object’s `locationId` field. */
  locationId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `objectName` field. */
  objectName?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `LocationAttachment` values. */
export type LocationAttachmentsConnection = {
  __typename?: 'LocationAttachmentsConnection';
  /** A list of edges which contains the `LocationAttachment` and cursor to aid in pagination. */
  edges: Array<LocationAttachmentsEdge>;
  /** A list of `LocationAttachment` objects. */
  nodes: Array<LocationAttachment>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `LocationAttachment` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `LocationAttachment` edge in the connection. */
export type LocationAttachmentsEdge = {
  __typename?: 'LocationAttachmentsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `LocationAttachment` at the end of the edge. */
  node: LocationAttachment;
};

/** Methods to use when ordering `LocationAttachment`. */
export type LocationAttachmentsOrderBy =
  | 'ATTACHMENT_BY_OBJECT_NAME__OBJECT_NAME_ASC'
  | 'ATTACHMENT_BY_OBJECT_NAME__OBJECT_NAME_DESC'
  | 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_BY_ASC'
  | 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_BY_DESC'
  | 'LOCATION_BY_LOCATION_ID__ID_ASC'
  | 'LOCATION_BY_LOCATION_ID__ID_DESC'
  | 'LOCATION_ID_ASC'
  | 'LOCATION_ID_DESC'
  | 'NATURAL'
  | 'OBJECT_NAME_ASC'
  | 'OBJECT_NAME_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Location` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type LocationCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `Location` */
export type LocationInput = {
  address?: InputMaybe<AddressDomainInput>;
  description: Scalars['JSON']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  name: Scalars['String']['input'];
};

/** Represents an update to a `Location`. Fields that are set will be updated. */
export type LocationPatch = {
  address?: InputMaybe<AddressDomainInput>;
  description?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `Location` values. */
export type LocationsConnection = {
  __typename?: 'LocationsConnection';
  /** A list of edges which contains the `Location` and cursor to aid in pagination. */
  edges: Array<LocationsEdge>;
  /** A list of `Location` objects. */
  nodes: Array<Location>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Location` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Location` edge in the connection. */
export type LocationsEdge = {
  __typename?: 'LocationsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Location` at the end of the edge. */
  node: Location;
};

/** Methods to use when ordering `Location`. */
export type LocationsOrderBy =
  | 'EVENT_INSTANCES_BY_LOCATION_ID__COUNT_ASC'
  | 'EVENT_INSTANCES_BY_LOCATION_ID__COUNT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'LOCATION_ATTACHMENTS_BY_LOCATION_ID__COUNT_ASC'
  | 'LOCATION_ATTACHMENTS_BY_LOCATION_ID__COUNT_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'ROOMS_BY_LOCATION__COUNT_ASC'
  | 'ROOMS_BY_LOCATION__COUNT_DESC'
  | 'TENANT_LOCATIONS_BY_LOCATION_ID__COUNT_ASC'
  | 'TENANT_LOCATIONS_BY_LOCATION_ID__COUNT_DESC';

/** All input for the `login` mutation. */
export type LoginInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  login: Scalars['String']['input'];
  passwd: Scalars['String']['input'];
};

/** The output of our `login` mutation. */
export type LoginPayload = {
  __typename?: 'LoginPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  result: Maybe<LoginRecord>;
};

/** The return type of our `login` mutation. */
export type LoginRecord = {
  __typename?: 'LoginRecord';
  sess: Maybe<Session>;
  usr: Maybe<User>;
};

/** All input for the `logout` mutation. */
export type LogoutInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our `logout` mutation. */
export type LogoutPayload = {
  __typename?: 'LogoutPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  __typename?: 'Mutation';
  cancelRegistration: Maybe<CancelRegistrationPayload>;
  changePassword: Maybe<ChangePasswordPayload>;
  confirmUser: Maybe<ConfirmUserPayload>;
  /** Creates a single `Aktuality`. */
  createAktuality: Maybe<CreateAktualityPayload>;
  /** Creates a single `Attachment`. */
  createAttachment: Maybe<CreateAttachmentPayload>;
  /** Creates a single `CohortGroup`. */
  createCohortGroup: Maybe<CreateCohortGroupPayload>;
  /** Creates a single `Couple`. */
  createCouple: Maybe<CreateCouplePayload>;
  /** Creates a single `Dokumenty`. */
  createDokumenty: Maybe<CreateDokumentyPayload>;
  /** Creates a single `Event`. */
  createEvent: Maybe<CreateEventPayload>;
  /** Creates a single `FormResponse`. */
  createFormResponse: Maybe<CreateFormResponsePayload>;
  /** Creates a single `Location`. */
  createLocation: Maybe<CreateLocationPayload>;
  /** Creates a single `Permission`. */
  createPermission: Maybe<CreatePermissionPayload>;
  /** Creates a single `Room`. */
  createRoom: Maybe<CreateRoomPayload>;
  /** Creates a single `Skupiny`. */
  createSkupiny: Maybe<CreateSkupinyPayload>;
  /** Creates a single `Upozorneni`. */
  createUpozorneni: Maybe<CreateUpozorneniPayload>;
  currentPersonIds: Maybe<CurrentPersonIdsPayload>;
  /** Deletes a single `Aktuality` using a unique key. */
  deleteAktuality: Maybe<DeleteAktualityPayload>;
  /** Deletes a single `Attachment` using a unique key. */
  deleteAttachment: Maybe<DeleteAttachmentPayload>;
  /** Deletes a single `CohortGroup` using a unique key. */
  deleteCohortGroup: Maybe<DeleteCohortGroupPayload>;
  deleteCouple: Maybe<DeleteCouplePayload>;
  /** Deletes a single `Dokumenty` using a unique key. */
  deleteDokumenty: Maybe<DeleteDokumentyPayload>;
  /** Deletes a single `Event` using a unique key. */
  deleteEvent: Maybe<DeleteEventPayload>;
  /** Deletes a single `Location` using a unique key. */
  deleteLocation: Maybe<DeleteLocationPayload>;
  /** Deletes a single `Room` using a unique key. */
  deleteRoom: Maybe<DeleteRoomPayload>;
  /** Deletes a single `Skupiny` using a unique key. */
  deleteSkupiny: Maybe<DeleteSkupinyPayload>;
  /** Deletes a single `Upozorneni` using a unique key. */
  deleteUpozorneni: Maybe<DeleteUpozorneniPayload>;
  editRegistration: Maybe<EditRegistrationPayload>;
  isCurrentTenantMember: Maybe<IsCurrentTenantMemberPayload>;
  login: Maybe<LoginPayload>;
  logout: Maybe<LogoutPayload>;
  registerToEvent: Maybe<RegisterToEventPayload>;
  resetPassword: Maybe<ResetPasswordPayload>;
  setLessonDemand: Maybe<SetLessonDemandPayload>;
  submitForm: Maybe<SubmitFormPayload>;
  /** Updates a single `Aktuality` using a unique key and a patch. */
  updateAktuality: Maybe<UpdateAktualityPayload>;
  /** Updates a single `CohortGroup` using a unique key and a patch. */
  updateCohortGroup: Maybe<UpdateCohortGroupPayload>;
  /** Updates a single `Dokumenty` using a unique key and a patch. */
  updateDokumenty: Maybe<UpdateDokumentyPayload>;
  /** Updates a single `Event` using a unique key and a patch. */
  updateEvent: Maybe<UpdateEventPayload>;
  /** Updates a single `Location` using a unique key and a patch. */
  updateLocation: Maybe<UpdateLocationPayload>;
  /** Updates a single `Person` using a unique key and a patch. */
  updatePerson: Maybe<UpdatePersonPayload>;
  /** Updates a single `Room` using a unique key and a patch. */
  updateRoom: Maybe<UpdateRoomPayload>;
  /** Updates a single `Skupiny` using a unique key and a patch. */
  updateSkupiny: Maybe<UpdateSkupinyPayload>;
  /** Updates a single `Tenant` using a unique key and a patch. */
  updateTenant: Maybe<UpdateTenantPayload>;
  /** Updates a single `Upozorneni` using a unique key and a patch. */
  updateUpozorneni: Maybe<UpdateUpozorneniPayload>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCancelRegistrationArgs = {
  input: CancelRegistrationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationChangePasswordArgs = {
  input: ChangePasswordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationConfirmUserArgs = {
  input: ConfirmUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAktualityArgs = {
  input: CreateAktualityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAttachmentArgs = {
  input: CreateAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCohortGroupArgs = {
  input: CreateCohortGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCoupleArgs = {
  input: CreateCoupleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDokumentyArgs = {
  input: CreateDokumentyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEventArgs = {
  input: CreateEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFormResponseArgs = {
  input: CreateFormResponseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLocationArgs = {
  input: CreateLocationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePermissionArgs = {
  input: CreatePermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRoomArgs = {
  input: CreateRoomInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSkupinyArgs = {
  input: CreateSkupinyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUpozorneniArgs = {
  input: CreateUpozorneniInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCurrentPersonIdsArgs = {
  input: CurrentPersonIdsInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAktualityArgs = {
  input: DeleteAktualityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAttachmentArgs = {
  input: DeleteAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCohortGroupArgs = {
  input: DeleteCohortGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCoupleArgs = {
  input: DeleteCoupleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDokumentyArgs = {
  input: DeleteDokumentyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEventArgs = {
  input: DeleteEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLocationArgs = {
  input: DeleteLocationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoomArgs = {
  input: DeleteRoomInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSkupinyArgs = {
  input: DeleteSkupinyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUpozorneniArgs = {
  input: DeleteUpozorneniInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationEditRegistrationArgs = {
  input: EditRegistrationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationIsCurrentTenantMemberArgs = {
  input: IsCurrentTenantMemberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationLoginArgs = {
  input: LoginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationLogoutArgs = {
  input: LogoutInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationRegisterToEventArgs = {
  input: RegisterToEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationResetPasswordArgs = {
  input: ResetPasswordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationSetLessonDemandArgs = {
  input: SetLessonDemandInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationSubmitFormArgs = {
  input: SubmitFormInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAktualityArgs = {
  input: UpdateAktualityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCohortGroupArgs = {
  input: UpdateCohortGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDokumentyArgs = {
  input: UpdateDokumentyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEventArgs = {
  input: UpdateEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLocationArgs = {
  input: UpdateLocationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePersonArgs = {
  input: UpdatePersonInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoomArgs = {
  input: UpdateRoomInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSkupinyArgs = {
  input: UpdateSkupinyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTenantArgs = {
  input: UpdateTenantInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUpozorneniArgs = {
  input: UpdateUpozorneniInput;
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor: Maybe<Scalars['Cursor']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor: Maybe<Scalars['Cursor']['output']>;
};

export type Pary = {
  __typename?: 'Pary';
  id: Maybe<Scalars['BigInt']['output']>;
  pArchiv: Scalars['Boolean']['output'];
  pHodnoceni: Scalars['Int']['output'];
  pId: Scalars['BigInt']['output'];
  pIdPartner: Scalars['BigInt']['output'];
  pIdPartnerka: Maybe<Scalars['BigInt']['output']>;
  pLatBody: Scalars['Int']['output'];
  pLatFinale: Scalars['Boolean']['output'];
  pLatTrida: ParyPLatTrida;
  pSttBody: Scalars['Int']['output'];
  pSttFinale: Scalars['Boolean']['output'];
  pSttTrida: ParyPSttTrida;
  pTimestampAdd: Scalars['Datetime']['output'];
  pTimestampArchive: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartner: Maybe<User>;
  /** Reads a single `User` that is related to this `Pary`. */
  userByPIdPartnerka: Maybe<User>;
};

export type ParyPLatTrida =
  | 'A'
  | 'B'
  | 'C'
  | 'D'
  | 'H'
  | 'M'
  | 'Z';

export type ParyPSttTrida =
  | 'A'
  | 'B'
  | 'C'
  | 'D'
  | 'H'
  | 'M'
  | 'Z';

export type PaymentStatus =
  | 'PAID'
  | 'TENTATIVE'
  | 'UNPAID';

/** A connection to a list of `Person` values. */
export type PeopleConnection = {
  __typename?: 'PeopleConnection';
  /** A list of edges which contains the `Person` and cursor to aid in pagination. */
  edges: Array<PeopleEdge>;
  /** A list of `Person` objects. */
  nodes: Array<Person>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Person` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Person` edge in the connection. */
export type PeopleEdge = {
  __typename?: 'PeopleEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Person` at the end of the edge. */
  node: Person;
};

/** Methods to use when ordering `Person`. */
export type PeopleOrderBy =
  | 'COHORT_MEMBERSHIPS_BY_PERSON_ID__COUNT_ASC'
  | 'COHORT_MEMBERSHIPS_BY_PERSON_ID__COUNT_DESC'
  | 'COUPLES_BY_MAN_ID__COUNT_ASC'
  | 'COUPLES_BY_MAN_ID__COUNT_DESC'
  | 'COUPLES_BY_WOMAN_ID__COUNT_ASC'
  | 'COUPLES_BY_WOMAN_ID__COUNT_DESC'
  | 'EVENT_ATTENDANCES_BY_PERSON_ID__COUNT_ASC'
  | 'EVENT_ATTENDANCES_BY_PERSON_ID__COUNT_DESC'
  | 'EVENT_INSTANCE_TRAINERS_BY_PERSON_ID__COUNT_ASC'
  | 'EVENT_INSTANCE_TRAINERS_BY_PERSON_ID__COUNT_DESC'
  | 'EVENT_REGISTRATIONS_BY_PERSON_ID__COUNT_ASC'
  | 'EVENT_REGISTRATIONS_BY_PERSON_ID__COUNT_DESC'
  | 'EVENT_TRAINERS_BY_PERSON_ID__COUNT_ASC'
  | 'EVENT_TRAINERS_BY_PERSON_ID__COUNT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PERSON_ADDRESSES_BY_PERSON_ID__COUNT_ASC'
  | 'PERSON_ADDRESSES_BY_PERSON_ID__COUNT_DESC'
  | 'PERSON_EMAILS_BY_PERSON_ID__COUNT_ASC'
  | 'PERSON_EMAILS_BY_PERSON_ID__COUNT_DESC'
  | 'PERSON_PHONES_BY_PERSON_ID__COUNT_ASC'
  | 'PERSON_PHONES_BY_PERSON_ID__COUNT_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TENANT_ADMINISTRATORS_BY_PERSON_ID__COUNT_ASC'
  | 'TENANT_ADMINISTRATORS_BY_PERSON_ID__COUNT_DESC'
  | 'TENANT_MEMBERSHIPS_BY_PERSON_ID__COUNT_ASC'
  | 'TENANT_MEMBERSHIPS_BY_PERSON_ID__COUNT_DESC'
  | 'TENANT_TRAINERS_BY_PERSON_ID__COUNT_ASC'
  | 'TENANT_TRAINERS_BY_PERSON_ID__COUNT_DESC'
  | 'USER_PROXIES_BY_PERSON_ID__COUNT_ASC'
  | 'USER_PROXIES_BY_PERSON_ID__COUNT_DESC';

export type Permission = {
  __typename?: 'Permission';
  id: Maybe<Scalars['BigInt']['output']>;
  peAkce: Scalars['Int']['output'];
  peAktuality: Scalars['Int']['output'];
  peAnkety: Scalars['Int']['output'];
  peDescription: Scalars['String']['output'];
  peDokumenty: Scalars['Int']['output'];
  peGalerie: Scalars['Int']['output'];
  peId: Scalars['BigInt']['output'];
  peInzerce: Scalars['Int']['output'];
  peKonzole: Scalars['Int']['output'];
  peMain: Scalars['Int']['output'];
  peNabidka: Scalars['Int']['output'];
  peName: Scalars['String']['output'];
  peNastenka: Scalars['Int']['output'];
  peNovinky: Scalars['Int']['output'];
  pePary: Scalars['Int']['output'];
  pePermissions: Scalars['Int']['output'];
  pePlatby: Scalars['Int']['output'];
  peRozpis: Scalars['Int']['output'];
  peSkupiny: Scalars['Int']['output'];
  peUsers: Scalars['Int']['output'];
};

/** An input for mutations affecting `Permission` */
export type PermissionInput = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  peAkce: Scalars['Int']['input'];
  peAktuality: Scalars['Int']['input'];
  peAnkety: Scalars['Int']['input'];
  peDescription: Scalars['String']['input'];
  peDokumenty: Scalars['Int']['input'];
  peGalerie: Scalars['Int']['input'];
  peId?: InputMaybe<Scalars['BigInt']['input']>;
  peInzerce: Scalars['Int']['input'];
  peKonzole: Scalars['Int']['input'];
  peMain: Scalars['Int']['input'];
  peNabidka: Scalars['Int']['input'];
  peName: Scalars['String']['input'];
  peNastenka: Scalars['Int']['input'];
  peNovinky: Scalars['Int']['input'];
  pePary: Scalars['Int']['input'];
  pePermissions: Scalars['Int']['input'];
  pePlatby: Scalars['Int']['input'];
  peRozpis: Scalars['Int']['input'];
  peSkupiny: Scalars['Int']['input'];
  peUsers: Scalars['Int']['input'];
};

export type Person = {
  __typename?: 'Person';
  birthDate: Scalars['Date']['output'];
  cohortIds: Maybe<Array<Maybe<Scalars['BigInt']['output']>>>;
  /** Reads and enables pagination through a set of `CohortMembership`. */
  cohortMembershipsList: Array<CohortMembership>;
  coupleIds: Maybe<Array<Maybe<Scalars['BigInt']['output']>>>;
  /** Reads and enables pagination through a set of `Couple`. */
  couplesByManId: CouplesConnection;
  /** Reads and enables pagination through a set of `Couple`. */
  couplesByWomanId: CouplesConnection;
  /** Reads and enables pagination through a set of `Couple`. */
  couplesList: Maybe<Array<Couple>>;
  createdAt: Scalars['Datetime']['output'];
  cstsId: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `EventAttendance`. */
  eventAttendancesList: Array<EventAttendance>;
  /** Reads and enables pagination through a set of `EventInstanceTrainer`. */
  eventInstanceTrainersList: Array<EventInstanceTrainer>;
  /** Reads and enables pagination through a set of `EventRegistration`. */
  eventRegistrationsList: Array<EventRegistration>;
  /** Reads and enables pagination through a set of `EventTrainer`. */
  eventTrainersList: Array<EventTrainer>;
  firstName: Scalars['String']['output'];
  gender: GenderType;
  hasUser: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['BigInt']['output'];
  isAdmin: Maybe<Scalars['Boolean']['output']>;
  isTrainer: Maybe<Scalars['Boolean']['output']>;
  lastName: Scalars['String']['output'];
  legacyUserId: Maybe<Scalars['BigInt']['output']>;
  middleName: Maybe<Scalars['String']['output']>;
  nationalIdNumber: Maybe<Scalars['String']['output']>;
  nationality: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `PersonAddress`. */
  personAddressesList: Array<PersonAddress>;
  /** Reads and enables pagination through a set of `PersonEmail`. */
  personEmailsList: Array<PersonEmail>;
  /** Reads and enables pagination through a set of `PersonPhone`. */
  personPhonesList: Array<PersonPhone>;
  primaryAddress: Maybe<Address>;
  primaryEmail: Maybe<Scalars['String']['output']>;
  primaryPhone: Maybe<Scalars['String']['output']>;
  taxIdentificationNumber: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `TenantAdministrator`. */
  tenantAdministratorsList: Array<TenantAdministrator>;
  tenantIds: Maybe<Array<Maybe<Scalars['BigInt']['output']>>>;
  /** Reads and enables pagination through a set of `TenantMembership`. */
  tenantMembershipsList: Array<TenantMembership>;
  /** Reads and enables pagination through a set of `TenantTrainer`. */
  tenantTrainersList: Array<TenantTrainer>;
  updatedAt: Scalars['Datetime']['output'];
  /** Reads and enables pagination through a set of `UserProxy`. */
  userProxiesList: Array<UserProxy>;
  wdsfId: Maybe<Scalars['String']['output']>;
};


export type PersonCohortMembershipsListArgs = {
  condition?: InputMaybe<CohortMembershipCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CohortMembershipsOrderBy>>;
};


export type PersonCouplesByManIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CoupleCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CouplesOrderBy>>;
};


export type PersonCouplesByWomanIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CoupleCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CouplesOrderBy>>;
};


export type PersonCouplesListArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type PersonEventAttendancesListArgs = {
  condition?: InputMaybe<EventAttendanceCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventAttendancesOrderBy>>;
};


export type PersonEventInstanceTrainersListArgs = {
  condition?: InputMaybe<EventInstanceTrainerCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventInstanceTrainersOrderBy>>;
};


export type PersonEventRegistrationsListArgs = {
  condition?: InputMaybe<EventRegistrationCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventRegistrationsOrderBy>>;
};


export type PersonEventTrainersListArgs = {
  condition?: InputMaybe<EventTrainerCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventTrainersOrderBy>>;
};


export type PersonPersonAddressesListArgs = {
  condition?: InputMaybe<PersonAddressCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PersonAddressesOrderBy>>;
};


export type PersonPersonEmailsListArgs = {
  condition?: InputMaybe<PersonEmailCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PersonEmailsOrderBy>>;
};


export type PersonPersonPhonesListArgs = {
  condition?: InputMaybe<PersonPhoneCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PersonPhonesOrderBy>>;
};


export type PersonTenantAdministratorsListArgs = {
  condition?: InputMaybe<TenantAdministratorCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TenantAdministratorsOrderBy>>;
};


export type PersonTenantMembershipsListArgs = {
  condition?: InputMaybe<TenantMembershipCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TenantMembershipsOrderBy>>;
};


export type PersonTenantTrainersListArgs = {
  condition?: InputMaybe<TenantTrainerCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TenantTrainersOrderBy>>;
};


export type PersonUserProxiesListArgs = {
  condition?: InputMaybe<UserProxyCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserProxiesOrderBy>>;
};

export type PersonAddress = {
  __typename?: 'PersonAddress';
  address: Maybe<AddressDomain>;
  createdAt: Scalars['Datetime']['output'];
  isPrimary: Maybe<Scalars['Boolean']['output']>;
  /** Reads a single `Person` that is related to this `PersonAddress`. */
  person: Maybe<Person>;
  personId: Scalars['BigInt']['output'];
  updatedAt: Scalars['Datetime']['output'];
};

/**
 * A condition to be used against `PersonAddress` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PersonAddressCondition = {
  /** Checks for equality with the object’s `personId` field. */
  personId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Methods to use when ordering `PersonAddress`. */
export type PersonAddressesOrderBy =
  | 'NATURAL'
  | 'PERSON_BY_PERSON_ID__ID_ASC'
  | 'PERSON_BY_PERSON_ID__ID_DESC'
  | 'PERSON_ID_ASC'
  | 'PERSON_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Person` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PersonCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
};

export type PersonEmail = {
  __typename?: 'PersonEmail';
  createdAt: Scalars['Datetime']['output'];
  email: Scalars['String']['output'];
  isPrimary: Maybe<Scalars['Boolean']['output']>;
  /** Reads a single `Person` that is related to this `PersonEmail`. */
  person: Maybe<Person>;
  personId: Scalars['BigInt']['output'];
  updatedAt: Scalars['Datetime']['output'];
};

/**
 * A condition to be used against `PersonEmail` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PersonEmailCondition = {
  /** Checks for equality with the object’s `personId` field. */
  personId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Methods to use when ordering `PersonEmail`. */
export type PersonEmailsOrderBy =
  | 'NATURAL'
  | 'PERSON_BY_PERSON_ID__ID_ASC'
  | 'PERSON_BY_PERSON_ID__ID_DESC'
  | 'PERSON_ID_ASC'
  | 'PERSON_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** Represents an update to a `Person`. Fields that are set will be updated. */
export type PersonPatch = {
  birthDate?: InputMaybe<Scalars['Date']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  cstsId?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  gender?: InputMaybe<GenderType>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  legacyUserId?: InputMaybe<Scalars['BigInt']['input']>;
  middleName?: InputMaybe<Scalars['String']['input']>;
  nationalIdNumber?: InputMaybe<Scalars['String']['input']>;
  nationality?: InputMaybe<Scalars['String']['input']>;
  taxIdentificationNumber?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  wdsfId?: InputMaybe<Scalars['String']['input']>;
};

export type PersonPhone = {
  __typename?: 'PersonPhone';
  createdAt: Scalars['Datetime']['output'];
  isPrimary: Maybe<Scalars['Boolean']['output']>;
  /** Reads a single `Person` that is related to this `PersonPhone`. */
  person: Maybe<Person>;
  personId: Scalars['BigInt']['output'];
  phone: Scalars['String']['output'];
  updatedAt: Scalars['Datetime']['output'];
};

/**
 * A condition to be used against `PersonPhone` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PersonPhoneCondition = {
  /** Checks for equality with the object’s `personId` field. */
  personId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Methods to use when ordering `PersonPhone`. */
export type PersonPhonesOrderBy =
  | 'NATURAL'
  | 'PERSON_BY_PERSON_ID__ID_ASC'
  | 'PERSON_BY_PERSON_ID__ID_DESC'
  | 'PERSON_ID_ASC'
  | 'PERSON_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A connection to a list of `PlatbyCategory` values. */
export type PlatbyCategoriesConnection = {
  __typename?: 'PlatbyCategoriesConnection';
  /** A list of edges which contains the `PlatbyCategory` and cursor to aid in pagination. */
  edges: Array<PlatbyCategoriesEdge>;
  /** A list of `PlatbyCategory` objects. */
  nodes: Array<PlatbyCategory>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PlatbyCategory` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PlatbyCategory` edge in the connection. */
export type PlatbyCategoriesEdge = {
  __typename?: 'PlatbyCategoriesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `PlatbyCategory` at the end of the edge. */
  node: PlatbyCategory;
};

/** Methods to use when ordering `PlatbyCategory`. */
export type PlatbyCategoriesOrderBy =
  | 'NATURAL'
  | 'PC_ID_ASC'
  | 'PC_ID_DESC'
  | 'PC_SYMBOL_ASC'
  | 'PC_SYMBOL_DESC'
  | 'PLATBY_ITEMS_BY_PI_ID_CATEGORY__COUNT_ASC'
  | 'PLATBY_ITEMS_BY_PI_ID_CATEGORY__COUNT_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

export type PlatbyCategory = {
  __typename?: 'PlatbyCategory';
  id: Maybe<Scalars['BigInt']['output']>;
  pcAmount: Scalars['BigFloat']['output'];
  pcArchive: Scalars['Boolean']['output'];
  pcDateDue: Scalars['Date']['output'];
  pcId: Scalars['BigInt']['output'];
  pcName: Scalars['String']['output'];
  pcSymbol: Scalars['BigInt']['output'];
  pcUseBase: Scalars['Boolean']['output'];
  pcUsePrefix: Scalars['Boolean']['output'];
  pcValidFrom: Scalars['Date']['output'];
  pcValidTo: Scalars['Date']['output'];
  pcVisible: Scalars['Boolean']['output'];
  /** Reads and enables pagination through a set of `PlatbyItem`. */
  platbyItemsByPiIdCategory: PlatbyItemsConnection;
  tenantId: Scalars['BigInt']['output'];
};


export type PlatbyCategoryPlatbyItemsByPiIdCategoryArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PlatbyItemCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PlatbyItemsOrderBy>>;
};

/**
 * A condition to be used against `PlatbyCategory` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PlatbyCategoryCondition = {
  /** Checks for equality with the object’s `pcId` field. */
  pcId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `pcSymbol` field. */
  pcSymbol?: InputMaybe<Scalars['BigInt']['input']>;
};

export type PlatbyItem = {
  __typename?: 'PlatbyItem';
  /** Reads and enables pagination through a set of `EventRegistration`. */
  eventRegistrationsByPaymentIdList: Array<EventRegistration>;
  id: Maybe<Scalars['BigInt']['output']>;
  piAmount: Scalars['BigFloat']['output'];
  piDate: Scalars['Date']['output'];
  piId: Scalars['BigInt']['output'];
  piIdCategory: Scalars['BigInt']['output'];
  piIdRaw: Maybe<Scalars['BigInt']['output']>;
  piIdUser: Maybe<Scalars['BigInt']['output']>;
  piPrefix: Scalars['Int']['output'];
  /** Reads a single `PlatbyCategory` that is related to this `PlatbyItem`. */
  platbyCategoryByPiIdCategory: Maybe<PlatbyCategory>;
  status: PaymentStatus;
  tenantId: Scalars['BigInt']['output'];
  /** Reads a single `User` that is related to this `PlatbyItem`. */
  userByPiIdUser: Maybe<User>;
};


export type PlatbyItemEventRegistrationsByPaymentIdListArgs = {
  condition?: InputMaybe<EventRegistrationCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventRegistrationsOrderBy>>;
};

/**
 * A condition to be used against `PlatbyItem` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PlatbyItemCondition = {
  /** Checks for equality with the object’s `piId` field. */
  piId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `piIdCategory` field. */
  piIdCategory?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `piIdRaw` field. */
  piIdRaw?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `piIdUser` field. */
  piIdUser?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `PlatbyItem` values. */
export type PlatbyItemsConnection = {
  __typename?: 'PlatbyItemsConnection';
  /** A list of edges which contains the `PlatbyItem` and cursor to aid in pagination. */
  edges: Array<PlatbyItemsEdge>;
  /** A list of `PlatbyItem` objects. */
  nodes: Array<PlatbyItem>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PlatbyItem` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PlatbyItem` edge in the connection. */
export type PlatbyItemsEdge = {
  __typename?: 'PlatbyItemsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `PlatbyItem` at the end of the edge. */
  node: PlatbyItem;
};

/** Methods to use when ordering `PlatbyItem`. */
export type PlatbyItemsOrderBy =
  | 'EVENT_REGISTRATIONS_BY_PAYMENT_ID__COUNT_ASC'
  | 'EVENT_REGISTRATIONS_BY_PAYMENT_ID__COUNT_DESC'
  | 'NATURAL'
  | 'PI_ID_ASC'
  | 'PI_ID_CATEGORY_ASC'
  | 'PI_ID_CATEGORY_DESC'
  | 'PI_ID_DESC'
  | 'PI_ID_RAW_ASC'
  | 'PI_ID_RAW_DESC'
  | 'PI_ID_USER_ASC'
  | 'PI_ID_USER_DESC'
  | 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_ID_ASC'
  | 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_ID_DESC'
  | 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_SYMBOL_ASC'
  | 'PLATBY_CATEGORY_BY_PI_ID_CATEGORY__PC_SYMBOL_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'USER_BY_PI_ID_USER__U_ID_ASC'
  | 'USER_BY_PI_ID_USER__U_ID_DESC'
  | 'USER_BY_PI_ID_USER__U_JMENO_ASC'
  | 'USER_BY_PI_ID_USER__U_JMENO_DESC'
  | 'USER_BY_PI_ID_USER__U_LOGIN_ASC'
  | 'USER_BY_PI_ID_USER__U_LOGIN_DESC'
  | 'USER_BY_PI_ID_USER__U_PRIJMENI_ASC'
  | 'USER_BY_PI_ID_USER__U_PRIJMENI_DESC';

export type Price = {
  __typename?: 'Price';
  amount: Maybe<Scalars['BigFloat']['output']>;
  currency: Maybe<Scalars['String']['output']>;
};

export type PriceInput = {
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
};

/** The root query type which gives access points into the data universe. */
export type Query = {
  __typename?: 'Query';
  /** Reads and enables pagination through a set of `Aktuality`. */
  aktualities: Maybe<AktualitiesConnection>;
  aktuality: Maybe<Aktuality>;
  /** Reads and enables pagination through a set of `Upozorneni`. */
  archivedAnnouncements: Maybe<UpozornenisConnection>;
  attachment: Maybe<Attachment>;
  attachmentDirectories: Maybe<AttachmentDirectoriesConnection>;
  /** Reads and enables pagination through a set of `Attachment`. */
  attachments: Maybe<AttachmentsConnection>;
  cohortGroup: Maybe<CohortGroup>;
  /** Reads and enables pagination through a set of `CohortGroup`. */
  cohortGroups: Maybe<CohortGroupsConnection>;
  cohortMembership: Maybe<CohortMembership>;
  /** Reads a set of `CohortMembership`. */
  cohortMembershipsList: Maybe<Array<CohortMembership>>;
  couple: Maybe<Couple>;
  /** Reads and enables pagination through a set of `Couple`. */
  couples: Maybe<CouplesConnection>;
  currentCoupleIds: Maybe<CurrentCoupleIdsConnection>;
  currentSessionId: Maybe<Scalars['String']['output']>;
  currentTenantId: Maybe<Scalars['BigInt']['output']>;
  currentUserId: Maybe<Scalars['BigInt']['output']>;
  /** Reads a set of `Dokumenty`. */
  dokumentiesList: Maybe<Array<Dokumenty>>;
  dokumenty: Maybe<Dokumenty>;
  event: Maybe<Event>;
  eventAttendance: Maybe<EventAttendance>;
  /** Reads a set of `EventAttendance`. */
  eventAttendancesList: Maybe<Array<EventAttendance>>;
  eventInstance: Maybe<EventInstance>;
  eventInstanceTrainer: Maybe<EventInstanceTrainer>;
  /** Reads a set of `EventInstanceTrainer`. */
  eventInstanceTrainersList: Maybe<Array<EventInstanceTrainer>>;
  /** Reads and enables pagination through a set of `EventInstance`. */
  eventInstances: Maybe<EventInstancesConnection>;
  /** Reads and enables pagination through a set of `EventInstance`. */
  eventInstancesForRangeList: Maybe<Array<EventInstance>>;
  /** Reads a set of `EventInstance`. */
  eventInstancesList: Maybe<Array<EventInstance>>;
  eventLessonDemand: Maybe<EventLessonDemand>;
  eventLessonDemandByRegistrationIdAndTrainerId: Maybe<EventLessonDemand>;
  /** Reads a set of `EventLessonDemand`. */
  eventLessonDemandsList: Maybe<Array<EventLessonDemand>>;
  eventRegistration: Maybe<EventRegistration>;
  eventRegistrationByEventIdAndPersonIdAndCoupleId: Maybe<EventRegistration>;
  /** Reads a set of `EventRegistration`. */
  eventRegistrationsList: Maybe<Array<EventRegistration>>;
  eventTargetCohort: Maybe<EventTargetCohort>;
  /** Reads a set of `EventTargetCohort`. */
  eventTargetCohortsList: Maybe<Array<EventTargetCohort>>;
  eventTrainer: Maybe<EventTrainer>;
  /** Reads a set of `EventTrainer`. */
  eventTrainersList: Maybe<Array<EventTrainer>>;
  /** Reads and enables pagination through a set of `Event`. */
  events: Maybe<EventsConnection>;
  /** Reads and enables pagination through a set of `Person`. */
  filteredPeopleList: Maybe<Array<Person>>;
  formResponse: Maybe<FormResponse>;
  /** Reads and enables pagination through a set of `FormResponse`. */
  formResponses: Maybe<FormResponsesConnection>;
  galerieDir: Maybe<GalerieDir>;
  /** Reads and enables pagination through a set of `GalerieDir`. */
  galerieDirs: Maybe<GalerieDirsConnection>;
  galerieFoto: Maybe<GalerieFoto>;
  /** Reads and enables pagination through a set of `GalerieFoto`. */
  galerieFotos: Maybe<GalerieFotosConnection>;
  getCurrentCouple: Maybe<Pary>;
  getCurrentTenant: Maybe<Tenant>;
  getCurrentUser: Maybe<User>;
  location: Maybe<Location>;
  locationAttachment: Maybe<LocationAttachment>;
  /** Reads and enables pagination through a set of `LocationAttachment`. */
  locationAttachments: Maybe<LocationAttachmentsConnection>;
  /** Reads and enables pagination through a set of `Location`. */
  locations: Maybe<LocationsConnection>;
  /** Reads and enables pagination through a set of `Upozorneni`. */
  myAnnouncements: Maybe<UpozornenisConnection>;
  /** Reads and enables pagination through a set of `Person`. */
  people: Maybe<PeopleConnection>;
  permission: Maybe<Permission>;
  /** Reads a set of `Permission`. */
  permissionsList: Maybe<Array<Permission>>;
  person: Maybe<Person>;
  /** Reads a set of `PersonAddress`. */
  personAddressesList: Maybe<Array<PersonAddress>>;
  personEmail: Maybe<PersonEmail>;
  /** Reads a set of `PersonEmail`. */
  personEmailsList: Maybe<Array<PersonEmail>>;
  personPhone: Maybe<PersonPhone>;
  /** Reads a set of `PersonPhone`. */
  personPhonesList: Maybe<Array<PersonPhone>>;
  /** Reads and enables pagination through a set of `PlatbyCategory`. */
  platbyCategories: Maybe<PlatbyCategoriesConnection>;
  platbyCategory: Maybe<PlatbyCategory>;
  platbyItem: Maybe<PlatbyItem>;
  /** Reads and enables pagination through a set of `PlatbyItem`. */
  platbyItems: Maybe<PlatbyItemsConnection>;
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
  room: Maybe<Room>;
  roomAttachment: Maybe<RoomAttachment>;
  /** Reads and enables pagination through a set of `RoomAttachment`. */
  roomAttachments: Maybe<RoomAttachmentsConnection>;
  /** Reads and enables pagination through a set of `Room`. */
  rooms: Maybe<RoomsConnection>;
  /** Reads and enables pagination through a set of `Skupiny`. */
  skupinies: Maybe<SkupiniesConnection>;
  skupiny: Maybe<Skupiny>;
  /** Reads and enables pagination through a set of `Upozorneni`. */
  stickyAnnouncements: Maybe<UpozornenisConnection>;
  tenant: Maybe<Tenant>;
  tenantAdministrator: Maybe<TenantAdministrator>;
  /** Reads a set of `TenantAdministrator`. */
  tenantAdministratorsList: Maybe<Array<TenantAdministrator>>;
  tenantAttachment: Maybe<TenantAttachment>;
  /** Reads and enables pagination through a set of `TenantAttachment`. */
  tenantAttachments: Maybe<TenantAttachmentsConnection>;
  tenantLocation: Maybe<TenantLocation>;
  /** Reads a set of `TenantLocation`. */
  tenantLocationsList: Maybe<Array<TenantLocation>>;
  tenantMembership: Maybe<TenantMembership>;
  /** Reads a set of `TenantMembership`. */
  tenantMembershipsList: Maybe<Array<TenantMembership>>;
  tenantTrainer: Maybe<TenantTrainer>;
  /** Reads a set of `TenantTrainer`. */
  tenantTrainersList: Maybe<Array<TenantTrainer>>;
  /** Reads a set of `Tenant`. */
  tenantsList: Maybe<Array<Tenant>>;
  upozorneni: Maybe<Upozorneni>;
  /** Reads and enables pagination through a set of `UpozorneniSkupiny`. */
  upozorneniSkupinies: Maybe<UpozorneniSkupiniesConnection>;
  upozorneniSkupiny: Maybe<UpozorneniSkupiny>;
  /** Reads and enables pagination through a set of `Upozorneni`. */
  upozornenis: Maybe<UpozornenisConnection>;
  user: Maybe<User>;
  /** Reads a set of `UserProxy`. */
  userProxiesList: Maybe<Array<UserProxy>>;
  userProxy: Maybe<UserProxy>;
  /** Reads and enables pagination through a set of `User`. */
  users: Maybe<UsersConnection>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAktualitiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AktualityCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AktualitiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAktualityArgs = {
  atId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryArchivedAnnouncementsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAttachmentArgs = {
  objectName: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAttachmentDirectoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AttachmentCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AttachmentsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCohortGroupArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCohortGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CohortGroupCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CohortGroupsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCohortMembershipArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCohortMembershipsListArgs = {
  condition?: InputMaybe<CohortMembershipCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CohortMembershipsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCoupleArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCouplesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CoupleCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CouplesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCurrentCoupleIdsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDokumentiesListArgs = {
  condition?: InputMaybe<DokumentyCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DokumentiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDokumentyArgs = {
  dId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventAttendanceArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventAttendancesListArgs = {
  condition?: InputMaybe<EventAttendanceCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventAttendancesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventInstanceArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventInstanceTrainerArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventInstanceTrainersListArgs = {
  condition?: InputMaybe<EventInstanceTrainerCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventInstanceTrainersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventInstancesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventInstanceCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventInstancesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventInstancesForRangeListArgs = {
  endRange?: InputMaybe<Scalars['Datetime']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  onlyMine?: InputMaybe<Scalars['Boolean']['input']>;
  startRange?: InputMaybe<Scalars['Datetime']['input']>;
  type?: InputMaybe<EventType>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventInstancesListArgs = {
  condition?: InputMaybe<EventInstanceCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventInstancesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventLessonDemandArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventLessonDemandByRegistrationIdAndTrainerIdArgs = {
  registrationId: Scalars['BigInt']['input'];
  trainerId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventLessonDemandsListArgs = {
  condition?: InputMaybe<EventLessonDemandCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventLessonDemandsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventRegistrationArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventRegistrationByEventIdAndPersonIdAndCoupleIdArgs = {
  coupleId: Scalars['BigInt']['input'];
  eventId: Scalars['BigInt']['input'];
  personId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventRegistrationsListArgs = {
  condition?: InputMaybe<EventRegistrationCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventRegistrationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventTargetCohortArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventTargetCohortsListArgs = {
  condition?: InputMaybe<EventTargetCohortCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventTargetCohortsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventTrainerArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventTrainersListArgs = {
  condition?: InputMaybe<EventTrainerCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventTrainersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFilteredPeopleListArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  inCohort?: InputMaybe<Scalars['BigInt']['input']>;
  inTenants?: InputMaybe<Array<InputMaybe<Scalars['BigInt']['input']>>>;
  isAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  isTrainer?: InputMaybe<Scalars['Boolean']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFormResponseArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFormResponsesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormResponseCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormResponsesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGalerieDirArgs = {
  gdId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGalerieDirsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GalerieDirCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GalerieDirsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGalerieFotoArgs = {
  gfId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGalerieFotosArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GalerieFotoCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GalerieFotosOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLocationArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLocationAttachmentArgs = {
  locationId: Scalars['BigInt']['input'];
  objectName: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLocationAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LocationAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LocationAttachmentsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLocationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LocationCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LocationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMyAnnouncementsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  archive?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPeopleArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PersonCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PeopleOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionArgs = {
  peId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionsListArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPersonArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPersonAddressesListArgs = {
  condition?: InputMaybe<PersonAddressCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PersonAddressesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPersonEmailArgs = {
  email: Scalars['String']['input'];
  personId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPersonEmailsListArgs = {
  condition?: InputMaybe<PersonEmailCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PersonEmailsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPersonPhoneArgs = {
  personId: Scalars['BigInt']['input'];
  phone: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPersonPhonesListArgs = {
  condition?: InputMaybe<PersonPhoneCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PersonPhonesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyCategoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PlatbyCategoryCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PlatbyCategoriesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyCategoryArgs = {
  pcId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyItemArgs = {
  piId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlatbyItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PlatbyItemCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PlatbyItemsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomAttachmentArgs = {
  objectName: Scalars['String']['input'];
  roomId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomAttachmentsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySkupiniesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SkupinyCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SkupiniesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySkupinyArgs = {
  sId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStickyAnnouncementsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantAdministratorArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantAdministratorsListArgs = {
  condition?: InputMaybe<TenantAdministratorCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TenantAdministratorsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantAttachmentArgs = {
  objectName: Scalars['String']['input'];
  tenantId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TenantAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TenantAttachmentsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantLocationArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantLocationsListArgs = {
  condition?: InputMaybe<TenantLocationCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TenantLocationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantMembershipArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantMembershipsListArgs = {
  condition?: InputMaybe<TenantMembershipCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TenantMembershipsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantTrainerArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantTrainersListArgs = {
  condition?: InputMaybe<TenantTrainerCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TenantTrainersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTenantsListArgs = {
  condition?: InputMaybe<TenantCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TenantsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUpozorneniArgs = {
  upId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUpozorneniSkupiniesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UpozorneniSkupinyCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UpozorneniSkupiniesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUpozorneniSkupinyArgs = {
  upsId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUpozornenisArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UpozorneniCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UpozornenisOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserArgs = {
  uId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserProxiesListArgs = {
  condition?: InputMaybe<UserProxyCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserProxiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserProxyArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the `registerToEvent` mutation. */
export type RegisterToEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  lessons: Array<InputMaybe<EventLessonDemandPatch>>;
  registration: EventRegistrationInput;
};

/** The output of our `registerToEvent` mutation. */
export type RegisterToEventPayload = {
  __typename?: 'RegisterToEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Couple` that is related to this `EventRegistration`. */
  couple: Maybe<Couple>;
  /** Reads a single `Event` that is related to this `EventRegistration`. */
  event: Maybe<Event>;
  /** Reads a single `PlatbyItem` that is related to this `EventRegistration`. */
  payment: Maybe<PlatbyItem>;
  /** Reads a single `Person` that is related to this `EventRegistration`. */
  person: Maybe<Person>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  registration: Maybe<EventRegistration>;
  /** Reads a single `EventTargetCohort` that is related to this `EventRegistration`. */
  targetCohort: Maybe<EventTargetCohort>;
  /** Reads a single `Tenant` that is related to this `EventRegistration`. */
  tenant: Maybe<Tenant>;
};

export type RegistrationTime =
  | 'POST'
  | 'PRE'
  | 'REGULAR';

/** All input for the `resetPassword` mutation. */
export type ResetPasswordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  login: Scalars['String']['input'];
};

/** The output of our `resetPassword` mutation. */
export type ResetPasswordPayload = {
  __typename?: 'ResetPasswordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type Room = {
  __typename?: 'Room';
  description: Scalars['JSON']['output'];
  id: Scalars['BigInt']['output'];
  location: Maybe<Scalars['BigInt']['output']>;
  /** Reads a single `Location` that is related to this `Room`. */
  locationByLocation: Maybe<Location>;
  name: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `RoomAttachment`. */
  roomAttachments: RoomAttachmentsConnection;
};


export type RoomRoomAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomAttachmentsOrderBy>>;
};

export type RoomAttachment = {
  __typename?: 'RoomAttachment';
  /** Reads a single `Attachment` that is related to this `RoomAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  objectName: Scalars['String']['output'];
  /** Reads a single `Room` that is related to this `RoomAttachment`. */
  room: Maybe<Room>;
  roomId: Scalars['BigInt']['output'];
};

/**
 * A condition to be used against `RoomAttachment` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type RoomAttachmentCondition = {
  /** Checks for equality with the object’s `objectName` field. */
  objectName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `roomId` field. */
  roomId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `RoomAttachment` values. */
export type RoomAttachmentsConnection = {
  __typename?: 'RoomAttachmentsConnection';
  /** A list of edges which contains the `RoomAttachment` and cursor to aid in pagination. */
  edges: Array<RoomAttachmentsEdge>;
  /** A list of `RoomAttachment` objects. */
  nodes: Array<RoomAttachment>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `RoomAttachment` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `RoomAttachment` edge in the connection. */
export type RoomAttachmentsEdge = {
  __typename?: 'RoomAttachmentsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `RoomAttachment` at the end of the edge. */
  node: RoomAttachment;
};

/** Methods to use when ordering `RoomAttachment`. */
export type RoomAttachmentsOrderBy =
  | 'ATTACHMENT_BY_OBJECT_NAME__OBJECT_NAME_ASC'
  | 'ATTACHMENT_BY_OBJECT_NAME__OBJECT_NAME_DESC'
  | 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_BY_ASC'
  | 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_BY_DESC'
  | 'NATURAL'
  | 'OBJECT_NAME_ASC'
  | 'OBJECT_NAME_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'ROOM_BY_ROOM_ID__ID_ASC'
  | 'ROOM_BY_ROOM_ID__ID_DESC'
  | 'ROOM_BY_ROOM_ID__LOCATION_ASC'
  | 'ROOM_BY_ROOM_ID__LOCATION_DESC'
  | 'ROOM_ID_ASC'
  | 'ROOM_ID_DESC';

/** A condition to be used against `Room` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type RoomCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `location` field. */
  location?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An input for mutations affecting `Room` */
export type RoomInput = {
  description: Scalars['JSON']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  location?: InputMaybe<Scalars['BigInt']['input']>;
  name: Scalars['String']['input'];
};

/** Represents an update to a `Room`. Fields that are set will be updated. */
export type RoomPatch = {
  description?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  location?: InputMaybe<Scalars['BigInt']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `Room` values. */
export type RoomsConnection = {
  __typename?: 'RoomsConnection';
  /** A list of edges which contains the `Room` and cursor to aid in pagination. */
  edges: Array<RoomsEdge>;
  /** A list of `Room` objects. */
  nodes: Array<Room>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Room` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Room` edge in the connection. */
export type RoomsEdge = {
  __typename?: 'RoomsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Room` at the end of the edge. */
  node: Room;
};

/** Methods to use when ordering `Room`. */
export type RoomsOrderBy =
  | 'ID_ASC'
  | 'ID_DESC'
  | 'LOCATION_ASC'
  | 'LOCATION_BY_LOCATION__ID_ASC'
  | 'LOCATION_BY_LOCATION__ID_DESC'
  | 'LOCATION_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'ROOM_ATTACHMENTS_BY_ROOM_ID__COUNT_ASC'
  | 'ROOM_ATTACHMENTS_BY_ROOM_ID__COUNT_DESC';

export type Session = {
  __typename?: 'Session';
  ssId: Scalars['String']['output'];
  ssLifetime: Scalars['BigInt']['output'];
  ssUpdatedAt: Scalars['Datetime']['output'];
  ssUser: Maybe<Scalars['BigInt']['output']>;
  /** Reads a single `User` that is related to this `Session`. */
  userBySsUser: Maybe<User>;
};

/** All input for the `setLessonDemand` mutation. */
export type SetLessonDemandInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  lessonCount: Scalars['Int']['input'];
  registrationId: Scalars['BigInt']['input'];
  trainerId: Scalars['BigInt']['input'];
};

/** The output of our `setLessonDemand` mutation. */
export type SetLessonDemandPayload = {
  __typename?: 'SetLessonDemandPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  eventLessonDemand: Maybe<EventLessonDemand>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `EventRegistration` that is related to this `EventLessonDemand`. */
  registration: Maybe<EventRegistration>;
  /** Reads a single `Tenant` that is related to this `EventLessonDemand`. */
  tenant: Maybe<Tenant>;
  /** Reads a single `EventTrainer` that is related to this `EventLessonDemand`. */
  trainer: Maybe<EventTrainer>;
};

/** A connection to a list of `Skupiny` values. */
export type SkupiniesConnection = {
  __typename?: 'SkupiniesConnection';
  /** A list of edges which contains the `Skupiny` and cursor to aid in pagination. */
  edges: Array<SkupiniesEdge>;
  /** A list of `Skupiny` objects. */
  nodes: Array<Skupiny>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Skupiny` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Skupiny` edge in the connection. */
export type SkupiniesEdge = {
  __typename?: 'SkupiniesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Skupiny` at the end of the edge. */
  node: Skupiny;
};

/** Methods to use when ordering `Skupiny`. */
export type SkupiniesOrderBy =
  | 'COHORT_GROUP_ASC'
  | 'COHORT_GROUP_BY_COHORT_GROUP__ID_ASC'
  | 'COHORT_GROUP_BY_COHORT_GROUP__ID_DESC'
  | 'COHORT_GROUP_BY_COHORT_GROUP__IS_PUBLIC_ASC'
  | 'COHORT_GROUP_BY_COHORT_GROUP__IS_PUBLIC_DESC'
  | 'COHORT_GROUP_BY_COHORT_GROUP__ORDERING_ASC'
  | 'COHORT_GROUP_BY_COHORT_GROUP__ORDERING_DESC'
  | 'COHORT_GROUP_BY_COHORT_GROUP__TENANT_ASC'
  | 'COHORT_GROUP_BY_COHORT_GROUP__TENANT_DESC'
  | 'COHORT_GROUP_DESC'
  | 'COHORT_MEMBERSHIPS_BY_COHORT_ID__COUNT_ASC'
  | 'COHORT_MEMBERSHIPS_BY_COHORT_ID__COUNT_DESC'
  | 'EVENT_TARGET_COHORTS_BY_COHORT_ID__COUNT_ASC'
  | 'EVENT_TARGET_COHORTS_BY_COHORT_ID__COUNT_DESC'
  | 'NATURAL'
  | 'ORDERING_ASC'
  | 'ORDERING_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'S_ID_ASC'
  | 'S_ID_DESC'
  | 'S_VISIBLE_ASC'
  | 'S_VISIBLE_DESC'
  | 'UPOZORNENI_SKUPINIES_BY_UPS_ID_SKUPINA__COUNT_ASC'
  | 'UPOZORNENI_SKUPINIES_BY_UPS_ID_SKUPINA__COUNT_DESC';

export type Skupiny = {
  __typename?: 'Skupiny';
  cohortGroup: Maybe<Scalars['BigInt']['output']>;
  /** Reads a single `CohortGroup` that is related to this `Skupiny`. */
  cohortGroupByCohortGroup: Maybe<CohortGroup>;
  /** Reads and enables pagination through a set of `CohortMembership`. */
  cohortMembershipsByCohortIdList: Array<CohortMembership>;
  /** Reads and enables pagination through a set of `EventTargetCohort`. */
  eventTargetCohortsByCohortIdList: Array<EventTargetCohort>;
  id: Maybe<Scalars['BigInt']['output']>;
  internalInfo: Scalars['String']['output'];
  ordering: Scalars['Int']['output'];
  sColorRgb: Scalars['String']['output'];
  sColorText: Scalars['String']['output'];
  sDescription: Scalars['String']['output'];
  sId: Scalars['BigInt']['output'];
  sLocation: Scalars['String']['output'];
  sName: Scalars['String']['output'];
  sVisible: Scalars['Boolean']['output'];
  tenantId: Scalars['BigInt']['output'];
  /** Reads and enables pagination through a set of `UpozorneniSkupiny`. */
  upozorneniSkupiniesByUpsIdSkupina: UpozorneniSkupiniesConnection;
};


export type SkupinyCohortMembershipsByCohortIdListArgs = {
  condition?: InputMaybe<CohortMembershipCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CohortMembershipsOrderBy>>;
};


export type SkupinyEventTargetCohortsByCohortIdListArgs = {
  condition?: InputMaybe<EventTargetCohortCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventTargetCohortsOrderBy>>;
};


export type SkupinyUpozorneniSkupiniesByUpsIdSkupinaArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UpozorneniSkupinyCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UpozorneniSkupiniesOrderBy>>;
};

/** A condition to be used against `Skupiny` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type SkupinyCondition = {
  /** Checks for equality with the object’s `cohortGroup` field. */
  cohortGroup?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `ordering` field. */
  ordering?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sId` field. */
  sId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `sVisible` field. */
  sVisible?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `Skupiny` */
export type SkupinyInput = {
  cohortGroup?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  internalInfo?: InputMaybe<Scalars['String']['input']>;
  ordering?: InputMaybe<Scalars['Int']['input']>;
  sColorRgb: Scalars['String']['input'];
  sColorText?: InputMaybe<Scalars['String']['input']>;
  sDescription: Scalars['String']['input'];
  sId?: InputMaybe<Scalars['BigInt']['input']>;
  sLocation?: InputMaybe<Scalars['String']['input']>;
  sName: Scalars['String']['input'];
  sVisible?: InputMaybe<Scalars['Boolean']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Represents an update to a `Skupiny`. Fields that are set will be updated. */
export type SkupinyPatch = {
  cohortGroup?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  internalInfo?: InputMaybe<Scalars['String']['input']>;
  ordering?: InputMaybe<Scalars['Int']['input']>;
  sColorRgb?: InputMaybe<Scalars['String']['input']>;
  sColorText?: InputMaybe<Scalars['String']['input']>;
  sDescription?: InputMaybe<Scalars['String']['input']>;
  sId?: InputMaybe<Scalars['BigInt']['input']>;
  sLocation?: InputMaybe<Scalars['String']['input']>;
  sName?: InputMaybe<Scalars['String']['input']>;
  sVisible?: InputMaybe<Scalars['Boolean']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** All input for the `submitForm` mutation. */
export type SubmitFormInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  data: Scalars['JSON']['input'];
  type: Scalars['String']['input'];
  url: Scalars['String']['input'];
};

/** The output of our `submitForm` mutation. */
export type SubmitFormPayload = {
  __typename?: 'SubmitFormPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type Tenant = {
  __typename?: 'Tenant';
  address: Maybe<AddressDomain>;
  /** Reads and enables pagination through a set of `CohortGroup`. */
  cohortGroupsByTenant: CohortGroupsConnection;
  czDic: Scalars['String']['output'];
  czIco: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `EventAttendance`. */
  eventAttendancesList: Array<EventAttendance>;
  /** Reads and enables pagination through a set of `EventInstanceTrainer`. */
  eventInstanceTrainersList: Array<EventInstanceTrainer>;
  /** Reads and enables pagination through a set of `EventInstance`. */
  eventInstances: EventInstancesConnection;
  /** Reads and enables pagination through a set of `EventInstance`. */
  eventInstancesList: Array<EventInstance>;
  /** Reads and enables pagination through a set of `EventLessonDemand`. */
  eventLessonDemandsList: Array<EventLessonDemand>;
  /** Reads and enables pagination through a set of `EventRegistration`. */
  eventRegistrationsList: Array<EventRegistration>;
  /** Reads and enables pagination through a set of `EventTargetCohort`. */
  eventTargetCohortsList: Array<EventTargetCohort>;
  /** Reads and enables pagination through a set of `EventTrainer`. */
  eventTrainersList: Array<EventTrainer>;
  id: Scalars['BigInt']['output'];
  memberInfo: Scalars['String']['output'];
  name: Scalars['String']['output'];
  origins: Array<Maybe<Scalars['String']['output']>>;
  /** Reads and enables pagination through a set of `TenantAdministrator`. */
  tenantAdministratorsList: Array<TenantAdministrator>;
  /** Reads and enables pagination through a set of `TenantAttachment`. */
  tenantAttachments: TenantAttachmentsConnection;
  /** Reads and enables pagination through a set of `TenantLocation`. */
  tenantLocationsList: Array<TenantLocation>;
  /** Reads and enables pagination through a set of `TenantMembership`. */
  tenantMembershipsList: Array<TenantMembership>;
  /** Reads and enables pagination through a set of `TenantTrainer`. */
  tenantTrainersList: Array<TenantTrainer>;
};


export type TenantCohortGroupsByTenantArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CohortGroupCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CohortGroupsOrderBy>>;
};


export type TenantEventAttendancesListArgs = {
  condition?: InputMaybe<EventAttendanceCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventAttendancesOrderBy>>;
};


export type TenantEventInstanceTrainersListArgs = {
  condition?: InputMaybe<EventInstanceTrainerCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventInstanceTrainersOrderBy>>;
};


export type TenantEventInstancesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventInstanceCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventInstancesOrderBy>>;
};


export type TenantEventInstancesListArgs = {
  condition?: InputMaybe<EventInstanceCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventInstancesOrderBy>>;
};


export type TenantEventLessonDemandsListArgs = {
  condition?: InputMaybe<EventLessonDemandCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventLessonDemandsOrderBy>>;
};


export type TenantEventRegistrationsListArgs = {
  condition?: InputMaybe<EventRegistrationCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventRegistrationsOrderBy>>;
};


export type TenantEventTargetCohortsListArgs = {
  condition?: InputMaybe<EventTargetCohortCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventTargetCohortsOrderBy>>;
};


export type TenantEventTrainersListArgs = {
  condition?: InputMaybe<EventTrainerCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventTrainersOrderBy>>;
};


export type TenantTenantAdministratorsListArgs = {
  condition?: InputMaybe<TenantAdministratorCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TenantAdministratorsOrderBy>>;
};


export type TenantTenantAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TenantAttachmentCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TenantAttachmentsOrderBy>>;
};


export type TenantTenantLocationsListArgs = {
  condition?: InputMaybe<TenantLocationCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TenantLocationsOrderBy>>;
};


export type TenantTenantMembershipsListArgs = {
  condition?: InputMaybe<TenantMembershipCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TenantMembershipsOrderBy>>;
};


export type TenantTenantTrainersListArgs = {
  condition?: InputMaybe<TenantTrainerCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TenantTrainersOrderBy>>;
};

export type TenantAdministrator = {
  __typename?: 'TenantAdministrator';
  active: Scalars['Boolean']['output'];
  createdAt: Scalars['Datetime']['output'];
  description: Scalars['String']['output'];
  id: Scalars['BigInt']['output'];
  isVisible: Scalars['Boolean']['output'];
  /** Reads a single `Person` that is related to this `TenantAdministrator`. */
  person: Maybe<Person>;
  personId: Scalars['BigInt']['output'];
  since: Scalars['Datetime']['output'];
  /** Reads a single `Tenant` that is related to this `TenantAdministrator`. */
  tenant: Maybe<Tenant>;
  tenantId: Scalars['BigInt']['output'];
  until: Maybe<Scalars['Datetime']['output']>;
  updatedAt: Scalars['Datetime']['output'];
};

/**
 * A condition to be used against `TenantAdministrator` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type TenantAdministratorCondition = {
  /** Checks for equality with the object’s `active` field. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `personId` field. */
  personId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `tenantId` field. */
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Methods to use when ordering `TenantAdministrator`. */
export type TenantAdministratorsOrderBy =
  | 'ACTIVE_ASC'
  | 'ACTIVE_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PERSON_BY_PERSON_ID__ID_ASC'
  | 'PERSON_BY_PERSON_ID__ID_DESC'
  | 'PERSON_ID_ASC'
  | 'PERSON_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TENANT_BY_TENANT_ID__ID_ASC'
  | 'TENANT_BY_TENANT_ID__ID_DESC'
  | 'TENANT_ID_ASC'
  | 'TENANT_ID_DESC';

export type TenantAttachment = {
  __typename?: 'TenantAttachment';
  /** Reads a single `Attachment` that is related to this `TenantAttachment`. */
  attachmentByObjectName: Maybe<Attachment>;
  objectName: Scalars['String']['output'];
  /** Reads a single `Tenant` that is related to this `TenantAttachment`. */
  tenant: Maybe<Tenant>;
  tenantId: Scalars['BigInt']['output'];
  type: Maybe<TenantAttachmentType>;
};

/**
 * A condition to be used against `TenantAttachment` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TenantAttachmentCondition = {
  /** Checks for equality with the object’s `objectName` field. */
  objectName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `tenantId` field. */
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

export type TenantAttachmentType =
  | 'LOGO'
  | 'MAP'
  | 'PHOTO';

/** A connection to a list of `TenantAttachment` values. */
export type TenantAttachmentsConnection = {
  __typename?: 'TenantAttachmentsConnection';
  /** A list of edges which contains the `TenantAttachment` and cursor to aid in pagination. */
  edges: Array<TenantAttachmentsEdge>;
  /** A list of `TenantAttachment` objects. */
  nodes: Array<TenantAttachment>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TenantAttachment` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TenantAttachment` edge in the connection. */
export type TenantAttachmentsEdge = {
  __typename?: 'TenantAttachmentsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `TenantAttachment` at the end of the edge. */
  node: TenantAttachment;
};

/** Methods to use when ordering `TenantAttachment`. */
export type TenantAttachmentsOrderBy =
  | 'ATTACHMENT_BY_OBJECT_NAME__OBJECT_NAME_ASC'
  | 'ATTACHMENT_BY_OBJECT_NAME__OBJECT_NAME_DESC'
  | 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_BY_ASC'
  | 'ATTACHMENT_BY_OBJECT_NAME__UPLOADED_BY_DESC'
  | 'NATURAL'
  | 'OBJECT_NAME_ASC'
  | 'OBJECT_NAME_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TENANT_BY_TENANT_ID__ID_ASC'
  | 'TENANT_BY_TENANT_ID__ID_DESC'
  | 'TENANT_ID_ASC'
  | 'TENANT_ID_DESC';

/** A condition to be used against `Tenant` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TenantCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
};

export type TenantLocation = {
  __typename?: 'TenantLocation';
  id: Scalars['BigInt']['output'];
  /** Reads a single `Location` that is related to this `TenantLocation`. */
  location: Maybe<Location>;
  locationId: Scalars['BigInt']['output'];
  /** Reads a single `Tenant` that is related to this `TenantLocation`. */
  tenant: Maybe<Tenant>;
  tenantId: Scalars['BigInt']['output'];
};

/**
 * A condition to be used against `TenantLocation` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TenantLocationCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `locationId` field. */
  locationId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `tenantId` field. */
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Methods to use when ordering `TenantLocation`. */
export type TenantLocationsOrderBy =
  | 'ID_ASC'
  | 'ID_DESC'
  | 'LOCATION_BY_LOCATION_ID__ID_ASC'
  | 'LOCATION_BY_LOCATION_ID__ID_DESC'
  | 'LOCATION_ID_ASC'
  | 'LOCATION_ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TENANT_BY_TENANT_ID__ID_ASC'
  | 'TENANT_BY_TENANT_ID__ID_DESC'
  | 'TENANT_ID_ASC'
  | 'TENANT_ID_DESC';

export type TenantMembership = {
  __typename?: 'TenantMembership';
  active: Scalars['Boolean']['output'];
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['BigInt']['output'];
  /** Reads a single `Person` that is related to this `TenantMembership`. */
  person: Maybe<Person>;
  personId: Scalars['BigInt']['output'];
  since: Scalars['Datetime']['output'];
  /** Reads a single `Tenant` that is related to this `TenantMembership`. */
  tenant: Maybe<Tenant>;
  tenantId: Scalars['BigInt']['output'];
  until: Maybe<Scalars['Datetime']['output']>;
  updatedAt: Scalars['Datetime']['output'];
};

/**
 * A condition to be used against `TenantMembership` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TenantMembershipCondition = {
  /** Checks for equality with the object’s `active` field. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `personId` field. */
  personId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `tenantId` field. */
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Methods to use when ordering `TenantMembership`. */
export type TenantMembershipsOrderBy =
  | 'ACTIVE_ASC'
  | 'ACTIVE_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PERSON_BY_PERSON_ID__ID_ASC'
  | 'PERSON_BY_PERSON_ID__ID_DESC'
  | 'PERSON_ID_ASC'
  | 'PERSON_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TENANT_BY_TENANT_ID__ID_ASC'
  | 'TENANT_BY_TENANT_ID__ID_DESC'
  | 'TENANT_ID_ASC'
  | 'TENANT_ID_DESC';

/** Represents an update to a `Tenant`. Fields that are set will be updated. */
export type TenantPatch = {
  address?: InputMaybe<AddressDomainInput>;
  czDic?: InputMaybe<Scalars['String']['input']>;
  czIco?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  memberInfo?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  origins?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export type TenantTrainer = {
  __typename?: 'TenantTrainer';
  active: Scalars['Boolean']['output'];
  createdAt: Scalars['Datetime']['output'];
  defaultPrice: Maybe<Price>;
  description: Scalars['String']['output'];
  id: Scalars['BigInt']['output'];
  isVisible: Maybe<Scalars['Boolean']['output']>;
  /** Reads a single `Person` that is related to this `TenantTrainer`. */
  person: Maybe<Person>;
  personId: Scalars['BigInt']['output'];
  since: Scalars['Datetime']['output'];
  /** Reads a single `Tenant` that is related to this `TenantTrainer`. */
  tenant: Maybe<Tenant>;
  tenantId: Scalars['BigInt']['output'];
  until: Maybe<Scalars['Datetime']['output']>;
  updatedAt: Scalars['Datetime']['output'];
};

/**
 * A condition to be used against `TenantTrainer` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TenantTrainerCondition = {
  /** Checks for equality with the object’s `active` field. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `personId` field. */
  personId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `tenantId` field. */
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Methods to use when ordering `TenantTrainer`. */
export type TenantTrainersOrderBy =
  | 'ACTIVE_ASC'
  | 'ACTIVE_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PERSON_BY_PERSON_ID__ID_ASC'
  | 'PERSON_BY_PERSON_ID__ID_DESC'
  | 'PERSON_ID_ASC'
  | 'PERSON_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TENANT_BY_TENANT_ID__ID_ASC'
  | 'TENANT_BY_TENANT_ID__ID_DESC'
  | 'TENANT_ID_ASC'
  | 'TENANT_ID_DESC';

/** Methods to use when ordering `Tenant`. */
export type TenantsOrderBy =
  | 'COHORT_GROUPS_BY_TENANT__COUNT_ASC'
  | 'COHORT_GROUPS_BY_TENANT__COUNT_DESC'
  | 'EVENT_ATTENDANCES_BY_TENANT_ID__COUNT_ASC'
  | 'EVENT_ATTENDANCES_BY_TENANT_ID__COUNT_DESC'
  | 'EVENT_INSTANCES_BY_TENANT_ID__COUNT_ASC'
  | 'EVENT_INSTANCES_BY_TENANT_ID__COUNT_DESC'
  | 'EVENT_INSTANCE_TRAINERS_BY_TENANT_ID__COUNT_ASC'
  | 'EVENT_INSTANCE_TRAINERS_BY_TENANT_ID__COUNT_DESC'
  | 'EVENT_LESSON_DEMANDS_BY_TENANT_ID__COUNT_ASC'
  | 'EVENT_LESSON_DEMANDS_BY_TENANT_ID__COUNT_DESC'
  | 'EVENT_REGISTRATIONS_BY_TENANT_ID__COUNT_ASC'
  | 'EVENT_REGISTRATIONS_BY_TENANT_ID__COUNT_DESC'
  | 'EVENT_TARGET_COHORTS_BY_TENANT_ID__COUNT_ASC'
  | 'EVENT_TARGET_COHORTS_BY_TENANT_ID__COUNT_DESC'
  | 'EVENT_TRAINERS_BY_TENANT_ID__COUNT_ASC'
  | 'EVENT_TRAINERS_BY_TENANT_ID__COUNT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TENANT_ADMINISTRATORS_BY_TENANT_ID__COUNT_ASC'
  | 'TENANT_ADMINISTRATORS_BY_TENANT_ID__COUNT_DESC'
  | 'TENANT_ATTACHMENTS_BY_TENANT_ID__COUNT_ASC'
  | 'TENANT_ATTACHMENTS_BY_TENANT_ID__COUNT_DESC'
  | 'TENANT_LOCATIONS_BY_TENANT_ID__COUNT_ASC'
  | 'TENANT_LOCATIONS_BY_TENANT_ID__COUNT_DESC'
  | 'TENANT_MEMBERSHIPS_BY_TENANT_ID__COUNT_ASC'
  | 'TENANT_MEMBERSHIPS_BY_TENANT_ID__COUNT_DESC'
  | 'TENANT_TRAINERS_BY_TENANT_ID__COUNT_ASC'
  | 'TENANT_TRAINERS_BY_TENANT_ID__COUNT_DESC';

/** All input for the `updateAktuality` mutation. */
export type UpdateAktualityInput = {
  atId: Scalars['BigInt']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Aktuality` being updated. */
  patch: AktualityPatch;
};

/** The output of our update `Aktuality` mutation. */
export type UpdateAktualityPayload = {
  __typename?: 'UpdateAktualityPayload';
  /** The `Aktuality` that was updated by this mutation. */
  aktuality: Maybe<Aktuality>;
  /** An edge for our `Aktuality`. May be used by Relay 1. */
  aktualityEdge: Maybe<AktualitiesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `GalerieFoto` that is related to this `Aktuality`. */
  galerieFotoByAtFotoMain: Maybe<GalerieFoto>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Aktuality`. */
  userByAtKdo: Maybe<User>;
};


/** The output of our update `Aktuality` mutation. */
export type UpdateAktualityPayloadAktualityEdgeArgs = {
  orderBy?: InputMaybe<Array<AktualitiesOrderBy>>;
};

/** All input for the `updateCohortGroup` mutation. */
export type UpdateCohortGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `CohortGroup` being updated. */
  patch: CohortGroupPatch;
};

/** The output of our update `CohortGroup` mutation. */
export type UpdateCohortGroupPayload = {
  __typename?: 'UpdateCohortGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `CohortGroup` that was updated by this mutation. */
  cohortGroup: Maybe<CohortGroup>;
  /** An edge for our `CohortGroup`. May be used by Relay 1. */
  cohortGroupEdge: Maybe<CohortGroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Tenant` that is related to this `CohortGroup`. */
  tenantByTenant: Maybe<Tenant>;
};


/** The output of our update `CohortGroup` mutation. */
export type UpdateCohortGroupPayloadCohortGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<CohortGroupsOrderBy>>;
};

/** All input for the `updateDokumenty` mutation. */
export type UpdateDokumentyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  dId: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Dokumenty` being updated. */
  patch: DokumentyPatch;
};

/** The output of our update `Dokumenty` mutation. */
export type UpdateDokumentyPayload = {
  __typename?: 'UpdateDokumentyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Dokumenty` that was updated by this mutation. */
  dokumenty: Maybe<Dokumenty>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Dokumenty`. */
  userByDKdo: Maybe<User>;
};

/** All input for the `updateEvent` mutation. */
export type UpdateEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Event` being updated. */
  patch: EventPatch;
};

/** The output of our update `Event` mutation. */
export type UpdateEventPayload = {
  __typename?: 'UpdateEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Event` that was updated by this mutation. */
  event: Maybe<Event>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge: Maybe<EventsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Event` mutation. */
export type UpdateEventPayloadEventEdgeArgs = {
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};

/** All input for the `updateLocation` mutation. */
export type UpdateLocationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Location` being updated. */
  patch: LocationPatch;
};

/** The output of our update `Location` mutation. */
export type UpdateLocationPayload = {
  __typename?: 'UpdateLocationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Location` that was updated by this mutation. */
  location: Maybe<Location>;
  /** An edge for our `Location`. May be used by Relay 1. */
  locationEdge: Maybe<LocationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Location` mutation. */
export type UpdateLocationPayloadLocationEdgeArgs = {
  orderBy?: InputMaybe<Array<LocationsOrderBy>>;
};

/** All input for the `updatePerson` mutation. */
export type UpdatePersonInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Person` being updated. */
  patch: PersonPatch;
};

/** The output of our update `Person` mutation. */
export type UpdatePersonPayload = {
  __typename?: 'UpdatePersonPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Person` that was updated by this mutation. */
  person: Maybe<Person>;
  /** An edge for our `Person`. May be used by Relay 1. */
  personEdge: Maybe<PeopleEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Person` mutation. */
export type UpdatePersonPayloadPersonEdgeArgs = {
  orderBy?: InputMaybe<Array<PeopleOrderBy>>;
};

/** All input for the `updateRoom` mutation. */
export type UpdateRoomInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Room` being updated. */
  patch: RoomPatch;
};

/** The output of our update `Room` mutation. */
export type UpdateRoomPayload = {
  __typename?: 'UpdateRoomPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Location` that is related to this `Room`. */
  locationByLocation: Maybe<Location>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Room` that was updated by this mutation. */
  room: Maybe<Room>;
  /** An edge for our `Room`. May be used by Relay 1. */
  roomEdge: Maybe<RoomsEdge>;
};


/** The output of our update `Room` mutation. */
export type UpdateRoomPayloadRoomEdgeArgs = {
  orderBy?: InputMaybe<Array<RoomsOrderBy>>;
};

/** All input for the `updateSkupiny` mutation. */
export type UpdateSkupinyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Skupiny` being updated. */
  patch: SkupinyPatch;
  sId: Scalars['BigInt']['input'];
};

/** The output of our update `Skupiny` mutation. */
export type UpdateSkupinyPayload = {
  __typename?: 'UpdateSkupinyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `CohortGroup` that is related to this `Skupiny`. */
  cohortGroupByCohortGroup: Maybe<CohortGroup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Skupiny` that was updated by this mutation. */
  skupiny: Maybe<Skupiny>;
  /** An edge for our `Skupiny`. May be used by Relay 1. */
  skupinyEdge: Maybe<SkupiniesEdge>;
};


/** The output of our update `Skupiny` mutation. */
export type UpdateSkupinyPayloadSkupinyEdgeArgs = {
  orderBy?: InputMaybe<Array<SkupiniesOrderBy>>;
};

/** All input for the `updateTenant` mutation. */
export type UpdateTenantInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Tenant` being updated. */
  patch: TenantPatch;
};

/** The output of our update `Tenant` mutation. */
export type UpdateTenantPayload = {
  __typename?: 'UpdateTenantPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Tenant` that was updated by this mutation. */
  tenant: Maybe<Tenant>;
};

/** All input for the `updateUpozorneni` mutation. */
export type UpdateUpozorneniInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Upozorneni` being updated. */
  patch: UpozorneniPatch;
  upId: Scalars['BigInt']['input'];
};

/** The output of our update `Upozorneni` mutation. */
export type UpdateUpozorneniPayload = {
  __typename?: 'UpdateUpozorneniPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Upozorneni` that was updated by this mutation. */
  upozorneni: Maybe<Upozorneni>;
  /** An edge for our `Upozorneni`. May be used by Relay 1. */
  upozorneniEdge: Maybe<UpozornenisEdge>;
  /** Reads a single `User` that is related to this `Upozorneni`. */
  userByUpKdo: Maybe<User>;
};


/** The output of our update `Upozorneni` mutation. */
export type UpdateUpozorneniPayloadUpozorneniEdgeArgs = {
  orderBy?: InputMaybe<Array<UpozornenisOrderBy>>;
};

export type Upozorneni = {
  __typename?: 'Upozorneni';
  id: Maybe<Scalars['BigInt']['output']>;
  isVisible: Maybe<Scalars['Boolean']['output']>;
  scheduledSince: Maybe<Scalars['Datetime']['output']>;
  scheduledUntil: Maybe<Scalars['Datetime']['output']>;
  sticky: Scalars['Boolean']['output'];
  tenantId: Scalars['BigInt']['output'];
  upBarvy: Scalars['BigInt']['output'];
  upId: Scalars['BigInt']['output'];
  upKdo: Maybe<Scalars['BigInt']['output']>;
  upLock: Scalars['Boolean']['output'];
  upNadpis: Scalars['String']['output'];
  upText: Scalars['String']['output'];
  upTimestamp: Maybe<Scalars['Datetime']['output']>;
  upTimestampAdd: Scalars['Datetime']['output'];
  /** Reads and enables pagination through a set of `UpozorneniSkupiny`. */
  upozorneniSkupiniesByUpsIdRodic: UpozorneniSkupiniesConnection;
  /** Reads a single `User` that is related to this `Upozorneni`. */
  userByUpKdo: Maybe<User>;
};


export type UpozorneniUpozorneniSkupiniesByUpsIdRodicArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UpozorneniSkupinyCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UpozorneniSkupiniesOrderBy>>;
};

/**
 * A condition to be used against `Upozorneni` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type UpozorneniCondition = {
  /** Checks for equality with the object’s `upId` field. */
  upId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `upKdo` field. */
  upKdo?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `upTimestampAdd` field. */
  upTimestampAdd?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An input for mutations affecting `Upozorneni` */
export type UpozorneniInput = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  isVisible?: InputMaybe<Scalars['Boolean']['input']>;
  scheduledSince?: InputMaybe<Scalars['Datetime']['input']>;
  scheduledUntil?: InputMaybe<Scalars['Datetime']['input']>;
  sticky?: InputMaybe<Scalars['Boolean']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
  upBarvy?: InputMaybe<Scalars['BigInt']['input']>;
  upId?: InputMaybe<Scalars['BigInt']['input']>;
  upKdo?: InputMaybe<Scalars['BigInt']['input']>;
  upLock?: InputMaybe<Scalars['Boolean']['input']>;
  upNadpis: Scalars['String']['input'];
  upText: Scalars['String']['input'];
  upTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
  upTimestampAdd?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `Upozorneni`. Fields that are set will be updated. */
export type UpozorneniPatch = {
  id?: InputMaybe<Scalars['BigInt']['input']>;
  isVisible?: InputMaybe<Scalars['Boolean']['input']>;
  scheduledSince?: InputMaybe<Scalars['Datetime']['input']>;
  scheduledUntil?: InputMaybe<Scalars['Datetime']['input']>;
  sticky?: InputMaybe<Scalars['Boolean']['input']>;
  tenantId?: InputMaybe<Scalars['BigInt']['input']>;
  upBarvy?: InputMaybe<Scalars['BigInt']['input']>;
  upId?: InputMaybe<Scalars['BigInt']['input']>;
  upKdo?: InputMaybe<Scalars['BigInt']['input']>;
  upLock?: InputMaybe<Scalars['Boolean']['input']>;
  upNadpis?: InputMaybe<Scalars['String']['input']>;
  upText?: InputMaybe<Scalars['String']['input']>;
  upTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
  upTimestampAdd?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `UpozorneniSkupiny` values. */
export type UpozorneniSkupiniesConnection = {
  __typename?: 'UpozorneniSkupiniesConnection';
  /** A list of edges which contains the `UpozorneniSkupiny` and cursor to aid in pagination. */
  edges: Array<UpozorneniSkupiniesEdge>;
  /** A list of `UpozorneniSkupiny` objects. */
  nodes: Array<UpozorneniSkupiny>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UpozorneniSkupiny` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UpozorneniSkupiny` edge in the connection. */
export type UpozorneniSkupiniesEdge = {
  __typename?: 'UpozorneniSkupiniesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `UpozorneniSkupiny` at the end of the edge. */
  node: UpozorneniSkupiny;
};

/** Methods to use when ordering `UpozorneniSkupiny`. */
export type UpozorneniSkupiniesOrderBy =
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__COHORT_GROUP_ASC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__COHORT_GROUP_DESC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__ORDERING_ASC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__ORDERING_DESC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__S_ID_ASC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__S_ID_DESC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__S_VISIBLE_ASC'
  | 'SKUPINY_BY_UPS_ID_SKUPINA__S_VISIBLE_DESC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__UP_ID_ASC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__UP_ID_DESC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__UP_KDO_ASC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__UP_KDO_DESC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__UP_TIMESTAMP_ADD_ASC'
  | 'UPOZORNENI_BY_UPS_ID_RODIC__UP_TIMESTAMP_ADD_DESC'
  | 'UPS_ID_ASC'
  | 'UPS_ID_DESC'
  | 'UPS_ID_RODIC_ASC'
  | 'UPS_ID_RODIC_DESC'
  | 'UPS_ID_SKUPINA_ASC'
  | 'UPS_ID_SKUPINA_DESC';

export type UpozorneniSkupiny = {
  __typename?: 'UpozorneniSkupiny';
  id: Maybe<Scalars['BigInt']['output']>;
  /** Reads a single `Skupiny` that is related to this `UpozorneniSkupiny`. */
  skupinyByUpsIdSkupina: Maybe<Skupiny>;
  tenantId: Scalars['BigInt']['output'];
  /** Reads a single `Upozorneni` that is related to this `UpozorneniSkupiny`. */
  upozorneniByUpsIdRodic: Maybe<Upozorneni>;
  upsColor: Scalars['String']['output'];
  upsId: Scalars['BigInt']['output'];
  upsIdRodic: Scalars['BigInt']['output'];
  upsIdSkupina: Scalars['BigInt']['output'];
};

/**
 * A condition to be used against `UpozorneniSkupiny` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type UpozorneniSkupinyCondition = {
  /** Checks for equality with the object’s `upsId` field. */
  upsId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `upsIdRodic` field. */
  upsIdRodic?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `upsIdSkupina` field. */
  upsIdSkupina?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `Upozorneni` values. */
export type UpozornenisConnection = {
  __typename?: 'UpozornenisConnection';
  /** A list of edges which contains the `Upozorneni` and cursor to aid in pagination. */
  edges: Array<UpozornenisEdge>;
  /** A list of `Upozorneni` objects. */
  nodes: Array<Upozorneni>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Upozorneni` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Upozorneni` edge in the connection. */
export type UpozornenisEdge = {
  __typename?: 'UpozornenisEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Upozorneni` at the end of the edge. */
  node: Upozorneni;
};

/** Methods to use when ordering `Upozorneni`. */
export type UpozornenisOrderBy =
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'UPOZORNENI_SKUPINIES_BY_UPS_ID_RODIC__COUNT_ASC'
  | 'UPOZORNENI_SKUPINIES_BY_UPS_ID_RODIC__COUNT_DESC'
  | 'UP_ID_ASC'
  | 'UP_ID_DESC'
  | 'UP_KDO_ASC'
  | 'UP_KDO_DESC'
  | 'UP_TIMESTAMP_ADD_ASC'
  | 'UP_TIMESTAMP_ADD_DESC'
  | 'USER_BY_UP_KDO__U_ID_ASC'
  | 'USER_BY_UP_KDO__U_ID_DESC'
  | 'USER_BY_UP_KDO__U_JMENO_ASC'
  | 'USER_BY_UP_KDO__U_JMENO_DESC'
  | 'USER_BY_UP_KDO__U_LOGIN_ASC'
  | 'USER_BY_UP_KDO__U_LOGIN_DESC'
  | 'USER_BY_UP_KDO__U_PRIJMENI_ASC'
  | 'USER_BY_UP_KDO__U_PRIJMENI_DESC';

export type User = {
  __typename?: 'User';
  /** Reads and enables pagination through a set of `Aktuality`. */
  aktualitiesByAtKdo: AktualitiesConnection;
  /** Reads and enables pagination through a set of `Attachment`. */
  attachmentsByUploadedBy: AttachmentsConnection;
  dateOfNewestPayment: Maybe<Scalars['Date']['output']>;
  dateOfOldestPayment: Maybe<Scalars['Date']['output']>;
  /** Reads and enables pagination through a set of `Dokumenty`. */
  dokumentiesByDKdoList: Array<Dokumenty>;
  /** Reads and enables pagination through a set of `GalerieFoto`. */
  galerieFotosByGfKdo: GalerieFotosConnection;
  hasValidPayment: Maybe<Scalars['Boolean']['output']>;
  id: Maybe<Scalars['BigInt']['output']>;
  inPublicCohort: Maybe<Scalars['Boolean']['output']>;
  /** Reads and enables pagination through a set of `PlatbyItem`. */
  platbyItemsByPiIdUser: PlatbyItemsConnection;
  tenantId: Scalars['BigInt']['output'];
  uCity: Scalars['String']['output'];
  uConscriptionNumber: Scalars['String']['output'];
  uCreatedAt: Scalars['Datetime']['output'];
  uDistrict: Scalars['String']['output'];
  uEmail: Scalars['String']['output'];
  uId: Scalars['BigInt']['output'];
  uJmeno: Scalars['String']['output'];
  uLogin: Scalars['String']['output'];
  uNationality: Scalars['String']['output'];
  uOrientationNumber: Scalars['String']['output'];
  uPostalCode: Scalars['String']['output'];
  uPrijmeni: Scalars['String']['output'];
  uStreet: Scalars['String']['output'];
  uTimestamp: Scalars['Datetime']['output'];
  /** Reads and enables pagination through a set of `Upozorneni`. */
  upozornenisByUpKdo: UpozornenisConnection;
  /** Reads and enables pagination through a set of `UserProxy`. */
  userProxiesList: Array<UserProxy>;
};


export type UserAktualitiesByAtKdoArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AktualityCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AktualitiesOrderBy>>;
};


export type UserAttachmentsByUploadedByArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AttachmentCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AttachmentsOrderBy>>;
};


export type UserDokumentiesByDKdoListArgs = {
  condition?: InputMaybe<DokumentyCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DokumentiesOrderBy>>;
};


export type UserGalerieFotosByGfKdoArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GalerieFotoCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GalerieFotosOrderBy>>;
};


export type UserPlatbyItemsByPiIdUserArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PlatbyItemCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PlatbyItemsOrderBy>>;
};


export type UserUpozornenisByUpKdoArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UpozorneniCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UpozornenisOrderBy>>;
};


export type UserUserProxiesListArgs = {
  condition?: InputMaybe<UserProxyCondition>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserProxiesOrderBy>>;
};

/** A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UserCondition = {
  /** Checks for equality with the object’s `inPublicCohort` field. */
  inPublicCohort?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `uId` field. */
  uId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `uJmeno` field. */
  uJmeno?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `uLogin` field. */
  uLogin?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `uPrijmeni` field. */
  uPrijmeni?: InputMaybe<Scalars['String']['input']>;
};

/** Methods to use when ordering `UserProxy`. */
export type UserProxiesOrderBy =
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PERSON_BY_PERSON_ID__ID_ASC'
  | 'PERSON_BY_PERSON_ID__ID_DESC'
  | 'PERSON_ID_ASC'
  | 'PERSON_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'USER_BY_USER_ID__U_ID_ASC'
  | 'USER_BY_USER_ID__U_ID_DESC'
  | 'USER_BY_USER_ID__U_JMENO_ASC'
  | 'USER_BY_USER_ID__U_JMENO_DESC'
  | 'USER_BY_USER_ID__U_LOGIN_ASC'
  | 'USER_BY_USER_ID__U_LOGIN_DESC'
  | 'USER_BY_USER_ID__U_PRIJMENI_ASC'
  | 'USER_BY_USER_ID__U_PRIJMENI_DESC'
  | 'USER_ID_ASC'
  | 'USER_ID_DESC';

export type UserProxy = {
  __typename?: 'UserProxy';
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['BigInt']['output'];
  /** Reads a single `Person` that is related to this `UserProxy`. */
  person: Maybe<Person>;
  personId: Scalars['BigInt']['output'];
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `User` that is related to this `UserProxy`. */
  user: Maybe<User>;
  userId: Scalars['BigInt']['output'];
};

/**
 * A condition to be used against `UserProxy` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type UserProxyCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `personId` field. */
  personId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `User` values. */
export type UsersConnection = {
  __typename?: 'UsersConnection';
  /** A list of edges which contains the `User` and cursor to aid in pagination. */
  edges: Array<UsersEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection. */
export type UsersEdge = {
  __typename?: 'UsersEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
};

/** Methods to use when ordering `User`. */
export type UsersOrderBy =
  | 'AKTUALITIES_BY_AT_KDO__COUNT_ASC'
  | 'AKTUALITIES_BY_AT_KDO__COUNT_DESC'
  | 'ATTACHMENTS_BY_UPLOADED_BY__COUNT_ASC'
  | 'ATTACHMENTS_BY_UPLOADED_BY__COUNT_DESC'
  | 'DOKUMENTIES_BY_D_KDO__COUNT_ASC'
  | 'DOKUMENTIES_BY_D_KDO__COUNT_DESC'
  | 'GALERIE_FOTOS_BY_GF_KDO__COUNT_ASC'
  | 'GALERIE_FOTOS_BY_GF_KDO__COUNT_DESC'
  | 'NATURAL'
  | 'PLATBY_ITEMS_BY_PI_ID_USER__COUNT_ASC'
  | 'PLATBY_ITEMS_BY_PI_ID_USER__COUNT_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'UPOZORNENIS_BY_UP_KDO__COUNT_ASC'
  | 'UPOZORNENIS_BY_UP_KDO__COUNT_DESC'
  | 'USER_PROXIES_BY_USER_ID__COUNT_ASC'
  | 'USER_PROXIES_BY_USER_ID__COUNT_DESC'
  | 'U_ID_ASC'
  | 'U_ID_DESC'
  | 'U_JMENO_ASC'
  | 'U_JMENO_DESC'
  | 'U_LOGIN_ASC'
  | 'U_LOGIN_DESC'
  | 'U_PRIJMENI_ASC'
  | 'U_PRIJMENI_DESC';

export type WithTypename<T extends { __typename?: any }> = Partial<T> & { __typename: NonNullable<T['__typename']> };

export type GraphCacheKeysConfig = {
  Address?: (data: WithTypename<Address>) => null | string,
  AddressDomain?: (data: WithTypename<AddressDomain>) => null | string,
  AktualitiesConnection?: (data: WithTypename<AktualitiesConnection>) => null | string,
  AktualitiesEdge?: (data: WithTypename<AktualitiesEdge>) => null | string,
  Aktuality?: (data: WithTypename<Aktuality>) => null | string,
  Attachment?: (data: WithTypename<Attachment>) => null | string,
  AttachmentDirectoriesConnection?: (data: WithTypename<AttachmentDirectoriesConnection>) => null | string,
  AttachmentDirectoryEdge?: (data: WithTypename<AttachmentDirectoryEdge>) => null | string,
  AttachmentsConnection?: (data: WithTypename<AttachmentsConnection>) => null | string,
  AttachmentsEdge?: (data: WithTypename<AttachmentsEdge>) => null | string,
  CancelRegistrationPayload?: (data: WithTypename<CancelRegistrationPayload>) => null | string,
  ChangePasswordPayload?: (data: WithTypename<ChangePasswordPayload>) => null | string,
  CohortGroup?: (data: WithTypename<CohortGroup>) => null | string,
  CohortGroupsConnection?: (data: WithTypename<CohortGroupsConnection>) => null | string,
  CohortGroupsEdge?: (data: WithTypename<CohortGroupsEdge>) => null | string,
  CohortMembership?: (data: WithTypename<CohortMembership>) => null | string,
  ConfirmUserPayload?: (data: WithTypename<ConfirmUserPayload>) => null | string,
  Couple?: (data: WithTypename<Couple>) => null | string,
  CouplesConnection?: (data: WithTypename<CouplesConnection>) => null | string,
  CouplesEdge?: (data: WithTypename<CouplesEdge>) => null | string,
  CreateAktualityPayload?: (data: WithTypename<CreateAktualityPayload>) => null | string,
  CreateAttachmentPayload?: (data: WithTypename<CreateAttachmentPayload>) => null | string,
  CreateCohortGroupPayload?: (data: WithTypename<CreateCohortGroupPayload>) => null | string,
  CreateCouplePayload?: (data: WithTypename<CreateCouplePayload>) => null | string,
  CreateDokumentyPayload?: (data: WithTypename<CreateDokumentyPayload>) => null | string,
  CreateEventPayload?: (data: WithTypename<CreateEventPayload>) => null | string,
  CreateFormResponsePayload?: (data: WithTypename<CreateFormResponsePayload>) => null | string,
  CreateLocationPayload?: (data: WithTypename<CreateLocationPayload>) => null | string,
  CreatePermissionPayload?: (data: WithTypename<CreatePermissionPayload>) => null | string,
  CreateRoomPayload?: (data: WithTypename<CreateRoomPayload>) => null | string,
  CreateSkupinyPayload?: (data: WithTypename<CreateSkupinyPayload>) => null | string,
  CreateUpozorneniPayload?: (data: WithTypename<CreateUpozorneniPayload>) => null | string,
  CurrentCoupleIdEdge?: (data: WithTypename<CurrentCoupleIdEdge>) => null | string,
  CurrentCoupleIdsConnection?: (data: WithTypename<CurrentCoupleIdsConnection>) => null | string,
  CurrentPersonIdsPayload?: (data: WithTypename<CurrentPersonIdsPayload>) => null | string,
  DatetimeRange?: (data: WithTypename<DatetimeRange>) => null | string,
  DatetimeRangeBound?: (data: WithTypename<DatetimeRangeBound>) => null | string,
  DeleteAktualityPayload?: (data: WithTypename<DeleteAktualityPayload>) => null | string,
  DeleteAttachmentPayload?: (data: WithTypename<DeleteAttachmentPayload>) => null | string,
  DeleteCohortGroupPayload?: (data: WithTypename<DeleteCohortGroupPayload>) => null | string,
  DeleteCouplePayload?: (data: WithTypename<DeleteCouplePayload>) => null | string,
  DeleteDokumentyPayload?: (data: WithTypename<DeleteDokumentyPayload>) => null | string,
  DeleteEventPayload?: (data: WithTypename<DeleteEventPayload>) => null | string,
  DeleteLocationPayload?: (data: WithTypename<DeleteLocationPayload>) => null | string,
  DeleteRoomPayload?: (data: WithTypename<DeleteRoomPayload>) => null | string,
  DeleteSkupinyPayload?: (data: WithTypename<DeleteSkupinyPayload>) => null | string,
  DeleteUpozorneniPayload?: (data: WithTypename<DeleteUpozorneniPayload>) => null | string,
  Dokumenty?: (data: WithTypename<Dokumenty>) => null | string,
  EditRegistrationPayload?: (data: WithTypename<EditRegistrationPayload>) => null | string,
  Event?: (data: WithTypename<Event>) => null | string,
  EventAttendance?: (data: WithTypename<EventAttendance>) => null | string,
  EventInstance?: (data: WithTypename<EventInstance>) => null | string,
  EventInstanceTrainer?: (data: WithTypename<EventInstanceTrainer>) => null | string,
  EventInstancesConnection?: (data: WithTypename<EventInstancesConnection>) => null | string,
  EventInstancesEdge?: (data: WithTypename<EventInstancesEdge>) => null | string,
  EventLessonDemand?: (data: WithTypename<EventLessonDemand>) => null | string,
  EventRegistration?: (data: WithTypename<EventRegistration>) => null | string,
  EventTargetCohort?: (data: WithTypename<EventTargetCohort>) => null | string,
  EventTrainer?: (data: WithTypename<EventTrainer>) => null | string,
  EventsConnection?: (data: WithTypename<EventsConnection>) => null | string,
  EventsEdge?: (data: WithTypename<EventsEdge>) => null | string,
  FormResponse?: (data: WithTypename<FormResponse>) => null | string,
  FormResponsesConnection?: (data: WithTypename<FormResponsesConnection>) => null | string,
  FormResponsesEdge?: (data: WithTypename<FormResponsesEdge>) => null | string,
  GalerieDir?: (data: WithTypename<GalerieDir>) => null | string,
  GalerieDirsConnection?: (data: WithTypename<GalerieDirsConnection>) => null | string,
  GalerieDirsEdge?: (data: WithTypename<GalerieDirsEdge>) => null | string,
  GalerieFoto?: (data: WithTypename<GalerieFoto>) => null | string,
  GalerieFotosConnection?: (data: WithTypename<GalerieFotosConnection>) => null | string,
  GalerieFotosEdge?: (data: WithTypename<GalerieFotosEdge>) => null | string,
  IsCurrentTenantMemberPayload?: (data: WithTypename<IsCurrentTenantMemberPayload>) => null | string,
  Location?: (data: WithTypename<Location>) => null | string,
  LocationAttachment?: (data: WithTypename<LocationAttachment>) => null | string,
  LocationAttachmentsConnection?: (data: WithTypename<LocationAttachmentsConnection>) => null | string,
  LocationAttachmentsEdge?: (data: WithTypename<LocationAttachmentsEdge>) => null | string,
  LocationsConnection?: (data: WithTypename<LocationsConnection>) => null | string,
  LocationsEdge?: (data: WithTypename<LocationsEdge>) => null | string,
  LoginPayload?: (data: WithTypename<LoginPayload>) => null | string,
  LoginRecord?: (data: WithTypename<LoginRecord>) => null | string,
  LogoutPayload?: (data: WithTypename<LogoutPayload>) => null | string,
  PageInfo?: (data: WithTypename<PageInfo>) => null | string,
  Pary?: (data: WithTypename<Pary>) => null | string,
  PeopleConnection?: (data: WithTypename<PeopleConnection>) => null | string,
  PeopleEdge?: (data: WithTypename<PeopleEdge>) => null | string,
  Permission?: (data: WithTypename<Permission>) => null | string,
  Person?: (data: WithTypename<Person>) => null | string,
  PersonAddress?: (data: WithTypename<PersonAddress>) => null | string,
  PersonEmail?: (data: WithTypename<PersonEmail>) => null | string,
  PersonPhone?: (data: WithTypename<PersonPhone>) => null | string,
  PlatbyCategoriesConnection?: (data: WithTypename<PlatbyCategoriesConnection>) => null | string,
  PlatbyCategoriesEdge?: (data: WithTypename<PlatbyCategoriesEdge>) => null | string,
  PlatbyCategory?: (data: WithTypename<PlatbyCategory>) => null | string,
  PlatbyItem?: (data: WithTypename<PlatbyItem>) => null | string,
  PlatbyItemsConnection?: (data: WithTypename<PlatbyItemsConnection>) => null | string,
  PlatbyItemsEdge?: (data: WithTypename<PlatbyItemsEdge>) => null | string,
  Price?: (data: WithTypename<Price>) => null | string,
  RegisterToEventPayload?: (data: WithTypename<RegisterToEventPayload>) => null | string,
  ResetPasswordPayload?: (data: WithTypename<ResetPasswordPayload>) => null | string,
  Room?: (data: WithTypename<Room>) => null | string,
  RoomAttachment?: (data: WithTypename<RoomAttachment>) => null | string,
  RoomAttachmentsConnection?: (data: WithTypename<RoomAttachmentsConnection>) => null | string,
  RoomAttachmentsEdge?: (data: WithTypename<RoomAttachmentsEdge>) => null | string,
  RoomsConnection?: (data: WithTypename<RoomsConnection>) => null | string,
  RoomsEdge?: (data: WithTypename<RoomsEdge>) => null | string,
  Session?: (data: WithTypename<Session>) => null | string,
  SetLessonDemandPayload?: (data: WithTypename<SetLessonDemandPayload>) => null | string,
  SkupiniesConnection?: (data: WithTypename<SkupiniesConnection>) => null | string,
  SkupiniesEdge?: (data: WithTypename<SkupiniesEdge>) => null | string,
  Skupiny?: (data: WithTypename<Skupiny>) => null | string,
  SubmitFormPayload?: (data: WithTypename<SubmitFormPayload>) => null | string,
  Tenant?: (data: WithTypename<Tenant>) => null | string,
  TenantAdministrator?: (data: WithTypename<TenantAdministrator>) => null | string,
  TenantAttachment?: (data: WithTypename<TenantAttachment>) => null | string,
  TenantAttachmentsConnection?: (data: WithTypename<TenantAttachmentsConnection>) => null | string,
  TenantAttachmentsEdge?: (data: WithTypename<TenantAttachmentsEdge>) => null | string,
  TenantLocation?: (data: WithTypename<TenantLocation>) => null | string,
  TenantMembership?: (data: WithTypename<TenantMembership>) => null | string,
  TenantTrainer?: (data: WithTypename<TenantTrainer>) => null | string,
  UpdateAktualityPayload?: (data: WithTypename<UpdateAktualityPayload>) => null | string,
  UpdateCohortGroupPayload?: (data: WithTypename<UpdateCohortGroupPayload>) => null | string,
  UpdateDokumentyPayload?: (data: WithTypename<UpdateDokumentyPayload>) => null | string,
  UpdateEventPayload?: (data: WithTypename<UpdateEventPayload>) => null | string,
  UpdateLocationPayload?: (data: WithTypename<UpdateLocationPayload>) => null | string,
  UpdatePersonPayload?: (data: WithTypename<UpdatePersonPayload>) => null | string,
  UpdateRoomPayload?: (data: WithTypename<UpdateRoomPayload>) => null | string,
  UpdateSkupinyPayload?: (data: WithTypename<UpdateSkupinyPayload>) => null | string,
  UpdateTenantPayload?: (data: WithTypename<UpdateTenantPayload>) => null | string,
  UpdateUpozorneniPayload?: (data: WithTypename<UpdateUpozorneniPayload>) => null | string,
  Upozorneni?: (data: WithTypename<Upozorneni>) => null | string,
  UpozorneniSkupiniesConnection?: (data: WithTypename<UpozorneniSkupiniesConnection>) => null | string,
  UpozorneniSkupiniesEdge?: (data: WithTypename<UpozorneniSkupiniesEdge>) => null | string,
  UpozorneniSkupiny?: (data: WithTypename<UpozorneniSkupiny>) => null | string,
  UpozornenisConnection?: (data: WithTypename<UpozornenisConnection>) => null | string,
  UpozornenisEdge?: (data: WithTypename<UpozornenisEdge>) => null | string,
  User?: (data: WithTypename<User>) => null | string,
  UserProxy?: (data: WithTypename<UserProxy>) => null | string,
  UsersConnection?: (data: WithTypename<UsersConnection>) => null | string,
  UsersEdge?: (data: WithTypename<UsersEdge>) => null | string
}

export type GraphCacheResolvers = {
  Query?: {
    aktualities?: GraphCacheResolver<WithTypename<Query>, QueryAktualitiesArgs, WithTypename<AktualitiesConnection> | string>,
    aktuality?: GraphCacheResolver<WithTypename<Query>, QueryAktualityArgs, WithTypename<Aktuality> | string>,
    archivedAnnouncements?: GraphCacheResolver<WithTypename<Query>, QueryArchivedAnnouncementsArgs, WithTypename<UpozornenisConnection> | string>,
    attachment?: GraphCacheResolver<WithTypename<Query>, QueryAttachmentArgs, WithTypename<Attachment> | string>,
    attachmentDirectories?: GraphCacheResolver<WithTypename<Query>, QueryAttachmentDirectoriesArgs, WithTypename<AttachmentDirectoriesConnection> | string>,
    attachments?: GraphCacheResolver<WithTypename<Query>, QueryAttachmentsArgs, WithTypename<AttachmentsConnection> | string>,
    cohortGroup?: GraphCacheResolver<WithTypename<Query>, QueryCohortGroupArgs, WithTypename<CohortGroup> | string>,
    cohortGroups?: GraphCacheResolver<WithTypename<Query>, QueryCohortGroupsArgs, WithTypename<CohortGroupsConnection> | string>,
    cohortMembership?: GraphCacheResolver<WithTypename<Query>, QueryCohortMembershipArgs, WithTypename<CohortMembership> | string>,
    cohortMembershipsList?: GraphCacheResolver<WithTypename<Query>, QueryCohortMembershipsListArgs, Array<WithTypename<CohortMembership> | string>>,
    couple?: GraphCacheResolver<WithTypename<Query>, QueryCoupleArgs, WithTypename<Couple> | string>,
    couples?: GraphCacheResolver<WithTypename<Query>, QueryCouplesArgs, WithTypename<CouplesConnection> | string>,
    currentCoupleIds?: GraphCacheResolver<WithTypename<Query>, QueryCurrentCoupleIdsArgs, WithTypename<CurrentCoupleIdsConnection> | string>,
    currentSessionId?: GraphCacheResolver<WithTypename<Query>, Record<string, never>, Scalars['String'] | string>,
    currentTenantId?: GraphCacheResolver<WithTypename<Query>, Record<string, never>, Scalars['BigInt'] | string>,
    currentUserId?: GraphCacheResolver<WithTypename<Query>, Record<string, never>, Scalars['BigInt'] | string>,
    dokumentiesList?: GraphCacheResolver<WithTypename<Query>, QueryDokumentiesListArgs, Array<WithTypename<Dokumenty> | string>>,
    dokumenty?: GraphCacheResolver<WithTypename<Query>, QueryDokumentyArgs, WithTypename<Dokumenty> | string>,
    event?: GraphCacheResolver<WithTypename<Query>, QueryEventArgs, WithTypename<Event> | string>,
    eventAttendance?: GraphCacheResolver<WithTypename<Query>, QueryEventAttendanceArgs, WithTypename<EventAttendance> | string>,
    eventAttendancesList?: GraphCacheResolver<WithTypename<Query>, QueryEventAttendancesListArgs, Array<WithTypename<EventAttendance> | string>>,
    eventInstance?: GraphCacheResolver<WithTypename<Query>, QueryEventInstanceArgs, WithTypename<EventInstance> | string>,
    eventInstanceTrainer?: GraphCacheResolver<WithTypename<Query>, QueryEventInstanceTrainerArgs, WithTypename<EventInstanceTrainer> | string>,
    eventInstanceTrainersList?: GraphCacheResolver<WithTypename<Query>, QueryEventInstanceTrainersListArgs, Array<WithTypename<EventInstanceTrainer> | string>>,
    eventInstances?: GraphCacheResolver<WithTypename<Query>, QueryEventInstancesArgs, WithTypename<EventInstancesConnection> | string>,
    eventInstancesForRangeList?: GraphCacheResolver<WithTypename<Query>, QueryEventInstancesForRangeListArgs, Array<WithTypename<EventInstance> | string>>,
    eventInstancesList?: GraphCacheResolver<WithTypename<Query>, QueryEventInstancesListArgs, Array<WithTypename<EventInstance> | string>>,
    eventLessonDemand?: GraphCacheResolver<WithTypename<Query>, QueryEventLessonDemandArgs, WithTypename<EventLessonDemand> | string>,
    eventLessonDemandByRegistrationIdAndTrainerId?: GraphCacheResolver<WithTypename<Query>, QueryEventLessonDemandByRegistrationIdAndTrainerIdArgs, WithTypename<EventLessonDemand> | string>,
    eventLessonDemandsList?: GraphCacheResolver<WithTypename<Query>, QueryEventLessonDemandsListArgs, Array<WithTypename<EventLessonDemand> | string>>,
    eventRegistration?: GraphCacheResolver<WithTypename<Query>, QueryEventRegistrationArgs, WithTypename<EventRegistration> | string>,
    eventRegistrationByEventIdAndPersonIdAndCoupleId?: GraphCacheResolver<WithTypename<Query>, QueryEventRegistrationByEventIdAndPersonIdAndCoupleIdArgs, WithTypename<EventRegistration> | string>,
    eventRegistrationsList?: GraphCacheResolver<WithTypename<Query>, QueryEventRegistrationsListArgs, Array<WithTypename<EventRegistration> | string>>,
    eventTargetCohort?: GraphCacheResolver<WithTypename<Query>, QueryEventTargetCohortArgs, WithTypename<EventTargetCohort> | string>,
    eventTargetCohortsList?: GraphCacheResolver<WithTypename<Query>, QueryEventTargetCohortsListArgs, Array<WithTypename<EventTargetCohort> | string>>,
    eventTrainer?: GraphCacheResolver<WithTypename<Query>, QueryEventTrainerArgs, WithTypename<EventTrainer> | string>,
    eventTrainersList?: GraphCacheResolver<WithTypename<Query>, QueryEventTrainersListArgs, Array<WithTypename<EventTrainer> | string>>,
    events?: GraphCacheResolver<WithTypename<Query>, QueryEventsArgs, WithTypename<EventsConnection> | string>,
    filteredPeopleList?: GraphCacheResolver<WithTypename<Query>, QueryFilteredPeopleListArgs, Array<WithTypename<Person> | string>>,
    formResponse?: GraphCacheResolver<WithTypename<Query>, QueryFormResponseArgs, WithTypename<FormResponse> | string>,
    formResponses?: GraphCacheResolver<WithTypename<Query>, QueryFormResponsesArgs, WithTypename<FormResponsesConnection> | string>,
    galerieDir?: GraphCacheResolver<WithTypename<Query>, QueryGalerieDirArgs, WithTypename<GalerieDir> | string>,
    galerieDirs?: GraphCacheResolver<WithTypename<Query>, QueryGalerieDirsArgs, WithTypename<GalerieDirsConnection> | string>,
    galerieFoto?: GraphCacheResolver<WithTypename<Query>, QueryGalerieFotoArgs, WithTypename<GalerieFoto> | string>,
    galerieFotos?: GraphCacheResolver<WithTypename<Query>, QueryGalerieFotosArgs, WithTypename<GalerieFotosConnection> | string>,
    getCurrentCouple?: GraphCacheResolver<WithTypename<Query>, Record<string, never>, WithTypename<Pary> | string>,
    getCurrentTenant?: GraphCacheResolver<WithTypename<Query>, Record<string, never>, WithTypename<Tenant> | string>,
    getCurrentUser?: GraphCacheResolver<WithTypename<Query>, Record<string, never>, WithTypename<User> | string>,
    location?: GraphCacheResolver<WithTypename<Query>, QueryLocationArgs, WithTypename<Location> | string>,
    locationAttachment?: GraphCacheResolver<WithTypename<Query>, QueryLocationAttachmentArgs, WithTypename<LocationAttachment> | string>,
    locationAttachments?: GraphCacheResolver<WithTypename<Query>, QueryLocationAttachmentsArgs, WithTypename<LocationAttachmentsConnection> | string>,
    locations?: GraphCacheResolver<WithTypename<Query>, QueryLocationsArgs, WithTypename<LocationsConnection> | string>,
    myAnnouncements?: GraphCacheResolver<WithTypename<Query>, QueryMyAnnouncementsArgs, WithTypename<UpozornenisConnection> | string>,
    people?: GraphCacheResolver<WithTypename<Query>, QueryPeopleArgs, WithTypename<PeopleConnection> | string>,
    permission?: GraphCacheResolver<WithTypename<Query>, QueryPermissionArgs, WithTypename<Permission> | string>,
    permissionsList?: GraphCacheResolver<WithTypename<Query>, QueryPermissionsListArgs, Array<WithTypename<Permission> | string>>,
    person?: GraphCacheResolver<WithTypename<Query>, QueryPersonArgs, WithTypename<Person> | string>,
    personAddressesList?: GraphCacheResolver<WithTypename<Query>, QueryPersonAddressesListArgs, Array<WithTypename<PersonAddress> | string>>,
    personEmail?: GraphCacheResolver<WithTypename<Query>, QueryPersonEmailArgs, WithTypename<PersonEmail> | string>,
    personEmailsList?: GraphCacheResolver<WithTypename<Query>, QueryPersonEmailsListArgs, Array<WithTypename<PersonEmail> | string>>,
    personPhone?: GraphCacheResolver<WithTypename<Query>, QueryPersonPhoneArgs, WithTypename<PersonPhone> | string>,
    personPhonesList?: GraphCacheResolver<WithTypename<Query>, QueryPersonPhonesListArgs, Array<WithTypename<PersonPhone> | string>>,
    platbyCategories?: GraphCacheResolver<WithTypename<Query>, QueryPlatbyCategoriesArgs, WithTypename<PlatbyCategoriesConnection> | string>,
    platbyCategory?: GraphCacheResolver<WithTypename<Query>, QueryPlatbyCategoryArgs, WithTypename<PlatbyCategory> | string>,
    platbyItem?: GraphCacheResolver<WithTypename<Query>, QueryPlatbyItemArgs, WithTypename<PlatbyItem> | string>,
    platbyItems?: GraphCacheResolver<WithTypename<Query>, QueryPlatbyItemsArgs, WithTypename<PlatbyItemsConnection> | string>,
    query?: GraphCacheResolver<WithTypename<Query>, Record<string, never>, WithTypename<Query> | string>,
    room?: GraphCacheResolver<WithTypename<Query>, QueryRoomArgs, WithTypename<Room> | string>,
    roomAttachment?: GraphCacheResolver<WithTypename<Query>, QueryRoomAttachmentArgs, WithTypename<RoomAttachment> | string>,
    roomAttachments?: GraphCacheResolver<WithTypename<Query>, QueryRoomAttachmentsArgs, WithTypename<RoomAttachmentsConnection> | string>,
    rooms?: GraphCacheResolver<WithTypename<Query>, QueryRoomsArgs, WithTypename<RoomsConnection> | string>,
    skupinies?: GraphCacheResolver<WithTypename<Query>, QuerySkupiniesArgs, WithTypename<SkupiniesConnection> | string>,
    skupiny?: GraphCacheResolver<WithTypename<Query>, QuerySkupinyArgs, WithTypename<Skupiny> | string>,
    stickyAnnouncements?: GraphCacheResolver<WithTypename<Query>, QueryStickyAnnouncementsArgs, WithTypename<UpozornenisConnection> | string>,
    tenant?: GraphCacheResolver<WithTypename<Query>, QueryTenantArgs, WithTypename<Tenant> | string>,
    tenantAdministrator?: GraphCacheResolver<WithTypename<Query>, QueryTenantAdministratorArgs, WithTypename<TenantAdministrator> | string>,
    tenantAdministratorsList?: GraphCacheResolver<WithTypename<Query>, QueryTenantAdministratorsListArgs, Array<WithTypename<TenantAdministrator> | string>>,
    tenantAttachment?: GraphCacheResolver<WithTypename<Query>, QueryTenantAttachmentArgs, WithTypename<TenantAttachment> | string>,
    tenantAttachments?: GraphCacheResolver<WithTypename<Query>, QueryTenantAttachmentsArgs, WithTypename<TenantAttachmentsConnection> | string>,
    tenantLocation?: GraphCacheResolver<WithTypename<Query>, QueryTenantLocationArgs, WithTypename<TenantLocation> | string>,
    tenantLocationsList?: GraphCacheResolver<WithTypename<Query>, QueryTenantLocationsListArgs, Array<WithTypename<TenantLocation> | string>>,
    tenantMembership?: GraphCacheResolver<WithTypename<Query>, QueryTenantMembershipArgs, WithTypename<TenantMembership> | string>,
    tenantMembershipsList?: GraphCacheResolver<WithTypename<Query>, QueryTenantMembershipsListArgs, Array<WithTypename<TenantMembership> | string>>,
    tenantTrainer?: GraphCacheResolver<WithTypename<Query>, QueryTenantTrainerArgs, WithTypename<TenantTrainer> | string>,
    tenantTrainersList?: GraphCacheResolver<WithTypename<Query>, QueryTenantTrainersListArgs, Array<WithTypename<TenantTrainer> | string>>,
    tenantsList?: GraphCacheResolver<WithTypename<Query>, QueryTenantsListArgs, Array<WithTypename<Tenant> | string>>,
    upozorneni?: GraphCacheResolver<WithTypename<Query>, QueryUpozorneniArgs, WithTypename<Upozorneni> | string>,
    upozorneniSkupinies?: GraphCacheResolver<WithTypename<Query>, QueryUpozorneniSkupiniesArgs, WithTypename<UpozorneniSkupiniesConnection> | string>,
    upozorneniSkupiny?: GraphCacheResolver<WithTypename<Query>, QueryUpozorneniSkupinyArgs, WithTypename<UpozorneniSkupiny> | string>,
    upozornenis?: GraphCacheResolver<WithTypename<Query>, QueryUpozornenisArgs, WithTypename<UpozornenisConnection> | string>,
    user?: GraphCacheResolver<WithTypename<Query>, QueryUserArgs, WithTypename<User> | string>,
    userProxiesList?: GraphCacheResolver<WithTypename<Query>, QueryUserProxiesListArgs, Array<WithTypename<UserProxy> | string>>,
    userProxy?: GraphCacheResolver<WithTypename<Query>, QueryUserProxyArgs, WithTypename<UserProxy> | string>,
    users?: GraphCacheResolver<WithTypename<Query>, QueryUsersArgs, WithTypename<UsersConnection> | string>
  },
  Address?: {
    city?: GraphCacheResolver<WithTypename<Address>, Record<string, never>, Scalars['String'] | string>,
    conscriptionNumber?: GraphCacheResolver<WithTypename<Address>, Record<string, never>, Scalars['String'] | string>,
    createdAt?: GraphCacheResolver<WithTypename<Address>, Record<string, never>, Scalars['Datetime'] | string>,
    district?: GraphCacheResolver<WithTypename<Address>, Record<string, never>, Scalars['String'] | string>,
    id?: GraphCacheResolver<WithTypename<Address>, Record<string, never>, Scalars['BigInt'] | string>,
    orientationNumber?: GraphCacheResolver<WithTypename<Address>, Record<string, never>, Scalars['String'] | string>,
    postalCode?: GraphCacheResolver<WithTypename<Address>, Record<string, never>, Scalars['String'] | string>,
    street?: GraphCacheResolver<WithTypename<Address>, Record<string, never>, Scalars['String'] | string>,
    updatedAt?: GraphCacheResolver<WithTypename<Address>, Record<string, never>, Scalars['Datetime'] | string>
  },
  AddressDomain?: {
    city?: GraphCacheResolver<WithTypename<AddressDomain>, Record<string, never>, Scalars['String'] | string>,
    conscriptionNumber?: GraphCacheResolver<WithTypename<AddressDomain>, Record<string, never>, Scalars['String'] | string>,
    district?: GraphCacheResolver<WithTypename<AddressDomain>, Record<string, never>, Scalars['String'] | string>,
    orientationNumber?: GraphCacheResolver<WithTypename<AddressDomain>, Record<string, never>, Scalars['String'] | string>,
    postalCode?: GraphCacheResolver<WithTypename<AddressDomain>, Record<string, never>, Scalars['String'] | string>,
    region?: GraphCacheResolver<WithTypename<AddressDomain>, Record<string, never>, Scalars['String'] | string>,
    street?: GraphCacheResolver<WithTypename<AddressDomain>, Record<string, never>, Scalars['String'] | string>
  },
  AktualitiesConnection?: {
    edges?: GraphCacheResolver<WithTypename<AktualitiesConnection>, Record<string, never>, Array<WithTypename<AktualitiesEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<AktualitiesConnection>, Record<string, never>, Array<WithTypename<Aktuality> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<AktualitiesConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<AktualitiesConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  AktualitiesEdge?: {
    cursor?: GraphCacheResolver<WithTypename<AktualitiesEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<AktualitiesEdge>, Record<string, never>, WithTypename<Aktuality> | string>
  },
  Aktuality?: {
    atFoto?: GraphCacheResolver<WithTypename<Aktuality>, Record<string, never>, Scalars['BigInt'] | string>,
    atFotoMain?: GraphCacheResolver<WithTypename<Aktuality>, Record<string, never>, Scalars['BigInt'] | string>,
    atId?: GraphCacheResolver<WithTypename<Aktuality>, Record<string, never>, Scalars['BigInt'] | string>,
    atJmeno?: GraphCacheResolver<WithTypename<Aktuality>, Record<string, never>, Scalars['String'] | string>,
    atKat?: GraphCacheResolver<WithTypename<Aktuality>, Record<string, never>, Scalars['String'] | string>,
    atKdo?: GraphCacheResolver<WithTypename<Aktuality>, Record<string, never>, Scalars['BigInt'] | string>,
    atPreview?: GraphCacheResolver<WithTypename<Aktuality>, Record<string, never>, Scalars['String'] | string>,
    atText?: GraphCacheResolver<WithTypename<Aktuality>, Record<string, never>, Scalars['String'] | string>,
    atTimestamp?: GraphCacheResolver<WithTypename<Aktuality>, Record<string, never>, Scalars['Datetime'] | string>,
    atTimestampAdd?: GraphCacheResolver<WithTypename<Aktuality>, Record<string, never>, Scalars['Datetime'] | string>,
    galerieFotoByAtFotoMain?: GraphCacheResolver<WithTypename<Aktuality>, Record<string, never>, WithTypename<GalerieFoto> | string>,
    id?: GraphCacheResolver<WithTypename<Aktuality>, Record<string, never>, Scalars['BigInt'] | string>,
    tenantId?: GraphCacheResolver<WithTypename<Aktuality>, Record<string, never>, Scalars['BigInt'] | string>,
    userByAtKdo?: GraphCacheResolver<WithTypename<Aktuality>, Record<string, never>, WithTypename<User> | string>
  },
  Attachment?: {
    directory?: GraphCacheResolver<WithTypename<Attachment>, Record<string, never>, Scalars['String'] | string>,
    downloadUrl?: GraphCacheResolver<WithTypename<Attachment>, Record<string, never>, Scalars['String'] | string>,
    height?: GraphCacheResolver<WithTypename<Attachment>, Record<string, never>, Scalars['Int'] | string>,
    locationAttachmentsByObjectName?: GraphCacheResolver<WithTypename<Attachment>, AttachmentLocationAttachmentsByObjectNameArgs, WithTypename<LocationAttachmentsConnection> | string>,
    objectName?: GraphCacheResolver<WithTypename<Attachment>, Record<string, never>, Scalars['String'] | string>,
    previewObjectName?: GraphCacheResolver<WithTypename<Attachment>, Record<string, never>, Scalars['String'] | string>,
    publicUrl?: GraphCacheResolver<WithTypename<Attachment>, Record<string, never>, Scalars['String'] | string>,
    roomAttachmentsByObjectName?: GraphCacheResolver<WithTypename<Attachment>, AttachmentRoomAttachmentsByObjectNameArgs, WithTypename<RoomAttachmentsConnection> | string>,
    tenantAttachmentsByObjectName?: GraphCacheResolver<WithTypename<Attachment>, AttachmentTenantAttachmentsByObjectNameArgs, WithTypename<TenantAttachmentsConnection> | string>,
    thumbhash?: GraphCacheResolver<WithTypename<Attachment>, Record<string, never>, Scalars['String'] | string>,
    uploadUrl?: GraphCacheResolver<WithTypename<Attachment>, Record<string, never>, Scalars['String'] | string>,
    uploadedAt?: GraphCacheResolver<WithTypename<Attachment>, Record<string, never>, Scalars['Datetime'] | string>,
    uploadedBy?: GraphCacheResolver<WithTypename<Attachment>, Record<string, never>, Scalars['BigInt'] | string>,
    userByUploadedBy?: GraphCacheResolver<WithTypename<Attachment>, Record<string, never>, WithTypename<User> | string>,
    width?: GraphCacheResolver<WithTypename<Attachment>, Record<string, never>, Scalars['Int'] | string>
  },
  AttachmentDirectoriesConnection?: {
    edges?: GraphCacheResolver<WithTypename<AttachmentDirectoriesConnection>, Record<string, never>, Array<WithTypename<AttachmentDirectoryEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<AttachmentDirectoriesConnection>, Record<string, never>, Array<Scalars['String'] | string>>,
    totalCount?: GraphCacheResolver<WithTypename<AttachmentDirectoriesConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  AttachmentDirectoryEdge?: {
    cursor?: GraphCacheResolver<WithTypename<AttachmentDirectoryEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<AttachmentDirectoryEdge>, Record<string, never>, Scalars['String'] | string>
  },
  AttachmentsConnection?: {
    edges?: GraphCacheResolver<WithTypename<AttachmentsConnection>, Record<string, never>, Array<WithTypename<AttachmentsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<AttachmentsConnection>, Record<string, never>, Array<WithTypename<Attachment> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<AttachmentsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<AttachmentsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  AttachmentsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<AttachmentsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<AttachmentsEdge>, Record<string, never>, WithTypename<Attachment> | string>
  },
  CancelRegistrationPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CancelRegistrationPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<CancelRegistrationPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  ChangePasswordPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<ChangePasswordPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<ChangePasswordPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  CohortGroup?: {
    description?: GraphCacheResolver<WithTypename<CohortGroup>, Record<string, never>, Scalars['String'] | string>,
    id?: GraphCacheResolver<WithTypename<CohortGroup>, Record<string, never>, Scalars['BigInt'] | string>,
    isPublic?: GraphCacheResolver<WithTypename<CohortGroup>, Record<string, never>, Scalars['Boolean'] | string>,
    name?: GraphCacheResolver<WithTypename<CohortGroup>, Record<string, never>, Scalars['String'] | string>,
    ordering?: GraphCacheResolver<WithTypename<CohortGroup>, Record<string, never>, Scalars['Int'] | string>,
    skupiniesByCohortGroup?: GraphCacheResolver<WithTypename<CohortGroup>, CohortGroupSkupiniesByCohortGroupArgs, WithTypename<SkupiniesConnection> | string>,
    tenant?: GraphCacheResolver<WithTypename<CohortGroup>, Record<string, never>, Scalars['BigInt'] | string>,
    tenantByTenant?: GraphCacheResolver<WithTypename<CohortGroup>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantId?: GraphCacheResolver<WithTypename<CohortGroup>, Record<string, never>, Scalars['BigInt'] | string>
  },
  CohortGroupsConnection?: {
    edges?: GraphCacheResolver<WithTypename<CohortGroupsConnection>, Record<string, never>, Array<WithTypename<CohortGroupsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<CohortGroupsConnection>, Record<string, never>, Array<WithTypename<CohortGroup> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<CohortGroupsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<CohortGroupsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  CohortGroupsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<CohortGroupsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<CohortGroupsEdge>, Record<string, never>, WithTypename<CohortGroup> | string>
  },
  CohortMembership?: {
    active?: GraphCacheResolver<WithTypename<CohortMembership>, Record<string, never>, Scalars['Boolean'] | string>,
    cohort?: GraphCacheResolver<WithTypename<CohortMembership>, Record<string, never>, WithTypename<Skupiny> | string>,
    cohortId?: GraphCacheResolver<WithTypename<CohortMembership>, Record<string, never>, Scalars['BigInt'] | string>,
    createdAt?: GraphCacheResolver<WithTypename<CohortMembership>, Record<string, never>, Scalars['Datetime'] | string>,
    id?: GraphCacheResolver<WithTypename<CohortMembership>, Record<string, never>, Scalars['BigInt'] | string>,
    person?: GraphCacheResolver<WithTypename<CohortMembership>, Record<string, never>, WithTypename<Person> | string>,
    personId?: GraphCacheResolver<WithTypename<CohortMembership>, Record<string, never>, Scalars['BigInt'] | string>,
    since?: GraphCacheResolver<WithTypename<CohortMembership>, Record<string, never>, Scalars['Datetime'] | string>,
    tenantId?: GraphCacheResolver<WithTypename<CohortMembership>, Record<string, never>, Scalars['BigInt'] | string>,
    until?: GraphCacheResolver<WithTypename<CohortMembership>, Record<string, never>, Scalars['Datetime'] | string>,
    updatedAt?: GraphCacheResolver<WithTypename<CohortMembership>, Record<string, never>, Scalars['Datetime'] | string>
  },
  ConfirmUserPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<ConfirmUserPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<ConfirmUserPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  Couple?: {
    active?: GraphCacheResolver<WithTypename<Couple>, Record<string, never>, Scalars['Boolean'] | string>,
    createdAt?: GraphCacheResolver<WithTypename<Couple>, Record<string, never>, Scalars['Datetime'] | string>,
    eventRegistrationsList?: GraphCacheResolver<WithTypename<Couple>, CoupleEventRegistrationsListArgs, Array<WithTypename<EventRegistration> | string>>,
    id?: GraphCacheResolver<WithTypename<Couple>, Record<string, never>, Scalars['BigInt'] | string>,
    legacyParyId?: GraphCacheResolver<WithTypename<Couple>, Record<string, never>, Scalars['BigInt'] | string>,
    man?: GraphCacheResolver<WithTypename<Couple>, Record<string, never>, WithTypename<Person> | string>,
    manId?: GraphCacheResolver<WithTypename<Couple>, Record<string, never>, Scalars['BigInt'] | string>,
    since?: GraphCacheResolver<WithTypename<Couple>, Record<string, never>, Scalars['Datetime'] | string>,
    until?: GraphCacheResolver<WithTypename<Couple>, Record<string, never>, Scalars['Datetime'] | string>,
    updatedAt?: GraphCacheResolver<WithTypename<Couple>, Record<string, never>, Scalars['Datetime'] | string>,
    woman?: GraphCacheResolver<WithTypename<Couple>, Record<string, never>, WithTypename<Person> | string>,
    womanId?: GraphCacheResolver<WithTypename<Couple>, Record<string, never>, Scalars['BigInt'] | string>
  },
  CouplesConnection?: {
    edges?: GraphCacheResolver<WithTypename<CouplesConnection>, Record<string, never>, Array<WithTypename<CouplesEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<CouplesConnection>, Record<string, never>, Array<WithTypename<Couple> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<CouplesConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<CouplesConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  CouplesEdge?: {
    cursor?: GraphCacheResolver<WithTypename<CouplesEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<CouplesEdge>, Record<string, never>, WithTypename<Couple> | string>
  },
  CreateAktualityPayload?: {
    aktuality?: GraphCacheResolver<WithTypename<CreateAktualityPayload>, Record<string, never>, WithTypename<Aktuality> | string>,
    aktualityEdge?: GraphCacheResolver<WithTypename<CreateAktualityPayload>, CreateAktualityPayloadAktualityEdgeArgs, WithTypename<AktualitiesEdge> | string>,
    clientMutationId?: GraphCacheResolver<WithTypename<CreateAktualityPayload>, Record<string, never>, Scalars['String'] | string>,
    galerieFotoByAtFotoMain?: GraphCacheResolver<WithTypename<CreateAktualityPayload>, Record<string, never>, WithTypename<GalerieFoto> | string>,
    query?: GraphCacheResolver<WithTypename<CreateAktualityPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByAtKdo?: GraphCacheResolver<WithTypename<CreateAktualityPayload>, Record<string, never>, WithTypename<User> | string>
  },
  CreateAttachmentPayload?: {
    attachment?: GraphCacheResolver<WithTypename<CreateAttachmentPayload>, Record<string, never>, WithTypename<Attachment> | string>,
    attachmentEdge?: GraphCacheResolver<WithTypename<CreateAttachmentPayload>, CreateAttachmentPayloadAttachmentEdgeArgs, WithTypename<AttachmentsEdge> | string>,
    clientMutationId?: GraphCacheResolver<WithTypename<CreateAttachmentPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<CreateAttachmentPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByUploadedBy?: GraphCacheResolver<WithTypename<CreateAttachmentPayload>, Record<string, never>, WithTypename<User> | string>
  },
  CreateCohortGroupPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateCohortGroupPayload>, Record<string, never>, Scalars['String'] | string>,
    cohortGroup?: GraphCacheResolver<WithTypename<CreateCohortGroupPayload>, Record<string, never>, WithTypename<CohortGroup> | string>,
    cohortGroupEdge?: GraphCacheResolver<WithTypename<CreateCohortGroupPayload>, CreateCohortGroupPayloadCohortGroupEdgeArgs, WithTypename<CohortGroupsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<CreateCohortGroupPayload>, Record<string, never>, WithTypename<Query> | string>,
    tenantByTenant?: GraphCacheResolver<WithTypename<CreateCohortGroupPayload>, Record<string, never>, WithTypename<Tenant> | string>
  },
  CreateCouplePayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateCouplePayload>, Record<string, never>, Scalars['String'] | string>,
    couple?: GraphCacheResolver<WithTypename<CreateCouplePayload>, Record<string, never>, WithTypename<Couple> | string>,
    coupleEdge?: GraphCacheResolver<WithTypename<CreateCouplePayload>, CreateCouplePayloadCoupleEdgeArgs, WithTypename<CouplesEdge> | string>,
    man?: GraphCacheResolver<WithTypename<CreateCouplePayload>, Record<string, never>, WithTypename<Person> | string>,
    query?: GraphCacheResolver<WithTypename<CreateCouplePayload>, Record<string, never>, WithTypename<Query> | string>,
    woman?: GraphCacheResolver<WithTypename<CreateCouplePayload>, Record<string, never>, WithTypename<Person> | string>
  },
  CreateDokumentyPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateDokumentyPayload>, Record<string, never>, Scalars['String'] | string>,
    dokumenty?: GraphCacheResolver<WithTypename<CreateDokumentyPayload>, Record<string, never>, WithTypename<Dokumenty> | string>,
    query?: GraphCacheResolver<WithTypename<CreateDokumentyPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByDKdo?: GraphCacheResolver<WithTypename<CreateDokumentyPayload>, Record<string, never>, WithTypename<User> | string>
  },
  CreateEventPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateEventPayload>, Record<string, never>, Scalars['String'] | string>,
    event?: GraphCacheResolver<WithTypename<CreateEventPayload>, Record<string, never>, WithTypename<Event> | string>,
    eventEdge?: GraphCacheResolver<WithTypename<CreateEventPayload>, CreateEventPayloadEventEdgeArgs, WithTypename<EventsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<CreateEventPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  CreateFormResponsePayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateFormResponsePayload>, Record<string, never>, Scalars['String'] | string>,
    formResponse?: GraphCacheResolver<WithTypename<CreateFormResponsePayload>, Record<string, never>, WithTypename<FormResponse> | string>,
    formResponseEdge?: GraphCacheResolver<WithTypename<CreateFormResponsePayload>, CreateFormResponsePayloadFormResponseEdgeArgs, WithTypename<FormResponsesEdge> | string>,
    query?: GraphCacheResolver<WithTypename<CreateFormResponsePayload>, Record<string, never>, WithTypename<Query> | string>
  },
  CreateLocationPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateLocationPayload>, Record<string, never>, Scalars['String'] | string>,
    location?: GraphCacheResolver<WithTypename<CreateLocationPayload>, Record<string, never>, WithTypename<Location> | string>,
    locationEdge?: GraphCacheResolver<WithTypename<CreateLocationPayload>, CreateLocationPayloadLocationEdgeArgs, WithTypename<LocationsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<CreateLocationPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  CreatePermissionPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreatePermissionPayload>, Record<string, never>, Scalars['String'] | string>,
    permission?: GraphCacheResolver<WithTypename<CreatePermissionPayload>, Record<string, never>, WithTypename<Permission> | string>,
    query?: GraphCacheResolver<WithTypename<CreatePermissionPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  CreateRoomPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateRoomPayload>, Record<string, never>, Scalars['String'] | string>,
    locationByLocation?: GraphCacheResolver<WithTypename<CreateRoomPayload>, Record<string, never>, WithTypename<Location> | string>,
    query?: GraphCacheResolver<WithTypename<CreateRoomPayload>, Record<string, never>, WithTypename<Query> | string>,
    room?: GraphCacheResolver<WithTypename<CreateRoomPayload>, Record<string, never>, WithTypename<Room> | string>,
    roomEdge?: GraphCacheResolver<WithTypename<CreateRoomPayload>, CreateRoomPayloadRoomEdgeArgs, WithTypename<RoomsEdge> | string>
  },
  CreateSkupinyPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateSkupinyPayload>, Record<string, never>, Scalars['String'] | string>,
    cohortGroupByCohortGroup?: GraphCacheResolver<WithTypename<CreateSkupinyPayload>, Record<string, never>, WithTypename<CohortGroup> | string>,
    query?: GraphCacheResolver<WithTypename<CreateSkupinyPayload>, Record<string, never>, WithTypename<Query> | string>,
    skupiny?: GraphCacheResolver<WithTypename<CreateSkupinyPayload>, Record<string, never>, WithTypename<Skupiny> | string>,
    skupinyEdge?: GraphCacheResolver<WithTypename<CreateSkupinyPayload>, CreateSkupinyPayloadSkupinyEdgeArgs, WithTypename<SkupiniesEdge> | string>
  },
  CreateUpozorneniPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<CreateUpozorneniPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<CreateUpozorneniPayload>, Record<string, never>, WithTypename<Query> | string>,
    upozorneni?: GraphCacheResolver<WithTypename<CreateUpozorneniPayload>, Record<string, never>, WithTypename<Upozorneni> | string>,
    upozorneniEdge?: GraphCacheResolver<WithTypename<CreateUpozorneniPayload>, CreateUpozorneniPayloadUpozorneniEdgeArgs, WithTypename<UpozornenisEdge> | string>,
    userByUpKdo?: GraphCacheResolver<WithTypename<CreateUpozorneniPayload>, Record<string, never>, WithTypename<User> | string>
  },
  CurrentCoupleIdEdge?: {
    cursor?: GraphCacheResolver<WithTypename<CurrentCoupleIdEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<CurrentCoupleIdEdge>, Record<string, never>, Scalars['BigInt'] | string>
  },
  CurrentCoupleIdsConnection?: {
    edges?: GraphCacheResolver<WithTypename<CurrentCoupleIdsConnection>, Record<string, never>, Array<WithTypename<CurrentCoupleIdEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<CurrentCoupleIdsConnection>, Record<string, never>, Array<Scalars['BigInt'] | string>>,
    totalCount?: GraphCacheResolver<WithTypename<CurrentCoupleIdsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  CurrentPersonIdsPayload?: {
    bigInts?: GraphCacheResolver<WithTypename<CurrentPersonIdsPayload>, Record<string, never>, Array<Scalars['BigInt'] | string>>,
    clientMutationId?: GraphCacheResolver<WithTypename<CurrentPersonIdsPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<CurrentPersonIdsPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  DatetimeRange?: {
    end?: GraphCacheResolver<WithTypename<DatetimeRange>, Record<string, never>, WithTypename<DatetimeRangeBound> | string>,
    start?: GraphCacheResolver<WithTypename<DatetimeRange>, Record<string, never>, WithTypename<DatetimeRangeBound> | string>
  },
  DatetimeRangeBound?: {
    inclusive?: GraphCacheResolver<WithTypename<DatetimeRangeBound>, Record<string, never>, Scalars['Boolean'] | string>,
    value?: GraphCacheResolver<WithTypename<DatetimeRangeBound>, Record<string, never>, Scalars['Datetime'] | string>
  },
  DeleteAktualityPayload?: {
    aktuality?: GraphCacheResolver<WithTypename<DeleteAktualityPayload>, Record<string, never>, WithTypename<Aktuality> | string>,
    aktualityEdge?: GraphCacheResolver<WithTypename<DeleteAktualityPayload>, DeleteAktualityPayloadAktualityEdgeArgs, WithTypename<AktualitiesEdge> | string>,
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteAktualityPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedAktualityNodeId?: GraphCacheResolver<WithTypename<DeleteAktualityPayload>, Record<string, never>, Scalars['ID'] | string>,
    galerieFotoByAtFotoMain?: GraphCacheResolver<WithTypename<DeleteAktualityPayload>, Record<string, never>, WithTypename<GalerieFoto> | string>,
    query?: GraphCacheResolver<WithTypename<DeleteAktualityPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByAtKdo?: GraphCacheResolver<WithTypename<DeleteAktualityPayload>, Record<string, never>, WithTypename<User> | string>
  },
  DeleteAttachmentPayload?: {
    attachment?: GraphCacheResolver<WithTypename<DeleteAttachmentPayload>, Record<string, never>, WithTypename<Attachment> | string>,
    attachmentEdge?: GraphCacheResolver<WithTypename<DeleteAttachmentPayload>, DeleteAttachmentPayloadAttachmentEdgeArgs, WithTypename<AttachmentsEdge> | string>,
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteAttachmentPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedAttachmentNodeId?: GraphCacheResolver<WithTypename<DeleteAttachmentPayload>, Record<string, never>, Scalars['ID'] | string>,
    query?: GraphCacheResolver<WithTypename<DeleteAttachmentPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByUploadedBy?: GraphCacheResolver<WithTypename<DeleteAttachmentPayload>, Record<string, never>, WithTypename<User> | string>
  },
  DeleteCohortGroupPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteCohortGroupPayload>, Record<string, never>, Scalars['String'] | string>,
    cohortGroup?: GraphCacheResolver<WithTypename<DeleteCohortGroupPayload>, Record<string, never>, WithTypename<CohortGroup> | string>,
    cohortGroupEdge?: GraphCacheResolver<WithTypename<DeleteCohortGroupPayload>, DeleteCohortGroupPayloadCohortGroupEdgeArgs, WithTypename<CohortGroupsEdge> | string>,
    deletedCohortGroupNodeId?: GraphCacheResolver<WithTypename<DeleteCohortGroupPayload>, Record<string, never>, Scalars['ID'] | string>,
    query?: GraphCacheResolver<WithTypename<DeleteCohortGroupPayload>, Record<string, never>, WithTypename<Query> | string>,
    tenantByTenant?: GraphCacheResolver<WithTypename<DeleteCohortGroupPayload>, Record<string, never>, WithTypename<Tenant> | string>
  },
  DeleteCouplePayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteCouplePayload>, Record<string, never>, Scalars['String'] | string>,
    paries?: GraphCacheResolver<WithTypename<DeleteCouplePayload>, Record<string, never>, Array<WithTypename<Pary> | string>>,
    query?: GraphCacheResolver<WithTypename<DeleteCouplePayload>, Record<string, never>, WithTypename<Query> | string>
  },
  DeleteDokumentyPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteDokumentyPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedDokumentyNodeId?: GraphCacheResolver<WithTypename<DeleteDokumentyPayload>, Record<string, never>, Scalars['ID'] | string>,
    dokumenty?: GraphCacheResolver<WithTypename<DeleteDokumentyPayload>, Record<string, never>, WithTypename<Dokumenty> | string>,
    query?: GraphCacheResolver<WithTypename<DeleteDokumentyPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByDKdo?: GraphCacheResolver<WithTypename<DeleteDokumentyPayload>, Record<string, never>, WithTypename<User> | string>
  },
  DeleteEventPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteEventPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedEventNodeId?: GraphCacheResolver<WithTypename<DeleteEventPayload>, Record<string, never>, Scalars['ID'] | string>,
    event?: GraphCacheResolver<WithTypename<DeleteEventPayload>, Record<string, never>, WithTypename<Event> | string>,
    eventEdge?: GraphCacheResolver<WithTypename<DeleteEventPayload>, DeleteEventPayloadEventEdgeArgs, WithTypename<EventsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<DeleteEventPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  DeleteLocationPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteLocationPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedLocationNodeId?: GraphCacheResolver<WithTypename<DeleteLocationPayload>, Record<string, never>, Scalars['ID'] | string>,
    location?: GraphCacheResolver<WithTypename<DeleteLocationPayload>, Record<string, never>, WithTypename<Location> | string>,
    locationEdge?: GraphCacheResolver<WithTypename<DeleteLocationPayload>, DeleteLocationPayloadLocationEdgeArgs, WithTypename<LocationsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<DeleteLocationPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  DeleteRoomPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteRoomPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedRoomNodeId?: GraphCacheResolver<WithTypename<DeleteRoomPayload>, Record<string, never>, Scalars['ID'] | string>,
    locationByLocation?: GraphCacheResolver<WithTypename<DeleteRoomPayload>, Record<string, never>, WithTypename<Location> | string>,
    query?: GraphCacheResolver<WithTypename<DeleteRoomPayload>, Record<string, never>, WithTypename<Query> | string>,
    room?: GraphCacheResolver<WithTypename<DeleteRoomPayload>, Record<string, never>, WithTypename<Room> | string>,
    roomEdge?: GraphCacheResolver<WithTypename<DeleteRoomPayload>, DeleteRoomPayloadRoomEdgeArgs, WithTypename<RoomsEdge> | string>
  },
  DeleteSkupinyPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteSkupinyPayload>, Record<string, never>, Scalars['String'] | string>,
    cohortGroupByCohortGroup?: GraphCacheResolver<WithTypename<DeleteSkupinyPayload>, Record<string, never>, WithTypename<CohortGroup> | string>,
    deletedSkupinyNodeId?: GraphCacheResolver<WithTypename<DeleteSkupinyPayload>, Record<string, never>, Scalars['ID'] | string>,
    query?: GraphCacheResolver<WithTypename<DeleteSkupinyPayload>, Record<string, never>, WithTypename<Query> | string>,
    skupiny?: GraphCacheResolver<WithTypename<DeleteSkupinyPayload>, Record<string, never>, WithTypename<Skupiny> | string>,
    skupinyEdge?: GraphCacheResolver<WithTypename<DeleteSkupinyPayload>, DeleteSkupinyPayloadSkupinyEdgeArgs, WithTypename<SkupiniesEdge> | string>
  },
  DeleteUpozorneniPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<DeleteUpozorneniPayload>, Record<string, never>, Scalars['String'] | string>,
    deletedUpozorneniNodeId?: GraphCacheResolver<WithTypename<DeleteUpozorneniPayload>, Record<string, never>, Scalars['ID'] | string>,
    query?: GraphCacheResolver<WithTypename<DeleteUpozorneniPayload>, Record<string, never>, WithTypename<Query> | string>,
    upozorneni?: GraphCacheResolver<WithTypename<DeleteUpozorneniPayload>, Record<string, never>, WithTypename<Upozorneni> | string>,
    upozorneniEdge?: GraphCacheResolver<WithTypename<DeleteUpozorneniPayload>, DeleteUpozorneniPayloadUpozorneniEdgeArgs, WithTypename<UpozornenisEdge> | string>,
    userByUpKdo?: GraphCacheResolver<WithTypename<DeleteUpozorneniPayload>, Record<string, never>, WithTypename<User> | string>
  },
  Dokumenty?: {
    dFilename?: GraphCacheResolver<WithTypename<Dokumenty>, Record<string, never>, Scalars['String'] | string>,
    dId?: GraphCacheResolver<WithTypename<Dokumenty>, Record<string, never>, Scalars['BigInt'] | string>,
    dKategorie?: GraphCacheResolver<WithTypename<Dokumenty>, Record<string, never>, Scalars['Int'] | string>,
    dKdo?: GraphCacheResolver<WithTypename<Dokumenty>, Record<string, never>, Scalars['BigInt'] | string>,
    dName?: GraphCacheResolver<WithTypename<Dokumenty>, Record<string, never>, Scalars['String'] | string>,
    dPath?: GraphCacheResolver<WithTypename<Dokumenty>, Record<string, never>, Scalars['String'] | string>,
    dTimestamp?: GraphCacheResolver<WithTypename<Dokumenty>, Record<string, never>, Scalars['Datetime'] | string>,
    id?: GraphCacheResolver<WithTypename<Dokumenty>, Record<string, never>, Scalars['BigInt'] | string>,
    tenantId?: GraphCacheResolver<WithTypename<Dokumenty>, Record<string, never>, Scalars['BigInt'] | string>,
    userByDKdo?: GraphCacheResolver<WithTypename<Dokumenty>, Record<string, never>, WithTypename<User> | string>
  },
  EditRegistrationPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<EditRegistrationPayload>, Record<string, never>, Scalars['String'] | string>,
    couple?: GraphCacheResolver<WithTypename<EditRegistrationPayload>, Record<string, never>, WithTypename<Couple> | string>,
    event?: GraphCacheResolver<WithTypename<EditRegistrationPayload>, Record<string, never>, WithTypename<Event> | string>,
    eventRegistration?: GraphCacheResolver<WithTypename<EditRegistrationPayload>, Record<string, never>, WithTypename<EventRegistration> | string>,
    payment?: GraphCacheResolver<WithTypename<EditRegistrationPayload>, Record<string, never>, WithTypename<PlatbyItem> | string>,
    person?: GraphCacheResolver<WithTypename<EditRegistrationPayload>, Record<string, never>, WithTypename<Person> | string>,
    query?: GraphCacheResolver<WithTypename<EditRegistrationPayload>, Record<string, never>, WithTypename<Query> | string>,
    targetCohort?: GraphCacheResolver<WithTypename<EditRegistrationPayload>, Record<string, never>, WithTypename<EventTargetCohort> | string>,
    tenant?: GraphCacheResolver<WithTypename<EditRegistrationPayload>, Record<string, never>, WithTypename<Tenant> | string>
  },
  Event?: {
    capacity?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['BigInt'] | string>,
    description?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['String'] | string>,
    descriptionMember?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['String'] | string>,
    enableNotes?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['Boolean'] | string>,
    eventInstances?: GraphCacheResolver<WithTypename<Event>, EventEventInstancesArgs, WithTypename<EventInstancesConnection> | string>,
    eventInstancesList?: GraphCacheResolver<WithTypename<Event>, EventEventInstancesListArgs, Array<WithTypename<EventInstance> | string>>,
    eventRegistrationsList?: GraphCacheResolver<WithTypename<Event>, EventEventRegistrationsListArgs, Array<WithTypename<EventRegistration> | string>>,
    eventTargetCohortsList?: GraphCacheResolver<WithTypename<Event>, EventEventTargetCohortsListArgs, Array<WithTypename<EventTargetCohort> | string>>,
    eventTrainersList?: GraphCacheResolver<WithTypename<Event>, EventEventTrainersListArgs, Array<WithTypename<EventTrainer> | string>>,
    filesLegacy?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['String'] | string>,
    id?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['BigInt'] | string>,
    isLocked?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['Boolean'] | string>,
    isPublic?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['Boolean'] | string>,
    isVisible?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['Boolean'] | string>,
    locationText?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['String'] | string>,
    name?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['String'] | string>,
    registrationPrice?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, WithTypename<Price> | string>,
    remainingLessons?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['Int'] | string>,
    remainingPersonSpots?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['Int'] | string>,
    since?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['Date'] | string>,
    summary?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['String'] | string>,
    tenantId?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['BigInt'] | string>,
    titleImageLegacy?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['String'] | string>,
    type?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, EventType | string>,
    until?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['Date'] | string>,
    updatedAt?: GraphCacheResolver<WithTypename<Event>, Record<string, never>, Scalars['Datetime'] | string>
  },
  EventAttendance?: {
    createdAt?: GraphCacheResolver<WithTypename<EventAttendance>, Record<string, never>, Scalars['Datetime'] | string>,
    id?: GraphCacheResolver<WithTypename<EventAttendance>, Record<string, never>, Scalars['BigInt'] | string>,
    instance?: GraphCacheResolver<WithTypename<EventAttendance>, Record<string, never>, WithTypename<EventInstance> | string>,
    instanceId?: GraphCacheResolver<WithTypename<EventAttendance>, Record<string, never>, Scalars['BigInt'] | string>,
    note?: GraphCacheResolver<WithTypename<EventAttendance>, Record<string, never>, Scalars['String'] | string>,
    person?: GraphCacheResolver<WithTypename<EventAttendance>, Record<string, never>, WithTypename<Person> | string>,
    personId?: GraphCacheResolver<WithTypename<EventAttendance>, Record<string, never>, Scalars['BigInt'] | string>,
    status?: GraphCacheResolver<WithTypename<EventAttendance>, Record<string, never>, AttendanceType | string>,
    tenant?: GraphCacheResolver<WithTypename<EventAttendance>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantId?: GraphCacheResolver<WithTypename<EventAttendance>, Record<string, never>, Scalars['BigInt'] | string>,
    updatedAt?: GraphCacheResolver<WithTypename<EventAttendance>, Record<string, never>, Scalars['Datetime'] | string>
  },
  EventInstance?: {
    createdAt?: GraphCacheResolver<WithTypename<EventInstance>, Record<string, never>, Scalars['Datetime'] | string>,
    event?: GraphCacheResolver<WithTypename<EventInstance>, Record<string, never>, WithTypename<Event> | string>,
    eventAttendancesByInstanceIdList?: GraphCacheResolver<WithTypename<EventInstance>, EventInstanceEventAttendancesByInstanceIdListArgs, Array<WithTypename<EventAttendance> | string>>,
    eventId?: GraphCacheResolver<WithTypename<EventInstance>, Record<string, never>, Scalars['BigInt'] | string>,
    eventInstanceTrainersByInstanceIdList?: GraphCacheResolver<WithTypename<EventInstance>, EventInstanceEventInstanceTrainersByInstanceIdListArgs, Array<WithTypename<EventInstanceTrainer> | string>>,
    id?: GraphCacheResolver<WithTypename<EventInstance>, Record<string, never>, Scalars['BigInt'] | string>,
    location?: GraphCacheResolver<WithTypename<EventInstance>, Record<string, never>, WithTypename<Location> | string>,
    locationId?: GraphCacheResolver<WithTypename<EventInstance>, Record<string, never>, Scalars['BigInt'] | string>,
    range?: GraphCacheResolver<WithTypename<EventInstance>, Record<string, never>, WithTypename<DatetimeRange> | string>,
    since?: GraphCacheResolver<WithTypename<EventInstance>, Record<string, never>, Scalars['Datetime'] | string>,
    tenant?: GraphCacheResolver<WithTypename<EventInstance>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantId?: GraphCacheResolver<WithTypename<EventInstance>, Record<string, never>, Scalars['BigInt'] | string>,
    until?: GraphCacheResolver<WithTypename<EventInstance>, Record<string, never>, Scalars['Datetime'] | string>,
    updatedAt?: GraphCacheResolver<WithTypename<EventInstance>, Record<string, never>, Scalars['Datetime'] | string>
  },
  EventInstanceTrainer?: {
    createdAt?: GraphCacheResolver<WithTypename<EventInstanceTrainer>, Record<string, never>, Scalars['Datetime'] | string>,
    id?: GraphCacheResolver<WithTypename<EventInstanceTrainer>, Record<string, never>, Scalars['BigInt'] | string>,
    instance?: GraphCacheResolver<WithTypename<EventInstanceTrainer>, Record<string, never>, WithTypename<EventInstance> | string>,
    instanceId?: GraphCacheResolver<WithTypename<EventInstanceTrainer>, Record<string, never>, Scalars['BigInt'] | string>,
    person?: GraphCacheResolver<WithTypename<EventInstanceTrainer>, Record<string, never>, WithTypename<Person> | string>,
    personId?: GraphCacheResolver<WithTypename<EventInstanceTrainer>, Record<string, never>, Scalars['BigInt'] | string>,
    tenant?: GraphCacheResolver<WithTypename<EventInstanceTrainer>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantId?: GraphCacheResolver<WithTypename<EventInstanceTrainer>, Record<string, never>, Scalars['BigInt'] | string>,
    updatedAt?: GraphCacheResolver<WithTypename<EventInstanceTrainer>, Record<string, never>, Scalars['Datetime'] | string>
  },
  EventInstancesConnection?: {
    edges?: GraphCacheResolver<WithTypename<EventInstancesConnection>, Record<string, never>, Array<WithTypename<EventInstancesEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<EventInstancesConnection>, Record<string, never>, Array<WithTypename<EventInstance> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<EventInstancesConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<EventInstancesConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  EventInstancesEdge?: {
    cursor?: GraphCacheResolver<WithTypename<EventInstancesEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<EventInstancesEdge>, Record<string, never>, WithTypename<EventInstance> | string>
  },
  EventLessonDemand?: {
    createdAt?: GraphCacheResolver<WithTypename<EventLessonDemand>, Record<string, never>, Scalars['Datetime'] | string>,
    id?: GraphCacheResolver<WithTypename<EventLessonDemand>, Record<string, never>, Scalars['BigInt'] | string>,
    lessonCount?: GraphCacheResolver<WithTypename<EventLessonDemand>, Record<string, never>, Scalars['Int'] | string>,
    registration?: GraphCacheResolver<WithTypename<EventLessonDemand>, Record<string, never>, WithTypename<EventRegistration> | string>,
    registrationId?: GraphCacheResolver<WithTypename<EventLessonDemand>, Record<string, never>, Scalars['BigInt'] | string>,
    tenant?: GraphCacheResolver<WithTypename<EventLessonDemand>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantId?: GraphCacheResolver<WithTypename<EventLessonDemand>, Record<string, never>, Scalars['BigInt'] | string>,
    trainer?: GraphCacheResolver<WithTypename<EventLessonDemand>, Record<string, never>, WithTypename<EventTrainer> | string>,
    trainerId?: GraphCacheResolver<WithTypename<EventLessonDemand>, Record<string, never>, Scalars['BigInt'] | string>,
    updatedAt?: GraphCacheResolver<WithTypename<EventLessonDemand>, Record<string, never>, Scalars['Datetime'] | string>
  },
  EventRegistration?: {
    confirmedAt?: GraphCacheResolver<WithTypename<EventRegistration>, Record<string, never>, Scalars['Datetime'] | string>,
    couple?: GraphCacheResolver<WithTypename<EventRegistration>, Record<string, never>, WithTypename<Couple> | string>,
    coupleId?: GraphCacheResolver<WithTypename<EventRegistration>, Record<string, never>, Scalars['BigInt'] | string>,
    createdAt?: GraphCacheResolver<WithTypename<EventRegistration>, Record<string, never>, Scalars['Datetime'] | string>,
    event?: GraphCacheResolver<WithTypename<EventRegistration>, Record<string, never>, WithTypename<Event> | string>,
    eventId?: GraphCacheResolver<WithTypename<EventRegistration>, Record<string, never>, Scalars['BigInt'] | string>,
    eventLessonDemandsByRegistrationIdList?: GraphCacheResolver<WithTypename<EventRegistration>, EventRegistrationEventLessonDemandsByRegistrationIdListArgs, Array<WithTypename<EventLessonDemand> | string>>,
    id?: GraphCacheResolver<WithTypename<EventRegistration>, Record<string, never>, Scalars['BigInt'] | string>,
    isConfirmed?: GraphCacheResolver<WithTypename<EventRegistration>, Record<string, never>, Scalars['Boolean'] | string>,
    note?: GraphCacheResolver<WithTypename<EventRegistration>, Record<string, never>, Scalars['String'] | string>,
    payment?: GraphCacheResolver<WithTypename<EventRegistration>, Record<string, never>, WithTypename<PlatbyItem> | string>,
    paymentId?: GraphCacheResolver<WithTypename<EventRegistration>, Record<string, never>, Scalars['BigInt'] | string>,
    person?: GraphCacheResolver<WithTypename<EventRegistration>, Record<string, never>, WithTypename<Person> | string>,
    personId?: GraphCacheResolver<WithTypename<EventRegistration>, Record<string, never>, Scalars['BigInt'] | string>,
    statusTime?: GraphCacheResolver<WithTypename<EventRegistration>, Record<string, never>, RegistrationTime | string>,
    targetCohort?: GraphCacheResolver<WithTypename<EventRegistration>, Record<string, never>, WithTypename<EventTargetCohort> | string>,
    targetCohortId?: GraphCacheResolver<WithTypename<EventRegistration>, Record<string, never>, Scalars['BigInt'] | string>,
    tenant?: GraphCacheResolver<WithTypename<EventRegistration>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantId?: GraphCacheResolver<WithTypename<EventRegistration>, Record<string, never>, Scalars['BigInt'] | string>,
    updatedAt?: GraphCacheResolver<WithTypename<EventRegistration>, Record<string, never>, Scalars['Datetime'] | string>
  },
  EventTargetCohort?: {
    cohort?: GraphCacheResolver<WithTypename<EventTargetCohort>, Record<string, never>, WithTypename<Skupiny> | string>,
    cohortId?: GraphCacheResolver<WithTypename<EventTargetCohort>, Record<string, never>, Scalars['BigInt'] | string>,
    createdAt?: GraphCacheResolver<WithTypename<EventTargetCohort>, Record<string, never>, Scalars['Datetime'] | string>,
    event?: GraphCacheResolver<WithTypename<EventTargetCohort>, Record<string, never>, WithTypename<Event> | string>,
    eventId?: GraphCacheResolver<WithTypename<EventTargetCohort>, Record<string, never>, Scalars['BigInt'] | string>,
    eventRegistrationsByTargetCohortIdList?: GraphCacheResolver<WithTypename<EventTargetCohort>, EventTargetCohortEventRegistrationsByTargetCohortIdListArgs, Array<WithTypename<EventRegistration> | string>>,
    id?: GraphCacheResolver<WithTypename<EventTargetCohort>, Record<string, never>, Scalars['BigInt'] | string>,
    tenant?: GraphCacheResolver<WithTypename<EventTargetCohort>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantId?: GraphCacheResolver<WithTypename<EventTargetCohort>, Record<string, never>, Scalars['BigInt'] | string>,
    updatedAt?: GraphCacheResolver<WithTypename<EventTargetCohort>, Record<string, never>, Scalars['Datetime'] | string>
  },
  EventTrainer?: {
    createdAt?: GraphCacheResolver<WithTypename<EventTrainer>, Record<string, never>, Scalars['Datetime'] | string>,
    event?: GraphCacheResolver<WithTypename<EventTrainer>, Record<string, never>, WithTypename<Event> | string>,
    eventId?: GraphCacheResolver<WithTypename<EventTrainer>, Record<string, never>, Scalars['BigInt'] | string>,
    eventLessonDemandsByTrainerIdList?: GraphCacheResolver<WithTypename<EventTrainer>, EventTrainerEventLessonDemandsByTrainerIdListArgs, Array<WithTypename<EventLessonDemand> | string>>,
    id?: GraphCacheResolver<WithTypename<EventTrainer>, Record<string, never>, Scalars['BigInt'] | string>,
    lessonPrice?: GraphCacheResolver<WithTypename<EventTrainer>, Record<string, never>, WithTypename<Price> | string>,
    lessonsOffered?: GraphCacheResolver<WithTypename<EventTrainer>, Record<string, never>, Scalars['Int'] | string>,
    lessonsRemaining?: GraphCacheResolver<WithTypename<EventTrainer>, Record<string, never>, Scalars['Int'] | string>,
    person?: GraphCacheResolver<WithTypename<EventTrainer>, Record<string, never>, WithTypename<Person> | string>,
    personId?: GraphCacheResolver<WithTypename<EventTrainer>, Record<string, never>, Scalars['BigInt'] | string>,
    tenant?: GraphCacheResolver<WithTypename<EventTrainer>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantId?: GraphCacheResolver<WithTypename<EventTrainer>, Record<string, never>, Scalars['BigInt'] | string>,
    updatedAt?: GraphCacheResolver<WithTypename<EventTrainer>, Record<string, never>, Scalars['Datetime'] | string>
  },
  EventsConnection?: {
    edges?: GraphCacheResolver<WithTypename<EventsConnection>, Record<string, never>, Array<WithTypename<EventsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<EventsConnection>, Record<string, never>, Array<WithTypename<Event> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<EventsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<EventsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  EventsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<EventsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<EventsEdge>, Record<string, never>, WithTypename<Event> | string>
  },
  FormResponse?: {
    createdAt?: GraphCacheResolver<WithTypename<FormResponse>, Record<string, never>, Scalars['Datetime'] | string>,
    data?: GraphCacheResolver<WithTypename<FormResponse>, Record<string, never>, Scalars['JSON'] | string>,
    id?: GraphCacheResolver<WithTypename<FormResponse>, Record<string, never>, Scalars['BigInt'] | string>,
    tenantId?: GraphCacheResolver<WithTypename<FormResponse>, Record<string, never>, Scalars['BigInt'] | string>,
    type?: GraphCacheResolver<WithTypename<FormResponse>, Record<string, never>, Scalars['String'] | string>,
    updatedAt?: GraphCacheResolver<WithTypename<FormResponse>, Record<string, never>, Scalars['Datetime'] | string>,
    url?: GraphCacheResolver<WithTypename<FormResponse>, Record<string, never>, Scalars['String'] | string>
  },
  FormResponsesConnection?: {
    edges?: GraphCacheResolver<WithTypename<FormResponsesConnection>, Record<string, never>, Array<WithTypename<FormResponsesEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<FormResponsesConnection>, Record<string, never>, Array<WithTypename<FormResponse> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<FormResponsesConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<FormResponsesConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  FormResponsesEdge?: {
    cursor?: GraphCacheResolver<WithTypename<FormResponsesEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<FormResponsesEdge>, Record<string, never>, WithTypename<FormResponse> | string>
  },
  GalerieDir?: {
    galerieFotosByGfIdRodic?: GraphCacheResolver<WithTypename<GalerieDir>, GalerieDirGalerieFotosByGfIdRodicArgs, WithTypename<GalerieFotosConnection> | string>,
    gdHidden?: GraphCacheResolver<WithTypename<GalerieDir>, Record<string, never>, Scalars['Boolean'] | string>,
    gdId?: GraphCacheResolver<WithTypename<GalerieDir>, Record<string, never>, Scalars['BigInt'] | string>,
    gdIdRodic?: GraphCacheResolver<WithTypename<GalerieDir>, Record<string, never>, Scalars['BigInt'] | string>,
    gdLevel?: GraphCacheResolver<WithTypename<GalerieDir>, Record<string, never>, Scalars['Int'] | string>,
    gdName?: GraphCacheResolver<WithTypename<GalerieDir>, Record<string, never>, Scalars['String'] | string>,
    gdPath?: GraphCacheResolver<WithTypename<GalerieDir>, Record<string, never>, Scalars['String'] | string>,
    id?: GraphCacheResolver<WithTypename<GalerieDir>, Record<string, never>, Scalars['BigInt'] | string>,
    tenantId?: GraphCacheResolver<WithTypename<GalerieDir>, Record<string, never>, Scalars['BigInt'] | string>
  },
  GalerieDirsConnection?: {
    edges?: GraphCacheResolver<WithTypename<GalerieDirsConnection>, Record<string, never>, Array<WithTypename<GalerieDirsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<GalerieDirsConnection>, Record<string, never>, Array<WithTypename<GalerieDir> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<GalerieDirsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<GalerieDirsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  GalerieDirsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<GalerieDirsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<GalerieDirsEdge>, Record<string, never>, WithTypename<GalerieDir> | string>
  },
  GalerieFoto?: {
    aktualitiesByAtFotoMain?: GraphCacheResolver<WithTypename<GalerieFoto>, GalerieFotoAktualitiesByAtFotoMainArgs, WithTypename<AktualitiesConnection> | string>,
    galerieDirByGfIdRodic?: GraphCacheResolver<WithTypename<GalerieFoto>, Record<string, never>, WithTypename<GalerieDir> | string>,
    gfId?: GraphCacheResolver<WithTypename<GalerieFoto>, Record<string, never>, Scalars['BigInt'] | string>,
    gfIdRodic?: GraphCacheResolver<WithTypename<GalerieFoto>, Record<string, never>, Scalars['BigInt'] | string>,
    gfKdo?: GraphCacheResolver<WithTypename<GalerieFoto>, Record<string, never>, Scalars['BigInt'] | string>,
    gfName?: GraphCacheResolver<WithTypename<GalerieFoto>, Record<string, never>, Scalars['String'] | string>,
    gfPath?: GraphCacheResolver<WithTypename<GalerieFoto>, Record<string, never>, Scalars['String'] | string>,
    gfTimestamp?: GraphCacheResolver<WithTypename<GalerieFoto>, Record<string, never>, Scalars['Datetime'] | string>,
    id?: GraphCacheResolver<WithTypename<GalerieFoto>, Record<string, never>, Scalars['BigInt'] | string>,
    tenantId?: GraphCacheResolver<WithTypename<GalerieFoto>, Record<string, never>, Scalars['BigInt'] | string>,
    userByGfKdo?: GraphCacheResolver<WithTypename<GalerieFoto>, Record<string, never>, WithTypename<User> | string>
  },
  GalerieFotosConnection?: {
    edges?: GraphCacheResolver<WithTypename<GalerieFotosConnection>, Record<string, never>, Array<WithTypename<GalerieFotosEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<GalerieFotosConnection>, Record<string, never>, Array<WithTypename<GalerieFoto> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<GalerieFotosConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<GalerieFotosConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  GalerieFotosEdge?: {
    cursor?: GraphCacheResolver<WithTypename<GalerieFotosEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<GalerieFotosEdge>, Record<string, never>, WithTypename<GalerieFoto> | string>
  },
  IsCurrentTenantMemberPayload?: {
    boolean?: GraphCacheResolver<WithTypename<IsCurrentTenantMemberPayload>, Record<string, never>, Scalars['Boolean'] | string>,
    clientMutationId?: GraphCacheResolver<WithTypename<IsCurrentTenantMemberPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<IsCurrentTenantMemberPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  Location?: {
    address?: GraphCacheResolver<WithTypename<Location>, Record<string, never>, WithTypename<AddressDomain> | string>,
    description?: GraphCacheResolver<WithTypename<Location>, Record<string, never>, Scalars['JSON'] | string>,
    eventInstances?: GraphCacheResolver<WithTypename<Location>, LocationEventInstancesArgs, WithTypename<EventInstancesConnection> | string>,
    eventInstancesList?: GraphCacheResolver<WithTypename<Location>, LocationEventInstancesListArgs, Array<WithTypename<EventInstance> | string>>,
    id?: GraphCacheResolver<WithTypename<Location>, Record<string, never>, Scalars['BigInt'] | string>,
    locationAttachments?: GraphCacheResolver<WithTypename<Location>, LocationLocationAttachmentsArgs, WithTypename<LocationAttachmentsConnection> | string>,
    name?: GraphCacheResolver<WithTypename<Location>, Record<string, never>, Scalars['String'] | string>,
    roomsByLocation?: GraphCacheResolver<WithTypename<Location>, LocationRoomsByLocationArgs, WithTypename<RoomsConnection> | string>,
    tenantLocationsList?: GraphCacheResolver<WithTypename<Location>, LocationTenantLocationsListArgs, Array<WithTypename<TenantLocation> | string>>
  },
  LocationAttachment?: {
    attachmentByObjectName?: GraphCacheResolver<WithTypename<LocationAttachment>, Record<string, never>, WithTypename<Attachment> | string>,
    location?: GraphCacheResolver<WithTypename<LocationAttachment>, Record<string, never>, WithTypename<Location> | string>,
    locationId?: GraphCacheResolver<WithTypename<LocationAttachment>, Record<string, never>, Scalars['BigInt'] | string>,
    objectName?: GraphCacheResolver<WithTypename<LocationAttachment>, Record<string, never>, Scalars['String'] | string>
  },
  LocationAttachmentsConnection?: {
    edges?: GraphCacheResolver<WithTypename<LocationAttachmentsConnection>, Record<string, never>, Array<WithTypename<LocationAttachmentsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<LocationAttachmentsConnection>, Record<string, never>, Array<WithTypename<LocationAttachment> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<LocationAttachmentsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<LocationAttachmentsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  LocationAttachmentsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<LocationAttachmentsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<LocationAttachmentsEdge>, Record<string, never>, WithTypename<LocationAttachment> | string>
  },
  LocationsConnection?: {
    edges?: GraphCacheResolver<WithTypename<LocationsConnection>, Record<string, never>, Array<WithTypename<LocationsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<LocationsConnection>, Record<string, never>, Array<WithTypename<Location> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<LocationsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<LocationsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  LocationsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<LocationsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<LocationsEdge>, Record<string, never>, WithTypename<Location> | string>
  },
  LoginPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<LoginPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<LoginPayload>, Record<string, never>, WithTypename<Query> | string>,
    result?: GraphCacheResolver<WithTypename<LoginPayload>, Record<string, never>, WithTypename<LoginRecord> | string>
  },
  LoginRecord?: {
    sess?: GraphCacheResolver<WithTypename<LoginRecord>, Record<string, never>, WithTypename<Session> | string>,
    usr?: GraphCacheResolver<WithTypename<LoginRecord>, Record<string, never>, WithTypename<User> | string>
  },
  LogoutPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<LogoutPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<LogoutPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  PageInfo?: {
    endCursor?: GraphCacheResolver<WithTypename<PageInfo>, Record<string, never>, Scalars['Cursor'] | string>,
    hasNextPage?: GraphCacheResolver<WithTypename<PageInfo>, Record<string, never>, Scalars['Boolean'] | string>,
    hasPreviousPage?: GraphCacheResolver<WithTypename<PageInfo>, Record<string, never>, Scalars['Boolean'] | string>,
    startCursor?: GraphCacheResolver<WithTypename<PageInfo>, Record<string, never>, Scalars['Cursor'] | string>
  },
  Pary?: {
    id?: GraphCacheResolver<WithTypename<Pary>, Record<string, never>, Scalars['BigInt'] | string>,
    pArchiv?: GraphCacheResolver<WithTypename<Pary>, Record<string, never>, Scalars['Boolean'] | string>,
    pHodnoceni?: GraphCacheResolver<WithTypename<Pary>, Record<string, never>, Scalars['Int'] | string>,
    pId?: GraphCacheResolver<WithTypename<Pary>, Record<string, never>, Scalars['BigInt'] | string>,
    pIdPartner?: GraphCacheResolver<WithTypename<Pary>, Record<string, never>, Scalars['BigInt'] | string>,
    pIdPartnerka?: GraphCacheResolver<WithTypename<Pary>, Record<string, never>, Scalars['BigInt'] | string>,
    pLatBody?: GraphCacheResolver<WithTypename<Pary>, Record<string, never>, Scalars['Int'] | string>,
    pLatFinale?: GraphCacheResolver<WithTypename<Pary>, Record<string, never>, Scalars['Boolean'] | string>,
    pLatTrida?: GraphCacheResolver<WithTypename<Pary>, Record<string, never>, ParyPLatTrida | string>,
    pSttBody?: GraphCacheResolver<WithTypename<Pary>, Record<string, never>, Scalars['Int'] | string>,
    pSttFinale?: GraphCacheResolver<WithTypename<Pary>, Record<string, never>, Scalars['Boolean'] | string>,
    pSttTrida?: GraphCacheResolver<WithTypename<Pary>, Record<string, never>, ParyPSttTrida | string>,
    pTimestampAdd?: GraphCacheResolver<WithTypename<Pary>, Record<string, never>, Scalars['Datetime'] | string>,
    pTimestampArchive?: GraphCacheResolver<WithTypename<Pary>, Record<string, never>, Scalars['Datetime'] | string>,
    userByPIdPartner?: GraphCacheResolver<WithTypename<Pary>, Record<string, never>, WithTypename<User> | string>,
    userByPIdPartnerka?: GraphCacheResolver<WithTypename<Pary>, Record<string, never>, WithTypename<User> | string>
  },
  PeopleConnection?: {
    edges?: GraphCacheResolver<WithTypename<PeopleConnection>, Record<string, never>, Array<WithTypename<PeopleEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<PeopleConnection>, Record<string, never>, Array<WithTypename<Person> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<PeopleConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<PeopleConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  PeopleEdge?: {
    cursor?: GraphCacheResolver<WithTypename<PeopleEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<PeopleEdge>, Record<string, never>, WithTypename<Person> | string>
  },
  Permission?: {
    id?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['BigInt'] | string>,
    peAkce?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    peAktuality?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    peAnkety?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    peDescription?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['String'] | string>,
    peDokumenty?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    peGalerie?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    peId?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['BigInt'] | string>,
    peInzerce?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    peKonzole?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    peMain?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    peNabidka?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    peName?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['String'] | string>,
    peNastenka?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    peNovinky?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    pePary?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    pePermissions?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    pePlatby?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    peRozpis?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    peSkupiny?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>,
    peUsers?: GraphCacheResolver<WithTypename<Permission>, Record<string, never>, Scalars['Int'] | string>
  },
  Person?: {
    birthDate?: GraphCacheResolver<WithTypename<Person>, Record<string, never>, Scalars['Date'] | string>,
    cohortIds?: GraphCacheResolver<WithTypename<Person>, Record<string, never>, Array<Scalars['BigInt'] | string>>,
    cohortMembershipsList?: GraphCacheResolver<WithTypename<Person>, PersonCohortMembershipsListArgs, Array<WithTypename<CohortMembership> | string>>,
    coupleIds?: GraphCacheResolver<WithTypename<Person>, Record<string, never>, Array<Scalars['BigInt'] | string>>,
    couplesByManId?: GraphCacheResolver<WithTypename<Person>, PersonCouplesByManIdArgs, WithTypename<CouplesConnection> | string>,
    couplesByWomanId?: GraphCacheResolver<WithTypename<Person>, PersonCouplesByWomanIdArgs, WithTypename<CouplesConnection> | string>,
    couplesList?: GraphCacheResolver<WithTypename<Person>, PersonCouplesListArgs, Array<WithTypename<Couple> | string>>,
    createdAt?: GraphCacheResolver<WithTypename<Person>, Record<string, never>, Scalars['Datetime'] | string>,
    cstsId?: GraphCacheResolver<WithTypename<Person>, Record<string, never>, Scalars['String'] | string>,
    eventAttendancesList?: GraphCacheResolver<WithTypename<Person>, PersonEventAttendancesListArgs, Array<WithTypename<EventAttendance> | string>>,
    eventInstanceTrainersList?: GraphCacheResolver<WithTypename<Person>, PersonEventInstanceTrainersListArgs, Array<WithTypename<EventInstanceTrainer> | string>>,
    eventRegistrationsList?: GraphCacheResolver<WithTypename<Person>, PersonEventRegistrationsListArgs, Array<WithTypename<EventRegistration> | string>>,
    eventTrainersList?: GraphCacheResolver<WithTypename<Person>, PersonEventTrainersListArgs, Array<WithTypename<EventTrainer> | string>>,
    firstName?: GraphCacheResolver<WithTypename<Person>, Record<string, never>, Scalars['String'] | string>,
    gender?: GraphCacheResolver<WithTypename<Person>, Record<string, never>, GenderType | string>,
    hasUser?: GraphCacheResolver<WithTypename<Person>, Record<string, never>, Scalars['Boolean'] | string>,
    id?: GraphCacheResolver<WithTypename<Person>, Record<string, never>, Scalars['BigInt'] | string>,
    isAdmin?: GraphCacheResolver<WithTypename<Person>, Record<string, never>, Scalars['Boolean'] | string>,
    isTrainer?: GraphCacheResolver<WithTypename<Person>, Record<string, never>, Scalars['Boolean'] | string>,
    lastName?: GraphCacheResolver<WithTypename<Person>, Record<string, never>, Scalars['String'] | string>,
    legacyUserId?: GraphCacheResolver<WithTypename<Person>, Record<string, never>, Scalars['BigInt'] | string>,
    middleName?: GraphCacheResolver<WithTypename<Person>, Record<string, never>, Scalars['String'] | string>,
    nationalIdNumber?: GraphCacheResolver<WithTypename<Person>, Record<string, never>, Scalars['String'] | string>,
    nationality?: GraphCacheResolver<WithTypename<Person>, Record<string, never>, Scalars['String'] | string>,
    personAddressesList?: GraphCacheResolver<WithTypename<Person>, PersonPersonAddressesListArgs, Array<WithTypename<PersonAddress> | string>>,
    personEmailsList?: GraphCacheResolver<WithTypename<Person>, PersonPersonEmailsListArgs, Array<WithTypename<PersonEmail> | string>>,
    personPhonesList?: GraphCacheResolver<WithTypename<Person>, PersonPersonPhonesListArgs, Array<WithTypename<PersonPhone> | string>>,
    primaryAddress?: GraphCacheResolver<WithTypename<Person>, Record<string, never>, WithTypename<Address> | string>,
    primaryEmail?: GraphCacheResolver<WithTypename<Person>, Record<string, never>, Scalars['String'] | string>,
    primaryPhone?: GraphCacheResolver<WithTypename<Person>, Record<string, never>, Scalars['String'] | string>,
    taxIdentificationNumber?: GraphCacheResolver<WithTypename<Person>, Record<string, never>, Scalars['String'] | string>,
    tenantAdministratorsList?: GraphCacheResolver<WithTypename<Person>, PersonTenantAdministratorsListArgs, Array<WithTypename<TenantAdministrator> | string>>,
    tenantIds?: GraphCacheResolver<WithTypename<Person>, Record<string, never>, Array<Scalars['BigInt'] | string>>,
    tenantMembershipsList?: GraphCacheResolver<WithTypename<Person>, PersonTenantMembershipsListArgs, Array<WithTypename<TenantMembership> | string>>,
    tenantTrainersList?: GraphCacheResolver<WithTypename<Person>, PersonTenantTrainersListArgs, Array<WithTypename<TenantTrainer> | string>>,
    updatedAt?: GraphCacheResolver<WithTypename<Person>, Record<string, never>, Scalars['Datetime'] | string>,
    userProxiesList?: GraphCacheResolver<WithTypename<Person>, PersonUserProxiesListArgs, Array<WithTypename<UserProxy> | string>>,
    wdsfId?: GraphCacheResolver<WithTypename<Person>, Record<string, never>, Scalars['String'] | string>
  },
  PersonAddress?: {
    address?: GraphCacheResolver<WithTypename<PersonAddress>, Record<string, never>, WithTypename<AddressDomain> | string>,
    createdAt?: GraphCacheResolver<WithTypename<PersonAddress>, Record<string, never>, Scalars['Datetime'] | string>,
    isPrimary?: GraphCacheResolver<WithTypename<PersonAddress>, Record<string, never>, Scalars['Boolean'] | string>,
    person?: GraphCacheResolver<WithTypename<PersonAddress>, Record<string, never>, WithTypename<Person> | string>,
    personId?: GraphCacheResolver<WithTypename<PersonAddress>, Record<string, never>, Scalars['BigInt'] | string>,
    updatedAt?: GraphCacheResolver<WithTypename<PersonAddress>, Record<string, never>, Scalars['Datetime'] | string>
  },
  PersonEmail?: {
    createdAt?: GraphCacheResolver<WithTypename<PersonEmail>, Record<string, never>, Scalars['Datetime'] | string>,
    email?: GraphCacheResolver<WithTypename<PersonEmail>, Record<string, never>, Scalars['String'] | string>,
    isPrimary?: GraphCacheResolver<WithTypename<PersonEmail>, Record<string, never>, Scalars['Boolean'] | string>,
    person?: GraphCacheResolver<WithTypename<PersonEmail>, Record<string, never>, WithTypename<Person> | string>,
    personId?: GraphCacheResolver<WithTypename<PersonEmail>, Record<string, never>, Scalars['BigInt'] | string>,
    updatedAt?: GraphCacheResolver<WithTypename<PersonEmail>, Record<string, never>, Scalars['Datetime'] | string>
  },
  PersonPhone?: {
    createdAt?: GraphCacheResolver<WithTypename<PersonPhone>, Record<string, never>, Scalars['Datetime'] | string>,
    isPrimary?: GraphCacheResolver<WithTypename<PersonPhone>, Record<string, never>, Scalars['Boolean'] | string>,
    person?: GraphCacheResolver<WithTypename<PersonPhone>, Record<string, never>, WithTypename<Person> | string>,
    personId?: GraphCacheResolver<WithTypename<PersonPhone>, Record<string, never>, Scalars['BigInt'] | string>,
    phone?: GraphCacheResolver<WithTypename<PersonPhone>, Record<string, never>, Scalars['String'] | string>,
    updatedAt?: GraphCacheResolver<WithTypename<PersonPhone>, Record<string, never>, Scalars['Datetime'] | string>
  },
  PlatbyCategoriesConnection?: {
    edges?: GraphCacheResolver<WithTypename<PlatbyCategoriesConnection>, Record<string, never>, Array<WithTypename<PlatbyCategoriesEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<PlatbyCategoriesConnection>, Record<string, never>, Array<WithTypename<PlatbyCategory> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<PlatbyCategoriesConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<PlatbyCategoriesConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  PlatbyCategoriesEdge?: {
    cursor?: GraphCacheResolver<WithTypename<PlatbyCategoriesEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<PlatbyCategoriesEdge>, Record<string, never>, WithTypename<PlatbyCategory> | string>
  },
  PlatbyCategory?: {
    id?: GraphCacheResolver<WithTypename<PlatbyCategory>, Record<string, never>, Scalars['BigInt'] | string>,
    pcAmount?: GraphCacheResolver<WithTypename<PlatbyCategory>, Record<string, never>, Scalars['BigFloat'] | string>,
    pcArchive?: GraphCacheResolver<WithTypename<PlatbyCategory>, Record<string, never>, Scalars['Boolean'] | string>,
    pcDateDue?: GraphCacheResolver<WithTypename<PlatbyCategory>, Record<string, never>, Scalars['Date'] | string>,
    pcId?: GraphCacheResolver<WithTypename<PlatbyCategory>, Record<string, never>, Scalars['BigInt'] | string>,
    pcName?: GraphCacheResolver<WithTypename<PlatbyCategory>, Record<string, never>, Scalars['String'] | string>,
    pcSymbol?: GraphCacheResolver<WithTypename<PlatbyCategory>, Record<string, never>, Scalars['BigInt'] | string>,
    pcUseBase?: GraphCacheResolver<WithTypename<PlatbyCategory>, Record<string, never>, Scalars['Boolean'] | string>,
    pcUsePrefix?: GraphCacheResolver<WithTypename<PlatbyCategory>, Record<string, never>, Scalars['Boolean'] | string>,
    pcValidFrom?: GraphCacheResolver<WithTypename<PlatbyCategory>, Record<string, never>, Scalars['Date'] | string>,
    pcValidTo?: GraphCacheResolver<WithTypename<PlatbyCategory>, Record<string, never>, Scalars['Date'] | string>,
    pcVisible?: GraphCacheResolver<WithTypename<PlatbyCategory>, Record<string, never>, Scalars['Boolean'] | string>,
    platbyItemsByPiIdCategory?: GraphCacheResolver<WithTypename<PlatbyCategory>, PlatbyCategoryPlatbyItemsByPiIdCategoryArgs, WithTypename<PlatbyItemsConnection> | string>,
    tenantId?: GraphCacheResolver<WithTypename<PlatbyCategory>, Record<string, never>, Scalars['BigInt'] | string>
  },
  PlatbyItem?: {
    eventRegistrationsByPaymentIdList?: GraphCacheResolver<WithTypename<PlatbyItem>, PlatbyItemEventRegistrationsByPaymentIdListArgs, Array<WithTypename<EventRegistration> | string>>,
    id?: GraphCacheResolver<WithTypename<PlatbyItem>, Record<string, never>, Scalars['BigInt'] | string>,
    piAmount?: GraphCacheResolver<WithTypename<PlatbyItem>, Record<string, never>, Scalars['BigFloat'] | string>,
    piDate?: GraphCacheResolver<WithTypename<PlatbyItem>, Record<string, never>, Scalars['Date'] | string>,
    piId?: GraphCacheResolver<WithTypename<PlatbyItem>, Record<string, never>, Scalars['BigInt'] | string>,
    piIdCategory?: GraphCacheResolver<WithTypename<PlatbyItem>, Record<string, never>, Scalars['BigInt'] | string>,
    piIdRaw?: GraphCacheResolver<WithTypename<PlatbyItem>, Record<string, never>, Scalars['BigInt'] | string>,
    piIdUser?: GraphCacheResolver<WithTypename<PlatbyItem>, Record<string, never>, Scalars['BigInt'] | string>,
    piPrefix?: GraphCacheResolver<WithTypename<PlatbyItem>, Record<string, never>, Scalars['Int'] | string>,
    platbyCategoryByPiIdCategory?: GraphCacheResolver<WithTypename<PlatbyItem>, Record<string, never>, WithTypename<PlatbyCategory> | string>,
    status?: GraphCacheResolver<WithTypename<PlatbyItem>, Record<string, never>, PaymentStatus | string>,
    tenantId?: GraphCacheResolver<WithTypename<PlatbyItem>, Record<string, never>, Scalars['BigInt'] | string>,
    userByPiIdUser?: GraphCacheResolver<WithTypename<PlatbyItem>, Record<string, never>, WithTypename<User> | string>
  },
  PlatbyItemsConnection?: {
    edges?: GraphCacheResolver<WithTypename<PlatbyItemsConnection>, Record<string, never>, Array<WithTypename<PlatbyItemsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<PlatbyItemsConnection>, Record<string, never>, Array<WithTypename<PlatbyItem> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<PlatbyItemsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<PlatbyItemsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  PlatbyItemsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<PlatbyItemsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<PlatbyItemsEdge>, Record<string, never>, WithTypename<PlatbyItem> | string>
  },
  Price?: {
    amount?: GraphCacheResolver<WithTypename<Price>, Record<string, never>, Scalars['BigFloat'] | string>,
    currency?: GraphCacheResolver<WithTypename<Price>, Record<string, never>, Scalars['String'] | string>
  },
  RegisterToEventPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<RegisterToEventPayload>, Record<string, never>, Scalars['String'] | string>,
    couple?: GraphCacheResolver<WithTypename<RegisterToEventPayload>, Record<string, never>, WithTypename<Couple> | string>,
    event?: GraphCacheResolver<WithTypename<RegisterToEventPayload>, Record<string, never>, WithTypename<Event> | string>,
    payment?: GraphCacheResolver<WithTypename<RegisterToEventPayload>, Record<string, never>, WithTypename<PlatbyItem> | string>,
    person?: GraphCacheResolver<WithTypename<RegisterToEventPayload>, Record<string, never>, WithTypename<Person> | string>,
    query?: GraphCacheResolver<WithTypename<RegisterToEventPayload>, Record<string, never>, WithTypename<Query> | string>,
    registration?: GraphCacheResolver<WithTypename<RegisterToEventPayload>, Record<string, never>, WithTypename<EventRegistration> | string>,
    targetCohort?: GraphCacheResolver<WithTypename<RegisterToEventPayload>, Record<string, never>, WithTypename<EventTargetCohort> | string>,
    tenant?: GraphCacheResolver<WithTypename<RegisterToEventPayload>, Record<string, never>, WithTypename<Tenant> | string>
  },
  ResetPasswordPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<ResetPasswordPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<ResetPasswordPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  Room?: {
    description?: GraphCacheResolver<WithTypename<Room>, Record<string, never>, Scalars['JSON'] | string>,
    id?: GraphCacheResolver<WithTypename<Room>, Record<string, never>, Scalars['BigInt'] | string>,
    location?: GraphCacheResolver<WithTypename<Room>, Record<string, never>, Scalars['BigInt'] | string>,
    locationByLocation?: GraphCacheResolver<WithTypename<Room>, Record<string, never>, WithTypename<Location> | string>,
    name?: GraphCacheResolver<WithTypename<Room>, Record<string, never>, Scalars['String'] | string>,
    roomAttachments?: GraphCacheResolver<WithTypename<Room>, RoomRoomAttachmentsArgs, WithTypename<RoomAttachmentsConnection> | string>
  },
  RoomAttachment?: {
    attachmentByObjectName?: GraphCacheResolver<WithTypename<RoomAttachment>, Record<string, never>, WithTypename<Attachment> | string>,
    objectName?: GraphCacheResolver<WithTypename<RoomAttachment>, Record<string, never>, Scalars['String'] | string>,
    room?: GraphCacheResolver<WithTypename<RoomAttachment>, Record<string, never>, WithTypename<Room> | string>,
    roomId?: GraphCacheResolver<WithTypename<RoomAttachment>, Record<string, never>, Scalars['BigInt'] | string>
  },
  RoomAttachmentsConnection?: {
    edges?: GraphCacheResolver<WithTypename<RoomAttachmentsConnection>, Record<string, never>, Array<WithTypename<RoomAttachmentsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<RoomAttachmentsConnection>, Record<string, never>, Array<WithTypename<RoomAttachment> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<RoomAttachmentsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<RoomAttachmentsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  RoomAttachmentsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<RoomAttachmentsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<RoomAttachmentsEdge>, Record<string, never>, WithTypename<RoomAttachment> | string>
  },
  RoomsConnection?: {
    edges?: GraphCacheResolver<WithTypename<RoomsConnection>, Record<string, never>, Array<WithTypename<RoomsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<RoomsConnection>, Record<string, never>, Array<WithTypename<Room> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<RoomsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<RoomsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  RoomsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<RoomsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<RoomsEdge>, Record<string, never>, WithTypename<Room> | string>
  },
  Session?: {
    ssId?: GraphCacheResolver<WithTypename<Session>, Record<string, never>, Scalars['String'] | string>,
    ssLifetime?: GraphCacheResolver<WithTypename<Session>, Record<string, never>, Scalars['BigInt'] | string>,
    ssUpdatedAt?: GraphCacheResolver<WithTypename<Session>, Record<string, never>, Scalars['Datetime'] | string>,
    ssUser?: GraphCacheResolver<WithTypename<Session>, Record<string, never>, Scalars['BigInt'] | string>,
    userBySsUser?: GraphCacheResolver<WithTypename<Session>, Record<string, never>, WithTypename<User> | string>
  },
  SetLessonDemandPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<SetLessonDemandPayload>, Record<string, never>, Scalars['String'] | string>,
    eventLessonDemand?: GraphCacheResolver<WithTypename<SetLessonDemandPayload>, Record<string, never>, WithTypename<EventLessonDemand> | string>,
    query?: GraphCacheResolver<WithTypename<SetLessonDemandPayload>, Record<string, never>, WithTypename<Query> | string>,
    registration?: GraphCacheResolver<WithTypename<SetLessonDemandPayload>, Record<string, never>, WithTypename<EventRegistration> | string>,
    tenant?: GraphCacheResolver<WithTypename<SetLessonDemandPayload>, Record<string, never>, WithTypename<Tenant> | string>,
    trainer?: GraphCacheResolver<WithTypename<SetLessonDemandPayload>, Record<string, never>, WithTypename<EventTrainer> | string>
  },
  SkupiniesConnection?: {
    edges?: GraphCacheResolver<WithTypename<SkupiniesConnection>, Record<string, never>, Array<WithTypename<SkupiniesEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<SkupiniesConnection>, Record<string, never>, Array<WithTypename<Skupiny> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<SkupiniesConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<SkupiniesConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  SkupiniesEdge?: {
    cursor?: GraphCacheResolver<WithTypename<SkupiniesEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<SkupiniesEdge>, Record<string, never>, WithTypename<Skupiny> | string>
  },
  Skupiny?: {
    cohortGroup?: GraphCacheResolver<WithTypename<Skupiny>, Record<string, never>, Scalars['BigInt'] | string>,
    cohortGroupByCohortGroup?: GraphCacheResolver<WithTypename<Skupiny>, Record<string, never>, WithTypename<CohortGroup> | string>,
    cohortMembershipsByCohortIdList?: GraphCacheResolver<WithTypename<Skupiny>, SkupinyCohortMembershipsByCohortIdListArgs, Array<WithTypename<CohortMembership> | string>>,
    eventTargetCohortsByCohortIdList?: GraphCacheResolver<WithTypename<Skupiny>, SkupinyEventTargetCohortsByCohortIdListArgs, Array<WithTypename<EventTargetCohort> | string>>,
    id?: GraphCacheResolver<WithTypename<Skupiny>, Record<string, never>, Scalars['BigInt'] | string>,
    internalInfo?: GraphCacheResolver<WithTypename<Skupiny>, Record<string, never>, Scalars['String'] | string>,
    ordering?: GraphCacheResolver<WithTypename<Skupiny>, Record<string, never>, Scalars['Int'] | string>,
    sColorRgb?: GraphCacheResolver<WithTypename<Skupiny>, Record<string, never>, Scalars['String'] | string>,
    sColorText?: GraphCacheResolver<WithTypename<Skupiny>, Record<string, never>, Scalars['String'] | string>,
    sDescription?: GraphCacheResolver<WithTypename<Skupiny>, Record<string, never>, Scalars['String'] | string>,
    sId?: GraphCacheResolver<WithTypename<Skupiny>, Record<string, never>, Scalars['BigInt'] | string>,
    sLocation?: GraphCacheResolver<WithTypename<Skupiny>, Record<string, never>, Scalars['String'] | string>,
    sName?: GraphCacheResolver<WithTypename<Skupiny>, Record<string, never>, Scalars['String'] | string>,
    sVisible?: GraphCacheResolver<WithTypename<Skupiny>, Record<string, never>, Scalars['Boolean'] | string>,
    tenantId?: GraphCacheResolver<WithTypename<Skupiny>, Record<string, never>, Scalars['BigInt'] | string>,
    upozorneniSkupiniesByUpsIdSkupina?: GraphCacheResolver<WithTypename<Skupiny>, SkupinyUpozorneniSkupiniesByUpsIdSkupinaArgs, WithTypename<UpozorneniSkupiniesConnection> | string>
  },
  SubmitFormPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<SubmitFormPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<SubmitFormPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  Tenant?: {
    address?: GraphCacheResolver<WithTypename<Tenant>, Record<string, never>, WithTypename<AddressDomain> | string>,
    cohortGroupsByTenant?: GraphCacheResolver<WithTypename<Tenant>, TenantCohortGroupsByTenantArgs, WithTypename<CohortGroupsConnection> | string>,
    czDic?: GraphCacheResolver<WithTypename<Tenant>, Record<string, never>, Scalars['String'] | string>,
    czIco?: GraphCacheResolver<WithTypename<Tenant>, Record<string, never>, Scalars['String'] | string>,
    eventAttendancesList?: GraphCacheResolver<WithTypename<Tenant>, TenantEventAttendancesListArgs, Array<WithTypename<EventAttendance> | string>>,
    eventInstanceTrainersList?: GraphCacheResolver<WithTypename<Tenant>, TenantEventInstanceTrainersListArgs, Array<WithTypename<EventInstanceTrainer> | string>>,
    eventInstances?: GraphCacheResolver<WithTypename<Tenant>, TenantEventInstancesArgs, WithTypename<EventInstancesConnection> | string>,
    eventInstancesList?: GraphCacheResolver<WithTypename<Tenant>, TenantEventInstancesListArgs, Array<WithTypename<EventInstance> | string>>,
    eventLessonDemandsList?: GraphCacheResolver<WithTypename<Tenant>, TenantEventLessonDemandsListArgs, Array<WithTypename<EventLessonDemand> | string>>,
    eventRegistrationsList?: GraphCacheResolver<WithTypename<Tenant>, TenantEventRegistrationsListArgs, Array<WithTypename<EventRegistration> | string>>,
    eventTargetCohortsList?: GraphCacheResolver<WithTypename<Tenant>, TenantEventTargetCohortsListArgs, Array<WithTypename<EventTargetCohort> | string>>,
    eventTrainersList?: GraphCacheResolver<WithTypename<Tenant>, TenantEventTrainersListArgs, Array<WithTypename<EventTrainer> | string>>,
    id?: GraphCacheResolver<WithTypename<Tenant>, Record<string, never>, Scalars['BigInt'] | string>,
    memberInfo?: GraphCacheResolver<WithTypename<Tenant>, Record<string, never>, Scalars['String'] | string>,
    name?: GraphCacheResolver<WithTypename<Tenant>, Record<string, never>, Scalars['String'] | string>,
    origins?: GraphCacheResolver<WithTypename<Tenant>, Record<string, never>, Array<Scalars['String'] | string>>,
    tenantAdministratorsList?: GraphCacheResolver<WithTypename<Tenant>, TenantTenantAdministratorsListArgs, Array<WithTypename<TenantAdministrator> | string>>,
    tenantAttachments?: GraphCacheResolver<WithTypename<Tenant>, TenantTenantAttachmentsArgs, WithTypename<TenantAttachmentsConnection> | string>,
    tenantLocationsList?: GraphCacheResolver<WithTypename<Tenant>, TenantTenantLocationsListArgs, Array<WithTypename<TenantLocation> | string>>,
    tenantMembershipsList?: GraphCacheResolver<WithTypename<Tenant>, TenantTenantMembershipsListArgs, Array<WithTypename<TenantMembership> | string>>,
    tenantTrainersList?: GraphCacheResolver<WithTypename<Tenant>, TenantTenantTrainersListArgs, Array<WithTypename<TenantTrainer> | string>>
  },
  TenantAdministrator?: {
    active?: GraphCacheResolver<WithTypename<TenantAdministrator>, Record<string, never>, Scalars['Boolean'] | string>,
    createdAt?: GraphCacheResolver<WithTypename<TenantAdministrator>, Record<string, never>, Scalars['Datetime'] | string>,
    description?: GraphCacheResolver<WithTypename<TenantAdministrator>, Record<string, never>, Scalars['String'] | string>,
    id?: GraphCacheResolver<WithTypename<TenantAdministrator>, Record<string, never>, Scalars['BigInt'] | string>,
    isVisible?: GraphCacheResolver<WithTypename<TenantAdministrator>, Record<string, never>, Scalars['Boolean'] | string>,
    person?: GraphCacheResolver<WithTypename<TenantAdministrator>, Record<string, never>, WithTypename<Person> | string>,
    personId?: GraphCacheResolver<WithTypename<TenantAdministrator>, Record<string, never>, Scalars['BigInt'] | string>,
    since?: GraphCacheResolver<WithTypename<TenantAdministrator>, Record<string, never>, Scalars['Datetime'] | string>,
    tenant?: GraphCacheResolver<WithTypename<TenantAdministrator>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantId?: GraphCacheResolver<WithTypename<TenantAdministrator>, Record<string, never>, Scalars['BigInt'] | string>,
    until?: GraphCacheResolver<WithTypename<TenantAdministrator>, Record<string, never>, Scalars['Datetime'] | string>,
    updatedAt?: GraphCacheResolver<WithTypename<TenantAdministrator>, Record<string, never>, Scalars['Datetime'] | string>
  },
  TenantAttachment?: {
    attachmentByObjectName?: GraphCacheResolver<WithTypename<TenantAttachment>, Record<string, never>, WithTypename<Attachment> | string>,
    objectName?: GraphCacheResolver<WithTypename<TenantAttachment>, Record<string, never>, Scalars['String'] | string>,
    tenant?: GraphCacheResolver<WithTypename<TenantAttachment>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantId?: GraphCacheResolver<WithTypename<TenantAttachment>, Record<string, never>, Scalars['BigInt'] | string>,
    type?: GraphCacheResolver<WithTypename<TenantAttachment>, Record<string, never>, TenantAttachmentType | string>
  },
  TenantAttachmentsConnection?: {
    edges?: GraphCacheResolver<WithTypename<TenantAttachmentsConnection>, Record<string, never>, Array<WithTypename<TenantAttachmentsEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<TenantAttachmentsConnection>, Record<string, never>, Array<WithTypename<TenantAttachment> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<TenantAttachmentsConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<TenantAttachmentsConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  TenantAttachmentsEdge?: {
    cursor?: GraphCacheResolver<WithTypename<TenantAttachmentsEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<TenantAttachmentsEdge>, Record<string, never>, WithTypename<TenantAttachment> | string>
  },
  TenantLocation?: {
    id?: GraphCacheResolver<WithTypename<TenantLocation>, Record<string, never>, Scalars['BigInt'] | string>,
    location?: GraphCacheResolver<WithTypename<TenantLocation>, Record<string, never>, WithTypename<Location> | string>,
    locationId?: GraphCacheResolver<WithTypename<TenantLocation>, Record<string, never>, Scalars['BigInt'] | string>,
    tenant?: GraphCacheResolver<WithTypename<TenantLocation>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantId?: GraphCacheResolver<WithTypename<TenantLocation>, Record<string, never>, Scalars['BigInt'] | string>
  },
  TenantMembership?: {
    active?: GraphCacheResolver<WithTypename<TenantMembership>, Record<string, never>, Scalars['Boolean'] | string>,
    createdAt?: GraphCacheResolver<WithTypename<TenantMembership>, Record<string, never>, Scalars['Datetime'] | string>,
    id?: GraphCacheResolver<WithTypename<TenantMembership>, Record<string, never>, Scalars['BigInt'] | string>,
    person?: GraphCacheResolver<WithTypename<TenantMembership>, Record<string, never>, WithTypename<Person> | string>,
    personId?: GraphCacheResolver<WithTypename<TenantMembership>, Record<string, never>, Scalars['BigInt'] | string>,
    since?: GraphCacheResolver<WithTypename<TenantMembership>, Record<string, never>, Scalars['Datetime'] | string>,
    tenant?: GraphCacheResolver<WithTypename<TenantMembership>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantId?: GraphCacheResolver<WithTypename<TenantMembership>, Record<string, never>, Scalars['BigInt'] | string>,
    until?: GraphCacheResolver<WithTypename<TenantMembership>, Record<string, never>, Scalars['Datetime'] | string>,
    updatedAt?: GraphCacheResolver<WithTypename<TenantMembership>, Record<string, never>, Scalars['Datetime'] | string>
  },
  TenantTrainer?: {
    active?: GraphCacheResolver<WithTypename<TenantTrainer>, Record<string, never>, Scalars['Boolean'] | string>,
    createdAt?: GraphCacheResolver<WithTypename<TenantTrainer>, Record<string, never>, Scalars['Datetime'] | string>,
    defaultPrice?: GraphCacheResolver<WithTypename<TenantTrainer>, Record<string, never>, WithTypename<Price> | string>,
    description?: GraphCacheResolver<WithTypename<TenantTrainer>, Record<string, never>, Scalars['String'] | string>,
    id?: GraphCacheResolver<WithTypename<TenantTrainer>, Record<string, never>, Scalars['BigInt'] | string>,
    isVisible?: GraphCacheResolver<WithTypename<TenantTrainer>, Record<string, never>, Scalars['Boolean'] | string>,
    person?: GraphCacheResolver<WithTypename<TenantTrainer>, Record<string, never>, WithTypename<Person> | string>,
    personId?: GraphCacheResolver<WithTypename<TenantTrainer>, Record<string, never>, Scalars['BigInt'] | string>,
    since?: GraphCacheResolver<WithTypename<TenantTrainer>, Record<string, never>, Scalars['Datetime'] | string>,
    tenant?: GraphCacheResolver<WithTypename<TenantTrainer>, Record<string, never>, WithTypename<Tenant> | string>,
    tenantId?: GraphCacheResolver<WithTypename<TenantTrainer>, Record<string, never>, Scalars['BigInt'] | string>,
    until?: GraphCacheResolver<WithTypename<TenantTrainer>, Record<string, never>, Scalars['Datetime'] | string>,
    updatedAt?: GraphCacheResolver<WithTypename<TenantTrainer>, Record<string, never>, Scalars['Datetime'] | string>
  },
  UpdateAktualityPayload?: {
    aktuality?: GraphCacheResolver<WithTypename<UpdateAktualityPayload>, Record<string, never>, WithTypename<Aktuality> | string>,
    aktualityEdge?: GraphCacheResolver<WithTypename<UpdateAktualityPayload>, UpdateAktualityPayloadAktualityEdgeArgs, WithTypename<AktualitiesEdge> | string>,
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateAktualityPayload>, Record<string, never>, Scalars['String'] | string>,
    galerieFotoByAtFotoMain?: GraphCacheResolver<WithTypename<UpdateAktualityPayload>, Record<string, never>, WithTypename<GalerieFoto> | string>,
    query?: GraphCacheResolver<WithTypename<UpdateAktualityPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByAtKdo?: GraphCacheResolver<WithTypename<UpdateAktualityPayload>, Record<string, never>, WithTypename<User> | string>
  },
  UpdateCohortGroupPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateCohortGroupPayload>, Record<string, never>, Scalars['String'] | string>,
    cohortGroup?: GraphCacheResolver<WithTypename<UpdateCohortGroupPayload>, Record<string, never>, WithTypename<CohortGroup> | string>,
    cohortGroupEdge?: GraphCacheResolver<WithTypename<UpdateCohortGroupPayload>, UpdateCohortGroupPayloadCohortGroupEdgeArgs, WithTypename<CohortGroupsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<UpdateCohortGroupPayload>, Record<string, never>, WithTypename<Query> | string>,
    tenantByTenant?: GraphCacheResolver<WithTypename<UpdateCohortGroupPayload>, Record<string, never>, WithTypename<Tenant> | string>
  },
  UpdateDokumentyPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateDokumentyPayload>, Record<string, never>, Scalars['String'] | string>,
    dokumenty?: GraphCacheResolver<WithTypename<UpdateDokumentyPayload>, Record<string, never>, WithTypename<Dokumenty> | string>,
    query?: GraphCacheResolver<WithTypename<UpdateDokumentyPayload>, Record<string, never>, WithTypename<Query> | string>,
    userByDKdo?: GraphCacheResolver<WithTypename<UpdateDokumentyPayload>, Record<string, never>, WithTypename<User> | string>
  },
  UpdateEventPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateEventPayload>, Record<string, never>, Scalars['String'] | string>,
    event?: GraphCacheResolver<WithTypename<UpdateEventPayload>, Record<string, never>, WithTypename<Event> | string>,
    eventEdge?: GraphCacheResolver<WithTypename<UpdateEventPayload>, UpdateEventPayloadEventEdgeArgs, WithTypename<EventsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<UpdateEventPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  UpdateLocationPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateLocationPayload>, Record<string, never>, Scalars['String'] | string>,
    location?: GraphCacheResolver<WithTypename<UpdateLocationPayload>, Record<string, never>, WithTypename<Location> | string>,
    locationEdge?: GraphCacheResolver<WithTypename<UpdateLocationPayload>, UpdateLocationPayloadLocationEdgeArgs, WithTypename<LocationsEdge> | string>,
    query?: GraphCacheResolver<WithTypename<UpdateLocationPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  UpdatePersonPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdatePersonPayload>, Record<string, never>, Scalars['String'] | string>,
    person?: GraphCacheResolver<WithTypename<UpdatePersonPayload>, Record<string, never>, WithTypename<Person> | string>,
    personEdge?: GraphCacheResolver<WithTypename<UpdatePersonPayload>, UpdatePersonPayloadPersonEdgeArgs, WithTypename<PeopleEdge> | string>,
    query?: GraphCacheResolver<WithTypename<UpdatePersonPayload>, Record<string, never>, WithTypename<Query> | string>
  },
  UpdateRoomPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateRoomPayload>, Record<string, never>, Scalars['String'] | string>,
    locationByLocation?: GraphCacheResolver<WithTypename<UpdateRoomPayload>, Record<string, never>, WithTypename<Location> | string>,
    query?: GraphCacheResolver<WithTypename<UpdateRoomPayload>, Record<string, never>, WithTypename<Query> | string>,
    room?: GraphCacheResolver<WithTypename<UpdateRoomPayload>, Record<string, never>, WithTypename<Room> | string>,
    roomEdge?: GraphCacheResolver<WithTypename<UpdateRoomPayload>, UpdateRoomPayloadRoomEdgeArgs, WithTypename<RoomsEdge> | string>
  },
  UpdateSkupinyPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateSkupinyPayload>, Record<string, never>, Scalars['String'] | string>,
    cohortGroupByCohortGroup?: GraphCacheResolver<WithTypename<UpdateSkupinyPayload>, Record<string, never>, WithTypename<CohortGroup> | string>,
    query?: GraphCacheResolver<WithTypename<UpdateSkupinyPayload>, Record<string, never>, WithTypename<Query> | string>,
    skupiny?: GraphCacheResolver<WithTypename<UpdateSkupinyPayload>, Record<string, never>, WithTypename<Skupiny> | string>,
    skupinyEdge?: GraphCacheResolver<WithTypename<UpdateSkupinyPayload>, UpdateSkupinyPayloadSkupinyEdgeArgs, WithTypename<SkupiniesEdge> | string>
  },
  UpdateTenantPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateTenantPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<UpdateTenantPayload>, Record<string, never>, WithTypename<Query> | string>,
    tenant?: GraphCacheResolver<WithTypename<UpdateTenantPayload>, Record<string, never>, WithTypename<Tenant> | string>
  },
  UpdateUpozorneniPayload?: {
    clientMutationId?: GraphCacheResolver<WithTypename<UpdateUpozorneniPayload>, Record<string, never>, Scalars['String'] | string>,
    query?: GraphCacheResolver<WithTypename<UpdateUpozorneniPayload>, Record<string, never>, WithTypename<Query> | string>,
    upozorneni?: GraphCacheResolver<WithTypename<UpdateUpozorneniPayload>, Record<string, never>, WithTypename<Upozorneni> | string>,
    upozorneniEdge?: GraphCacheResolver<WithTypename<UpdateUpozorneniPayload>, UpdateUpozorneniPayloadUpozorneniEdgeArgs, WithTypename<UpozornenisEdge> | string>,
    userByUpKdo?: GraphCacheResolver<WithTypename<UpdateUpozorneniPayload>, Record<string, never>, WithTypename<User> | string>
  },
  Upozorneni?: {
    id?: GraphCacheResolver<WithTypename<Upozorneni>, Record<string, never>, Scalars['BigInt'] | string>,
    isVisible?: GraphCacheResolver<WithTypename<Upozorneni>, Record<string, never>, Scalars['Boolean'] | string>,
    scheduledSince?: GraphCacheResolver<WithTypename<Upozorneni>, Record<string, never>, Scalars['Datetime'] | string>,
    scheduledUntil?: GraphCacheResolver<WithTypename<Upozorneni>, Record<string, never>, Scalars['Datetime'] | string>,
    sticky?: GraphCacheResolver<WithTypename<Upozorneni>, Record<string, never>, Scalars['Boolean'] | string>,
    tenantId?: GraphCacheResolver<WithTypename<Upozorneni>, Record<string, never>, Scalars['BigInt'] | string>,
    upBarvy?: GraphCacheResolver<WithTypename<Upozorneni>, Record<string, never>, Scalars['BigInt'] | string>,
    upId?: GraphCacheResolver<WithTypename<Upozorneni>, Record<string, never>, Scalars['BigInt'] | string>,
    upKdo?: GraphCacheResolver<WithTypename<Upozorneni>, Record<string, never>, Scalars['BigInt'] | string>,
    upLock?: GraphCacheResolver<WithTypename<Upozorneni>, Record<string, never>, Scalars['Boolean'] | string>,
    upNadpis?: GraphCacheResolver<WithTypename<Upozorneni>, Record<string, never>, Scalars['String'] | string>,
    upText?: GraphCacheResolver<WithTypename<Upozorneni>, Record<string, never>, Scalars['String'] | string>,
    upTimestamp?: GraphCacheResolver<WithTypename<Upozorneni>, Record<string, never>, Scalars['Datetime'] | string>,
    upTimestampAdd?: GraphCacheResolver<WithTypename<Upozorneni>, Record<string, never>, Scalars['Datetime'] | string>,
    upozorneniSkupiniesByUpsIdRodic?: GraphCacheResolver<WithTypename<Upozorneni>, UpozorneniUpozorneniSkupiniesByUpsIdRodicArgs, WithTypename<UpozorneniSkupiniesConnection> | string>,
    userByUpKdo?: GraphCacheResolver<WithTypename<Upozorneni>, Record<string, never>, WithTypename<User> | string>
  },
  UpozorneniSkupiniesConnection?: {
    edges?: GraphCacheResolver<WithTypename<UpozorneniSkupiniesConnection>, Record<string, never>, Array<WithTypename<UpozorneniSkupiniesEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<UpozorneniSkupiniesConnection>, Record<string, never>, Array<WithTypename<UpozorneniSkupiny> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<UpozorneniSkupiniesConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<UpozorneniSkupiniesConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  UpozorneniSkupiniesEdge?: {
    cursor?: GraphCacheResolver<WithTypename<UpozorneniSkupiniesEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<UpozorneniSkupiniesEdge>, Record<string, never>, WithTypename<UpozorneniSkupiny> | string>
  },
  UpozorneniSkupiny?: {
    id?: GraphCacheResolver<WithTypename<UpozorneniSkupiny>, Record<string, never>, Scalars['BigInt'] | string>,
    skupinyByUpsIdSkupina?: GraphCacheResolver<WithTypename<UpozorneniSkupiny>, Record<string, never>, WithTypename<Skupiny> | string>,
    tenantId?: GraphCacheResolver<WithTypename<UpozorneniSkupiny>, Record<string, never>, Scalars['BigInt'] | string>,
    upozorneniByUpsIdRodic?: GraphCacheResolver<WithTypename<UpozorneniSkupiny>, Record<string, never>, WithTypename<Upozorneni> | string>,
    upsColor?: GraphCacheResolver<WithTypename<UpozorneniSkupiny>, Record<string, never>, Scalars['String'] | string>,
    upsId?: GraphCacheResolver<WithTypename<UpozorneniSkupiny>, Record<string, never>, Scalars['BigInt'] | string>,
    upsIdRodic?: GraphCacheResolver<WithTypename<UpozorneniSkupiny>, Record<string, never>, Scalars['BigInt'] | string>,
    upsIdSkupina?: GraphCacheResolver<WithTypename<UpozorneniSkupiny>, Record<string, never>, Scalars['BigInt'] | string>
  },
  UpozornenisConnection?: {
    edges?: GraphCacheResolver<WithTypename<UpozornenisConnection>, Record<string, never>, Array<WithTypename<UpozornenisEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<UpozornenisConnection>, Record<string, never>, Array<WithTypename<Upozorneni> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<UpozornenisConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<UpozornenisConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  UpozornenisEdge?: {
    cursor?: GraphCacheResolver<WithTypename<UpozornenisEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<UpozornenisEdge>, Record<string, never>, WithTypename<Upozorneni> | string>
  },
  User?: {
    aktualitiesByAtKdo?: GraphCacheResolver<WithTypename<User>, UserAktualitiesByAtKdoArgs, WithTypename<AktualitiesConnection> | string>,
    attachmentsByUploadedBy?: GraphCacheResolver<WithTypename<User>, UserAttachmentsByUploadedByArgs, WithTypename<AttachmentsConnection> | string>,
    dateOfNewestPayment?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['Date'] | string>,
    dateOfOldestPayment?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['Date'] | string>,
    dokumentiesByDKdoList?: GraphCacheResolver<WithTypename<User>, UserDokumentiesByDKdoListArgs, Array<WithTypename<Dokumenty> | string>>,
    galerieFotosByGfKdo?: GraphCacheResolver<WithTypename<User>, UserGalerieFotosByGfKdoArgs, WithTypename<GalerieFotosConnection> | string>,
    hasValidPayment?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['Boolean'] | string>,
    id?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['BigInt'] | string>,
    inPublicCohort?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['Boolean'] | string>,
    platbyItemsByPiIdUser?: GraphCacheResolver<WithTypename<User>, UserPlatbyItemsByPiIdUserArgs, WithTypename<PlatbyItemsConnection> | string>,
    tenantId?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['BigInt'] | string>,
    uCity?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['String'] | string>,
    uConscriptionNumber?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['String'] | string>,
    uCreatedAt?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['Datetime'] | string>,
    uDistrict?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['String'] | string>,
    uEmail?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['String'] | string>,
    uId?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['BigInt'] | string>,
    uJmeno?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['String'] | string>,
    uLogin?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['String'] | string>,
    uNationality?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['String'] | string>,
    uOrientationNumber?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['String'] | string>,
    uPostalCode?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['String'] | string>,
    uPrijmeni?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['String'] | string>,
    uStreet?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['String'] | string>,
    uTimestamp?: GraphCacheResolver<WithTypename<User>, Record<string, never>, Scalars['Datetime'] | string>,
    upozornenisByUpKdo?: GraphCacheResolver<WithTypename<User>, UserUpozornenisByUpKdoArgs, WithTypename<UpozornenisConnection> | string>,
    userProxiesList?: GraphCacheResolver<WithTypename<User>, UserUserProxiesListArgs, Array<WithTypename<UserProxy> | string>>
  },
  UserProxy?: {
    createdAt?: GraphCacheResolver<WithTypename<UserProxy>, Record<string, never>, Scalars['Datetime'] | string>,
    id?: GraphCacheResolver<WithTypename<UserProxy>, Record<string, never>, Scalars['BigInt'] | string>,
    person?: GraphCacheResolver<WithTypename<UserProxy>, Record<string, never>, WithTypename<Person> | string>,
    personId?: GraphCacheResolver<WithTypename<UserProxy>, Record<string, never>, Scalars['BigInt'] | string>,
    updatedAt?: GraphCacheResolver<WithTypename<UserProxy>, Record<string, never>, Scalars['Datetime'] | string>,
    user?: GraphCacheResolver<WithTypename<UserProxy>, Record<string, never>, WithTypename<User> | string>,
    userId?: GraphCacheResolver<WithTypename<UserProxy>, Record<string, never>, Scalars['BigInt'] | string>
  },
  UsersConnection?: {
    edges?: GraphCacheResolver<WithTypename<UsersConnection>, Record<string, never>, Array<WithTypename<UsersEdge> | string>>,
    nodes?: GraphCacheResolver<WithTypename<UsersConnection>, Record<string, never>, Array<WithTypename<User> | string>>,
    pageInfo?: GraphCacheResolver<WithTypename<UsersConnection>, Record<string, never>, WithTypename<PageInfo> | string>,
    totalCount?: GraphCacheResolver<WithTypename<UsersConnection>, Record<string, never>, Scalars['Int'] | string>
  },
  UsersEdge?: {
    cursor?: GraphCacheResolver<WithTypename<UsersEdge>, Record<string, never>, Scalars['Cursor'] | string>,
    node?: GraphCacheResolver<WithTypename<UsersEdge>, Record<string, never>, WithTypename<User> | string>
  }
};

export type GraphCacheOptimisticUpdaters = {
  cancelRegistration?: GraphCacheOptimisticMutationResolver<MutationCancelRegistrationArgs, Maybe<WithTypename<CancelRegistrationPayload>>>,
  changePassword?: GraphCacheOptimisticMutationResolver<MutationChangePasswordArgs, Maybe<WithTypename<ChangePasswordPayload>>>,
  confirmUser?: GraphCacheOptimisticMutationResolver<MutationConfirmUserArgs, Maybe<WithTypename<ConfirmUserPayload>>>,
  createAktuality?: GraphCacheOptimisticMutationResolver<MutationCreateAktualityArgs, Maybe<WithTypename<CreateAktualityPayload>>>,
  createAttachment?: GraphCacheOptimisticMutationResolver<MutationCreateAttachmentArgs, Maybe<WithTypename<CreateAttachmentPayload>>>,
  createCohortGroup?: GraphCacheOptimisticMutationResolver<MutationCreateCohortGroupArgs, Maybe<WithTypename<CreateCohortGroupPayload>>>,
  createCouple?: GraphCacheOptimisticMutationResolver<MutationCreateCoupleArgs, Maybe<WithTypename<CreateCouplePayload>>>,
  createDokumenty?: GraphCacheOptimisticMutationResolver<MutationCreateDokumentyArgs, Maybe<WithTypename<CreateDokumentyPayload>>>,
  createEvent?: GraphCacheOptimisticMutationResolver<MutationCreateEventArgs, Maybe<WithTypename<CreateEventPayload>>>,
  createFormResponse?: GraphCacheOptimisticMutationResolver<MutationCreateFormResponseArgs, Maybe<WithTypename<CreateFormResponsePayload>>>,
  createLocation?: GraphCacheOptimisticMutationResolver<MutationCreateLocationArgs, Maybe<WithTypename<CreateLocationPayload>>>,
  createPermission?: GraphCacheOptimisticMutationResolver<MutationCreatePermissionArgs, Maybe<WithTypename<CreatePermissionPayload>>>,
  createRoom?: GraphCacheOptimisticMutationResolver<MutationCreateRoomArgs, Maybe<WithTypename<CreateRoomPayload>>>,
  createSkupiny?: GraphCacheOptimisticMutationResolver<MutationCreateSkupinyArgs, Maybe<WithTypename<CreateSkupinyPayload>>>,
  createUpozorneni?: GraphCacheOptimisticMutationResolver<MutationCreateUpozorneniArgs, Maybe<WithTypename<CreateUpozorneniPayload>>>,
  currentPersonIds?: GraphCacheOptimisticMutationResolver<MutationCurrentPersonIdsArgs, Maybe<WithTypename<CurrentPersonIdsPayload>>>,
  deleteAktuality?: GraphCacheOptimisticMutationResolver<MutationDeleteAktualityArgs, Maybe<WithTypename<DeleteAktualityPayload>>>,
  deleteAttachment?: GraphCacheOptimisticMutationResolver<MutationDeleteAttachmentArgs, Maybe<WithTypename<DeleteAttachmentPayload>>>,
  deleteCohortGroup?: GraphCacheOptimisticMutationResolver<MutationDeleteCohortGroupArgs, Maybe<WithTypename<DeleteCohortGroupPayload>>>,
  deleteCouple?: GraphCacheOptimisticMutationResolver<MutationDeleteCoupleArgs, Maybe<WithTypename<DeleteCouplePayload>>>,
  deleteDokumenty?: GraphCacheOptimisticMutationResolver<MutationDeleteDokumentyArgs, Maybe<WithTypename<DeleteDokumentyPayload>>>,
  deleteEvent?: GraphCacheOptimisticMutationResolver<MutationDeleteEventArgs, Maybe<WithTypename<DeleteEventPayload>>>,
  deleteLocation?: GraphCacheOptimisticMutationResolver<MutationDeleteLocationArgs, Maybe<WithTypename<DeleteLocationPayload>>>,
  deleteRoom?: GraphCacheOptimisticMutationResolver<MutationDeleteRoomArgs, Maybe<WithTypename<DeleteRoomPayload>>>,
  deleteSkupiny?: GraphCacheOptimisticMutationResolver<MutationDeleteSkupinyArgs, Maybe<WithTypename<DeleteSkupinyPayload>>>,
  deleteUpozorneni?: GraphCacheOptimisticMutationResolver<MutationDeleteUpozorneniArgs, Maybe<WithTypename<DeleteUpozorneniPayload>>>,
  editRegistration?: GraphCacheOptimisticMutationResolver<MutationEditRegistrationArgs, Maybe<WithTypename<EditRegistrationPayload>>>,
  isCurrentTenantMember?: GraphCacheOptimisticMutationResolver<MutationIsCurrentTenantMemberArgs, Maybe<WithTypename<IsCurrentTenantMemberPayload>>>,
  login?: GraphCacheOptimisticMutationResolver<MutationLoginArgs, Maybe<WithTypename<LoginPayload>>>,
  logout?: GraphCacheOptimisticMutationResolver<MutationLogoutArgs, Maybe<WithTypename<LogoutPayload>>>,
  registerToEvent?: GraphCacheOptimisticMutationResolver<MutationRegisterToEventArgs, Maybe<WithTypename<RegisterToEventPayload>>>,
  resetPassword?: GraphCacheOptimisticMutationResolver<MutationResetPasswordArgs, Maybe<WithTypename<ResetPasswordPayload>>>,
  setLessonDemand?: GraphCacheOptimisticMutationResolver<MutationSetLessonDemandArgs, Maybe<WithTypename<SetLessonDemandPayload>>>,
  submitForm?: GraphCacheOptimisticMutationResolver<MutationSubmitFormArgs, Maybe<WithTypename<SubmitFormPayload>>>,
  updateAktuality?: GraphCacheOptimisticMutationResolver<MutationUpdateAktualityArgs, Maybe<WithTypename<UpdateAktualityPayload>>>,
  updateCohortGroup?: GraphCacheOptimisticMutationResolver<MutationUpdateCohortGroupArgs, Maybe<WithTypename<UpdateCohortGroupPayload>>>,
  updateDokumenty?: GraphCacheOptimisticMutationResolver<MutationUpdateDokumentyArgs, Maybe<WithTypename<UpdateDokumentyPayload>>>,
  updateEvent?: GraphCacheOptimisticMutationResolver<MutationUpdateEventArgs, Maybe<WithTypename<UpdateEventPayload>>>,
  updateLocation?: GraphCacheOptimisticMutationResolver<MutationUpdateLocationArgs, Maybe<WithTypename<UpdateLocationPayload>>>,
  updatePerson?: GraphCacheOptimisticMutationResolver<MutationUpdatePersonArgs, Maybe<WithTypename<UpdatePersonPayload>>>,
  updateRoom?: GraphCacheOptimisticMutationResolver<MutationUpdateRoomArgs, Maybe<WithTypename<UpdateRoomPayload>>>,
  updateSkupiny?: GraphCacheOptimisticMutationResolver<MutationUpdateSkupinyArgs, Maybe<WithTypename<UpdateSkupinyPayload>>>,
  updateTenant?: GraphCacheOptimisticMutationResolver<MutationUpdateTenantArgs, Maybe<WithTypename<UpdateTenantPayload>>>,
  updateUpozorneni?: GraphCacheOptimisticMutationResolver<MutationUpdateUpozorneniArgs, Maybe<WithTypename<UpdateUpozorneniPayload>>>
};

export type GraphCacheUpdaters = {
  Mutation?: {
    cancelRegistration?: GraphCacheUpdateResolver<{ cancelRegistration: Maybe<WithTypename<CancelRegistrationPayload>> }, MutationCancelRegistrationArgs>,
    changePassword?: GraphCacheUpdateResolver<{ changePassword: Maybe<WithTypename<ChangePasswordPayload>> }, MutationChangePasswordArgs>,
    confirmUser?: GraphCacheUpdateResolver<{ confirmUser: Maybe<WithTypename<ConfirmUserPayload>> }, MutationConfirmUserArgs>,
    createAktuality?: GraphCacheUpdateResolver<{ createAktuality: Maybe<WithTypename<CreateAktualityPayload>> }, MutationCreateAktualityArgs>,
    createAttachment?: GraphCacheUpdateResolver<{ createAttachment: Maybe<WithTypename<CreateAttachmentPayload>> }, MutationCreateAttachmentArgs>,
    createCohortGroup?: GraphCacheUpdateResolver<{ createCohortGroup: Maybe<WithTypename<CreateCohortGroupPayload>> }, MutationCreateCohortGroupArgs>,
    createCouple?: GraphCacheUpdateResolver<{ createCouple: Maybe<WithTypename<CreateCouplePayload>> }, MutationCreateCoupleArgs>,
    createDokumenty?: GraphCacheUpdateResolver<{ createDokumenty: Maybe<WithTypename<CreateDokumentyPayload>> }, MutationCreateDokumentyArgs>,
    createEvent?: GraphCacheUpdateResolver<{ createEvent: Maybe<WithTypename<CreateEventPayload>> }, MutationCreateEventArgs>,
    createFormResponse?: GraphCacheUpdateResolver<{ createFormResponse: Maybe<WithTypename<CreateFormResponsePayload>> }, MutationCreateFormResponseArgs>,
    createLocation?: GraphCacheUpdateResolver<{ createLocation: Maybe<WithTypename<CreateLocationPayload>> }, MutationCreateLocationArgs>,
    createPermission?: GraphCacheUpdateResolver<{ createPermission: Maybe<WithTypename<CreatePermissionPayload>> }, MutationCreatePermissionArgs>,
    createRoom?: GraphCacheUpdateResolver<{ createRoom: Maybe<WithTypename<CreateRoomPayload>> }, MutationCreateRoomArgs>,
    createSkupiny?: GraphCacheUpdateResolver<{ createSkupiny: Maybe<WithTypename<CreateSkupinyPayload>> }, MutationCreateSkupinyArgs>,
    createUpozorneni?: GraphCacheUpdateResolver<{ createUpozorneni: Maybe<WithTypename<CreateUpozorneniPayload>> }, MutationCreateUpozorneniArgs>,
    currentPersonIds?: GraphCacheUpdateResolver<{ currentPersonIds: Maybe<WithTypename<CurrentPersonIdsPayload>> }, MutationCurrentPersonIdsArgs>,
    deleteAktuality?: GraphCacheUpdateResolver<{ deleteAktuality: Maybe<WithTypename<DeleteAktualityPayload>> }, MutationDeleteAktualityArgs>,
    deleteAttachment?: GraphCacheUpdateResolver<{ deleteAttachment: Maybe<WithTypename<DeleteAttachmentPayload>> }, MutationDeleteAttachmentArgs>,
    deleteCohortGroup?: GraphCacheUpdateResolver<{ deleteCohortGroup: Maybe<WithTypename<DeleteCohortGroupPayload>> }, MutationDeleteCohortGroupArgs>,
    deleteCouple?: GraphCacheUpdateResolver<{ deleteCouple: Maybe<WithTypename<DeleteCouplePayload>> }, MutationDeleteCoupleArgs>,
    deleteDokumenty?: GraphCacheUpdateResolver<{ deleteDokumenty: Maybe<WithTypename<DeleteDokumentyPayload>> }, MutationDeleteDokumentyArgs>,
    deleteEvent?: GraphCacheUpdateResolver<{ deleteEvent: Maybe<WithTypename<DeleteEventPayload>> }, MutationDeleteEventArgs>,
    deleteLocation?: GraphCacheUpdateResolver<{ deleteLocation: Maybe<WithTypename<DeleteLocationPayload>> }, MutationDeleteLocationArgs>,
    deleteRoom?: GraphCacheUpdateResolver<{ deleteRoom: Maybe<WithTypename<DeleteRoomPayload>> }, MutationDeleteRoomArgs>,
    deleteSkupiny?: GraphCacheUpdateResolver<{ deleteSkupiny: Maybe<WithTypename<DeleteSkupinyPayload>> }, MutationDeleteSkupinyArgs>,
    deleteUpozorneni?: GraphCacheUpdateResolver<{ deleteUpozorneni: Maybe<WithTypename<DeleteUpozorneniPayload>> }, MutationDeleteUpozorneniArgs>,
    editRegistration?: GraphCacheUpdateResolver<{ editRegistration: Maybe<WithTypename<EditRegistrationPayload>> }, MutationEditRegistrationArgs>,
    isCurrentTenantMember?: GraphCacheUpdateResolver<{ isCurrentTenantMember: Maybe<WithTypename<IsCurrentTenantMemberPayload>> }, MutationIsCurrentTenantMemberArgs>,
    login?: GraphCacheUpdateResolver<{ login: Maybe<WithTypename<LoginPayload>> }, MutationLoginArgs>,
    logout?: GraphCacheUpdateResolver<{ logout: Maybe<WithTypename<LogoutPayload>> }, MutationLogoutArgs>,
    registerToEvent?: GraphCacheUpdateResolver<{ registerToEvent: Maybe<WithTypename<RegisterToEventPayload>> }, MutationRegisterToEventArgs>,
    resetPassword?: GraphCacheUpdateResolver<{ resetPassword: Maybe<WithTypename<ResetPasswordPayload>> }, MutationResetPasswordArgs>,
    setLessonDemand?: GraphCacheUpdateResolver<{ setLessonDemand: Maybe<WithTypename<SetLessonDemandPayload>> }, MutationSetLessonDemandArgs>,
    submitForm?: GraphCacheUpdateResolver<{ submitForm: Maybe<WithTypename<SubmitFormPayload>> }, MutationSubmitFormArgs>,
    updateAktuality?: GraphCacheUpdateResolver<{ updateAktuality: Maybe<WithTypename<UpdateAktualityPayload>> }, MutationUpdateAktualityArgs>,
    updateCohortGroup?: GraphCacheUpdateResolver<{ updateCohortGroup: Maybe<WithTypename<UpdateCohortGroupPayload>> }, MutationUpdateCohortGroupArgs>,
    updateDokumenty?: GraphCacheUpdateResolver<{ updateDokumenty: Maybe<WithTypename<UpdateDokumentyPayload>> }, MutationUpdateDokumentyArgs>,
    updateEvent?: GraphCacheUpdateResolver<{ updateEvent: Maybe<WithTypename<UpdateEventPayload>> }, MutationUpdateEventArgs>,
    updateLocation?: GraphCacheUpdateResolver<{ updateLocation: Maybe<WithTypename<UpdateLocationPayload>> }, MutationUpdateLocationArgs>,
    updatePerson?: GraphCacheUpdateResolver<{ updatePerson: Maybe<WithTypename<UpdatePersonPayload>> }, MutationUpdatePersonArgs>,
    updateRoom?: GraphCacheUpdateResolver<{ updateRoom: Maybe<WithTypename<UpdateRoomPayload>> }, MutationUpdateRoomArgs>,
    updateSkupiny?: GraphCacheUpdateResolver<{ updateSkupiny: Maybe<WithTypename<UpdateSkupinyPayload>> }, MutationUpdateSkupinyArgs>,
    updateTenant?: GraphCacheUpdateResolver<{ updateTenant: Maybe<WithTypename<UpdateTenantPayload>> }, MutationUpdateTenantArgs>,
    updateUpozorneni?: GraphCacheUpdateResolver<{ updateUpozorneni: Maybe<WithTypename<UpdateUpozorneniPayload>> }, MutationUpdateUpozorneniArgs>
  },
  Subscription?: {},
};

export type GraphCacheConfig = Parameters<typeof offlineExchange>[0] & {
  updates?: GraphCacheUpdaters,
  keys?: GraphCacheKeysConfig,
  optimistic?: GraphCacheOptimisticUpdaters,
  resolvers?: GraphCacheResolvers,
};